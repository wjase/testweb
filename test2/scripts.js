/*
Copyright 2011-14 Newcastle University
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/** @file Contains code to load in the other script files, and initialise the exam.
 *
 * Creates the global {@link Numbas} object, inside which everything else is stored, so as not to conflict with anything else that might be running in the page.
 */
(function() {
if(!window.Numbas) { window.Numbas = {} }
/** @namespace Numbas */
/** Extensions should add objects to this so they can be accessed */
Numbas.extensions = {};
/** A function for displaying debug info in the console. It will try to give a reference back to the line that called it, if it can.
 * @param {String} msg - text to display
 * @param {Boolean} [noStack=false] - don't show the stack trace
 */
Numbas.debug = function(msg,noStack)
{
    if(window.console)
    {
        var e = new Error(msg);
        if(e.stack && !noStack)
        {
            var words= e.stack.split('\n')[2];
            console.log(msg," "+words);
        }
        else
        {
            console.log(msg);
        }
    }
};
/** Display an error in a nice alert box. Also sends the error to the console via {@link Numbas.debug}
 * @param {Error} e
 */
Numbas.showError = function(e)
{
    var message = (e || e.message)+'';
    message += ' <br> ' + e.stack.replace(/\n/g,'<br>\n');
    Numbas.debug(message);
    Numbas.display.showAlert(message);
    throw(e);
};
/** Generic error class. Extends JavaScript's Error
 * @constructor
 * @param {String} message - A description of the error. Localised by R.js.
 */
Numbas.Error = function(message)
{
    Error.call(this);
    if(Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
    }
    this.name="Numbas Error";
    this.originalMessage = message;
    this.message = R.apply(this,arguments);
}
Numbas.Error.prototype = Error.prototype;
Numbas.Error.prototype.constructor = Numbas.Error;
var scriptreqs = {};
/** Keep track of loading status of a script and its dependencies
 * @param {String} file - name of script
 * @global
 * @constructor
 * @property {String} file - Name of script
 * @property {Boolean} loaded - Has the script been loaded yet?
 * @property {Boolean} executed - Has the script been run?
 * @property {Array.<String>} backdeps - Scripts which depend on this one (need this one to run first)
 * @property {Array.<String>} fdeps - Scripts which this one depends on (it must run after them)
 * @property {function} callback - The function to run when all this script's dependencies have run (this is the script itself)
 */
function RequireScript(file)
{
    this.file = file;
    scriptreqs[file] = this;
    this.backdeps = [];
    this.fdeps = [];
}
RequireScript.prototype = {
    loaded: false,
    executed: false,
    backdeps: [],
    fdeps: [],
    callback: null
};
/** Ask to load a javascript file. Unless `noreq` is set, the file's code must be wrapped in a call to Numbas.queueScript with its filename as the first parameter.
 * @memberof Numbas
 * @param {String} file
 * @param {Boolean} noreq - don't create a {@link Numbas.RequireScript} object
 */
var loadScript = Numbas.loadScript = function(file,noreq)
{
    if(!noreq)
    {
        if(scriptreqs[file]!==undefined)
            return;
        var req = new RequireScript(file);
    }
}
/**
 * Queue up a file's code to be executed.
 * Each script should be wrapped in this function
 * @param {String} file - Name of the script
 * @param {Array.<String>} deps - A list of other scripts which need to be run before this one can be run
 * @param {function} callback - A function wrapping up this file's code
 */
Numbas.queueScript = function(file, deps, callback)
{
    // find a RequireScript
    var req = scriptreqs[file] || new RequireScript(file);
    if(typeof(deps)=='string')
        deps = [deps];
    for(var i=0;i<deps.length;i++)
    {
        var dep = deps[i];
        deps[i] = dep;
        loadScript(dep);
        scriptreqs[dep].backdeps.push(file);
    }
    req.fdeps = deps;
    req.callback = callback;
    req.loaded = true;
    Numbas.tryInit();
}
/** Called when all files have been requested, will try to execute all queued code if all script files have been loaded. */
Numbas.tryInit = function()
{
    if(Numbas.dead) {
        return;
    }
    //put all scripts in a list and go through evaluating the ones that can be evaluated, until everything has been evaluated
    var stack = [];
    var ind = 0;
    function get_ind() {
        return 'margin-left: '+ind+'em';
    }
    function tryRun(req) {
        if(req.loaded && !req.executed) {
            var go = true;
            for(var j=0;j<req.fdeps.length;j++)
            {
                if(!scriptreqs[req.fdeps[j]].executed) {
                    go=false;
                    break;
                }
            }
            if(go)
            {
                if(req.callback) {
                    req.callback({exports:window});
                }
                req.executed=true;
                ind++;
                for(var j=0;j<req.backdeps.length;j++) {
                    tryRun(scriptreqs[req.backdeps[j]]);
                }
                ind--;
            }
        }
    }
    for(var x in scriptreqs)
    {
        try {
            tryRun(scriptreqs[x]);
        } catch(e) {
            alert(e+'');
            Numbas.debug(e.stack);
            Numbas.dead = true;
            return;
        }
    }
}
/** A wrapper round {@link Numbas.queueScript} to register extensions easily.
 * @param {String} name - unique name of the extension
 * @param {Array.<String>} deps - A list of other scripts which need to be run before this one can be run
 * @param {function} callback - Code to set up the extension. It's given the object `Numbas.extensions.<name>` as a parameter, which contains a {@link Numbas.jme.Scope} object.
 */
Numbas.addExtension = function(name,deps,callback) {
    deps.push('jme');
    Numbas.queueScript('extensions/'+name+'/'+name+'.js',deps,function() {
        var extension = Numbas.extensions[name] = {
            scope: new Numbas.jme.Scope()
        };
        callback(extension);
    });
}
/** Check all required scripts have executed - the theme should call this once the document has loaded
 */
Numbas.checkAllScriptsLoaded = function() {
    for(var file in scriptreqs) {
        var req = scriptreqs[file];
        if(req.executed) {
            continue;
        }
        if(req.fdeps.every(function(f){return scriptreqs[f].executed})) {
            var err = new Numbas.Error('die.script not loaded',{file:file});
            console.log(err.message);
            Numbas.display && Numbas.display.die(err);
            break;
        }
    }
}
})();

        Numbas.queueScript('localisation-resources',['i18next'],function() {
        Numbas.locale = {
            preferred_locale: "en-GB",
            resources: {"fr-fr": {"translation": {"jme.typecheck.no right type unbound name": "La variable <code>{{name}}</code> n'est pas d\u00e9finie.", "control.pause": "Pause", "feedback.taken away": "<strong>{{count,niceNumber}}</strong> $t(mark) $t(was) retir\u00e9(s).", "question.score feedback.unanswered": "Sans r\u00e9ponse.", "control.reveal": "R\u00e9v\u00e9ler les r\u00e9ponses", "part.marking.steps no matter": "Parce que vous avez re\u00e7u toutes les points pour la partie, vos r\u00e9ponses aux \u00e9tapes ne sont pas compt\u00e9es.", "part.marking.resubmit because of variable replacement": "Le note de cette partie d\u00e9pend de vos r\u00e9ponses \u00e0 d'autres parties que vous avez modifi\u00e9es. Soumettez \u00e0 nouveau cette partie pour mettre \u00e0 jour votre r\u00e9sultat.", "question.no such part": "Impossible de trouver la partie {{path}}", "control.back to results": "Retourner aux r\u00e9sultats", "part.unknown type": "{{part}}: Type de partie {{type}} non reconnu", "result.click a question to review": "Cliquez sur le num\u00e9ro d'une question pour voir comment vos r\u00e9ponses ont \u00e9t\u00e9 not\u00e9es et, le cas \u00e9ch\u00e9ant, les solutions compl\u00e8tes.", "part.missing type attribute": "{{part}}: Attribut de type de partie manquant", "matrixmath.abs.non-square": "Impossible de calculer le d\u00e9terminant d'une matrice qui n'est pas carr\u00e9e.", "result.performance summary": "Sommaire du rendement", "die.numbas failed": "Numbas a \u00e9chou\u00e9", "jme.shunt.no left bracket in function": "Aucun crochet ouvrant correspondant dans la fonction ou le tuple", "part.mcq.matrix cell empty": "La partie {{part}} de la cellule ({{row}},{{column}}) de la matrice d'\u00e9valuation est vide", "question.score feedback.show": "Afficher la r\u00e9troaction", "part.script.error": "Erreur dans {{path}} du script personnalis\u00e9 {{script}}: {{message}}\n", "part.numberentry.precision type.sigfig": "Chiffre significatif", "jme.variables.error computing dependency": "Erreur lors du calcul de la variable r\u00e9f\u00e9renc\u00e9e <code>{{name}}</code>", "exam.passed": "R\u00e9ussi", "result.questions attempted": "Questions essay\u00e9es:", "control.not all questions submitted": "Vous avez modifi\u00e9 une ou plusieurs r\u00e9ponses et ne les avez pas soumises. S.V.P., v\u00e9rifiez que chaque question a \u00e9t\u00e9 soumise.", "exam.student name": "Nom de l'\u00e9tudiant:", "scorm.no question suspend data": "Pas de donn\u00e9es en suspend pour la question", "result.exam start": "D\u00e9but de l'examen:", "part.extension.not implemented": "La partie n'a pas impl\u00e9ment\u00e9 la m\u00e9thode <code>{{name}}</code>.", "xml.property not boolean": "La propri\u00e9t\u00e9 {{name}} devrait \u00eatre un bool\u00e9en, mais n'en est pas un ({{value}}), dans le noeud {{element}}", "feedback.you were awarded": "Vous avez re\u00e7u <strong>{{count,niceNumber}}</strong> $t(mark).", "jme.variables.variable not defined": "La variable <code>{{name}}</code> n'est pas d\u00e9finie.", "question.loaded name mismatch": "Impossible de reprendre cette tentative - le progiciel a chang\u00e9 depuis la derni\u00e8re session.", "control.confirm end": "\u00cates-vous certain de vouloir terminer l'examen? Apr\u00e8s avoir termin\u00e9 l'examen, vous ne pourrez plus changer vos r\u00e9ponses.", "result.exam stop": "Fin de l'examen:", "exam.review header": "R\u00e9vision:", "jme.display.collectRuleset.no sets": "Aucun ensemble n'a \u00e9t\u00e9 fourni \u00e0 collectRuleset!", "result.exit": "Quitter l'examen", "scorm.error initialising": "Erreur lord de l'initialisation du protocole SCORM: {{message}}", "exam.pass percentage": "Pourcentage de r\u00e9ussite:", "math.permutations.complex": "Impossible de calculer des permutation de nombres complexes.", "scorm.error loading part": "Erreur lors du chargement de la partie {{part}}: {{message}}", "part.mcq.options def not a list": "L'expression d\u00e9finissant les {{properties}} n'est pas une liste.", "part.mcq.matrix mix of numbers and lists": "M\u00e9lange de nombres et de listes utilis\u00e9s dans la matrice d'\u00e9valuation.", "part.marking.variable replacement part not answered": "Vous devez r\u00e9pondre \u00e0 {{part}} en premier.", "part.marking.did not answer": "Vous n'avez pas r\u00e9pondu \u00e0 cette question.", "jme.shunt.missing operator": "L'expression ne peut \u00eatre \u00e9valu\u00e9e -- il manque un op\u00e9rateur.", "suspend.paused header": "En pause", "part.mcq.matrix wrong size": "La matrice d'\u00e9valuation est de la mauvaise taille.", "part.mcq.matrix jme error": "La partie {{part}} de la cellule ({{row}},{{column}}) de la matrice d'\u00e9valuation retourne une erreur JME: {{error}}\n", "end.exam has finished": "L'examen est termin\u00e9. Vous pouvez d\u00e9sormais fermer cette fen\u00eatre.", "suspend.exam suspended": "L'examen a \u00e9t\u00e9 suspendu. Appuyez sur <em>Reprendre</em> pour continuer.", "jme.texsubvars.missing parameter": "Param\u00e8tre manquant dans {{op}}: {{parameter}}", "part.numberentry.precision type.sigfig_plural": "Chiffres significatifs", "math.lt.order complex numbers": "Impossible de trier des nombres complexes.", "control.confirm reveal": "Voulez-vous r\u00e9v\u00e9ler la r\u00e9ponse \u00e0 cette question? Tous les points re\u00e7us jusqu'\u00e0 maintenant seront verrouill\u00e9s et vous ne pourrez pas r\u00e9pondre \u00e0 cette question plus tard.", "part.patternmatch.correct except case": "Votre r\u00e9ponse est correcte, \u00e0 l\u2019exception des majuscules et minuscules.", "part.marking.not submitted": "Aucune r\u00e9ponse soumise", "jme.variables.error making function": "Erreur lors de la cr\u00e9ation de la fonction <code>{{name}}</code>: {{message}}", "exam.xml.bad root": "L'\u00e9l\u00e9ment racine de l'examen XML devrait \u00eatre 'exam'", "part.mcq.matrix not a number": "Partie {{part}} de la cellule ({{row}},{{column}}) de la matrice d'\u00e9valuation ne donne pas un nombre", "question.score feedback.score total": "{{marksString}}. R\u00e9pondu.\n", "question.show steps penalty": "Vous allez perdre <strong>{{count,niceNumber}}</strong> $t(mark).\n", "question.unsubmitted changes_plural": "Vous avez apport\u00e9 des modifications \u00e0 vos r\u00e9ponses, mais vous ne les avez pas soumises. Veuillez v\u00e9rifier vos r\u00e9ponses \u00e0 chaque partie, puis appuyez sur le bouton <strong>Envoyer toutes les parties</strong>.", "question.show steps no penalty": "Votre r\u00e9sultat ne sera pas influenc\u00e9.", "scorm.no part suspend data": "Pas de donn\u00e9es en suspend pour la partie", "jme.typecheck.function not defined": "L'op\u00e9ration <code>{{op}}</code> n'est pas d\u00e9finie. Est-ce que <code>{{op}}</code> est une variable et voulez-vous dire <code>{{suggestion}}*(...)</code>?", "part.marking.revealed steps with penalty": "Vous avez affich\u00e9 les \u00e9tapes. Le r\u00e9sultat maximum pour cette partie est <strong>{{count,niceNumber}}</strong> $t(mark). Vos r\u00e9sultats seront r\u00e9duits en cons\u00e9quence.", "question.unsubmitted changes": "Vous avez apport\u00e9 une modification \u00e0 votre r\u00e9ponse mais vous ne l'avez pas soumise. Veuillez v\u00e9rifier votre r\u00e9ponse, puis appuyez sur le bouton <strong>Envoyer la r\u00e9ponse</strong>.", "ruleset.circular reference": "R\u00e9f\u00e9rence circulaire dans la d\u00e9finition du jeu de r\u00e8gles <code>{{name}}</code>", "math.combinations.n less than zero": "Impossible de calculer les combinaisons: n est plus petit que z\u00e9ro", "part.marking.incorrect": "Votre r\u00e9ponse est incorrecte.", "jme.variables.empty definition": "La d\u00e9finition de la variable <code>{{name}}</code> est vide.", "question.preamble.syntax error": "Erreur de syntaxe dans le pr\u00e9ambule", "util.equality not defined for type": "L'\u00e9galit\u00e9 n'est pas d\u00e9finie pour le {{type}}", "ruleset.set not defined": "Le jeu de r\u00e8gles {{name}} n'a pas \u00e9t\u00e9 d\u00e9fini", "result.question review title": "R\u00e9viser cette question", "jme.shunt.no right bracket": "Aucun crochet fermant correspondant", "die.sorry": "D\u00e9sol\u00e9, Numbas a rencontr\u00e9 une erreur fatale et ne peut continuer. Une description de l'erreur suit ci-dessous.", "control.end exam": "Fin de l'examen", "vectormath.cross.not 3d": "Ne peut prendre que le produit vectoriel de vecteurs tridimensionnels.", "part.mcq.matrix not a list": "La matrice d'\u00e9valuation, d\u00e9finie par l'expression JME, n'est pas une liste mais elle devrait l'\u00eatre.", "part.marking.nothing entered": "Vous n'avez pas entr\u00e9 de r\u00e9ponse.", "part.numberentry.give your answer as a reduced fraction": "Simplifiez votre r\u00e9ponse.", "mark_plural": "points", "question.hide steps no penalty": "Votre r\u00e9sultat ne sera pas influenc\u00e9.", "step": "\u00e9tape", "part.numberentry.correct except decimal": "Votre r\u00e9ponse se situe dans la plage autoris\u00e9e, mais les nombres d\u00e9cimaux ne sont pas autoris\u00e9s.", "question.can not submit": "Impossible de soumettre la r\u00e9ponse - v\u00e9rifiez s'il y a des erreurs.", "math.choose.empty selection": "S\u00e9lection vide donn\u00e9e \u00e0 la fonction al\u00e9atoire", "part.jme.answer too long": "Votre r\u00e9ponse est trop longue.", "mathjax.error": "Erreur de traitement MathJax: {{message}}", "control.submit answer": "Soumettre la r\u00e9ponse", "exam.failed": "\u00c9chou\u00e9", "part.jme.not-allowed one": "Votre r\u00e9ponse ne doit pas contenir: {{strings}}", "jme.shunt.not enough arguments": "Pas assez d'arguments pour l'op\u00e9ration {{op}}", "question.answer submitted": "R\u00e9ponse envoy\u00e9e.", "part.jme.must-have one": "Votre r\u00e9ponse doit contenir: {{strings}}", "part.correct answer": "R\u00e9ponse attendue:", "part.numberentry.answer not reduced": "Votre r\u00e9ponse n'est pas simplifi\u00e9e.", "control.next": "Suivant", "part.mcq.marking matrix string empty": "L'expression de la matrice d'\u00e9valuation personnalis\u00e9e est vide.", "matrixmath.abs.too big": "D\u00e9sol\u00e9, impossible pour l'instant de calculer le d\u00e9terminant d'une matrice plus grande que 3x3.", "jme.texsubvars.no right bracket": "Aucun <code>]</code> dans les arguments {{op}}.", "mathjax.math processing error": "Erreur d'analyse MathJax : \"{{message}}\" lors du rendu tex de <code>{{expression}}</code>", "jme.matrix.reports bad size": "La matrice d\u00e9clare sa taille incorrectement - doit \u00eatre une erreur dans la fonction du constructeur", "part.marking.steps change": "Vous avez re\u00e7u <strong>{{count,niceNumber}}</strong> $t(mark) pour vos r\u00e9ponses aux \u00e9tapes.", "part.mcq.choices": "choix", "part.jme.answer invalid": "Votre r\u00e9ponse n'est pas une expression math\u00e9matique valide.<br/>{{message}}.", "jme.shunt.list mixed argument types": "Impossible d'analyser {{mode}}: m\u00e9lange de dictionnaire et d'\u00e9l\u00e9ments de liste", "jme.func.except.continuous range": "Impossible d'utiliser l'op\u00e9rateur 'except' sur une plage continue.", "exam.marks available": "Points disponibles:", "math.combinations.k less than zero": "Impossible de calculer les combinaisons: k est plus petit que z\u00e9ro", "result.question number": "Num\u00e9ro de la question", "control.submit all parts": "Soumettre toutes les parties", "jme.func.listval.not a list": "L'objet n'est pas indi\u00e7able\n", "part.numberentry.give your answer to precision": "Arrondissez votre r\u00e9ponse \u00e0 {{count,niceNumber}} {{precisionType}}.", "part.mcq.wrong number of choices": "Vous avez s\u00e9lectionn\u00e9 le mauvais nombre de choix.", "jme.variables.syntax error in function definition": "Erreur de syntaxe dans la d\u00e9finition de la fonction", "page.saving": "<p>Sauvegarde en cours.</p>\n<p>Cela peut prendre quelques instants.</p>", "math.gcf.complex": "Impossible de calculer le plus grand facteur commun de nombres complexes.", "part.matrix.some incorrect": "Une ou plusieurs cellules de votre r\u00e9ponse sont incorrectes, mais vous avez re\u00e7u des points pour le reste.", "math.combinations.complex": "Impossible de calculer des combinaisons de nombres complexes", "control.total": "Total", "jme.user javascript.error": "Erreur dans la fonction javascript d\u00e9finie par l'utilisateur <code>{{name}}</code>: {{message}}", "part.matrix.invalid cell": "Une ou plusieurs cellules de votre r\u00e9ponse sont vides ou invalides.", "scorm.error loading question": "Erreur lors du chargement de la question {{number}}: {{message}}", "part.numberentry.give your answer to precision_0": "Arrondissez votre r\u00e9ponse \u00e0 l'entier le plus pr\u00e8s.", "jme.shunt.no right square bracket": "Aucun crochet fermant correspondant pour fermer la liste", "control.not all questions answered": "Vous n'avez pas compl\u00e9t\u00e9 toutes les questions de cet examen.", "jme.display.unknown token type": "Impossible de textifier le jeton de type {{type}}", "part.numberentry.answer invalid": "Vous n'avez pas entr\u00e9 un nombre valide.", "jme.user javascript.returned undefined": "La fonction javascript d\u00e9finie par l'utilisateur <code>{{name}}</ code> a renvoy\u00e9 <code>undefined</ code>.", "question.hide steps": "Masquer les \u00e9tapes", "part.mcq.matrix wrong type": "\u00c9l\u00e9ment de type '{{type}}' invalide utilis\u00e9 dans la matrice d'\u00e9valuation.\n", "math.combinations.n less than k": "Impossible de calculer les combinaisons: n est plus petit que k", "mark": "point", "suspend.you can resume": "Vous pourrez reprendre cette session la prochaine fois que vous d\u00e9marrerez cette activit\u00e9.", "scorm.error loading suspend data": "Erreur lors du chargement des donn\u00e9es en suspend: {{message}}", "result.result": "R\u00e9sultat:", "question.show steps": "Afficher les \u00e9tapes", "question.submit part": "Soumettre la partie", "part.jme.unexpected variable name": "Votre r\u00e9ponse a \u00e9t\u00e9 interpr\u00e9t\u00e9e pour utiliser le nom de variable inattendue <code> {{name}} </ code>.", "part.matrix.empty cell": "Une ou plusieurs cellules de votre r\u00e9ponse sont vides.\n", "control.regen": "Essayer une autre question comme celle-ci", "control.advice": "Conseil", "xml.could not load": "Impossible de charger un document XML: {{message}}", "part.marking.uncaught error": "Erreur lors de l'\u00e9valuation de la {{part}}: {{message}}", "question.score feedback.score total actual": "R\u00e9sultat: {{score,niceNumber}}/{{marks,niceNumber}}", "result.print": "Imprimer le sommaire des notes", "math.siground.complex": "Impossible d'arrondir \u00e0 un nombre complexe de chiffres significatifs", "question.header": "Question {{number}}", "math.permutations.k less than zero": "Impossible de calculer les permutations: k est plus petit que z\u00e9ro", "question.preamble.error": "Erreur dans le pr\u00e9ambule: {{message}}", "suspend.resume": "Reprendre", "part.mcq.correct choice": "Vous avez choisi la bonne r\u00e9ponse.", "part.numberentry.answer not integer": "Votre r\u00e9ponse est invalide. Vous devez entrer un nombre entier, pas un nombre d\u00e9cimal.", "part.jme.not-allowed several": "Votre r\u00e9ponse ne doit pas contenir: {{strings}}", "part.numberentry.precision type.dp_plural": "d\u00e9cimales", "question.unsupported part type": "Type de partie non support\u00e9", "jme.variables.error evaluating variable": "Erreur lors de l'\u00e9valuation de la variable {{name}}: {{message}}", "jme.func.listval.key not in dict": "Le dictionnaire ne contient pas la cl\u00e9 <code>{{key}}</code>", "part.mcq.answers": "r\u00e9ponses", "jme.typecheck.map not on enumerable": "L'op\u00e9ration <code>map</code> doit travailler sur une liste ou une plage, pas sur {{type}}", "jme.substituteTree.undefined variable": "Variable non d\u00e9finie: <code>{{name}}</code>", "modal.cancel": "Annuler", "scorm.failed save": "<p>La requ\u00eate pour sauvegarder les donn\u00e9es sur le serveur a \u00e9chou\u00e9. Appuyez sur <b>OK</b> pour essayer \u00e0 nouveau.</p>\n<p>Si vous rencontrez ce message de fa\u00e7on r\u00e9p\u00e9t\u00e9e, v\u00e9rifiez votre connexion internet ou utilisez un autre ordinateur. Les r\u00e9ponses que vous avez envoy\u00e9es pr\u00e9c\u00e9demment ont \u00e9t\u00e9 sauvegard\u00e9es avec succ\u00e8s et seront restaur\u00e9es si vous reprenez cette session sur un autre ordinateur.</p>\n<p>Si ce message apparait constamment et que vous ne pouvez sauvegarder <em>aucune</em> de vos r\u00e9ponses, merci de contacter votre professeur.</p>", "jme.typecheck.function maybe implicit multiplication": "L'op\u00e9ration {{name}} n'est pas d\u00e9finie. Voulez-vous dire <br/><code>{{first}}*{{possibleOp}}(...)</code>?", "part.jme.answer too short": "Votre r\u00e9ponse est trop courte.", "matrixmath.mul.different sizes": "Impossible de multiplier des matrices de tailles diff\u00e9rentes.", "jme.func.switch.no default case": "Aucun cas par d\u00e9faut pour l'instruction Switch.", "part.numberentry.zero sig fig": "Cette partie est r\u00e9gl\u00e9e pour arrondir la r\u00e9ponse de l'\u00e9tudiant \u00e0 z\u00e9ro chiffre significatif, ce qui n'a aucun sens.", "frontpage.start": "D\u00e9marrer", "result.question score": "Note", "part.mcq.choices missing": "La d\u00e9finition des choix est manquante", "question.score feedback.correct": "Votre r\u00e9ponse est correcte.", "part.feedback": "r\u00e9troaction", "question.score feedback.answered": "R\u00e9pondu.", "math.permutations.n less than k": "Impossible de calculer les permutations: n est plus petit k", "part.gapfill.feedback header": "<strong>\u00c9cart {{index}}</strong>", "question.advice": "Conseil", "vectormath.cross.matrix too big": "Impossible de calculer le produit vectoriel d'une matrice qui n'est pas $1 \\times N$ ou $N \\times 1$.", "part.jme.not-allowed bits": "<span class=\"monospace\">{{string}}</span>", "display.part.jme.error making maths": "Erreur lors de l'affichage des math\u00e9matiques", "part.prompt": "invite", "control.proceed anyway": "Continuer malgr\u00e9 tout?", "gap": "\u00e9cart", "jme.tokenise.invalid": "Expression invalide: <code>{{expression}}</code>", "result.score": "Note:", "math.lcm.complex": "Impossible de calculer le plus petit commun multiple de nombres complexes.", "exam.random seed": "Identificateur de session:", "modal.ok": "OK", "was": "\u00e9tait", "jme.thtml.not html": "Valeur non-HTML pass\u00e9e dans le constructeur THTML.", "question.score feedback.partial": "Votre r\u00e9ponse est partiellement correcte", "mathjax.error with context": "Erreur de traitement MathJax dans {{context}}: {{message}}", "question.score feedback.wrong": "Votre r\u00e9ponse est incorrecte", "question.score feedback.score actual": "R\u00e9sultat: {{scoreString}}", "part.numberentry.correct except fraction": "Votre r\u00e9ponse se situe dans la plage autoris\u00e9e, mais les fractions ne sont pas autoris\u00e9es.", "question.error": "Question {{number}}: {{message}}", "jme.evaluate.no scope given": "Numbas.jme.evaluate doit avoir une port\u00e9e", "question.show steps already penalised": "Vous avez d\u00e9j\u00e0 affich\u00e9 les \u00e9tapes. Vous pouvez les afficher de nouveau sans p\u00e9nalit\u00e9s.", "part.jme.answer missing": "R\u00e9ponse correcte manquante", "part.mcq.no choices selected": "Aucun choix s\u00e9lectionn\u00e9.", "die.script not loaded": "Numbas n'a pas pu d\u00e9marrer car le fichier <code>{{file}}</code> n'a pas \u00e9t\u00e9 charg\u00e9. V\u00e9rifiez qu'il est inclus dans <code>scripts.js</code>.\n", "part.numberentry.precision type.dp": "d\u00e9cimale", "part.matrix.answer invalid": "Votre r\u00e9ponse n'est pas valide.", "jme.variables.question took too many runs to generate variables": "Un ensemble valide de variables de question n'a pas \u00e9t\u00e9 g\u00e9n\u00e9r\u00e9 \u00e0 temps.", "jme.texsubvars.no right brace": "Aucun <code>}</code> dans {{op}}", "page.loading": "Chargement...", "part.jme.marking.correct": "Votre r\u00e9ponse est num\u00e9riquement correcte.", "part.marking.correct": "Votre r\u00e9ponse est correcte.", "part.matrix.size mismatch": "L'auteur de la question n'a pas permis \u00e0 l'\u00e9tudiant de d\u00e9cider des dimensions de sa r\u00e9ponse, mais la bonne r\u00e9ponse est {{correct_dimensions}} alors que la r\u00e9ponse est {{input_dimensions}}", "exam.feedback": "Message de r\u00e9troaction \u00e0 l'examen", "part.marking.used variable replacements": "Cette partie a \u00e9t\u00e9 not\u00e9e en utilisant vos r\u00e9ponses aux parties pr\u00e9c\u00e9dentes.", "control.submit": "Soumettre", "jme.shunt.no left square bracket": "Aucun crochet ouvrant correspondant", "jme.func.listval.invalid index": "Indice de liste {{index}} invalide sur une liste de taille {{size}}", "question.score feedback.hide": "Masquer la r\u00e9troaction", "jme.variables.circular reference": "R\u00e9f\u00e9rence circulaire \u00e0 une variable dans la d\u00e9finition de <code>{{name}}</code>", "result.time spent": "Temps \u00e9coul\u00e9:", "die.error": "Erreur", "timing.time remaining": "Temps restant:", "part.numberentry.negative decimal places": "Cette partie est r\u00e9gl\u00e9e pour arrondir la r\u00e9ponse de l'\u00e9tudiant \u00e0 un nombre n\u00e9gatif de d\u00e9cimales, ce qui n'a aucun sens.", "part.with steps answer prompt": "R\u00e9ponse: ", "control.confirm leave": "Vous n'avez pas termin\u00e9 l'examen.", "jme.typecheck.op not defined": "L'op\u00e9ration '{{op}}' n'est pas d\u00e9finie.", "part": "partie", "control.submit again": "Soumettre \u00e0 nouveau", "xml.error in variable definition": "Erreur dans la d\u00e9finition de la variable <code>{{name}}</code>", "exam.changeQuestion.no questions": "Cet examen ne contient aucune question! V\u00e9rifiez s'il y a des erreurs dans le fichier .exam.", "part.jme.must-have bits": "<span class=\"monospace\">{{string}}</span>", "part.marking.total score": "Vous avez obtenu <strong>{{count,niceNumber}}</strong> $t(mark) pour cette partie.", "exam.introduction": "Introduction \u00e0 l'examen", "control.confirm regen": "Voulez-vous \u00e0 nouveau r\u00e9partir au hasard cette question? Si vous cliquez OK, toutes vos r\u00e9ponses et vos r\u00e9sultats pour la question en cours seront perdus.", "jme.evaluate.undefined variable": "La variable {{name}} n'est pas d\u00e9finie", "jme.display.simplifyTree.no scope given": "Numbas.jme.display.simplifyTree doit avoir une port\u00e9e", "timing.no accumulator": "pas d'accumulateur de chronom\u00e9trage {{name}}", "util.product.non list": "Un \u00e9l\u00e9ment qui n'est pas une liste a \u00e9t\u00e9 pass\u00e9 \u00e0 <code>Numbas.util.product</code>\n", "part.marking.revealed steps no penalty": "Vous avez r\u00e9v\u00e9l\u00e9 les \u00e9tapes.", "part.jme.unexpected variable name suggestion": "Votre r\u00e9ponse a \u00e9t\u00e9 interpr\u00e9t\u00e9e pour utiliser le nom de variable inattendue <code> {{name}} </ code>. Voulez-vous dire <code>{{suggestion}}</code>?", "jme.display.collectRuleset.set not defined": "L'ensemble de r\u00e8gles {{name}} n'a pas \u00e9t\u00e9 d\u00e9fini", "was_plural": "\u00e9taient", "part.marking.no result": "Cette partie n'a pas pu \u00eatre \u00e9valu\u00e9e.", "part.setting not present": "Propri\u00e9t\u00e9 '{{property}}' non d\u00e9finie", "exam.number of questions": "Nombre de questions:", "part.numberentry.answer not integer or decimal": "Votre r\u00e9ponse est invalide. Vous devez entrer un nombre entier ou un nombre d\u00e9cimal.", "question.selector.unsubmitted changes": "Modifications non soumises.", "vectormath.dot.matrix too big": "Impossible de calculer le produit scalaire d'une matrice qui n'est pas $1 \\times N$ ou $N \\times 1$.", "scorm.no exam suspend data": "Impossible de reprendre: pas de donn\u00e9es d'examen en suspend.", "math.permutations.n less than zero": "Impossible de calculer les permutations: n est plus petit que z\u00e9ro", "part.matrix.empty": "Vous n'avez pas entr\u00e9 de r\u00e9ponse.", "part.jme.must-have several": "Votre r\u00e9ponse doit contenir tous les \u00e9l\u00e9ments suivants: {{strings}}", "part.patternmatch.display answer missing": "L'affichage de la r\u00e9ponse est manquant", "math.precround.complex": "Impossible d'arrondir un nombre complexe de d\u00e9cimales", "jme.func.matrix.invalid row type": "Impossible de construire une matrice \u00e0 partir de rang\u00e9es de type {{type}}", "jme.tokenise.keypair key not a string": "La cl\u00e9 du dictionnaire doit \u00eatre une cha\u00eene, pas {{type}}.\n", "jme.shunt.no left bracket": "Aucun crochet ouvrant correspondant", "result.exam summary": "Sommaire de l'examen", "jme.typecheck.no right type definition": "Aucune d\u00e9finition du bon type trouv\u00e9e pour '{{op}}'.", "exam.time allowed": "Temps accord\u00e9:", "question.statement": "D\u00e9claration", "xml.property not number": "La propri\u00e9t\u00e9 {{name}} devrait \u00eatre un nombre, mais n'en est pas un ({{value}}), dans le noeud {{element}}", "exam.exam name": "Nom de l'examen:", "control.previous": "Pr\u00e9c\u00e9dent"}}, "ja-jp": {"translation": {"jme.typecheck.no right type unbound name": "Variable <code>{{name}}</code> is not defined.", "control.pause": "Pause", "feedback.taken away": "<strong>{{count,niceNumber}}</strong> $t(mark) $t(was) taken away.", "question.score feedback.unanswered": "Unanswered.", "control.reveal": "Reveal answers", "part.marking.steps no matter": "Because you received full marks for the part, your answers to the steps aren't counted.", "part.marking.resubmit because of variable replacement": "This part's marking depends on your answers to other parts, which you have changed. Submit this part again to update your score.", "question.no such part": "Can't find part {{path}}", "control.back to results": "\u7d50\u679c\u306b\u623b\u308b", "part.unknown type": "{{part}}: Unrecognised part type {{type}}", "result.click a question to review": "Click on a question number to see how your answers were marked and, where available, full solutions.", "part.missing type attribute": "{{part}}: Missing part type attribute", "matrixmath.abs.non-square": "Can't compute the determinant of a matrix which isn't square.", "result.performance summary": "Performance Summary", "die.numbas failed": "Numbas has failed", "jme.shunt.no left bracket in function": "No matching left bracket in function application or tuple", "part.mcq.matrix cell empty": "Part {{part}} marking matrix cell ({{row}},{{column}}) is empty", "question.score feedback.show": "\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u3092\u8868\u793a\u3059\u308b", "part.script.error": "Error in part {{path}} custom script {{script}}: {{message}}", "part.numberentry.precision type.sigfig": "\u6709\u52b9\u6570\u5b57", "jme.variables.error computing dependency": "Error computing referenced variable <code>{{name}}</code>", "exam.passed": "Passed", "result.questions attempted": "Questions Attempted:", "control.not all questions submitted": "You have made changes to one or more answers but not submitted them. Please check each question has been submitted.", "exam.student name": "\u5b66\u751f\u6c0f\u540d:", "scorm.no question suspend data": "No question suspend data", "result.exam start": "\u8a66\u9a13\u958b\u59cb:", "part.extension.not implemented": "Part hasn't implemented the <code>{{name}}</code> method.", "xml.property not boolean": "Property {{name}} should be a boolean, but isn't ({{value}}), in node {{element}}", "feedback.you were awarded": "You were awarded <strong>{{count,niceNumber}}</strong> $t(mark).", "jme.variables.variable not defined": "Variable <code>{{name}}</code> is not defined.", "question.loaded name mismatch": "Can't resume this attempt - the package has changed since the last session.", "control.confirm end": "Are you sure you want to end the exam? After you end the exam, you will not be able to change any of your answers.", "result.exam stop": "\u8a66\u9a13\u7d42\u4e86:", "exam.review header": "Review: ", "jme.display.collectRuleset.no sets": "No sets given to collectRuleset!", "result.exit": "\u8a66\u9a13\u7d42\u4e86", "scorm.error initialising": "Error initialising SCORM protocol: {{message}}", "exam.pass percentage": "\u5408\u683c\u7387:", "math.permutations.complex": "Can't compute permutations of complex numbers", "scorm.error loading part": "Error loading part {{part}}: {{message}}", "part.mcq.options def not a list": "The expression defining the {{properties}} is not a list.", "part.mcq.matrix mix of numbers and lists": "Mix of numbers and lists used in marking matrix.", "part.marking.variable replacement part not answered": "You must answer {{part}} first", "part.marking.did not answer": "\u3053\u306e\u554f\u984c\u306b\u89e3\u7b54\u3057\u3066\u3044\u307e\u305b\u3093", "jme.shunt.missing operator": "Expression can't be evaluated -- missing an operator.", "suspend.paused header": "Paused", "part.mcq.matrix wrong size": "Marking matrix is the wrong size.", "part.mcq.matrix jme error": "Part {{part}} marking matrix cell ({{row}},{{column}}) gives a JME error: {{error}}", "end.exam has finished": "\u8a66\u9a13\u306f\u7d42\u4e86\u3057\u307e\u3057\u305f\u3002\u3053\u306e\u30a6\u30a3\u30f3\u30c9\u30a6\u3092\u9589\u3058\u3066\u3082\u304b\u307e\u3044\u307e\u305b\u3093\u3002", "suspend.exam suspended": "\u8a66\u9a13\u306f\u4e2d\u65ad\u3055\u308c\u307e\u3057\u305f\u3002<em>\u518d\u958b</em>\u3092\u30af\u30ea\u30c3\u30af\u3057\u3066\u7d9a\u3051\u3066\u304f\u3060\u3055\u3044\u3002", "jme.texsubvars.missing parameter": "Missing parameter in {{op}}: {{parameter}}", "part.numberentry.precision type.sigfig_plural": "\u6709\u52b9\u6570\u5b57", "math.lt.order complex numbers": "Can't order complex numbers", "control.confirm reveal": "Would you like to reveal the answer to this question? Any marks you have received so far will be locked and you will not be able to answer this question later.", "part.patternmatch.correct except case": "Your answer is correct, except for the case.", "part.marking.not submitted": "No answer submitted", "jme.variables.error making function": "Error making function <code>{{name}}</code>: {{message}}", "exam.xml.bad root": "Root element of exam XML should be 'exam'", "part.mcq.matrix not a number": "Part {{part}} marking matrix cell ({{row}},{{column}}) does not evaluate to a number", "question.score feedback.score total": "{{marksString}}. Answered.", "question.show steps penalty": "You will lose <strong>{{count,niceNumber}}</strong> $t(mark).", "question.unsubmitted changes_plural": "You have made changes to your answers but not submitted them. Please check your answers to each part and then press the <strong>Submit all parts</strong> button.", "question.show steps no penalty": "Your score will not be affected.", "scorm.no part suspend data": "No part suspend data", "jme.typecheck.function not defined": "Operation <code>{{op}}</code> is not defined. Is <code>{{op}}</code> a variable, and did you mean <code>{{suggestion}}*(...)</code>?", "part.marking.revealed steps with penalty": "You revealed the steps. The maximum you can score for this part is <strong>{{count,niceNumber}}</strong> $t(mark). Your scores will be scaled down accordingly.", "question.unsubmitted changes": "You have made a change to your answer but not submitted it. Please check your answer and then press the <strong>Submit answer</strong> button.", "ruleset.circular reference": "Circular reference in definition of ruleset <code>{{name}}</code>", "math.combinations.n less than zero": "Can't compute combinations: n is less than zero", "part.marking.incorrect": "\u9593\u9055\u3044\u3067\u3059", "jme.variables.empty definition": "Definition of variable <code>{{name}}</code> is empty.", "question.preamble.syntax error": "Syntax error in preamble", "util.equality not defined for type": "Equality not defined for type {{type}}", "ruleset.set not defined": "Ruleset {{name}} has not been defined", "result.question review title": "Review this question", "jme.shunt.no right bracket": "No matching right bracket", "die.sorry": "\u7533\u3057\u8a33\u3042\u308a\u307e\u305b\u3093\u3002Numbas\u306f\u30a8\u30e9\u30fc\u3092\u767a\u751f\u3057\u3053\u308c\u4ee5\u4e0a\u7d9a\u884c\u3067\u304d\u307e\u305b\u3093\u3002\u30a8\u30e9\u30fc\u306e\u8a73\u7d30\u306f\u4ee5\u4e0b\u3092\u53c2\u7167\u3057\u3066\u304f\u3060\u3055\u3044\u3002", "control.end exam": "End Exam", "vectormath.cross.not 3d": "Can only take the cross product of 3-dimensional vectors.", "part.mcq.matrix not a list": "Marking matrix, defined by JME expression, is not a list but it should be.", "part.marking.nothing entered": "\u89e3\u7b54\u3092\u5165\u529b\u3057\u3066\u3044\u307e\u305b\u3093", "part.numberentry.give your answer as a reduced fraction": "Reduce your answer to lowest terms.", "mark_plural": "marks", "question.hide steps no penalty": "Your score will not be affected.", "step": "step", "part.numberentry.correct except decimal": "Your answer is within the allowed range, but decimal numbers are not allowed.", "question.can not submit": "Can not submit answer - check for errors.", "math.choose.empty selection": "Empty selection given to random function", "part.jme.answer too long": "Your answer is too long.", "mathjax.error": "MathJax\u30d7\u30ed\u30bb\u30b9\u30a8\u30e9\u30fc: {{message}}", "control.submit answer": "\u89e3\u7b54\u306e\u63d0\u51fa", "exam.failed": "Failed", "part.jme.not-allowed one": "Your answer must not contain: {{strings}}", "jme.shunt.not enough arguments": "Not enough arguments for operation {{op}}", "question.answer submitted": "Answer submitted", "part.jme.must-have one": "Your answer must contain: {{strings}}", "part.correct answer": "Expected answer:", "part.numberentry.answer not reduced": "Your answer is not reduced to lowest terms.", "control.next": "\u6b21", "part.mcq.marking matrix string empty": "The custom marking matrix expression is empty.", "matrixmath.abs.too big": "Sorry, can't compute the determinant of a matrix bigger than 3x3 yet.", "jme.texsubvars.no right bracket": "No matching <code>]</code> in {{op}} arguments.", "mathjax.math processing error": "\"{{message}}\" when texifying <code>{{expression}}</code>", "jme.matrix.reports bad size": "Matrix reports its size incorrectly - must be an error in constructor function", "part.marking.steps change": "You were awarded <strong>{{count,niceNumber}}</strong> $t(mark) for your answers to the steps.", "part.mcq.choices": "\u9078\u629e\u80a2", "part.jme.answer invalid": "Your answer is not a valid mathematical expression.<br/>{{message}}.", "jme.shunt.list mixed argument types": "Can't parse {{mode}}: mix of dictionary and list elements", "jme.func.except.continuous range": "Can't use the 'except' operator on continuous ranges.", "exam.marks available": "\u63a1\u70b9\u53ef\u80fd:", "math.combinations.k less than zero": "Can't compute combinations: k is less than zero", "result.question number": "\u554f\u984c\u756a\u53f7", "control.submit all parts": "Submit all parts", "jme.func.listval.not a list": "Object is not subscriptable", "part.numberentry.give your answer to precision": "Round your answer to {{count,niceNumber}} {{precisionType}}.", "part.mcq.wrong number of choices": "\u9078\u629e\u80a2\u306e\u9078\u629e\u6570\u304c\u9593\u9055\u3063\u3066\u3044\u307e\u3059", "jme.variables.syntax error in function definition": "\u95a2\u6570\u5b9a\u7fa9\u306e\u6587\u6cd5\u30a8\u30e9\u30fc", "page.saving": "<p>Saving.</p>\n<p>This might take a few seconds.</p>", "math.gcf.complex": "Can't compute GCF of complex numbers", "part.matrix.some incorrect": "One or more of the cells in your answer is incorrect, but you have been awarded marks for the rest.", "math.combinations.complex": "Can't compute combinations of complex numbers", "control.total": "\u5408\u8a08", "jme.user javascript.error": "Error in user-defined javascript function <code>{{name}}</code>: {{message}}", "part.matrix.invalid cell": "One or more of the cells in your answer is empty or invalid.", "scorm.error loading question": "Error loading question {{number}}: {{message}}", "part.numberentry.give your answer to precision_0": "Round your answer to the nearest integer.", "jme.shunt.no right square bracket": "No matching right square bracket to end list", "control.not all questions answered": "\u3053\u306e\u8a66\u9a13\u306e\u554f\u984c\u306f\u5168\u3066\u306f\u5b8c\u4e86\u3057\u3066\u3044\u307e\u305b\u3093\u3002", "jme.display.unknown token type": "Can't texify token type {{type}}", "part.numberentry.answer invalid": "You did not enter a valid number.", "jme.user javascript.returned undefined": "User-defined javascript function <code>{{name}}</code> returned <code>undefined</code>.", "question.hide steps": "Hide steps", "part.mcq.matrix wrong type": "Element of invalid type '{{type}}' used in marking matrix.", "math.combinations.n less than k": "Can't compute combinations: n is less than k", "mark": "\u63a1\u70b9", "suspend.you can resume": "You will be able to resume this session the next time you start this activity.", "scorm.error loading suspend data": "Error loading suspend data: {{message}}", "result.result": "\u7d50\u679c:", "question.show steps": "Show steps", "question.submit part": "Submit part", "part.jme.unexpected variable name": "Your answer was interpreted to use the unexpected variable name <code>{{name}}</code>.", "part.matrix.empty cell": "One or more of the cells in your answer is empty.", "control.regen": "\u540c\u985e\u306e\u4ed6\u306e\u554f\u984c\u3092\u3084\u308a\u307e\u3057\u3087\u3046", "control.advice": "Advice", "xml.could not load": "Couldn't load an XML document: {{message}}", "part.marking.uncaught error": "Error when marking {{part}}: {{message}}", "question.score feedback.score total actual": "Score: {{score,niceNumber}}/{{marks,niceNumber}}", "result.print": "Print this results summary", "math.siground.complex": "Can't round to a complex number of sig figs", "question.header": "Question {{number}}", "math.permutations.k less than zero": "Can't compute permutations: k is less than zero", "question.preamble.error": "Error in preamble: {{message}}", "suspend.resume": "\u518d\u958b", "part.mcq.correct choice": "You chose the correct answer.", "part.numberentry.answer not integer": "Your answer is invalid. You must enter a whole number, not a decimal.", "part.jme.not-allowed several": "Your answer must not contain any of: {{strings}}", "part.numberentry.precision type.dp_plural": "decimal places", "question.unsupported part type": "Unsupported part type", "jme.variables.error evaluating variable": "Error evaluating variable {{name}}: {{message}}", "jme.func.listval.key not in dict": "Dictionary does not contain the key <code>{{key}}</code>", "part.mcq.answers": "\u89e3\u7b54", "jme.typecheck.map not on enumerable": "<code>map</code> operation must work over a list or a range, not {{type}}", "jme.substituteTree.undefined variable": "Undefined variable: <code>{{name}}</code>", "modal.cancel": "\u30ad\u30e3\u30f3\u30bb\u30eb", "scorm.failed save": "<p>The request to save data to the server failed. Press <b>OK</b> to try again.</p>\n<p>If you get this message repeatedly, check your internet connection or use a different computer. Your previously submitted answers have been successfully saved and will be restored if you resume this session on a different computer.</p>\n<p>If this message appears persistently and you can't save <em>any</em> answers, please contact your lecturer or teacher.</p>", "jme.typecheck.function maybe implicit multiplication": "Operation {{name}} is not defined. Did you mean <br/><code>{{first}}*{{possibleOp}}(...)</code>?", "part.jme.answer too short": "Your answer is too short.", "matrixmath.mul.different sizes": "Can't multiply matrices of different sizes.", "jme.func.switch.no default case": "No default case for Switch statement", "part.numberentry.zero sig fig": "This part is set up to round the student's answer to zero significant figures, which has no meaning.", "frontpage.start": "Start", "result.question score": "\u70b9\u6570", "part.mcq.choices missing": "Definition of choices is missing", "question.score feedback.correct": "\u6b63\u89e3\u3067\u3059", "part.feedback": "\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af", "question.score feedback.answered": "Answered.", "math.permutations.n less than k": "Can't compute permutations: n is less than k", "part.gapfill.feedback header": "<strong>Gap {{index}}</strong>", "question.advice": "Advice", "vectormath.cross.matrix too big": "Can't calculate cross product of a matrix which isn't $1 \\times N$ or $N \\times 1$.", "part.jme.not-allowed bits": "<span class=\"monospace\">{{string}}</span>", "display.part.jme.error making maths": "Error making maths display", "part.prompt": "prompt", "control.proceed anyway": "\u3068\u306b\u304b\u304f\u5148\u306b\u9032\u307f\u307e\u3059\u304b\uff1f", "gap": "gap", "jme.tokenise.invalid": "Invalid expression: <code>{{expression}}</code>", "result.score": "\u5f97\u70b9:", "math.lcm.complex": "Can't compute LCM of complex numbers", "exam.random seed": "\u30bb\u30c3\u30b7\u30e7\u30f3ID:", "modal.ok": "OK", "was": "was", "jme.thtml.not html": "Passed a non-HTML value into the THTML constructor.", "question.score feedback.partial": "\u90e8\u5206\u7684\u306b\u6b63\u89e3\u3067\u3059", "mathjax.error with context": "MathJax processing error in {{context}}: {{message}}", "question.score feedback.wrong": "\u9593\u9055\u3044\u3067\u3059", "question.score feedback.score actual": "Score: {{scoreString}}", "part.numberentry.correct except fraction": "Your answer is within the allowed range, but fractions are not allowed.", "question.error": "Question {{number}}: {{message}}", "jme.evaluate.no scope given": "Numbas.jme.evaluate must be given a Scope", "question.show steps already penalised": "You have already shown steps. You can show them again with no further penalty.", "part.jme.answer missing": "Correct answer is missing", "part.mcq.no choices selected": "\u9078\u629e\u80a2\u304c\u9078\u629e\u3055\u308c\u3066\u3044\u307e\u305b\u3093", "die.script not loaded": "Numbas couldn't start because the file <code>{{file}}</code> was not loaded. Check that it's included in <code>scripts.js</code>.", "part.numberentry.precision type.dp": "decimal place", "part.matrix.answer invalid": "Your answer is not valid.", "jme.variables.question took too many runs to generate variables": "A valid set of question variables was not generated in time.", "jme.texsubvars.no right brace": "No matching <code>}</code> in {{op}}", "page.loading": "\u8aad\u307f\u8fbc\u307f\u4e2d...", "part.jme.marking.correct": "Your answer is numerically correct.", "part.marking.correct": "\u6b63\u89e3\u3067\u3059", "part.matrix.size mismatch": "The question author hasn't allowed the student to decide the dimensions of their answer, but the correct answer is {{correct_dimensions}} while the answer input is {{input_dimensions}}", "exam.feedback": "Exam feedback message", "part.marking.used variable replacements": "This part was marked using your answers to previous parts.", "control.submit": "\u63d0\u51fa", "jme.shunt.no left square bracket": "No matching left bracket", "jme.func.listval.invalid index": "Invalid list index {{index}} on list of size {{size}}", "question.score feedback.hide": "\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u3092\u96a0\u3059", "jme.variables.circular reference": "Circular variable reference in definition of <code>{{name}}</code>", "result.time spent": "\u7d4c\u904e\u6642\u9593:", "die.error": "\u30a8\u30e9\u30fc", "timing.time remaining": "\u6b8b\u308a\u6642\u9593:", "part.numberentry.negative decimal places": "This part is set up to round the student's answer to a negative number of decimal places, which has no meaning.", "part.with steps answer prompt": "\u89e3\u7b54: ", "control.confirm leave": "\u307e\u3060\u8a66\u9a13\u306f\u7d42\u4e86\u3057\u3066\u3044\u307e\u305b\u3093\u3002", "jme.typecheck.op not defined": "Operation '{{op}}' is not defined.", "part": "part", "control.submit again": "\u518d\u63d0\u51fa", "xml.error in variable definition": "Error in definition of variable <code>{{name}}</code>", "exam.changeQuestion.no questions": "This exam contains no questions! Check the .exam file for errors.", "part.jme.must-have bits": "<span class=\"monospace\">{{string}}</span>", "part.marking.total score": "You scored <strong>{{count,niceNumber}}</strong> $t(mark) for this part.", "exam.introduction": "Exam introduction", "control.confirm regen": "Would you like to re-randomise this question? If you click OK, all your answers and marks for the current question will be lost.", "jme.evaluate.undefined variable": "Variable {{name}} is undefined", "jme.display.simplifyTree.no scope given": "Numbas.jme.display.simplifyTree must be given a Scope", "timing.no accumulator": "no timing accumulator {{name}}", "util.product.non list": "Passed a non-list to <code>Numbas.util.product</code>", "part.marking.revealed steps no penalty": "You revealed the steps.", "part.jme.unexpected variable name suggestion": "Your answer was interpreted to use the unexpected variable name <code>{{name}}</code>. Did you mean <code>{{suggestion}}</code>?", "jme.display.collectRuleset.set not defined": "Ruleset {{name}} has not been defined", "was_plural": "were", "part.marking.no result": "This part could not be marked.", "part.setting not present": "Property '{{property}}' not set", "exam.number of questions": "\u554f\u984c\u6570:", "part.numberentry.answer not integer or decimal": "Your answer is invalid. You must enter an integer or a decimal.", "question.selector.unsubmitted changes": "Unsubmitted changes.", "vectormath.dot.matrix too big": "Can't calculate dot product of a matrix which isn't $1 \\times N$ or $N \\times 1$.", "scorm.no exam suspend data": "Failed to resume: no exam suspend data.", "math.permutations.n less than zero": "Can't compute permutations: n is less than zero", "part.matrix.empty": "\u307e\u3060\u89e3\u7b54\u304c\u5165\u529b\u3055\u308c\u3066\u3044\u307e\u305b\u3093", "part.jme.must-have several": "Your answer must contain all of: {{strings}}", "part.patternmatch.display answer missing": "Display answer is missing", "math.precround.complex": "Can't round to a complex number of decimal places", "jme.func.matrix.invalid row type": "Can't construct a matrix from rows of type {{type}}", "jme.tokenise.keypair key not a string": "Dictionary key should be a string, not {{type}}.", "jme.shunt.no left bracket": "No matching left bracket", "result.exam summary": "Exam Summary", "jme.typecheck.no right type definition": "No definition of '{{op}}' of correct type found.", "exam.time allowed": "\u5236\u9650\u6642\u9593:", "question.statement": "Statement", "xml.property not number": "Property {{name}} should be a number, but isn't ({{value}}), in node {{element}}", "exam.exam name": "Exam Name:", "control.previous": "\u524d"}}, "nl-nl": {"translation": {"jme.typecheck.no right type unbound name": "Variabele <code>{{name}}</code> is niet gedefinieerd.", "control.pause": "Pauze", "feedback.taken away": "<strong>{{count}}</strong> $t(mark) $t(was) ingehouden.", "question.score feedback.unanswered": "Niet gemaakt.", "control.reveal": "Laat zien", "part.marking.steps no matter": "Omdat je al alle punten voor dit onderdeel hebt leveren de afzonderlijke stappen geen punten meer op.", "part.marking.resubmit because of variable replacement": "De score van dit onderdeel hangt af van eerder gegeven antwoorden die je nu hebt gewijzigd. Verzend dit deel opnieuw om je score te updaten.", "question.no such part": "Onderdeel {{path}} ontbreekt", "control.back to results": "Ga terug naar resultaten", "part.unknown type": "{{part}}: Onderdeeltype {{type}} is onbekend", "result.click a question to review": "Klik op een vraagnummer om je scores en eventuele uitwerkingen te zien.", "part.missing type attribute": "{{part}}: Onderdeeltype ontbreekt", "matrixmath.abs.non-square": "De determinant van een niet-vierkante matrix kan niet berekend worden.", "result.performance summary": "Overzicht van de resultaten", "die.numbas failed": "Er is een fout opgetreden", "jme.shunt.no left bracket in function": "Linker haakje ontbreekt in functieaanroep of rijtje", "part.mcq.matrix cell empty": "Part {{part}} marking matrix cell ({{row}},{{column}}) is empty", "question.score feedback.show": "Geef feedback", "part.script.error": "Fout in deel {{path}} custom script {{script}}: {{message}}", "part.numberentry.precision type.sigfig": "significant cijfer", "jme.variables.error computing dependency": "Fout tijdens het berekenen van variabele <code>{{name}}</code>", "exam.passed": "Gehaald", "result.questions attempted": "Aantal gemaakte vragen:", "control.not all questions submitted": "Je hebt een of meer antwoorden gewijzigd maar ze nog niet verzonden. Controleer of elk antwoord verzonden is.", "exam.student name": "Naam:", "scorm.no question suspend data": "Geen vraaggegevens", "result.exam start": "Start toets:", "part.extension.not implemented": "Part hasn't implemented the <code>{{name}}</code> method.", "xml.property not boolean": "Property {{name}} moet een boolean zijn maar is het niet ({{value}}), in node {{element}}", "feedback.you were awarded": "Je hebt <strong>{{count}}</strong> $t(mark) gekregen.", "jme.variables.variable not defined": "Variabele <code>{{name}}</code> is niet gedefinieerd.", "question.loaded name mismatch": "Kan deze poging niet hervatten - de toets is veranderd sinds de vorige sessie.", "control.confirm end": "Weet je zeker dat je de toets wilt afsluiten? Als je afsluit kun je geen antwoorden meer wijzigen.", "result.exam stop": "Einde toets:", "exam.review header": "Review: ", "jme.display.collectRuleset.no sets": "Geen sets opgegeven aan collectRuleset!", "result.exit": "Exit", "scorm.error initialising": "Fout initialiseren SCORM protocol: {{message}}", "exam.pass percentage": "Geslaagd bij:", "math.permutations.complex": "Permutaties van complexe getallen kunnen niet berekend worden", "scorm.error loading part": "Fout bij laden van deel {{part}}: {{message}}", "part.mcq.options def not a list": "De expressie die {{properties}} definieert is geen list.", "part.mcq.matrix mix of numbers and lists": "Mix van getallen en lijsten gebruikt in de score matrix.", "part.marking.variable replacement part not answered": "Je moet {{part}} eerst beantwoorden", "part.marking.did not answer": "Je hebt deze vraag niet beantwoord.", "jme.shunt.missing operator": "Formule kan niet berekend worden -- operator ontbreekt.", "suspend.paused header": "Gepauzeerd", "part.mcq.matrix wrong size": "Score matrix heeft de verkeerde afmetingen.", "part.mcq.matrix jme error": "Part {{part}} marking matrix cell ({{row}},{{column}}) gives a JME error: {{error}}", "end.exam has finished": "De toets is afgelopen. Je kunt het venster sluiten.", "suspend.exam suspended": "De toets is onderbroken. Klik Ga door om verder te gaan.", "jme.texsubvars.missing parameter": "Ontbrekende parameter in {{op}}: {{parameter}}", "part.numberentry.precision type.sigfig_plural": "significante cijfers", "math.lt.order complex numbers": "Complexe getallen kunnen niet geordend worden", "control.confirm reveal": "Wil je het antwoord zien? Je verliest je huidige score en kunt de vraag later niet opnieuw beantwoorden.", "part.patternmatch.correct except case": "Je antwoord is goed, maar je haalt hoofd- en kleine letters door elkaar.", "part.marking.not submitted": "Geen antwoord verzonden", "jme.variables.error making function": "Fout tijdens genereren functie <code>{{name}}</code>: {{message}}", "exam.xml.bad root": "Top element van toets XML moet 'exam' zijn", "part.mcq.matrix not a number": "In onderdeel {{part}} specificeert cel {{row}},{{column}} van de scorematrix geen getal", "question.score feedback.score total": "{{marksString}}. Beantwoord.", "question.show steps penalty": "Je verliest <strong>{{count}}</strong> $t(mark).", "question.unsubmitted changes_plural": "Je hebt antwoorden gewijzigd maar niet verzonden. Controleer alle antwoorden en klik op <strong>Verzend alles</strong>.", "question.show steps no penalty": "Je score verandert niet.", "scorm.no part suspend data": "Geen gegevens van dit deel gevonden", "jme.typecheck.function not defined": "Operator {{op}} is niet gedefinieerd. Bedoel je <br/><code>{{suggestion}}*(...)</code>?", "part.marking.revealed steps with penalty": "Je hebt de stappen bekeken. Het maximale aantal $t(mark) voor dit onderdeel is <strong>{{count}}</strong>. Je score wordt verlaagd.", "question.unsubmitted changes": "Je hebt je antwoord veranderd maar nog niet verzonden. Controleer je antwoord en klik op <strong>Verzend</strong>.", "ruleset.circular reference": "Circular reference in definition of ruleset <code>{{name}}</code>", "math.combinations.n less than zero": "Can't compute combinations: n is less than zero", "part.marking.incorrect": "Je antwoord is fout.", "jme.variables.empty definition": "Definitie van variabele <code>{{name}}</code> is leeg.", "question.preamble.syntax error": "Syntaxisfout in preamble", "util.equality not defined for type": "Gelijkheid niet gedefinieerd voor type {{type}}", "ruleset.set not defined": "Ruleset {{name}} has not been defined", "result.question review title": "Review deze vraag", "jme.shunt.no right bracket": "Rechter haakje ontbreekt", "die.sorry": "Sorry, Numbas is een probleem tegengekomen en kan niet verder. Hieronder staat een beschrijving van het probleem.", "control.end exam": "Klaar", "vectormath.cross.not 3d": "Uitproduct is alleen te berekenen voor 3D-vectoren.", "part.mcq.matrix not a list": "De scorematrix van een Multiple Response onderdeel, gegeven door een JME expressie, moet een list zijn maar is het niet.", "part.marking.nothing entered": "Je hebt geen antwoord ingevuld.", "part.numberentry.give your answer as a reduced fraction": "Reduce your answer to lowest terms.", "mark_plural": "pt", "question.hide steps no penalty": "Je score blijft ongewijzigd.", "step": "stap", "part.numberentry.correct except decimal": "Je antwoord is goed maar mag geen decimaal getal zijn.", "question.can not submit": "Antwoord kan niet verzonden worden - controleer op fouten.", "math.choose.empty selection": "Een lege selectie gebruikt voor de random functie", "part.jme.answer too long": "Je antwoord is te lang.", "mathjax.error": "MathJax processing error: {{message}}", "control.submit answer": "Verzend", "exam.failed": "Niet gehaald", "part.jme.not-allowed one": "In je antwoord mag {{strings}} niet voorkomen", "jme.shunt.not enough arguments": "Te weinig argumenten voor operator {{op}}", "question.answer submitted": "Antwoord verzonden", "part.jme.must-have one": "In je antwoord moet {{strings}} voorkomen", "part.correct answer": "Goede antwoord:", "part.numberentry.answer not reduced": "Your answer is not reduced to lowest terms.", "control.next": "Volgende", "part.mcq.marking matrix string empty": "De score-matrix is leeg.", "matrixmath.abs.too big": "Sorry, de determinant van een matrix groter dan 3x3 kan nog niet berekend worden.", "jme.texsubvars.no right bracket": "Geen passend <code>]</code> in {{op}} argumenten.", "mathjax.math processing error": "MathJax processing error: \"{{message}}\" when texifying <code>{{expression}}</code>", "jme.matrix.reports bad size": "Matrix afmetingen incorrect - moet fout in constructor functie zijn", "part.marking.steps change": "Je krijgt <strong>{{count}}</strong> $t(mark) voor je antwoorden bij de verschillende stappen", "part.mcq.choices": "choices", "part.jme.answer invalid": "Je antwoord is geen geldige formule.<br/>{{message}}", "jme.shunt.list mixed argument types": "Can't parse {{mode}}: mix of dictionary and list elements", "jme.func.except.continuous range": "De 'except' operator kan niet gebruikt worden op continue intervallen.", "exam.marks available": "Aantal punten:", "math.combinations.k less than zero": "Can't compute combinations: k is less than zero", "result.question number": "Vraag nummer", "control.submit all parts": "Verzend alles", "jme.func.listval.not a list": "Object is niet indexeerbaar", "part.numberentry.give your answer to precision": "Rond af op {{count}} {{precisionType}}. ", "part.mcq.wrong number of choices": "Je hebt het verkeerde aantal mogelijkheden geselecteerd.", "jme.variables.syntax error in function definition": "Syntax error in functie definitie", "page.saving": "<p>Gegevens worden opgeslagen.</p>\n<p>Dit kan even duren.</p>", "math.gcf.complex": "De GGD van complexe getallen kan niet berekend worden", "part.matrix.some incorrect": "Een of meer van de cellen in uw antwoord onjuist is, maar je hebt gekregen cijfers voor de rest.", "math.combinations.complex": "Combinaties van complexe getallen kunnen niet berekend worden", "control.total": "Totaal", "jme.user javascript.error": "Fout in javascript functie <code>{{name}}</code>: {{message}}", "part.matrix.invalid cell": "E\u00e9n of meer van de cellen in antwoord leeg of ongeldig.", "scorm.error loading question": "Fout bij het laden van vraag {{number}}: {{message}}", "part.numberentry.give your answer to precision_0": "Round your answer to the nearest integer.", "jme.shunt.no right square bracket": "Rechter blokhaak ontbreekt aan het einde van de lijst", "control.not all questions answered": "Je hebt niet alle vragen in deze toets beantwoord.", "jme.display.unknown token type": "Kan token van type {{type}} niet naar TeX vertalen", "part.numberentry.answer invalid": "Je hebt geen geldig getal ingevoerd.", "jme.user javascript.returned undefined": "User-defined javascript function <code>{{name}}</code> returned <code>undefined</code>.", "question.hide steps": "Verberg stappen", "part.mcq.matrix wrong type": "Element heeft een verkeerd type '{{type}}' in de score matrix.", "math.combinations.n less than k": "Can't compute combinations: n is less than k", "mark": "pt", "suspend.you can resume": "Volgende keer dat je de toets opstart kun je verder gaan met deze sessie.", "scorm.error loading suspend data": "Fout bij het laden van toetsgegevens: {{message}}", "result.result": "Resultaat:", "question.show steps": "Laat stappen zien", "question.submit part": "Verzend antwoord", "part.jme.unexpected variable name": "In je antwoord gebruik je de onbekende variabelenaam <code>{{name}}</code>.", "part.matrix.empty cell": "E\u00e9n of meer van de cellen in antwoord leeg.", "control.regen": "Probeer soortgelijke vraag opnieuw", "control.advice": "Uitwerking", "xml.could not load": "Het XML document kan niet geladen worden: {{message}}", "part.marking.uncaught error": "Fout bij scoren van {{part}}: {{message}}", "question.score feedback.score total actual": "Score: {{score}}/{{marks}}", "result.print": "Print dit overzicht van de resultaten", "math.siground.complex": "Afronden op een complex aantal significante cijfers is niet mogelijk", "question.header": "Vraag {{number}}", "math.permutations.k less than zero": "Can't compute permutations: k is less than zero", "question.preamble.error": "Fout in preamble: {{message}}", "suspend.resume": "Ga door", "part.mcq.correct choice": "Je hebt het juiste antwoord gekozen.", "part.numberentry.answer not integer": "Je antwoord is niet correct. Vul een geheel getal in, geen decimaal getal.", "part.jme.not-allowed several": "In je antwoord mag niets uit {{strings}} voorkomen", "part.numberentry.precision type.dp_plural": "decimalen", "question.unsupported part type": "Onbekend onderdeeltype", "jme.variables.error evaluating variable": "Fout bij berekenen variabele {{name}}: {{message}}", "jme.func.listval.key not in dict": "Dictionary does not contain the key <code>{{key}}</code>", "part.mcq.answers": "answers", "jme.typecheck.map not on enumerable": "<code>map</code> operator vereist een list of range, niet {{type}}", "jme.substituteTree.undefined variable": "Ongedefinieerde variabele: <code>{{name}}</code>", "modal.cancel": "Annuleren", "scorm.failed save": "De gegevens konden niet opgeslagen worden op de server. Je huidige sessie, inclusief antwoorden en scores, is misschien niet bewaard. Je kunt het nog eens proberen. Mail naar <a href=\"mailto:numbas@ncl.ac.uk\">numbas@ncl.ac.uk</a> als dit vaker voorkomt.", "jme.typecheck.function maybe implicit multiplication": "Operator {{name}} is niet gedefinieerd. Bedoel je <br/><code>{{first}}*{{possibleOp}}(...)</code>?", "part.jme.answer too short": "Je antwoord is te kort.", "matrixmath.mul.different sizes": "Matrices van verschillende grootte kunnen niet vermenigvuldigd worden.", "jme.func.switch.no default case": "Default case van Switch statement ontbreekt", "part.numberentry.zero sig fig": "Dit deel is zo gemaakt dat een antwoord op 0 significante cijfers wordt afgerond wat zinloos is.", "frontpage.start": "Start", "result.question score": "Score", "part.mcq.choices missing": "Antwoordmogelijkheden voor Multiple Response onderdeel (%s) ontbreken", "question.score feedback.correct": "Je antwoord is goed", "part.feedback": "feedback", "question.score feedback.answered": "Beantwoord.", "math.permutations.n less than k": "Can't compute permutations: n is less than k", "part.gapfill.feedback header": "<strong>Vak {{index}}</strong>", "question.advice": "Uitwerking", "vectormath.cross.matrix too big": "Uitproduct is alleen te berekenen voor een matrix met afmetingen $1 \\times N$ of $N \\times 1$.", "part.jme.not-allowed bits": "<span class=\"monospace\">{{string}}</span>", "display.part.jme.error making maths": "Fout tijdens weergeven formule", "part.prompt": "prompt", "control.proceed anyway": "Doorgaan?", "gap": "gat", "jme.tokenise.invalid": "Ongeldige formule: <code>{{expression}}</code>", "result.score": "Score:", "math.lcm.complex": "Het KGV van complexe getallen kan niet berekend worden", "exam.random seed": "Sessie ID:", "modal.ok": "OK", "was": "was", "jme.thtml.not html": "Passed een niet-HTML waarde in de THML constructor", "question.score feedback.partial": "Je antwoord is gedeeltelijk goed", "mathjax.error with context": "MathJax processing error in {{context}}: {{message}}", "question.score feedback.wrong": "Je antwoord is fout", "question.score feedback.score actual": "Score: {{scoreString}}", "part.numberentry.correct except fraction": "Je antwoord klopt maar breuken zijn niet toegestaan.", "question.error": "Vraag {{number}}: {{message}}", "jme.evaluate.no scope given": "Numbas.jme.evaluate must be given a Scope", "question.show steps already penalised": "Je hebt de stappen al bekeken. Je kunt ze nog eens bekijken zonder opnieuw punten te verliezen.", "part.jme.answer missing": "Goede antwoord voor een JME onderdeel ontbreekt (%s)", "part.mcq.no choices selected": "Geen keuze gemaakt.", "die.script not loaded": "Numbas couldn't start because the file <code>{{file}}</code> was not loaded. Check that it's included in <code>scripts.js</code>.", "part.numberentry.precision type.dp": "decimaal", "part.matrix.answer invalid": "Je antwoord is ongeldig.", "jme.variables.question took too many runs to generate variables": "Een geldige set vraag variabelen werd niet gegenereerd in de tijd.", "jme.texsubvars.no right brace": "Geen passend <code>}</code> in {{op}}", "page.loading": "Bezig met laden ...", "part.jme.marking.correct": "Je antwoord heeft de juiste waarde.", "part.marking.correct": "Je antwoord is goed.", "part.matrix.size mismatch": "The question author hasn't allowed the student to decide the dimensions of their answer, but the correct answer is {{correct_dimensions}} while the answer input is {{input_dimensions}}", "exam.feedback": "Exam feedback message", "part.marking.used variable replacements": "Dit deel is gescoord op basis van eerder gegeven antwoorden.", "control.submit": "Verzend", "jme.shunt.no left square bracket": "Linker haakje ontbreekt", "jme.func.listval.invalid index": "Ongeldige list index {{index}} voor een list van grootte {{size}}", "question.score feedback.hide": "Verberg", "jme.variables.circular reference": "Circulaire verwijzing naar variabele in <code>{{name}}</code>", "result.time spent": "Tijd:", "die.error": "Probleem", "timing.time remaining": "Resterende tijd: %s", "part.numberentry.negative decimal places": "This part is set up to round the student's answer to a negative number of decimal places, which has no meaning.", "part.with steps answer prompt": "Antwoord: ", "control.confirm leave": "De toets is nog niet af.", "jme.typecheck.op not defined": "Operator '{{op}}' is niet gedefinieerd.", "part": "deel", "control.submit again": "Verzend opnieuw", "xml.error in variable definition": "Fout in definitie van variabele <code>{{name}}</code>", "exam.changeQuestion.no questions": "Deze toets bevat geen vragen! Controleer het .exam bestand op fouten.", "part.jme.must-have bits": "<span class=\"monospace\">{{string}}</span>", "part.marking.total score": "Je krijgt <strong>{{count}}</strong> $t(mark) voor dit onderdeel.", "exam.introduction": "Exam introduction", "control.confirm regen": "Weet je zeker dat je deze vraag opnieuw wilt maken? Als je opnieuw begint verlies je je huidige score.", "jme.evaluate.undefined variable": "Variabele {{name}} is niet gedefinieerd", "jme.display.simplifyTree.no scope given": "Numbas.jme.display.simplifyTree vereist een Scope", "timing.no accumulator": "no timing accumulator {{name}}", "util.product.non list": "Passed a non-list to <code>Numbas.util.product</code>", "part.marking.revealed steps no penalty": "Je hebt de stappen bekeken.", "part.jme.unexpected variable name suggestion": "In je antwoord gebruik je de onbekende variabelenaam <code>{{name}}</code>. Bedoel je <code>{{suggestion}}</code>?", "jme.display.collectRuleset.set not defined": "Ruleset {{name}} is niet gedefinieerd", "was_plural": "waren", "part.marking.no result": "Dit onderdeel kan niet gescoord worden.", "part.setting not present": "Property '{{property}}' onbekend", "exam.number of questions": "Aantal vragen:", "part.numberentry.answer not integer or decimal": "Je antwoord is niet correct. Vul een geheel getal of decimaal getal in.", "question.selector.unsubmitted changes": "Niet verzonden wijzigingen.", "vectormath.dot.matrix too big": "Het inproduct is alleen te berekenen voor een matrix met afmetingen $1 \\times N$ of $N \\times 1$.", "scorm.no exam suspend data": "Hervatten mislukt: geen toetsgegevens gevonden.", "math.permutations.n less than zero": "Can't compute permutations: n is less than zero", "part.matrix.empty": "U hebt geen antwoord ingevuld", "part.jme.must-have several": "In je antwoord moet {{string}} allemaal voorkomen", "part.patternmatch.display answer missing": "Display answer ontbreekt in het Pattern Match onderdeel (%s)", "math.precround.complex": "Afronden op een complex aantal decimalen is niet mogelijk", "jme.func.matrix.invalid row type": "Een matrix kan niet gemaakt worden uit rijen van type {{type}}", "jme.tokenise.keypair key not a string": "Dictionary key should be a string, not {{type}}.", "jme.shunt.no left bracket": "Linker haakje ontbreekt", "result.exam summary": "Overzicht toets", "jme.typecheck.no right type definition": "Geen definitie van '{{op}}' bekend van het juiste type.", "exam.time allowed": "Beschikbare tijd:", "question.statement": "Statement", "xml.property not number": "Property {{name}} moet een getal zijn maar is het niet ({{value}}), in node {{element}}", "exam.exam name": "Naam toets:", "control.previous": "Vorige"}}, "sq-al": {"translation": {"jme.typecheck.no right type unbound name": "Variabli <code>{{name}}</code> nuk \u00ebsht\u00eb i p\u00ebrcaktuar.", "control.pause": "Nd\u00ebrprit p\u00ebrkoh\u00ebsisht", "feedback.taken away": "<strong>{{count,niceNumber}}</strong> $t(mark) $t(was) zbritur.", "question.score feedback.unanswered": "Pa p\u00ebrgjigje", "control.reveal": "Zbulo p\u00ebrgjigjet", "part.marking.steps no matter": "Meqen\u00ebse keni marr\u00eb t\u00eb gjtha pik\u00ebt p\u00ebr pjes\u00ebn, p\u00ebrgjigjet p\u00ebr hapat nuk do t\u00eb llogariten.", "part.marking.resubmit because of variable replacement": "Vler\u00ebsimi i k\u00ebsaj k\u00ebrkese varet nga p\u00ebrgjigjet e k\u00ebrkesave t\u00eb tjera, t\u00eb cilat ju i keni ndryshuar. Dor\u00ebzoni p\u00ebrs\u00ebri p\u00ebrgjigjen p\u00ebr k\u00ebt\u00eb k\u00ebrkes\u00eb p\u00ebr t\u00eb azhornuar rezultatin. ", "question.no such part": "K\u00ebrkesa {{path}} nuk mund t\u00eb gjendet ", "control.back to results": "Kthehu tek rezultatet", "part.unknown type": "{{part}}: Unrecognised part type {{type}}", "result.click a question to review": "Kliko mbi nj\u00eb num\u00ebr pyetjeje p\u00ebr t\u00eb par\u00eb se si jan\u00eb vler\u00ebsuar p\u00ebrgjigjet tuaja dhe kur \u00ebsht\u00eb e mundur, zgjidhjet e plota.", "part.missing type attribute": "{{part}}: Missing part type attribute", "matrixmath.abs.non-square": "Can't compute the determinant of a matrix which isn't square.", "result.performance summary": "P\u00ebrmbledhje e rezultateve", "die.numbas failed": "Numbas d\u00ebshtoi", "jme.shunt.no left bracket in function": "Nuk kombinon kllapa majtas n\u00eb aplikimin e funksionit ose tek sistemi i renditur", "part.mcq.matrix cell empty": "Part {{part}} marking matrix cell ({{row}},{{column}}) is empty", "question.score feedback.show": "Paraqit vler\u00ebsim", "part.script.error": "Error in part {{path}} custom script {{script}}: {{message}}", "part.numberentry.precision type.sigfig": "shif\u00ebr me vler\u00eb", "jme.variables.error computing dependency": "Error computing referenced variable <code>{{name}}</code>", "exam.passed": "Pranohet", "result.questions attempted": "Pyetjte t\u00eb tratjuara:", "control.not all questions submitted": "Ju keni b\u00ebr\u00eb ndryshime n\u00eb nj\u00eb ose m\u00eb shum\u00eb p\u00ebrgjigje, por nuk i keni dor\u00ebzuar ato. Ju lutemi kontrolloni q\u00eb \u00e7do pyetje t\u00eb jet\u00eb dor\u00ebzuar.", "exam.student name": "Emri i Studentit:", "scorm.no question suspend data": "Nuk ka t\u00eb dh\u00ebna t\u00eb pezulluara p\u00ebr pyetjen", "result.exam start": "Fillimi i Provimit:", "part.extension.not implemented": "K\u00ebrkesa nuk ka implementuar metod\u00ebn <code>{{name}}</code>.", "xml.property not boolean": "Property {{name}} should be a boolean, but isn't ({{value}}), in node {{element}}", "feedback.you were awarded": "Jeni vler\u00ebsuar me <strong>{{count,niceNumber}}</strong> $t(mark).", "jme.variables.variable not defined": "Variabli <code>{{name}}</code> nuk \u00ebsht\u00eb i p\u00ebrcaktuar.", "question.loaded name mismatch": "Nuk mund t\u00eb vazhdohet ky sesion, sepse aplikacioni ka ndryshuar.", "control.confirm end": "Jeni t\u00eb sigurt q\u00eb doni t\u00eb p\u00ebrfundoni provimin? Pas k\u00ebsaj, nuk do t\u00eb jeni n\u00eb gjendje t\u00eb ndryshoni asnj\u00eb nga p\u00ebrgjigjet tuaja.", "result.exam stop": "Mbarimi i Provimit:", "exam.review header": "Koment: ", "jme.display.collectRuleset.no sets": "No sets given to collectRuleset!", "result.exit": "Dil nga Provimi", "scorm.error initialising": "Error initialising SCORM protocol: {{message}}", "exam.pass percentage": "P\u00ebrqindja p\u00ebr t\u00eb kaluar:", "math.permutations.complex": "Can't compute permutations of complex numbers", "scorm.error loading part": "Gabim n\u00eb ngarkimin e k\u00ebrkes\u00ebs {{part}}: {{message}}", "part.mcq.options def not a list": "The expression defining the {{properties}} is not a list.", "part.mcq.matrix mix of numbers and lists": "Mix of numbers and lists used in marking matrix.", "part.marking.variable replacement part not answered": "Duhet ti p\u00ebrgjigjeni {{part}} m\u00eb par\u00eb", "part.marking.did not answer": "Nuk i jeni p\u00ebrgjigjur k\u00ebsaj pyetjeje.", "jme.shunt.missing operator": "Shprehja nuk mund t\u00eb vler\u00ebsohet - mungon nj\u00eb operator.", "suspend.paused header": "I nd\u00ebrprer\u00eb p\u00ebrkoh\u00ebsisht", "part.mcq.matrix wrong size": "Marking matrix is the wrong size.", "part.mcq.matrix jme error": "Part {{part}} marking matrix cell ({{row}},{{column}}) gives a JME error: {{error}}", "end.exam has finished": "Provimi ka mbaruar. Tani mund ta mbyllni k\u00ebt\u00eb dritare.", "suspend.exam suspended": "Provimi \u00ebsht\u00eb nd\u00ebrprer\u00eb p\u00ebrkoh\u00ebsisht. Shtypni <em>Vazhdo</em> p\u00ebr t\u00eb vazhduar.", "jme.texsubvars.missing parameter": "Missing parameter in {{op}}: {{parameter}}", "part.numberentry.precision type.sigfig_plural": "shifra me vler\u00eb", "math.lt.order complex numbers": "Can't order complex numbers", "control.confirm reveal": "D\u00ebshironi t\u00eb zbuloni p\u00ebrgjigjen p\u00ebr k\u00ebt\u00eb pyetje? \u00c7do vler\u00ebsim q\u00eb keni marr\u00eb deri tani do t\u00eb bllokohet dhe nuk do t\u00eb jeni n\u00eb gjendje t'i p\u00ebrgjigjeni k\u00ebsaj pyetjeje m\u00eb von\u00eb.", "part.patternmatch.correct except case": "P\u00ebrgjigja juaj \u00ebsht\u00eb e sakt\u00eb, p\u00ebrve\u00e7 k\u00ebtij rasti.", "part.marking.not submitted": "Nuk \u00ebsht\u00eb dor\u00ebzuar p\u00ebrgjigje", "jme.variables.error making function": "Error making function <code>{{name}}</code>: {{message}}", "exam.xml.bad root": "Elementi rr\u00ebnj\u00eb i provimit XML duhet t\u00eb jet\u00eb 'exam'", "part.mcq.matrix not a number": "Part {{part}} marking matrix cell ({{row}},{{column}}) does not evaluate to a number", "question.score feedback.score total": "{{marksString}}. Me p\u00ebrgjigje.", "question.show steps penalty": "Do ju zbriten <strong>{{count,niceNumber}}</strong> $t(mark).", "question.unsubmitted changes_plural": "Keni ndryshuar p\u00ebrgjigjet por nuk i keni dor\u00ebzuar. Ju lutemi kontrolloni p\u00ebrgjigjet dhe klikoni butonin <strong>Dor\u00ebzo t\u00eb gjitha p\u00ebrgjigjet</strong>.", "question.show steps no penalty": "Vler\u00ebsimi nuk do t\u00eb ndikohet.", "scorm.no part suspend data": "Nuk ka t\u00eb dh\u00ebna t\u00eb pezulluara p\u00ebr k\u00ebrkes\u00ebn", "jme.typecheck.function not defined": "Veprimi {{name}} nuk \u00ebsht\u00eb i p\u00ebrcaktuar. Mos keni dashur <br/><code>{{suggestion}}*(...)</code>?", "part.marking.revealed steps with penalty": "Keni paraqitur hapat. Maksimumi i vler\u00ebsimit p\u00ebr k\u00ebt\u00eb k\u00ebrkes\u00eb \u00ebsht\u00eb <strong>{{count,niceNumber}}</strong> $t(mark). Vler\u00ebsimi juaj do t\u00eb ulet bazuar mbi k\u00ebt\u00eb.", "question.unsubmitted changes": "Keni ndryshuar p\u00ebrgjigjen por nuk e keni dor\u00ebzuar. Ju lutemi kontrolloni p\u00ebrgjigjen dhe klikoni butonin <strong>Dor\u00ebzo p\u00ebrgjigje</strong>.", "ruleset.circular reference": "Circular reference in definition of ruleset <code>{{name}}</code>", "math.combinations.n less than zero": "Can't compute combinations: n is less than zero", "part.marking.incorrect": "P\u00ebrgjigja juaj \u00ebsht\u00eb e pasakt\u00eb.", "jme.variables.empty definition": "P\u00ebrcaktimi i variablit <code>{{name}}</code> \u00ebsht\u00eb bosh.", "question.preamble.syntax error": "Syntax error in preamble", "util.equality not defined for type": "Equality not defined for type {{type}}", "ruleset.set not defined": "Ruleset {{name}} has not been defined", "result.question review title": "Komento k\u00ebt\u00eb pyetje", "jme.shunt.no right bracket": "Nuk kombinon kllapa djathtas", "die.sorry": "Na vjen keq, Numbas ka hasur n\u00eb nj\u00eb gabim q\u00eb do t\u00eb thot\u00eb se nuk mund t\u00eb vazhdoj\u00eb. M\u00eb posht\u00eb \u00ebsht\u00eb nj\u00eb p\u00ebrshkrim i gabimit.", "control.end exam": "P\u00ebrfundo Provimin", "vectormath.cross.not 3d": "Can only take the cross product of 3-dimensional vectors.", "part.mcq.matrix not a list": "Marking matrix, defined by JME expression, is not a list but it should be.", "part.marking.nothing entered": "Nuk keni dh\u00ebn\u00eb nj\u00eb p\u00ebrgjigje.", "part.numberentry.give your answer as a reduced fraction": "Thjeshtoni p\u00ebrgjigjen n\u00eb termat m\u00eb t\u00eb vegj\u00ebl.", "mark_plural": "pik\u00eb", "question.hide steps no penalty": "Vler\u00ebsimi nuk do t\u00eb ndikohet.", "step": "hap", "part.numberentry.correct except decimal": "P\u00ebrgjigja juaj \u00ebsht\u00eb brenda intervalit t\u00eb lejuar, por nuk pranohen numrat dhjetor\u00eb.", "question.can not submit": "P\u00ebrgjigja nuk mund t\u00eb dor\u00ebzohet - kontrolloni p\u00ebr gabime.", "math.choose.empty selection": "Empty selection given to random function", "part.jme.answer too long": "P\u00ebrgjigja juaj \u00ebsht\u00eb shum\u00eb e gjat\u00eb.", "mathjax.error": "MathJax processing error: {{message}}", "control.submit answer": "Dor\u00ebzo p\u00ebrgjigjen", "exam.failed": "Nuk pranohet", "part.jme.not-allowed one": "P\u00ebrgjigja juaj nuk duhet t\u00eb p\u00ebrmbaj\u00eb: {{strings}}", "jme.shunt.not enough arguments": "Nuk ka argumente t\u00eb mjaftuesh\u00ebm p\u00ebr operatorin {{op}}", "question.answer submitted": "P\u00ebrgjigja u dor\u00ebzua.", "part.jme.must-have one": "P\u00ebrgjigja juaj duhet t\u00eb p\u00ebrmbaj\u00eb: {{strings}}", "part.correct answer": "P\u00ebrgjigja e pritshme:", "part.numberentry.answer not reduced": "P\u00ebrgjigja juaj nuk \u00ebsht\u00eb thjeshtuar n\u00eb termat m\u00eb t\u00eb vegj\u00ebl.", "control.next": "Pasardh\u00ebs", "part.mcq.marking matrix string empty": "The custom marking matrix expression is empty.", "matrixmath.abs.too big": "Sorry, can't compute the determinant of a matrix bigger than 3x3 yet.", "jme.texsubvars.no right bracket": "No matching <code>]</code> in {{op}} arguments.", "mathjax.math processing error": "\"{{message}}\" gjat\u00eb tex-ifikimit t\u00eb <code>{{expression}}</code>", "jme.matrix.reports bad size": "Matrix reports its size incorrectly - must be an error in constructor function", "part.marking.steps change": "Jeni vler\u00ebsuar me <strong>{{count,niceNumber}}</strong> $t(mark) p\u00ebr p\u00ebrgjigjet e dh\u00ebna tek hapat.", "part.mcq.choices": "opsione", "part.jme.answer invalid": "P\u00ebrgjigja juaj nuk \u00ebsht\u00eb nj\u00eb shprehje e vlefshme matematike.<br/>{{message}}.", "jme.shunt.list mixed argument types": "Can't parse {{mode}}: mix of dictionary and list elements", "jme.func.except.continuous range": "Can't use the 'except' operator on continuous ranges.", "exam.marks available": "Vler\u00ebsime n\u00eb dispozicion:", "math.combinations.k less than zero": "Can't compute combinations: k is less than zero", "result.question number": "Pyetja Nr", "control.submit all parts": "Dor\u00ebzo t\u00eb gjitha", "jme.func.listval.not a list": "Object is not subscriptable", "part.numberentry.give your answer to precision": "Rrumbullakoseni p\u00ebrgjigjen me {{count,niceNumber}} {{precisionType}}.", "part.mcq.wrong number of choices": "Keni zgjedhur numrin e gabuar t\u00eb opsioneve.", "jme.variables.syntax error in function definition": "Syntax error in function definition", "page.saving": "<p>Duke ruajtur.</p>\n<p>Kjo mund t\u00eb k\u00ebrkoj\u00eb disa seconda.</p>", "math.gcf.complex": "Can't compute GCF of complex numbers", "part.matrix.some incorrect": "Nj\u00eb ose m\u00eb shum\u00eb qeliza n\u00eb p\u00ebrgjigjen tuaj jan\u00eb jo t\u00eb sakta, por jeni vler\u00ebsuar mbi pjes\u00ebn tjet\u00ebr.", "math.combinations.complex": "Can't compute combinations of complex numbers", "control.total": "Total", "jme.user javascript.error": "Error in user-defined javascript function <code>{{name}}</code>: {{message}}", "part.matrix.invalid cell": "Nj\u00eb ose m\u00eb shum\u00eb qeliza n\u00eb p\u00ebrgjigjen tuaj jan\u00eb bosh ose t\u00eb pavlefshme.", "scorm.error loading question": "Gabim n\u00eb ngarkimin e pyetjes {{number}}: {{message}}", "part.numberentry.give your answer to precision_0": "Rrumbullakoseni p\u00ebrgjigjen n\u00eb numrin e plot\u00eb m\u00eb t\u00eb af\u00ebrt.", "jme.shunt.no right square bracket": "Nuk kombinon kllapa djathtas p\u00ebr t\u00eb mbyllur list\u00ebn", "control.not all questions answered": "Nuk i keni trajtuar t\u00eb gjitha pyetjet e provimit.", "jme.display.unknown token type": "Can't texify token type {{type}}", "part.numberentry.answer invalid": "Nuk keni shkruar nj\u00eb num\u00ebr.", "jme.user javascript.returned undefined": "User-defined javascript function <code>{{name}}</code> returned <code>undefined</code>.", "question.hide steps": "Fshih hapat.", "part.mcq.matrix wrong type": "Element of invalid type '{{type}}' used in marking matrix.", "math.combinations.n less than k": "Can't compute combinations: n is less than k", "mark": "pik\u00eb", "suspend.you can resume": "Ju mund ta vazhdoni k\u00ebt\u00eb sesion aty ku e keni l\u00ebn\u00eb, kur t\u00eb filloni k\u00ebt\u00eb aktivitet her\u00ebn tjet\u00ebr.", "scorm.error loading suspend data": "Gabim n\u00eb ngarkimin e t\u00eb dh\u00ebnave t\u00eb sesionit: {{message}}", "result.result": "Rezultati:", "question.show steps": "Paraqit hapat", "question.submit part": "Dor\u00ebzo k\u00ebt\u00eb p\u00ebrgjigje", "part.jme.unexpected variable name": "P\u00ebrgjigja juaj \u00ebsht\u00eb interpretuar sikur p\u00ebrdor variablin e pap\u00ebrcaktuar <code>{{name}}</code>.", "part.matrix.empty cell": "Nj\u00eb ose m\u00eb shum\u00eb qeliza n\u00eb p\u00ebrgjigjen tuaj jan\u00eb bosh.", "control.regen": "Provo nj\u00eb pyetje tjet\u00ebr t\u00eb ngjashme", "control.advice": "Udh\u00ebzim", "xml.could not load": "Nuk mund t\u00eb ngarkohet dokumenti XML: {{message}}", "part.marking.uncaught error": "Gabim n\u00eb vler\u00ebsimin e {{part}}: {{message}} ", "question.score feedback.score total actual": "Vler\u00ebsimi: {{score,niceNumber}}/{{marks,niceNumber}}", "result.print": "Printoni k\u00ebt\u00eb p\u00ebrmbledhje t\u00eb rezultateve", "math.siground.complex": "Can't round to a complex number of sig figs", "question.header": "Pyetja {{number}}", "math.permutations.k less than zero": "Can't compute permutations: k is less than zero", "question.preamble.error": "Error in preamble: {{message}}", "suspend.resume": "Vazhdo", "part.mcq.correct choice": "Keni zgjedhur p\u00ebrgjigjen e sakt\u00eb.", "part.numberentry.answer not integer": "P\u00ebrgjigja jua \u00ebsht\u00eb e gabuar. Duhet t\u00eb shkruani nj\u00eb num\u00ebr t\u00eb plot\u00eb dhe jo nj\u00eb num\u00ebr dhjetor.", "part.jme.not-allowed several": "P\u00ebrgjigja juaj nuk duhet t\u00eb p\u00ebrmbaj\u00eb asnj\u00eb nga fjal\u00ebt: {{strings}}", "part.numberentry.precision type.dp_plural": "shifra dhjetore", "question.unsupported part type": "Unsupported part type", "jme.variables.error evaluating variable": "Error evaluating variable {{name}}: {{message}}", "jme.func.listval.key not in dict": "Dictionary does not contain the key <code>{{key}}</code>", "part.mcq.answers": "p\u00ebrgjigje", "jme.typecheck.map not on enumerable": "veprimi <code>map</code> duhet t\u00eb p\u00ebrdoret p\u00ebr nj\u00eb list\u00eb ose zon\u00eb (interval), jo p\u00ebr {{type}}", "jme.substituteTree.undefined variable": "Variab\u00ebl i pap\u00ebrcaktuar: <code>{{name}}</code>", "modal.cancel": "Anulo", "scorm.failed save": "<p>K\u00ebrkesa p\u00ebr t\u00eb ruajtur t\u00eb dh\u00ebnat n\u00eb server d\u00ebshtoi. Klikoni <b>OK</b> p\u00ebr ta provuar p\u00ebrs\u00ebri.</p>\n<p>N\u00ebse ky mesazh p\u00ebrs\u00ebritet disa her\u00eb, kontrolloni lidhjen tuaj me internetin ose p\u00ebrdorni nj\u00eb kompjuter tjet\u00ebr. P\u00ebrgjigjet tuaja t\u00eb m\u00ebparshme jan\u00eb ruajtur me sukses dhe do t\u00eb ringarkohen n\u00ebse e vazhdoni k\u00ebt\u00eb sesion n\u00eb nj\u00eb kompjuter tjet\u00ebr.</p>\n<p>N\u00ebse ky mesazh shafet vazhdimisht dhe nuk mund t\u00eb ruani <em>asnj\u00eb</em> p\u00ebrgjigje, ju lutem kontaktoni pedagogun ose m\u00ebsuesin.</p>", "jme.typecheck.function maybe implicit multiplication": "Veprimi {{name}} nuk \u00ebsht\u00eb i p\u00ebrcaktuar. Mos keni dashur <br/><code>{{first}}*{{possibleOp}}(...)</code>?", "part.jme.answer too short": "P\u00ebrgjigja juaj \u00ebsht\u00eb shum\u00eb e shkurt\u00eb.", "matrixmath.mul.different sizes": "Can't multiply matrices of different sizes.", "jme.func.switch.no default case": "No default case for Switch statement", "part.numberentry.zero sig fig": "Kjo k\u00ebrkes\u00eb \u00ebsht\u00eb nd\u00ebrtuar n\u00eb m\u00ebnyr\u00eb q\u00eb t\u00eb rrumbullakos\u00eb p\u00ebrgjigjen e studentit me zero shifra me vlere, gj\u00eb q\u00eb nuk ka kuptim.", "frontpage.start": "Fillo", "result.question score": "Vler\u00ebsimi", "part.mcq.choices missing": "Definition of choices is missing", "question.score feedback.correct": "P\u00ebrgjigja juaj \u00ebsht\u00eb e sakt\u00eb.", "part.feedback": "vler\u00ebsim", "question.score feedback.answered": "Me p\u00ebrgjigje", "math.permutations.n less than k": "Can't compute permutations: n is less than k", "part.gapfill.feedback header": "<strong>Hap\u00ebsir\u00eb {{index}}</strong>", "question.advice": "Udh\u00ebzim", "vectormath.cross.matrix too big": "Can't calculate cross product of a matrix which isn't $1 \\times N$ or $N \\times 1$.", "part.jme.not-allowed bits": "<span class=\"monospace\">{{string}}</span>", "display.part.jme.error making maths": "Gabim n\u00eb paraqitjen e shprehjeve matematikore", "part.prompt": "prompt", "control.proceed anyway": "Vazhdo gjith\u00ebsesi?", "gap": "hap\u00ebsir\u00eb", "jme.tokenise.invalid": "Shprehje e gabuar: <code>{{expression}}</code>", "result.score": "Vler\u00ebsimi:", "math.lcm.complex": "Can't compute LCM of complex numbers", "exam.random seed": "ID e Sesionit:", "modal.ok": "OK", "was": "ishte", "jme.thtml.not html": "Konstruktorit THTML i \u00ebsht\u00eb kaluar nj\u00eb vler\u00eb jo-HTML.", "question.score feedback.partial": "P\u00ebrgjigja juaj \u00ebsht\u00eb pjes\u00ebrisht e sakt\u00eb", "mathjax.error with context": "MathJax processing error in {{context}}: {{message}}", "question.score feedback.wrong": "P\u00ebrgjigja juaj \u00ebsht\u00eb e gabuar", "question.score feedback.score actual": "Vler\u00ebsimi: {{scoreString}}", "part.numberentry.correct except fraction": "P\u00ebrgjigja juaj \u00ebsht\u00eb brenda intervalit t\u00eb lejuar, por nuk pranohen thyesat.", "question.error": "Pyetja {{number}}: {{message}}", "jme.evaluate.no scope given": "Numbas.jme.evaluate must be given a Scope", "question.show steps already penalised": "Tashm\u00eb ju i kani paraqitur hapat. Paraqitja e tyre p\u00ebrs\u00ebri nuk ju penalizon.", "part.jme.answer missing": "Mungon p\u00ebrgjigja e sakt\u00eb", "part.mcq.no choices selected": "Nuk \u00ebsht\u00eb b\u00ebr\u00eb asnj\u00eb zgjedhje.", "die.script not loaded": "Numbas couldn't start because the file <code>{{file}}</code> was not loaded. Check that it's included in <code>scripts.js</code>.", "part.numberentry.precision type.dp": "shif\u00ebr dhjetore", "part.matrix.answer invalid": "P\u00ebrgjigja juaj nuk \u00ebsht\u00eb e sakt\u00eb.", "jme.variables.question took too many runs to generate variables": "A valid set of question variables was not generated in time.", "jme.texsubvars.no right brace": "No matching <code>}</code> in {{op}}", "page.loading": "Duke u ngarkuar ...", "part.jme.marking.correct": "P\u00ebrgjigja juaj \u00ebsht\u00eb numerikisht e sakt\u00eb.", "part.marking.correct": "P\u00ebrgjigja juaj \u00ebsht\u00eb e sakt\u00eb.", "part.matrix.size mismatch": "Autori i pyetjes nuk i ka lejuar studentit t\u00eb vendos\u00eb dimensionin e p\u00ebrgjgigjes, por p\u00ebrgjigja e sakt\u00eb \u00ebsht\u00eb me {{correct_dimmensions}} nd\u00ebrsa p\u00ebrgjigja e dh\u00ebn\u00eb \u00ebsht\u00eb me {{input_dimensions}}", "exam.feedback": "Mesazhi i vler\u00ebsimit t\u00eb provimit", "part.marking.used variable replacements": "Kjo k\u00ebrkes\u00eb \u00ebsht\u00eb vler\u00ebsusr duke p\u00ebrdorur p\u00ebrgjigjet e dh\u00ebna n\u00eb k\u00ebrkesat paraardh\u00ebse. ", "control.submit": "Dor\u00ebzo", "jme.shunt.no left square bracket": "Nuk kombinon kllapa majtas", "jme.func.listval.invalid index": "Invalid list index {{index}} on list of size {{size}}", "question.score feedback.hide": "Fshih vler\u00ebsim", "jme.variables.circular reference": "Circular variable reference in definition of <code>{{name}}</code>", "result.time spent": "Koha e p\u00ebrdorur:", "die.error": "Gabim", "timing.time remaining": "Koha e mbetur:", "part.numberentry.negative decimal places": "This part is set up to round the student's answer to a negative number of decimal places, which has no meaning.", "part.with steps answer prompt": "P\u00ebrgjigje: ", "control.confirm leave": "Akoma nuk e keni mbaruar provimin.", "jme.typecheck.op not defined": "Veprimi '{{op}}' nuk \u00ebsht\u00eb i p\u00ebrcaktuar.", "part": "k\u00ebrkes\u00eb", "control.submit again": "Dor\u00ebzo p\u00ebrs\u00ebri", "xml.error in variable definition": "Error in definition of variable <code>{{name}}</code>", "exam.changeQuestion.no questions": "Provimi nuk p\u00ebrmban asnj\u00eb pyetje! Kontrolloni skedarin .exam p\u00ebr gabime.", "part.jme.must-have bits": "<span class=\"monospace\">{{string}}</span>", "part.marking.total score": "Jeni vler\u00ebsuar me <strong>{{count,niceNumber}}</strong> $t(mark) p\u00ebr k\u00ebt\u00eb k\u00ebrkes\u00eb.", "exam.introduction": "Prezantim i provimit", "control.confirm regen": "D\u00ebshironi t\u00eb ri-krijoni k\u00ebt\u00eb pyetje? N\u00ebse klikoni OK, t\u00eb gjitha p\u00ebrgjigjet dhe vler\u00ebsimet tuaja p\u00ebr pyetjen aktuale do t\u00eb humbasin.", "jme.evaluate.undefined variable": "Variabli {{name}} nuk \u00ebsht\u00eb i p\u00ebrcaktuar.", "jme.display.simplifyTree.no scope given": "Numbas.jme.display.simplifyTree must be given a Scope", "timing.no accumulator": "nuk ka akumulator kohor {{name}}", "util.product.non list": "Passed a non-list to <code>Numbas.util.product</code>", "part.marking.revealed steps no penalty": "Keni zbuluar hapat.", "part.jme.unexpected variable name suggestion": "P\u00ebrgjigja juaj \u00ebsht\u00eb interpretuar sikur p\u00ebrdor variablin e pap\u00ebrcaktuar <code>{{name}}</code>. Ndoshta keni dashur <code>{{suggestion}}</code>?", "jme.display.collectRuleset.set not defined": "Ruleset {{name}} has not been defined", "was_plural": "jan\u00eb", "part.marking.no result": "Kjo k\u00ebrkes\u00eb nuk mund t\u00eb vler\u00ebsohet.", "part.setting not present": "Property '{{property}}' not set", "exam.number of questions": "Numri i Pyetjeve:", "part.numberentry.answer not integer or decimal": "P\u00ebrgjigja jua \u00ebsht\u00eb e gabuar. Duhet t\u00eb shkruani nj\u00eb num\u00ebr t\u00eb plot\u00eb ose dhjetor.", "question.selector.unsubmitted changes": "Ndryshime t\u00eb pa dor\u00ebzuara.", "vectormath.dot.matrix too big": "Can't calculate dot product of a matrix which isn't $1 \\times N$ or $N \\times 1$.", "scorm.no exam suspend data": "Vazhdimi i sesionit d\u00ebshtoi: nuk ka t\u00eb dh\u00ebna mbi provimin.", "math.permutations.n less than zero": "Can't compute permutations: n is less than zero", "part.matrix.empty": "Nuk keni shkruar nj\u00eb p\u00ebrgjigje.", "part.jme.must-have several": "P\u00ebrgjigja juaj duhet t\u00eb p\u00ebrmbaj\u00eb t\u00eb gjitha fjal\u00ebt: {{strings}}", "part.patternmatch.display answer missing": "Paraqitja e p\u00ebrgjigjes mungon", "math.precround.complex": "Can't round to a complex number of decimal places", "jme.func.matrix.invalid row type": "Can't construct a matrix from rows of type {{type}}", "jme.tokenise.keypair key not a string": "Dictionary key should be a string, not {{type}}.", "jme.shunt.no left bracket": "Nuk kombinon kllapa majtas", "result.exam summary": "P\u00ebrmbledhje e provimit", "jme.typecheck.no right type definition": "Nuk ka nj\u00eb p\u00ebrcaktim t\u00eb '{{op}}' p\u00ebr tipin e gjetur.", "exam.time allowed": "Koha e lejuar:", "question.statement": "Formulimi", "xml.property not number": "Property {{name}} should be a number, but isn't ({{value}}), in node {{element}}", "exam.exam name": "Emri i Provimit:", "control.previous": "Paraardh\u00ebs"}}, "pl-pl": {"translation": {"jme.typecheck.no right type unbound name": "Zmienna <code>{{name}}</code> nie jest zdefiniowana.", "control.pause": "Wstrzymaj", "feedback.taken away": "<strong>{{count,niceNumber}}</strong> $t(mark) $t(was) taken away.", "question.score feedback.unanswered": "Unanswered.", "control.reveal": "Poka\u017c odpowiedzi", "part.marking.steps no matter": "Because you received full marks for the part, your answers to the steps aren't counted.", "part.marking.resubmit because of variable replacement": "This part's marking depends on your answers to other parts, which you have changed. Submit this part again to update your score.", "question.no such part": "Can't find part {{path}}", "control.back to results": "Wr\u00f3\u0107 do wynik\u00f3w", "part.unknown type": "{{part}}: Unrecognised part type {{type}}", "result.click a question to review": "Kliknij na numer pytania, by zobaczy\u0107, jak Twoje odpowiedzi zosta\u0142y ocenione i, gdzie to mo\u017cliwe, modelowe odpowiedzi.", "part.missing type attribute": "{{part}}: Missing part type attribute", "matrixmath.abs.non-square": "Can't compute the determinant of a matrix which isn't square.", "result.performance summary": "Performance Summary", "die.numbas failed": "Numbas has failed", "jme.shunt.no left bracket in function": "No matching left bracket in function application or tuple", "part.mcq.matrix cell empty": "Part {{part}} marking matrix cell ({{row}},{{column}}) is empty", "question.score feedback.show": "Show feedback", "part.script.error": "Error in part {{path}} custom script {{script}}: {{message}}", "part.numberentry.precision type.sigfig": "significant figure", "jme.variables.error computing dependency": "Error computing referenced variable <code>{{name}}</code>", "exam.passed": "Zdane", "result.questions attempted": "Zadania podj\u0119te:", "control.not all questions submitted": "Dokona\u0142e\u015b/\u0142a\u015b zmian w przynajmniej jednej ze swoich odpowiedzi, ale nie zatwierdzi\u0142e\u015b/\u0142a\u015b jej. Prosz\u0119 sprawd\u017a czy ka\u017cde zdanie zosta\u0142o zatwierdzone.", "exam.student name": "Imi\u0119 Ucznia:", "scorm.no question suspend data": "No question suspend data", "result.exam start": "Rozpocznij Egzamin:", "part.extension.not implemented": "Part hasn't implemented the <code>{{name}}</code> method.", "xml.property not boolean": "Property {{name}} should be a boolean, but isn't ({{value}}), in node {{element}}", "feedback.you were awarded": "You were awarded <strong>{{count,niceNumber}}</strong> $t(mark).", "jme.variables.variable not defined": "Zmienna <code>{{name}}</code> nie zosta\u0142a zdefiniowana.", "question.loaded name mismatch": "Can't resume this attempt - the package has changed since the last session.", "control.confirm end": "Czy jeste\u015b pewny/na, \u017ce chcesz zako\u0144czy\u0107 egzamin? Po jego zako\u0144czeniu nie b\u0119dziesz m\u00f3g\u0142/mog\u0142a ju\u017c dokonywa\u0107 zmian na swoich odpowiedziach.", "result.exam stop": "Zako\u0144cz Egzamin:", "exam.review header": "Review: ", "jme.display.collectRuleset.no sets": "No sets given to collectRuleset!", "result.exit": "Zako\u0144cz egzamin", "scorm.error initialising": "Error initialising SCORM protocol: {{message}}", "exam.pass percentage": "Pr\u00f3g procentowy:", "math.permutations.complex": "Can't compute permutations of complex numbers", "scorm.error loading part": "Error loading part {{part}}: {{message}}", "part.mcq.options def not a list": "The expression defining the {{properties}} is not a list.", "part.mcq.matrix mix of numbers and lists": "Mix of numbers and lists used in marking matrix.", "part.marking.variable replacement part not answered": "You must answer {{part}} first", "part.marking.did not answer": "You did not answer this question.", "jme.shunt.missing operator": "Wyra\u017cenie nie mo\u017ce by\u0107 obliczone -- brakuje operatora.", "suspend.paused header": "Wstrzymaj", "part.mcq.matrix wrong size": "Marking matrix is the wrong size.", "part.mcq.matrix jme error": "Part {{part}} marking matrix cell ({{row}},{{column}}) gives a JME error: {{error}}", "end.exam has finished": "Egzamin zosta\u0142 zako\u0144czony. Mo\u017cesz zamkn\u0105\u0107 to okno.", "suspend.exam suspended": "Egzamin zosta\u0142 wstrzymany. Wci\u015bnij <em>Wzn\u00f3w</em> by kontynuowa\u0107 egzamin.", "jme.texsubvars.missing parameter": "Brakuje parametra w {{op}}: {{parameter}}", "part.numberentry.precision type.sigfig_plural": "significant figures", "math.lt.order complex numbers": "Can't order complex numbers", "control.confirm reveal": "Czy chcesz zobaczy\u0107 odpowiedzi do tego zadania? Wszelkie punkty, kt\u00f3re uzyska\u0142e\u015b/\u0142a\u015b za to zadanie zostan\u0105 zablokowane i nie b\u0119dziesz ju\u017c p\u00f3\u017aniej m\u00f3g\u0142/mog\u0142a go wykona\u0107.", "part.patternmatch.correct except case": "Your answer is correct, except for the case.", "part.marking.not submitted": "No answer submitted", "jme.variables.error making function": "B\u0142\u0105d tworzenia funkcji <code>{{name}}</code>: {{message}}", "exam.xml.bad root": "Root element of exam XML should be 'exam'", "part.mcq.matrix not a number": "Part {{part}} marking matrix cell ({{row}},{{column}}) does not evaluate to a number", "question.score feedback.score total": "{{marksString}}.", "question.show steps penalty": "You will lose <strong>{{count,niceNumber}}</strong> $t(mark).", "question.unsubmitted changes_plural": "You have made changes to your answers but not submitted them. Please check your answers to each part and then press the <strong>Submit all parts</strong> button.", "question.show steps no penalty": "Your score will not be affected.", "scorm.no part suspend data": "No part suspend data", "jme.typecheck.function not defined": "Operacja {{op}} nie jest zdefiniowana. Czy mia\u0142e\u015b/\u0142a\u015b na my\u015bli <br/><code>{{suggestion}}*(...)</code>?", "part.marking.revealed steps with penalty": "You revealed the steps. The maximum you can score for this part is <strong>{{count,niceNumber}}</strong> $t(mark). Your scores will be scaled down accordingly.", "question.unsubmitted changes": "You have made a change to your answer but not submitted it. Please check your answer and then press the <strong>Submit answer</strong> button.", "ruleset.circular reference": "Circular reference in definition of ruleset <code>{{name}}</code>", "math.combinations.n less than zero": "Can't compute combinations: n is less than zero", "part.marking.incorrect": "Your answer is incorrect.", "jme.variables.empty definition": "Definicja zmiennej <code>{{name}}</code> jest pusta.", "question.preamble.syntax error": "Syntax error in preamble", "util.equality not defined for type": "Equality not defined for type {{type}}", "ruleset.set not defined": "Ruleset {{name}} has not been defined", "result.question review title": "Review this question", "jme.shunt.no right bracket": "Brak pasuj\u0105cego prawego nawiasu", "die.sorry": "Przepraszamy, Numbas napotka\u0142o b\u0142\u0105d, co znaczy, \u017ce nie mo\u017ce kontynuowa\u0107. Poni\u017cej jest opis b\u0142\u0119du.", "control.end exam": "Zako\u0144cz Egzamin", "vectormath.cross.not 3d": "Can only take the cross product of 3-dimensional vectors.", "part.mcq.matrix not a list": "Marking matrix, defined by JME expression, is not a list but it should be.", "part.marking.nothing entered": "You did not enter an answer.", "part.numberentry.give your answer as a reduced fraction": "Reduce your answer to lowest terms.", "mark_plural": "marks", "question.hide steps no penalty": "Your score will not be affected.", "step": "step", "part.numberentry.correct except decimal": "Your answer is within the allowed range, but decimal numbers are not allowed.", "question.can not submit": "Can not submit answer - check for errors.", "math.choose.empty selection": "Empty selection given to random function", "part.jme.answer too long": "Your answer is too long.", "mathjax.error": "MathJax processing error: {{message}}", "control.submit answer": "Zatwierd\u017a odpowied\u017a", "exam.failed": "Niezdane", "part.jme.not-allowed one": "Your answer must not contain: {{strings}}", "jme.shunt.not enough arguments": "Not enough arguments for operation {{op}}", "question.answer submitted": "Answer submitted", "part.jme.must-have one": "Your answer must contain: {{strings}}", "part.correct answer": "Expected answer:", "part.numberentry.answer not reduced": "Your answer is not reduced to lowest terms.", "control.next": "Nast\u0119pne", "part.mcq.marking matrix string empty": "The custom marking matrix expression is empty.", "matrixmath.abs.too big": "Sorry, can't compute the determinant of a matrix bigger than 3x3 yet.", "jme.texsubvars.no right bracket": "No matching <code>]</code> in {{op}} arguments.", "mathjax.math processing error": "\"{{message}}\" when texifying <code>{{expression}}</code>", "jme.matrix.reports bad size": "Matrix reports its size incorrectly - must be an error in constructor function", "part.marking.steps change": "You were awarded <strong>{{count,niceNumber}}</strong> $t(mark) for your answers to the steps.", "part.mcq.choices": "choices", "part.jme.answer invalid": "Your answer is not a valid mathematical expression.<br/>{{message}}.", "jme.shunt.list mixed argument types": "Can't parse {{mode}}: mix of dictionary and list elements", "jme.func.except.continuous range": "Can't use the 'except' operator on continuous ranges.", "exam.marks available": "Dost\u0119pne Oceny:", "math.combinations.k less than zero": "Can't compute combinations: k is less than zero", "result.question number": "Numer pytania", "control.submit all parts": "Zatwierd\u017a wszystkie cz\u0119\u015bci", "jme.func.listval.not a list": "Obiekt nie mo\u017ce mie\u0107 indeksu dolnego.", "part.numberentry.give your answer to precision": "Round your answer to {{count,niceNumber}} {{precisionType}}.", "part.mcq.wrong number of choices": "You selected the wrong number of choices.", "jme.variables.syntax error in function definition": "B\u0142\u0105d sk\u0142adni w definicji funkcji", "page.saving": "<p>Zapisywanie.</p>\n<p>To mo\u017ce potrwa\u0107 par\u0119 sekund.</p>", "math.gcf.complex": "Can't compute GCF of complex numbers", "part.matrix.some incorrect": "One or more of the cells in your answer is incorrect, but you have been awarded marks for the rest.", "math.combinations.complex": "Can't compute combinations of complex numbers", "control.total": "Suma", "jme.user javascript.error": "Error in user-defined javascript function <code>{{name}}</code>: {{message}}", "part.matrix.invalid cell": "One or more of the cells in your answer is empty or invalid.", "scorm.error loading question": "Error loading question {{number}}: {{message}}", "part.numberentry.give your answer to precision_0": "Round your answer to the nearest integer.", "jme.shunt.no right square bracket": "Brak pasuj\u0105cego prawego kwadratowego nawiasu na ko\u0144cu tej listy.", "control.not all questions answered": "Nie odpowiedzia\u0142e\u015b/\u0142a\u015b na ka\u017cde pytanie w tym egzaminie.", "jme.display.unknown token type": "Can't texify token type {{type}}", "part.numberentry.answer invalid": "You did not enter a valid number.", "jme.user javascript.returned undefined": "User-defined javascript function <code>{{name}}</code> returned <code>undefined</code>.", "question.hide steps": "Hide steps", "part.mcq.matrix wrong type": "Element of invalid type '{{type}}' used in marking matrix.", "math.combinations.n less than k": "Can't compute combinations: n is less than k", "mark": "mark", "suspend.you can resume": "B\u0119dziesz m\u00f3g\u0142/mog\u0142a wznowi\u0107 t\u0105 sesj\u0119, kiedy rozpoczniesz to zadanie nast\u0119pnym razem.", "scorm.error loading suspend data": "Error loading suspend data: {{message}}", "result.result": "Wynik:", "question.show steps": "Show steps", "question.submit part": "Submit part", "part.jme.unexpected variable name": "Your answer was interpreted to use the unexpected variable name <code>{{name}}</code>.", "part.matrix.empty cell": "One or more of the cells in your answer is empty.", "control.regen": "Spr\u00f3buj podobne zadanie.", "control.advice": "Porada", "xml.could not load": "Couldn't load an XML document: {{message}}", "part.marking.uncaught error": "Error when marking {{part}}: {{message}}", "question.score feedback.score total actual": "Score: {{score,niceNumber}}/{{marks,niceNumber}}", "result.print": "Print this results summary", "math.siground.complex": "Can't round to a complex number of sig figs", "question.header": "Question {{number}}", "math.permutations.k less than zero": "Can't compute permutations: k is less than zero", "question.preamble.error": "Error in preamble: {{message}}", "suspend.resume": "Wzn\u00f3w", "part.mcq.correct choice": "You chose the correct answer.", "part.numberentry.answer not integer": "Your answer is invalid. You must enter a whole number, not a decimal.", "part.jme.not-allowed several": "Your answer must not contain any of: {{strings}}", "part.numberentry.precision type.dp_plural": "decimal places", "question.unsupported part type": "Unsupported part type", "jme.variables.error evaluating variable": "Error evaluating variable {{name}}: {{message}}", "jme.func.listval.key not in dict": "Dictionary does not contain the key <code>{{key}}</code>", "part.mcq.answers": "answers", "jme.typecheck.map not on enumerable": "<code>map</code> operacja musi zosta\u0107 wykonana na li\u015bcie albo przedziale, a nie na {{type}}", "jme.substituteTree.undefined variable": "Undefined variable: <code>{{name}}</code>", "modal.cancel": "Anuluj", "scorm.failed save": "<p>The request to save data to the server failed. Press <b>OK</b> to try again.</p>\n<p>If you get this message repeatedly, check your internet connection or use a different computer. Your previously submitted answers have been successfully saved and will be restored if you resume this session on a different computer.</p>\n<p>If this message appears persistently and you can't save <em>any</em> answers, please contact your lecturer or teacher.</p>", "jme.typecheck.function maybe implicit multiplication": "Operacja {{name}} nie jest zdefiniowana. Czy mia\u0142e\u015b/\u0142a\u015b na my\u015bli <br/><code>{{first}}*{{possibleOp}}(...)</code>?", "part.jme.answer too short": "Your answer is too short.", "matrixmath.mul.different sizes": "Can't multiply matrices of different sizes.", "jme.func.switch.no default case": "No default case for Switch statement", "part.numberentry.zero sig fig": "This part is set up to round the student's answer to zero significant figures, which has no meaning.", "frontpage.start": "Rozpocznij", "result.question score": "Liczba Punkt\u00f3w", "part.mcq.choices missing": "Definition of choices is missing", "question.score feedback.correct": "Your answer is correct", "part.feedback": "feedback", "question.score feedback.answered": "Answered.", "math.permutations.n less than k": "Can't compute permutations: n is less than k", "part.gapfill.feedback header": "<strong>Gap {{index}}</strong>", "question.advice": "Advice", "vectormath.cross.matrix too big": "Can't calculate cross product of a matrix which isn't $1 \\times N$ or $N \\times 1$.", "part.jme.not-allowed bits": "<span class=\"monospace\">{{string}}</span>", "display.part.jme.error making maths": "Error making maths display", "part.prompt": "prompt", "control.proceed anyway": "Proceed anyway?", "gap": "gap", "jme.tokenise.invalid": "Invalid expression: <code>{{expression}}</code>", "result.score": "Liczba punkt\u00f3w:", "math.lcm.complex": "Can't compute LCM of complex numbers", "exam.random seed": "Numer Sesji:", "modal.ok": "OK", "was": "was", "jme.thtml.not html": "Passed a non-HTML value into the THTML constructor.", "question.score feedback.partial": "Your answer is partially correct", "mathjax.error with context": "MathJax processing error in {{context}}: {{message}}", "question.score feedback.wrong": "Your answer is incorrect", "question.score feedback.score actual": "Score: {{scoreString}}", "part.numberentry.correct except fraction": "Your answer is within the allowed range, but fractions are not allowed.", "question.error": "Question {{number}}: {{message}}", "jme.evaluate.no scope given": "Numbas.jme.evaluate must be given a Scope", "question.show steps already penalised": "You have already shown steps. You can show them again with no further penalty.", "part.jme.answer missing": "Correct answer is missing", "part.mcq.no choices selected": "No choices selected.", "die.script not loaded": "Numbas couldn't start because the file <code>{{file}}</code> was not loaded. Check that it's included in <code>scripts.js</code>.", "part.numberentry.precision type.dp": "decimal place", "part.matrix.answer invalid": "Your answer is not valid.", "jme.variables.question took too many runs to generate variables": "A valid set of question variables was not generated in time.", "jme.texsubvars.no right brace": "Brak pasuj\u0105cego <code>}</code> w {{op}}", "page.loading": "\u0141adowanie...", "part.jme.marking.correct": "Your answer is numerically correct.", "part.marking.correct": "Your answer is correct.", "part.matrix.size mismatch": "The question author hasn't allowed the student to decide the dimensions of their answer, but the correct answer is {{correct_dimensions}} while the answer input is {{input_dimensions}}", "exam.feedback": "Exam feedback message", "part.marking.used variable replacements": "This part was marked using your answers to previous parts.", "control.submit": "Zatwierd\u017a", "jme.shunt.no left square bracket": "Brak pasuj\u0105cego lewego nawiasu", "jme.func.listval.invalid index": "Invalid list index {{index}} on list of size {{size}}", "question.score feedback.hide": "Hide feedback", "jme.variables.circular reference": "Circular variable reference in definition of <code>{{name}}</code>", "result.time spent": "Czas po\u015bwi\u0119cony:", "die.error": "B\u0142\u0105d", "timing.time remaining": "Time remaining:", "part.numberentry.negative decimal places": "This part is set up to round the student's answer to a negative number of decimal places, which has no meaning.", "part.with steps answer prompt": "Answer: ", "control.confirm leave": "Nie zako\u0144czy\u0142e\u015b/\u0142a\u015b jeszcze tego egzaminu.", "jme.typecheck.op not defined": "Operacja '{{op}}' nie jest zdefiniowana.", "part": "part", "control.submit again": "Zatwierd\u017a ponownie", "xml.error in variable definition": "Error in definition of variable <code>{{name}}</code>", "exam.changeQuestion.no questions": "Ten egzamin nie zawiera \u017cadnych pyta\u0144! Sprawd\u017a plik .exam nie ma b\u0142\u0119d\u00f3w.", "part.jme.must-have bits": "<span class=\"monospace\">{{string}}</span>", "part.marking.total score": "You scored <strong>{{count,niceNumber}}</strong> $t(mark) for this part.", "exam.introduction": "Exam introduction", "control.confirm regen": "Czy chcia\u0142by\u015b/chcia\u0142aby\u015b wylosowa\u0107 nowe dane to tego zadania? Je\u015bli klikniesz OK, wszystkie Twoje odpowiedzi i punkty za to zadanie zostan\u0105 utracone.", "jme.evaluate.undefined variable": "Zmienna {{name}} nie jest zdefiniowana.", "jme.display.simplifyTree.no scope given": "Numbas.jme.display.simplifyTree must be given a Scope", "timing.no accumulator": "no timing accumulator {{name}}", "util.product.non list": "Passed a non-list to <code>Numbas.util.product</code>", "part.marking.revealed steps no penalty": "You revealed the steps.", "part.jme.unexpected variable name suggestion": "Your answer was interpreted to use the unexpected variable name <code>{{name}}</code>. Did you mean <code>{{suggestion}}</code>?", "jme.display.collectRuleset.set not defined": "Ruleset {{name}} has not been defined", "was_plural": "were", "part.marking.no result": "This part could not be marked.", "part.setting not present": "Property '{{property}}' not set", "exam.number of questions": "Liczba Pyta\u0144:", "part.numberentry.answer not integer or decimal": "Your answer is invalid. You must enter an integer or a decimal.", "question.selector.unsubmitted changes": "Unsubmitted changes.", "vectormath.dot.matrix too big": "Can't calculate dot product of a matrix which isn't $1 \\times N$ or $N \\times 1$.", "scorm.no exam suspend data": "Failed to resume: no exam suspend data.", "math.permutations.n less than zero": "Can't compute permutations: n is less than zero", "part.matrix.empty": "You have not entered an answer.", "part.jme.must-have several": "Your answer must contain all of: {{strings}}", "part.patternmatch.display answer missing": "Display answer is missing", "math.precround.complex": "Can't round to a complex number of decimal places", "jme.func.matrix.invalid row type": "Nie mo\u017cna skonstruowa\u0107 macierzy z rz\u0119d\u00f3w typu {{type}}", "jme.tokenise.keypair key not a string": "Dictionary key should be a string, not {{type}}.", "jme.shunt.no left bracket": "Brak pasuj\u0105cego lewego nawiasu", "result.exam summary": "Podsumowanie Egzaminu", "jme.typecheck.no right type definition": "Nie zaleziono definicji '{{op}}' poprawnego typu.", "exam.time allowed": "Czas dozwolony:", "question.statement": "Statement", "xml.property not number": "Property {{name}} should be a number, but isn't ({{value}}), in node {{element}}", "exam.exam name": "Nazwa Egzaminu:", "control.previous": "Poprzednie"}}, "es-es": {"translation": {"jme.typecheck.no right type unbound name": "La variable <code>{{name}}</code> no est\u00e1 definida.", "control.pause": "Pausa", "feedback.taken away": "%s %s ha sido quitado.", "question.score feedback.unanswered": "No Respondida.", "control.reveal": "Mostrar las respuestas correctas", "part.marking.steps no matter": "Como has recibido la m\u00e1xima puntuaci\u00f3n para esta parte, las respuestas de los pasos intermedios no se tienen en consideraci\u00f3n.", "part.marking.resubmit because of variable replacement": "La puntuaci\u00f3n de esta parte depende de las respuestas que has dado en partes anteriores, las cuales has cambiado. Por favor, env\u00eda de nuevo la respuesta de esta parte para actualizar to nota.", "question.no such part": "No puedo encontrar la parte {{part}}", "control.back to results": "Volver a Resultados", "part.unknown type": "{{part}}: tipo {{type}} de parte no reconocido", "result.click a question to review": "Haga click sobre el n\u00famero de la pregunta para revisar sus respuestas, y si est\u00e1 disponible, la soluci\u00f3n al problema.", "part.missing type attribute": "{{part}}: falta atributo de tipo en la parte", "matrixmath.abs.non-square": "No se puede calcular el determinante de una matriz que no es cuadrada.", "result.performance summary": "Informe de Rendimiento", "die.numbas failed": "Numbas ha fallado", "jme.shunt.no left bracket in function": "No concuerda el par\u00e9ntesis de la izquierda al aplicar la funci\u00f3n o tupla", "part.mcq.matrix cell empty": "Parte{{part}} marcar la c\u00e9lula de un matriz ({{row}},{{column}}) est\u00e1 vac\u00eda", "question.score feedback.show": "Mostrar Retroalimentaci\u00f3n", "part.script.error": "Error en la parte {{path}} del script personalizado {{script}}: {{message}}", "part.numberentry.precision type.sigfig": "cifra significativa", "jme.variables.error computing dependency": "Error al calcular la variable referenciada <code> {{name}} </ code>", "exam.passed": "Aprobado... Muy Bien!!!", "result.questions attempted": "Preguntas Respondidas:", "control.not all questions submitted": "Ha realizado cambios en una o m\u00e1s respuestas, pero no las ha enviado. Por favor, compruebe cada pregunta se ha respondido.", "exam.student name": "Nombre del estudiante: ", "scorm.no question suspend data": "No hay datos de la pregunta suspendida", "result.exam start": "Inicio del Examen:", "part.extension.not implemented": "Esta parte no tiene implementado el m\u00e9todo <code>{{name}}</code>.", "xml.property not boolean": "El propiedad {{name}} en el nodo {{element}} deber\u00eda ser un valor booleano, pero no lo es ({{value}})", "feedback.you were awarded": "Usted ha sido favorecido <strong>{{count}}</strong> $t(mark).", "jme.variables.variable not defined": "La variable {{name}} no est\u00e1 definida.", "question.loaded name mismatch": "No se puede reanudar este intento - el paquete ha cambiado desde la \u00faltima sesi\u00f3n.", "control.confirm end": "\u00bfEst\u00e1 seguro de terminar su examen? Despu\u00e9s que usted finalice el examen, ya no ser\u00e1 posible cambiar sus respuestas.", "result.exam stop": "Termino del Examen:", "exam.review header": "Revisi\u00f3n: ", "jme.display.collectRuleset.no sets": "No se han proporcionado conjuntos a collectRuleset!", "result.exit": "Salir", "scorm.error initialising": "Error al inicializar el protocolo SCORM: {{message}}.", "exam.pass percentage": "Porcentaje de aprobaci\u00f3n:", "math.permutations.complex": "No se puede calcular permutaciones de n\u00fameros complejos.", "scorm.error loading part": "Error ala cargar la parte {{part}}: {{message}}", "part.mcq.options def not a list": "La expresi\u00f3n que define las {{properties}} no es una lista.", "part.mcq.matrix mix of numbers and lists": "Se ha usado una mezcla de listas y n\u00fameros en la matriz de puntuaciones.", "part.marking.variable replacement part not answered": "Debes responder primero a {{part}}", "part.marking.did not answer": "Usted no ha respondido esta pregunta.", "jme.shunt.missing operator": "La expresi\u00f3n nopuede ser evaluada -- falta un operador.", "suspend.paused header": "Pausado", "part.mcq.matrix wrong size": "La matriz de puntuaciones tiene un tama\u00f1o err\u00f3neo.", "part.mcq.matrix jme error": "Parte {{part}} marcar la c\u00e9lula de una matriz ({{row}}.{{column}}) produce un error JME: {{error}}", "end.exam has finished": "El examen ha finalizado. Ahora puede cerrar esta ventana.", "suspend.exam suspended": "El Examen ha sido suspendido. Presione Reanudar para continuar.", "jme.texsubvars.missing parameter": "Falta un par\u00e1metro en {{op}}: {{parameter}}", "part.numberentry.precision type.sigfig_plural": "cifras significativas", "math.lt.order complex numbers": "No se pueden ordenar n\u00fameros complejos.", "control.confirm reveal": "\u00bfQuiere mostrar las respuestas a esta pregunta? Perder\u00e1 la puntuaci\u00f3n recibida hasta ahora.", "part.patternmatch.correct except case": "Tu respuesta es correcta, excepto para el caso.", "part.marking.not submitted": "No ha enviado respuesta", "jme.variables.error making function": "Hubo un error en la construcci\u00f3n de la funci\u00f3n <code>{{name}}</code>: {{message}}", "exam.xml.bad root": "El elemento ra\u00edz de un examen XML deber\u00eda ser 'exam'", "part.mcq.matrix not a number": "La celda {{row}},{{column}} de la matriz de puntuaciones de la parte {{part}} no se evalua como un n\u00famero.", "question.score feedback.score total": "{{marksString}}. Respondida.", "question.show steps penalty": "Usted perder\u00e1 <strong>{{count}}</strong> $t(mark).", "question.unsubmitted changes_plural": "Has realizado cambios a tus respuestas, pero no las has enviado. Por favor, revisa tus respuestas a cada parte y luego presiona el bot\u00f3n  <strong>Enviar todas las partes </strong>. ", "question.show steps no penalty": "Su puntuaci\u00f3n no se ver\u00e1 afectada.", "scorm.no part suspend data": "No hay datos suspendidos de esta parte", "jme.typecheck.function not defined": "La operaci\u00f3n {{op}} no est\u00e1 definida. Did you mean <br/><code>{{suggestion}}*(...)</code>?", "part.marking.revealed steps with penalty": "Has revelado los pasos. Lo m\u00e1ximo que puedes puntear para esta parte es <strong>{{count,niceNumber}}</strong> $t(mark). Tu puntuaci\u00f3n ser\u00e1 reducida en consecuencia.", "question.unsubmitted changes": "Has realizado un cambio en tu respuesta, pero no la has enviado a\u00fan. Por favor, revisa tu respuesta y luego presiona el bot\u00f3n <strong>Enviar respuesta</strong>.", "ruleset.circular reference": "Referencia circular en la definici\u00f3n de ruleset <code>{{name}}</code>", "math.combinations.n less than zero": "No se puede calcular combinaciones: n es menor que cero.", "part.marking.incorrect": "Su respuesta es incorrecta.", "jme.variables.empty definition": "Nombre de la variable <code>{{name}}</code> is empty.  est\u00e1 vacio", "question.preamble.syntax error": "Error de sintaxis en el pre\u00e1mbulo", "util.equality not defined for type": "Igualdad no definida para el tipo {{type}} ", "ruleset.set not defined": "Ruleset {{name}} no ha sido definida", "result.question review title": "Revisar esta Pregunta", "jme.shunt.no right bracket": "No concuerda el par\u00e9ntesis de la derecha", "die.sorry": "Lo siento, Numbas ha encontrado un error, por lo tanto no puede continuar. A continuaci\u00f3n se muestra una descripci\u00f3n del error.", "control.end exam": "Finalizar Examen", "vectormath.cross.not 3d": "S\u00f3lo puedo hacer el producto cruzado de vectores tridimensionales.", "part.mcq.matrix not a list": "La matriz de puntuaciones, definida por la expresi\u00f3n JME, no es una lista, y deber\u00eda serlo.", "part.marking.nothing entered": "Ud no ha entrado una respuesta.", "part.numberentry.give your answer as a reduced fraction": "Reduzca su respuesta a la menor expresi\u00f3n.", "mark_plural": "Puntos", "question.hide steps no penalty": "Su puntuaci\u00f3n no se ver\u00e1 afectada.", "step": "Paso.", "part.numberentry.correct except decimal": "Su respuesta est\u00e1 dentro del rango permitido, pero los n\u00fameros decimales no est\u00e1n permitidos.", "question.can not submit": "No se puede ingresar su respuesta - por favor revise errores.", "math.choose.empty selection": "Se le ha proporcionado una selecci\u00f3n vac\u00eda a una funci\u00f3n aleatoria", "part.jme.answer too long": "Su respuesta es demasiado larga.", "mathjax.error": "MathJax procesando error: {{message}}", "control.submit answer": "Enviar Respuesta", "exam.failed": "Reprobado... Intente otra vez", "part.jme.not-allowed one": "Su respuesta no debe contener: {{strings}}", "jme.shunt.not enough arguments": "No hay suficientes argumentos para la operaci\u00f3n {{op}}", "question.answer submitted": "Respuesta enviada", "part.jme.must-have one": "Su respuesta debe contener: {{strings}}", "part.correct answer": "Respuesta correcta:", "part.numberentry.answer not reduced": "Su respuesta no est\u00e1 reducida a su menor expresi\u00f3n.", "control.next": "Siguiente", "part.mcq.marking matrix string empty": "La matriz de puntuaciones personalizada est\u00e1 vac\u00eda.", "matrixmath.abs.too big": "Lo sentimos, no se puede calcular el determinante de una matriz mayor que 3x3.", "jme.texsubvars.no right bracket": "Falta <code>]</code> en los argumentos de {{op}}.", "mathjax.math processing error": "Error de procesamiento en MathJax: \"{{message}}\" al compilar <code>{{expression}}</code> ", "jme.matrix.reports bad size": "No se puede construir una matriz a partir de filas de tipo {{type}}", "part.marking.steps change": "Has ganado <strong>{{count,niceNumber}}</strong> $t(mark) por tus respuestas a los pasos.", "part.mcq.choices": "opciones", "part.jme.answer invalid": "Su respuesta no es una expresi\u00f3n matem\u00e1tica v\u00e1lida. <br/> {{message}}.", "jme.shunt.list mixed argument types": "No puede analizar gram\u00e1ticamente {{mode}}: mezcla de diccionario y lista de elementos", "jme.func.except.continuous range": "No se puede usar el operador 'except' en intervalos continuos.", "exam.marks available": "Puntuaci\u00f3n m\u00e1xima:", "math.combinations.k less than zero": "No se puede calcular combinaciones: k es menor que cero.", "result.question number": "N\u00famero de la Pregunta", "control.submit all parts": "Enviar todas las partes de la pregunta", "jme.func.listval.not a list": "El objeto no se pude indizar", "part.numberentry.give your answer to precision": "Redondea tu respuesta a {{count,niceNumber}} {{precisionType}}.", "part.mcq.wrong number of choices": "Ha seleccionado un n\u00famero incorrecto de opciones.", "jme.variables.syntax error in function definition": "Error de sintaxis en la definici\u00f3n de la funci\u00f3n", "page.saving": "<p>Guardando.</p>\n<p>Esto podr\u00eda tardar unos segundos.</p>", "math.gcf.complex": "No se puede calcular MCD de n\u00fameros complejos.", "part.matrix.some incorrect": "Una o m\u00e1s celdas de tu respuesta son incorrectas, pero se te ha puntuado el resto.", "math.combinations.complex": "No se puede calcular combinaciones de n\u00fameros complejos.", "control.total": "Total", "jme.user javascript.error": "Error en la funci\u00f3n javascript definida por el usuario <code> {{name}} </ code>: {{message}}", "part.matrix.invalid cell": "Una o m\u00e1s de las celdas de la respuesta est\u00e1 vac\u00eda o es inv\u00e1lida.", "scorm.error loading question": "Error al cargar la pregunta {{number}}: {{message}}", "part.numberentry.give your answer to precision_0": "Redondea tu respuesta al entero m\u00e1s cercano.", "jme.shunt.no right square bracket": "No concuerda el par\u00e9ntesis cuadrado de la derecha al final de la lista", "control.not all questions answered": "Usted no a constestado todas las preguntas de su examen.", "jme.display.unknown token type": "No puedo pasar a texto la expresi\u00f3n de tipo {{type}}", "part.numberentry.answer invalid": "No ha introducido un n\u00famero v\u00e1lido.", "jme.user javascript.returned undefined": "Funci\u00f3n javascript <code>{{name}}</code>, definida por el usuario, devolvi\u00f3 <code>undefined</code>.", "question.hide steps": "Ocultar Pasos", "part.mcq.matrix wrong type": "Se ha usado en la matriz de puntuaciones un elemento de tipo '{{type}}', el cual no es v\u00e1lido.", "math.combinations.n less than k": "No se puede calcular combinaciones: n es menor que k.", "mark": "punto", "suspend.you can resume": "Usted podr\u00e1 reanudar esta sesi\u00f3n la pr\u00f3xima vez que inicie esta actividad.", "scorm.error loading suspend data": "Error al cargar datos suspendidos: {{message}}", "result.result": "Resultado:", "question.show steps": "Mostrar Pasos", "question.submit part": "Enviar esta parte", "part.jme.unexpected variable name": "Se ha interpretado que tu respuesta usa el nombre de variable <code>{{name}}</code>, el cual es inapropiado.", "part.matrix.empty cell": "Una o m\u00e1s de las celdas de la respuesta est\u00e1 vac\u00eda.", "control.regen": "Intentar una nueva versi\u00f3n de esta pregunta", "control.advice": "Advice", "xml.could not load": "No se pudo cargar un documento XML: {{message}}.", "part.marking.uncaught error": "Error al puntuar {{part}}: {{message}}", "question.score feedback.score total actual": "Puntuaci\u00f3n: {{score}}/{{marks}}", "result.print": "Imprimir informe de resultados", "math.siground.complex": "No se puede aproximar un n\u00famero complejo a un n\u00famero de cifras significativas.", "question.header": "Pregunta {{number}}", "math.permutations.k less than zero": "No se puede calcular permutacione: k es menor que cero.", "question.preamble.error": "Error en el pre\u00e1mbulo: {{message}}", "suspend.resume": "Reanudar", "part.mcq.correct choice": "Usted eligi\u00f3 la respuesta correcta.", "part.numberentry.answer not integer": "Su respuesta no es v\u00e1lida. Debe ingresar un n\u00famero entero, no un decimal.", "part.jme.not-allowed several": "Su respuesta no debe contener: {{strings}}\n", "part.numberentry.precision type.dp_plural": "N\u00famero de decimales.", "question.unsupported part type": "Tipo de parte no soportado", "jme.variables.error evaluating variable": "Error al evaluar la variable {{name}}: {{message}}", "jme.func.listval.key not in dict": "El diccionario no contiene la clave <code>{{key}}</code>", "part.mcq.answers": "respuestas", "jme.typecheck.map not on enumerable": "<code>map</code> la operaci\u00f3n funciona sobre una lista o un rango, no sobre{{type}}", "jme.substituteTree.undefined variable": "Variable no definida: <code> {{name}} </ code>", "modal.cancel": "Cancelar", "scorm.failed save": "<p>La petici\u00f3n de guardar los datos en el servidor ha fallado. Pulsa  <b>OK</b> para intentarlo de nuevo.</p>\n<p>Si recibes este mensaje a menudo, comprueba tu conexi\u00f3n a internet o utiliza otro ordenador. Tus respuestas enviadas con anterioridad han sido guardadas y se restaurar\u00e1n cuando restablezcas esta sesi\u00f3n en otro ordenador.</p>\n<p>Si este mensaje persiste, y no puedes guardar <em>ninguna</em> respuesta, por favor, contacta con tu profesor.</p> ", "jme.typecheck.function maybe implicit multiplication": "La operaci\u00f3n {{name}} no est\u00e1 definida. \u00bfTal vez quiso decir <br/><code>{{first}}*{{possibleOp}}(...)</code>?", "part.jme.answer too short": "Su respuesta es demasiado corta.", "matrixmath.mul.different sizes": "No se pueden multiplicar matrices de diferentes tama\u00f1os (columnas-filas).", "jme.func.switch.no default case": "No ha establecido una opci\u00f3n por defecto.", "part.numberentry.zero sig fig": "Esta parte est\u00e1 configurada para redondear la respuesta del estudiante a cero cifras significativas, lo cual no tiene sentido.", "frontpage.start": "Comenzar Examen", "result.question score": "Puntuaci\u00f3n", "part.mcq.choices missing": "Falta la definici\u00f3n de opciones", "question.score feedback.correct": "Su respuesta es correcta", "part.feedback": "Retroalimentaci\u00f3n", "question.score feedback.answered": "Respondida.", "math.permutations.n less than k": "No se puede calcular permutaciones: n es menor que k.", "part.gapfill.feedback header": "<strong>Gap {{index}}</strong>", "question.advice": "Soluci\u00f3n", "vectormath.cross.matrix too big": "S\u00f3lo puedo calcular el producto cruzado de matrices que o bien tengan una sola fila o una sola columna.", "part.jme.not-allowed bits": "<span class=\"monospace\">{{string}}</span>", "display.part.jme.error making maths": "Error al desplegar escritura matem\u00e1tica", "part.prompt": "Indicaci\u00f3n", "control.proceed anyway": "\u00bfDesea continuar?", "gap": "hueco", "jme.tokenise.invalid": "Expresi\u00f3n inv\u00e1lida: <code>{{expression}}</code>", "result.score": "Puntuaci\u00f3n:", "math.lcm.complex": "No se puede calcular MCM de n\u00fameros complejos.", "exam.random seed": "ID de la Sesi\u00f3n:", "modal.ok": "OK", "was": "fue", "jme.thtml.not html": "Se ha pasado un valor no HTML a el constructor THTML.\n", "question.score feedback.partial": "Su respuesta es parcialmente correcta", "mathjax.error with context": "MathJax procesando error en {{context}}:{{message}}", "question.score feedback.wrong": "Su respuesta es incorrecta", "question.score feedback.score actual": "Puntuaci\u00f3n: {{scoreString}}", "part.numberentry.correct except fraction": "Su respuesta est\u00e1 dentro del rango permitido, pero no se permiten fracciones.", "question.error": "Pregunta {{number}}: {{message}}", "jme.evaluate.no scope given": "Hay que darle a Numbas.jme,evaluate un Scope", "question.show steps already penalised": "Ya se han mostrado los pasos, no tendr\u00e1 penalizaci\u00f3n adicional.", "part.jme.answer missing": "Falta la respuesta correcta.", "part.mcq.no choices selected": "No hay opciones seleccionadas.", "die.script not loaded": "Numbas no pudo iniciar porque el archivo <code>{{file}}</code> no carg\u00f3. Compruebe que est\u00e1 incluido en <code>scripts.js</code>. ", "part.numberentry.precision type.dp": "posici\u00f3n decimal", "part.matrix.answer invalid": "Su respuesta no es v\u00e1lida.", "jme.variables.question took too many runs to generate variables": "Un conjunto v\u00e1lido de variables de pregunta no se gener\u00f3 a tiempo.", "jme.texsubvars.no right brace": "No corresponde <code>}</code> en {{op}}", "page.loading": "Cargando...", "part.jme.marking.correct": "Su respuesta en num\u00e9ricamente correcta.", "part.marking.correct": "Su respuesta es correcta.", "part.matrix.size mismatch": "El autor de la pregunta no ha permitido al estudiante decidir la dimensiones de su respuesta; la respuesta correcta tiene {{correct_dimensions}} mientras que la entrada es {{input_dimensions}}", "exam.feedback": "Mensaje de retroalimentaci\u00f3n del examen", "part.marking.used variable replacements": "Esta parte ha sido puntuada usando tus respuestas a las partes anteriores.", "control.submit": "Enviar", "jme.shunt.no left square bracket": "No concuerda el par\u00e9ntesis de la izquierda", "jme.func.listval.invalid index": "\u00cdndice {{index}} de lista inv\u00e1lido en una lista de tama\u00f1o {{size}}", "question.score feedback.hide": "Ocultar Retroalimentaci\u00f3n", "jme.variables.circular reference": "Hay una referencia circular en la definici\u00f3n de la variable <code>{{name}}</code> is empty. ", "result.time spent": "Tiempo ocupado en resolver el examen:", "die.error": "Error", "timing.time remaining": "Tiempo restante: %s", "part.numberentry.negative decimal places": "Esta parte est\u00e1 configurada para redondear la respuesta del estudiante a un n\u00famero negativo de posiciones decimales, lo cual no tiene sentido.", "part.with steps answer prompt": "Respuesta.", "control.confirm leave": "Usted no a terminado de responder su examen.", "jme.typecheck.op not defined": "La operaci\u00f3n '{{op}}' no est\u00e1 definida.", "part": "Parte.", "control.submit again": "Enviar nuevamente", "xml.error in variable definition": "Error en la definici\u00f3n de la variable <code>{{name}}</code>", "exam.changeQuestion.no questions": "Este examen no tiene preguntas! Revisar el archivo con extensi\u00f3n .exam .", "part.jme.must-have bits": "<span class=\"monospace\">{{string}}</span>", "part.marking.total score": "Has punteado <strong>{{count,niceNumber}}</strong> $t(mark) para esta parte.", "exam.introduction": "Introducci\u00f3n al examen", "control.confirm regen": "\u00bfQuiere nuevos valores para la pregunta? Si usted hace click en OK, todas sus respuestas y puntuaci\u00f3n para esta pregunta se perder\u00e1n.", "jme.evaluate.undefined variable": "La variable {{name}} no est\u00e1 definida", "jme.display.simplifyTree.no scope given": "Hay que proporcionar un \u00e1mbito de actuaci\u00f3n a Numbas.jme.display.simplifyTree", "timing.no accumulator": "no hay acumulador de tiempo {{name}}", "util.product.non list": "A <code>Numbas.util.product</code> se le a pasado un argumento que no es una lista", "part.marking.revealed steps no penalty": "Has revelado los pasos.", "part.jme.unexpected variable name suggestion": "Se ha interpretado que tu respuesta usa el nombre de variable <code>{{name}}</code>, el cual es inapropiado. \u00bfQuiz\u00e1s quer\u00edas decir  <code>{{suggestion}}</code>?", "jme.display.collectRuleset.set not defined": "El conjunto de reglas para {{name}}, no ha sido definido.", "was_plural": "fueron", "part.marking.no result": "Esta parte no se pudo puntuar.", "part.setting not present": "Propiedad '{{property}}' no establecida", "exam.number of questions": "N\u00famero de Preguntas:", "part.numberentry.answer not integer or decimal": "Su respuesta no es v\u00e1lida. Debe ingresar un n\u00famero entero, o un decimal.", "question.selector.unsubmitted changes": "A\u00fan no ha enviado su respuesta.", "vectormath.dot.matrix too big": "S\u00f3lo puedo calcular el producto escalar de matrices que o bien tengan una sola fila o una sola columna.", "scorm.no exam suspend data": "No se ha podido reanudar: no hay datos del examen suspendido.", "math.permutations.n less than zero": "No se puede calcular permutaciones: n es menor que cero.", "part.matrix.empty": "No ha ingresado una respuesta.", "part.jme.must-have several": "Tu respuesta debe contener todas las cadenas: {{strings}}", "part.patternmatch.display answer missing": "Falta respuesta para mostrar.", "math.precround.complex": "No se puede aproximar un n\u00famero complejo a un n\u00famero de cifras decimales.", "jme.func.matrix.invalid row type": "No se puede construir una matriz a partir de filas de tipo {{type}}", "jme.tokenise.keypair key not a string": "La clave del diccionario tiene que ser una cadena, no {{type}}", "jme.shunt.no left bracket": "No concuerda el par\u00e9ntesis de la izquierda", "result.exam summary": "Informe del examen", "jme.typecheck.no right type definition": "No se ha encontrado una definici\u00f3n para '{{op}}' del tipo correcto.\n", "exam.time allowed": "Tiempo permitido:", "question.statement": "Declaraci\u00f3n", "xml.property not number": "El propiedad {{name}} en el nodo {{element}} deber\u00eda ser un numero, pero no lo es ({{value}})", "exam.exam name": "Nombre del Examen:", "control.previous": "Anterior"}}, "pt-br": {"translation": {"jme.typecheck.no right type unbound name": "Vari\u00e1vel <code>{{name}}</code> n\u00e3o definida.", "control.pause": "Pausar", "feedback.taken away": "<strong>{{count,niceNumber}}</strong> $t(mark) $t(was) tirados.", "question.score feedback.unanswered": "N\u00e3o respondida.", "control.reveal": "Revelar respostas", "part.marking.steps no matter": "Como voc\u00ea recebeu nota m\u00e1xima para esta parte, suas respostas para os passos n\u00e3o foram contabilizadas.", "part.marking.resubmit because of variable replacement": "A avalia\u00e7\u00e3o desta parte depende das duas respostas em outras partes, as quais voc\u00ea modificou. Envie esta parte novamente para atualizar sua pontua\u00e7\u00e3o.", "question.no such part": "N\u00e3o foi poss\u00edvel encontrar parte {{path}}", "control.back to results": "Retornar aos resultados", "part.unknown type": "{{part}}: Tipo de parte n\u00e3o reconhecido {{type}}", "result.click a question to review": "Clique no n\u00famero de uma quest\u00e3o para ver como as suas respostas foram avaliadas e, quando dispon\u00edvel, as solu\u00e7\u00f5es completas.", "part.missing type attribute": "{{part}}: Faltando atributo de tipo de parte", "matrixmath.abs.non-square": "N\u00e3o \u00e9 poss\u00edvel calcular a determinante de uma matriz n\u00e3o quadrada", "result.performance summary": "Relat\u00f3rio de performance", "die.numbas failed": "Numbas falhou", "jme.shunt.no left bracket in function": "Sem abertura de colchete correspondete na aplica\u00e7\u00e3o da fun\u00e7\u00e3o ou tupla", "part.mcq.matrix cell empty": "A c\u00e9lula da matriz de pontua\u00e7\u00e3o ({{row}},{{column}}) da parte {{part}} est\u00e1 vazia.", "question.score feedback.show": "Mostrar feedback", "part.script.error": "Erro na part {{path}}, no script {{script}}: {{message}}", "part.numberentry.precision type.sigfig": "algarismo significativo", "jme.variables.error computing dependency": "Erro ao computar vari\u00e1vel referenciada <code>{{name}}</code>", "exam.passed": "Aprovado", "result.questions attempted": "Quest\u00f5es tentadas:", "control.not all questions submitted": "Voc\u00ea modificou uma ou mais respostas mas n\u00e3o as enviou. Por favor, verifique se cada uma das quest\u00f5es foi enviada.", "exam.student name": "Nome do Estudante:", "scorm.no question suspend data": "Sem dados suspensos de quest\u00e3o", "result.exam start": "Iniciar exame", "part.extension.not implemented": "Parte n\u00e3o implementou o m\u00e9todo <code>{{name}}</code>.", "xml.property not boolean": "Propriedade {{name}} deve ser um booleano, mas n\u00e3o \u00e9 ({{value}}), no n\u00f3 {{element}}", "feedback.you were awarded": "Voc\u00ea recebeu <strong>{{count,niceNumber}}</strong> $t(mark).", "jme.variables.variable not defined": "Vari\u00e1vel <code>{{name}}</code> n\u00e3o definida.", "question.loaded name mismatch": "N\u00e3o \u00e9 poss\u00edvel retomar esta tentativa - o pacote modificou desde a \u00faltima sess\u00e3o.", "control.confirm end": "Tem certeza que quer finalizar o exame? Ap\u00f3s finalizar o exame n\u00e3o ser\u00e1 poss\u00edvel modificar as suas respostas.", "result.exam stop": "Parar exame", "exam.review header": "Avalia\u00e7\u00e3o:", "jme.display.collectRuleset.no sets": "Nenhum conjunto passado para collectRuleset!", "result.exit": "Sair", "scorm.error initialising": "Erro ao inicializar protocolo SCORM: {{message}}", "exam.pass percentage": "Percentual de aprova\u00e7\u00e3o:", "math.permutations.complex": "N\u00e3o \u00e9 poss\u00edvel calcular permuta\u00e7\u00f5es de n\u00fameros complexos", "scorm.error loading part": "Erro ao carregar parte {{part}}: {{message}}", "part.mcq.options def not a list": "A express\u00e3o que define {{properties}} n\u00e3o \u00e9 uma lista.", "part.mcq.matrix mix of numbers and lists": "Mix de n\u00fameros e listas usados na matriz de pontua\u00e7\u00e3o.", "part.marking.variable replacement part not answered": "Voc\u00ea deve responder {{part}} primeiro", "part.marking.did not answer": "Voc\u00ea n\u00e3o respondeu esta quest\u00e3o", "jme.shunt.missing operator": "Express\u00e3o n\u00e3o pode ser avaliada -- fata um operador.", "suspend.paused header": "Pausado", "part.mcq.matrix wrong size": "Matriz de pontua\u00e7\u00e3o tem ", "part.mcq.matrix jme error": "A c\u00e9lula da matriz de pontua\u00e7\u00e3o ({{row}},{{column}}) da parte {{part}} possui erro JME: {{error}}.", "end.exam has finished": "O exame terminou. Voc\u00ea pode fechar esta janela.", "suspend.exam suspended": "O exame foi interrompido. Pressione <em>Continuar<em> para continuar.", "jme.texsubvars.missing parameter": "Faltando par\u00e2metro em {{op}}: {{parameter}}", "part.numberentry.precision type.sigfig_plural": "algarismos significativos", "math.lt.order complex numbers": "N\u00e3o \u00e9 poss\u00edvel ordenar n\u00fameros complexos", "control.confirm reveal": "Gostaria de revelar a resposta para esta quest\u00e3o? Pontos recebidos at\u00e9 o momento ser\u00e3o bloqueados e voc\u00ea n\u00e3o poder\u00e1 responder essa quest\u00e3o mais tarde.", "part.patternmatch.correct except case": "Sua resposta est\u00e1 correta, exceto a formata\u00e7\u00e3o.", "part.marking.not submitted": "Sem resposta enviada", "jme.variables.error making function": "Erro ao criar fun\u00e7\u00e3o <code>{{name}}</code>: {{message}}", "exam.xml.bad root": "Elemento raiz do XML do exame deve ser 'exam'", "part.mcq.matrix not a number": "A c\u00e9lula da matriz de pontua\u00e7\u00e3o ({{row}},{{column}}) da parte {{part}} n\u00e3o cont\u00e9m um n\u00famero.", "question.score feedback.score total": "{{marksString}}. Respondida.", "question.show steps penalty": "Voc\u00ea perder\u00e1 <strong>{{count,niceNumber}}</strong> $t(mark).", "question.unsubmitted changes_plural": "Voc\u00ea modificou suas respostas mas n\u00e3o as enviou. Por favor, verifique suas respostas e pressione o bot\u00e3o <strong>Enviar todas as partes</stron>.", "question.show steps no penalty": "Sua pontua\u00e7\u00e3o n\u00e3o ser\u00e1 afetada.", "scorm.no part suspend data": "Sem dados suspensos de parte", "jme.typecheck.function not defined": "Opera\u00e7\u00e3o <code>{{op}}</code> n\u00e3o definida. <code>{{op}}</code> \u00e9 uma vari\u00e1vel e voc\u00ea quis dizer <code>{{sugestion}}*(...)</code>?", "part.marking.revealed steps with penalty": "Voc\u00ea revelou passos. A pontua\u00e7\u00e3o m\u00e1xima que pode obter por esta parte \u00e9 <strong>{{count,niceNumber}}</strong> $t(mark). Suas pontua\u00e7\u00f5es ser\u00e3o ajustadas de acordo.", "question.unsubmitted changes": "Voc\u00ea modificou a sua resposta mas n\u00e3o a enviou. Por favor, verifique sua resposta e pressione o bot\u00e3o <strong>Enviar resposta</stron>.", "ruleset.circular reference": "Refer\u00eancia circular na defini\u00e7\u00e3o do conjunto de regras <code>{{name}}</code>", "math.combinations.n less than zero": "Imposs\u00edvel calcular combina\u00e7\u00f5es: n \u00e9 menor que zero", "part.marking.incorrect": "Sua resposta est\u00e1 incorreta.", "jme.variables.empty definition": "Defini\u00e7\u00e3o da vari\u00e1vel <code>{{name}}</code> est\u00e1 vazia.", "question.preamble.syntax error": "Erro de sintaxe no pre\u00e2mbulo", "util.equality not defined for type": "Igualdade n\u00e3o definida para o tipo {{type}}", "ruleset.set not defined": "Conjunto de regras {{name}} n\u00e3o foi definido", "result.question review title": "Revisar esta quest\u00e3o", "jme.shunt.no right bracket": "Sem fechamento de colchete correspondente", "die.sorry": "Desculpe, Numbas encontrou um erro portanto n\u00e3o pode continuar. Abaixo est\u00e1 uma descri\u00e7\u00e3o do erro.", "control.end exam": "Finalizar exame", "vectormath.cross.not 3d": "Poss\u00edvel calcular produto vetorial apenas para vetores tridimensionais.", "part.mcq.matrix not a list": "Matriz de pontua\u00e7\u00e3o, definida por uma express\u00e3o JME, n\u00e3o \u00e9 uma lista mas deveria ser.", "part.marking.nothing entered": "Voc\u00ea n\u00e3o inseriu uma resposta.", "part.numberentry.give your answer as a reduced fraction": "Reduza a sua resposta para os menores termos.", "mark_plural": "pontos", "question.hide steps no penalty": "Sua pontua\u00e7\u00e3o n\u00e3o ser\u00e1 afetada.", "step": "passo", "part.numberentry.correct except decimal": "Sua resposta est\u00e1 na faixa permitida, por\u00e9m n\u00fameros decimais n\u00e3o s\u00e3o permitidos.", "question.can not submit": "N\u00e3o foi poss\u00edvel enviar a resposta - verifique se h\u00e1 erros", "math.choose.empty selection": "Sele\u00e7\u00e3o vazia passada a um fun\u00e7\u00e3o rand\u00f4mica", "part.jme.answer too long": "Sua resposta \u00e9 muito longa.", "mathjax.error": "Erro de processamento MathJax: {{message}}", "control.submit answer": "Enviar resposta", "exam.failed": "Reprovado", "part.jme.not-allowed one": "Sua resposta n\u00e3o deve conter: {{strings}}", "jme.shunt.not enough arguments": "Poucos argumentos para a opera\u00e7\u00e3o {{op}}", "question.answer submitted": "Resposta enviada", "part.jme.must-have one": "Sua resposta deve conter: {{strings}}", "part.correct answer": "Resposta esperada:", "part.numberentry.answer not reduced": "Sua respostar n\u00e3o est\u00e1 reduzida para os menores termos.", "control.next": "Pr\u00f3ximo", "part.mcq.marking matrix string empty": "A express\u00e3o customizada da matriz de pontua\u00e7\u00e3o est\u00e1 vazia.", "matrixmath.abs.too big": "Desculpe, ainda n\u00e3o \u00e9 poss\u00edvel calcular a determinante de matrizes maiores que 3x3", "jme.texsubvars.no right bracket": "Sem <code>]</code> correspondente nos argumentos de {{op}}.", "mathjax.math processing error": "\"{{message}}\" quando \"texificando\" <code>{{expression}}</ code>", "jme.matrix.reports bad size": "Matriz informa tamanho incorretamente - deve ser um erro na fun\u00e7\u00e3o construtor", "part.marking.steps change": "Voc\u00ea recebeu <strong>{{count,niceNumber}}</strong> $t(mark) por suas respostas aos passos.", "part.mcq.choices": "op\u00e7\u00f5es", "part.jme.answer invalid": "Sua resposta n\u00e3o \u00e9 uma express\u00e3o matem\u00e1tica v\u00e1lida.\n<br/>{{message}}", "jme.shunt.list mixed argument types": "N\u00e3o \u00e9 poss\u00edvel analisar {{mode}}: mix de dicion\u00e1rio e lista", "jme.func.except.continuous range": "N\u00e3o \u00e9 poss\u00edvel usar o operador 'except' em intervalos cont\u00ednuos.", "exam.marks available": "Notas dispon\u00edveis:", "math.combinations.k less than zero": "Imposs\u00edvel calcular combina\u00e7\u00f5es: k \u00e9 menor que zero", "result.question number": "N\u00famero da quest\u00e3o", "control.submit all parts": "Enviar todas as partes", "jme.func.listval.not a list": "Objeto n\u00e3o \u00e9 subscriptable", "part.numberentry.give your answer to precision": "Arredonde sua resposta para {{count,niceNumber}} {{precisionType}}", "part.mcq.wrong number of choices": "Voc\u00ea selecionou o n\u00famero errado de op\u00e7\u00f5es.", "jme.variables.syntax error in function definition": "Erro de sintaxe ao definir fun\u00e7\u00e3o", "page.saving": "<p>Salvando.</p>\n<p>Isso pode demorar alguns segundos.</p>", "math.gcf.complex": "N\u00e3o \u00e9 poss\u00edvel calcular o MDC de n\u00fameros complexos", "part.matrix.some incorrect": "Uma ou mais c\u00e9lulas da sua resposta est\u00e3o incorretas, mas voc\u00ea recebeu pontua\u00e7\u00e3o pelo resto.", "math.combinations.complex": "N\u00e3o \u00e9 poss\u00edvel calcular combina\u00e7\u00f5es de n\u00fameros complexos", "control.total": "Total", "jme.user javascript.error": "Erro na fun\u00e7\u00e3o definida pelo usu\u00e1rio <code>{{name}}</code>: {{message}}", "part.matrix.invalid cell": "Uma ou mais c\u00e9lulas da sua resposta est\u00e3o vazias ou s\u00e3o inv\u00e1lidas.", "scorm.error loading question": "Erro ao carregar quest\u00e4o {{number}}: {{message}}", "part.numberentry.give your answer to precision_0": "Arredonde sua resposta para o inteiro mais pr\u00f3ximo.", "jme.shunt.no right square bracket": "Sem fechamento de colchete para finalizar a lista", "control.not all questions answered": "Voc\u00ea n\u00e3o completou todas as quest\u00f5es neste exame.", "jme.display.unknown token type": "N\u00e3o \u00e9 poss\u00edvel \"texificar\" tipo {{type}}", "part.numberentry.answer invalid": "Voc\u00ea n\u00e3o inseriu um n\u00famero valido.", "jme.user javascript.returned undefined": "Fun\u00e7\u00e3o javascript definida pelo usu\u00e1rio <code>{{name}}</code> retornou <code>undefined</code>.", "question.hide steps": "Ocultar passos", "part.mcq.matrix wrong type": "Elemento de tipo inv\u00e1lido '{{type}}' usado na matriz de pontua\u00e7\u00e3o.", "math.combinations.n less than k": "Imposs\u00edvel calcular combina\u00e7\u00f5es: n \u00e9 menor que k", "mark": "ponto", "suspend.you can resume": "Voc\u00ea poder\u00e1 continuar essa sess\u00e3o na pr\u00f3xima vez que iniciar esta atividade.", "scorm.error loading suspend data": "Erro ao carregar dados suspensos: {{message}}", "result.result": "Resultado", "question.show steps": "Mostrar passos", "question.submit part": "Enviar parte", "part.jme.unexpected variable name": "Sua resposta usa uma vari\u00e1vel de nome inesperado <code>{{name}}</code>.", "part.matrix.empty cell": "Uma ou mais c\u00e9lulas da sua resposta est\u00e3o vazias.", "control.regen": "Tentar outra quest\u00e3o similar a esta", "control.advice": "Dica", "xml.could not load": "N\u00e3o foi poss\u00edvel carregar um documento XML: {{message}}", "part.marking.uncaught error": "Erro ao avaliar {{part}}: {{message}}", "question.score feedback.score total actual": "Pontua\u00e7\u00e3o: {{score,niceNumber}}/{{marks,niceNumber}}", "result.print": "Imprimir relat\u00f3rio de resultados", "math.siground.complex": "N\u00e3o \u00e9 poss\u00edvel arredondar para um n\u00famero complexo de algarismos significantes.", "question.header": "Quest\u00e3o {{number}}", "math.permutations.k less than zero": "Imposs\u00edvel calcular permuta\u00e7\u00f5es: k \u00e9 menor que zero", "question.preamble.error": "Erro no pre\u00e2mbulo: {{message}}", "suspend.resume": "Continuar", "part.mcq.correct choice": "Voc\u00ea escolheu a resposta correta.", "part.numberentry.answer not integer": "Sua resposta \u00e9 inv\u00e1lida. Voc\u00ea deve inserir um n\u00famero inteiro, n\u00e3o um decimal.", "part.jme.not-allowed several": "Sua resposta n\u00e3o deve conter nenhum de: {{strings}}", "part.numberentry.precision type.dp_plural": "casas decimais", "question.unsupported part type": "Tipo de parte n\u00e3o suportado.", "jme.variables.error evaluating variable": "Erro ao avaliar a vari\u00e1vel {{name}}: {{message}}", "jme.func.listval.key not in dict": "Dicion\u00e1rio n\u00e3o cont\u00e9m a chave <code>{{key}}</code>", "part.mcq.answers": "respostas", "jme.typecheck.map not on enumerable": "Opera\u00e7\u00e3o <code>map</code> funciona em uma listas ou intervalo, n\u00e3o {{type}}", "jme.substituteTree.undefined variable": "Vari\u00e1vel indifinida <code>{{name}}</code>", "modal.cancel": "Cancelar", "scorm.failed save": "<p> A requisi\u00e7\u00e3o para salvar dados falhou. Pressione <b>OK</b> para tentar novamente.</p>\n<p>Se receber essa mensagem repetidas vezes, verifique sua conex\u00e3o a internet ou use outro computador. Suas respostas previamente enviadas foram salvas com sucesso e ser\u00e3o restauradas caso continue esta sess\u00e3o em outro computador.</p>\n<p>Se esta mensagem aparecer persistentemente e voc\u00ea n\u00e3o conseguir salvar <em>nenhuma</em> resposta, por favor, contate o professor.</p>", "jme.typecheck.function maybe implicit multiplication": "Opera\u00e7\u00e3o {{name}} n\u00e3o definida. Voc\u00ea quis dizer <code>{{first}}*{{possibleOp}}(...)</code>?", "part.jme.answer too short": "Sua resposta \u00e9 muito curta.", "matrixmath.mul.different sizes": "N\u00e3o \u00e9 poss\u00edvel multiplicar matrizes de diferentes tamanhos", "jme.func.switch.no default case": "Sem caso default no Switch", "part.numberentry.zero sig fig": "Esta parte est\u00e1 configurada para arredondar a resposta do estudante para zero algarismos significantes, o que n\u00e3o faz sentido.", "frontpage.start": "Iniciar", "result.question score": "Pontua\u00e7\u00e3o", "part.mcq.choices missing": "Defini\u00e7\u00e3o das alternativas n\u00e3o encontrada", "question.score feedback.correct": "Sua resposta est\u00e1 correta.", "part.feedback": "feedback", "question.score feedback.answered": "Respondida.", "math.permutations.n less than k": "Imposs\u00edvel calcular permuta\u00e7\u00f5es: n \u00e9 menor que k", "part.gapfill.feedback header": "<strong> Lacuna {{index}}</strong>", "question.advice": "Dica", "vectormath.cross.matrix too big": "N\u00e3o \u00e9 poss\u00edvel calcular o produto vetorial de uma matriz que n\u00e3o seja  $1 \\times N$ ou $N \\times 1$.", "part.jme.not-allowed bits": "<span class=\"monospace\">{{string}}</span>", "display.part.jme.error making maths": "Erro ao criar o display matem\u00e1tico", "part.prompt": "aviso", "control.proceed anyway": "Prosseguir mesmo assim?", "gap": "lacuna", "jme.tokenise.invalid": "Express\u00e3o inv\u00e1lida: <code>{{expression}}</code>", "result.score": "Pontua\u00e7\u00e3o", "math.lcm.complex": "N\u00e3o \u00e9 poss\u00edvel calcular o MMC de n\u00fameros complexos", "exam.random seed": "ID de sess\u00e3o:", "modal.ok": "OK", "was": "era", "jme.thtml.not html": "Passou um valor n\u00e3o-HTML para o contrutor THTML.", "question.score feedback.partial": "Sua resposta est\u00e1 parcialmente correta.", "mathjax.error with context": "Erro de processamento MathJax em {{context}}: {{message}}", "question.score feedback.wrong": "Sua resposta est\u00e1 incorreta", "question.score feedback.score actual": "Pontua\u00e7\u00e3o: {{scoreString}}", "part.numberentry.correct except fraction": "Sua resposta est\u00e1 na faixa permitida, mas fra\u00e7\u00f5es n\u00e3o s\u00e3o permitidas.", "question.error": "Quest\u00e3o {{number}}: {{message}}", "jme.evaluate.no scope given": "Numbas.jme.evaluate deve receber um Scope", "question.show steps already penalised": "Voc\u00ea j\u00e1 mostrou passos. Voc\u00ea pode mostr\u00e1-los novamente sem mais penalidades.", "part.jme.answer missing": "Resposta correta n\u00e3o encontrada", "part.mcq.no choices selected": "Nenhuma op\u00e7\u00e3o selecionada.", "die.script not loaded": "Numbas n\u00e3o iniciou pois o arquivo <code>{{file}}</code> n\u00e3o foi carregado. Verifique se est\u00e1 incluso em <code>script.js</code>.", "part.numberentry.precision type.dp": "casa decimal", "part.matrix.answer invalid": "Sua resposta n\u00e3o \u00e9 v\u00e1lida.", "jme.variables.question took too many runs to generate variables": "Um conjunto v\u00e1lido de vari\u00e1veis de quest\u00e3o n\u00e3o foi gerado a tempo.", "jme.texsubvars.no right brace": "Sem <code>}</code> correspondente em {{op}}", "page.loading": "Carregando...", "part.jme.marking.correct": "Sua resposta est\u00e1 numericamente correta.", "part.marking.correct": "Sua resposta est\u00e1 correta.", "part.matrix.size mismatch": "O autor da quest\u00e3o n\u00e3o permitiu que o estudante decida as dimens\u00f5es da resposta, mas a resposta correta \u00e9 {{correct_dimension}} enquanto a resposta inserida \u00e9 {{input_dimensions}}", "exam.feedback": "Mensagem de feedback do exame", "part.marking.used variable replacements": "Esta parte foi pontuada usando suas respostas para as partes anteriores.", "control.submit": "Enviar", "jme.shunt.no left square bracket": "Sem abertura de colchete correspondente", "jme.func.listval.invalid index": "\u00cdndice {{index}} inv\u00e1lido em lista de tamanho {{size}}", "question.score feedback.hide": "Ocultar feedback", "jme.variables.circular reference": "Refer\u00eancia circular na defini\u00e7\u00e3o da vari\u00e1vel <code>{{name}}</code>", "result.time spent": "Tempo gasto", "die.error": "Erro", "timing.time remaining": "Tempo restante:", "part.numberentry.negative decimal places": "Esta parte est\u00e1 configurada para arredondar a resposta do estudante para um n\u00famero negativo de algarismos significantes, o que n\u00e3o faz sentido.", "part.with steps answer prompt": "Resposta:", "control.confirm leave": "Voc\u00ea n\u00e3o concluiu o exame.", "jme.typecheck.op not defined": "Opera\u00e7\u00e3o '{{op}}' n\u00e3o definida.", "part": "parte", "control.submit again": "Enviar novamente", "xml.error in variable definition": "Erro na defini\u00e7\u00e3o da vari\u00e1vel <code>{{name}}</code>", "exam.changeQuestion.no questions": "Este exame n\u00e3o cont\u00e9m quest\u00f5es! Verifique se h\u00e1 erros no arquivo .exam.", "part.jme.must-have bits": "<span class=\"monospace\">{{string}}</span>", "part.marking.total score": "Voc\u00ea pontuou <strong>{{count,niceNumber}}</strong> $t(mark) por esta parte.", "exam.introduction": "Introdu\u00e7\u00e3o do exame", "control.confirm regen": "Gostaria de re-aleatorizar esta quest\u00e3o? Se clicar OK, todas as suas respostas e pontua\u00e7\u00f5es para a quest\u00e3o atual ser\u00e3o perdidos.", "jme.evaluate.undefined variable": "Vari\u00e1vel {{name}} n\u00e3o definida.", "jme.display.simplifyTree.no scope given": "Numbas.jme.display.simplifyTree deve receber um Scope", "timing.no accumulator": "sem acumulador de tempo {{name}}", "util.product.non list": "Passou uma n\u00e3o-lista para <code>Numbas.util.product</code>", "part.marking.revealed steps no penalty": "Voc\u00ea revelou os passos.", "part.jme.unexpected variable name suggestion": "Sua resposta usa uma vari\u00e1vel de nome inesperado <code>{{name}}</code>. Voc\u00ea quis dizer <code>{{suggestion}}</code>?", "jme.display.collectRuleset.set not defined": "Conjunto de regras {{name}} n\u00e3o foi definido", "was_plural": "eram", "part.marking.no result": "Esta part n\u00e3o p\u00f4de ser avaliada.", "part.setting not present": "Propriedade '{{property}}' n\u00e3o atribuida", "exam.number of questions": "N\u00famero de perguntas:", "part.numberentry.answer not integer or decimal": "Sua resposta \u00e9 inv\u00e1lida. Voc\u00ea deve inserir um inteiro ou um decimal.", "question.selector.unsubmitted changes": "Modifica\u00e7\u00f5es n\u00e3o enviadas", "vectormath.dot.matrix too big": "N\u00e3o \u00e9 poss\u00edvel calcular o produto escalar de uma matriz que n\u00e3o seja $1 \\times N$ ou $N \\times 1$.", "scorm.no exam suspend data": "Falha ao retomar: sem dados suspensos do exame.", "math.permutations.n less than zero": "Imposs\u00edvel calcular permuta\u00e7\u00f5es: n \u00e9 menor que zero", "part.matrix.empty": "Voc\u00ea n\u00e3o inseriu uma resposta.", "part.jme.must-have several": "Sua resposta deve conter todos de: {{strings}}", "part.patternmatch.display answer missing": "Resposta para exibi\u00e7\u00e3o n\u00e3o encontrada", "math.precround.complex": "N\u00e3o \u00e9 poss\u00edvel arredondar para um n\u00famero complexo de casas decimais", "jme.func.matrix.invalid row type": "N\u00e3o \u00e9 poss\u00edvel construir uma matriz a partir de linhas do tipo {{type}}", "jme.tokenise.keypair key not a string": "Chave do dicion\u00e1rio deve ser uma string, n\u00e3o {{type}}.", "jme.shunt.no left bracket": "Sem abertura de colchete correspondente", "result.exam summary": "Relat\u00f3rio do exame", "jme.typecheck.no right type definition": "Nenhuma defini\u00e7\u00e3o de '{{op}}' do tipo correto foi encontrada.", "exam.time allowed": "Tempo Permitido:", "question.statement": "Enunciado", "xml.property not number": "Propriedade {{name}} deve ser um n\u00famero, mas n\u00e3o \u00e9 ({{value}}), no n\u00f3 {{element}}", "exam.exam name": "Nome do Exame:", "control.previous": "Anterior"}}, "nb-no": {"translation": {"jme.typecheck.no right type unbound name": "Variabel <code>{{name}}</code> er ikke definert.", "control.pause": "Pause", "feedback.taken away": "<strong>{{count}}</strong> $t(mark) er trukket fra.", "question.score feedback.unanswered": "Ubesvart.", "control.reveal": "Vis svar", "part.marking.steps no matter": "Ettersom du fikk alt riktig i oppgaven blir ikke delsvarene telt opp.", "part.marking.resubmit because of variable replacement": "This part's marking depends on your answers to other parts, which you have changed. Submit this part again to update your score.", "question.no such part": "Finner ikke sp\u00f8rsm\u00e5l {{path}}", "control.back to results": "Go back to results", "part.unknown type": "Ukjent sp\u00f8rsm\u00e5lsdel {{type}}", "result.click a question to review": "Klikk p\u00e5 et sp\u00f8rsm\u00e5lnummer for \u00e5 se karaktersetting, og om mulig, fullstendig l\u00f8sning.", "part.missing type attribute": "Sp\u00f8rsm\u00e5lsdel har feil atributt", "matrixmath.abs.non-square": "Kan ikke beregne determinanten til en matrise som ikke er kvadratisk.", "result.performance summary": "Resultatsammendrag", "die.numbas failed": "Numbas har feilet", "jme.shunt.no left bracket in function": "Venstre parentes mangler i funksjon eller tuppel", "part.mcq.matrix cell empty": "Part {{part}} marking matrix cell ({{row}},{{column}}) is empty", "question.score feedback.show": "Vis vurdering", "part.script.error": "Feil i del {{path}} brukerdefinert skript {{script}}: {{message}}", "part.numberentry.precision type.sigfig": "significant figure", "jme.variables.error computing dependency": "Feil ved beregning av referert variabel <code>{{name}}</code>", "exam.passed": "Best\u00e5tt", "result.questions attempted": "Antall besvarte sp\u00f8rsm\u00e5l:", "control.not all questions submitted": "Du har endret ett eller flere svar men ikke lagret dem. Vennligst se om svarene er lagret.", "exam.student name": "Studentens navn:", "scorm.no question suspend data": "Ingen sesjonsdata for sp\u00f8rsm\u00e5l", "result.exam start": "Eksamen start:", "part.extension.not implemented": "Part hasn't implemented the <code>{{name}}</code> method.", "xml.property not boolean": "Egenskap {{name}} m\u00e5 v\u00e6re en boolsk verdi, men er ikke ({{value}}), i node {{element}}", "feedback.you were awarded": "Du oppn\u00e5dde {{count}} $t(mark).", "jme.variables.variable not defined": "Variabel <code>{{name}}</code> er ikke definert.", "question.loaded name mismatch": "Kan ikke fortsette dette fors\u00f8ket - pakken er endret siden siste sesjon.", "control.confirm end": "Er du sikker p\u00e5 at du vil avslutte? Etter dette vil du ikke kunne endre p\u00e5 svarene dine..", "result.exam stop": "Eksamen slutt:", "exam.review header": "Gjennomgang: ", "jme.display.collectRuleset.no sets": "Ingen sett ble oppgitt til collectRuleset!", "result.exit": "Avslutt eksamen", "scorm.error initialising": "Feil ved initiering av SCORM protokoll: {{message}}", "exam.pass percentage": "Grense for best\u00e5tt:", "math.permutations.complex": "Kan ikke beregne permutasjoner for komplekse tall", "scorm.error loading part": "Feil ved lasting av del {{part}}: {{message}}", "part.mcq.options def not a list": "The expression defining the {{properties}} is not a list.", "part.mcq.matrix mix of numbers and lists": "En blanding av tall og lister er brukt i score matrise.", "part.marking.variable replacement part not answered": "Du m\u00e5 svare p\u00e5 {{part}} f\u00f8rst", "part.marking.did not answer": "Du svarte ikke p\u00e5 dette sp\u00f8rsm\u00e5let.", "jme.shunt.missing operator": "Uttrykket kan ikke evalueres -- operator mangler.", "suspend.paused header": "Pause", "part.mcq.matrix wrong size": "Score matrise er av feil dimensjon.", "part.mcq.matrix jme error": "Part {{part}} marking matrix cell ({{row}},{{column}}) gives a JME error: {{error}}", "end.exam has finished": "Eksamen er avsluttet. Du kan n\u00e5 lukke vinduet.", "suspend.exam suspended": "Eksamen er avbrutt. Klikk Fortsett for \u00e5 g\u00e5 videre.", "jme.texsubvars.missing parameter": "Manglende parameter in {{op}}: {{parameter}}", "part.numberentry.precision type.sigfig_plural": "significant figures", "math.lt.order complex numbers": "Kan ikke sortere komplekse tall", "control.confirm reveal": "Vil du se svaret p\u00e5 dette sp\u00f8rsm\u00e5let? Alle poeng du har f\u00e5tt hittil vil bli l\u00e5st - og du kan ikke besvare dette sp\u00f8rsm\u00e5let senere.", "part.patternmatch.correct except case": "Svaret er riktig, unntatt i dette tilfellet.", "part.marking.not submitted": "Du svarte ikke", "jme.variables.error making function": "Feil med funksjonskode <code>{{name}}</code>: {{message}}", "exam.xml.bad root": "Elementet p\u00e5 \u00f8verste niv\u00e5 i XML m\u00e5 v\u00e6re 'exam'", "part.mcq.matrix not a number": "Del %s evaluering av matrisecelle {{row}},{{column}} gir ikke et tall", "question.score feedback.score total": "{{marksString}}. Besvart.", "question.show steps penalty": "Du vil miste <strong>{{count}}</strong> $t(mark).", "question.unsubmitted changes_plural": "Du har gjort endringer i dine svar, men ikke sendt de inn. Vennligst se over svarene og klikk <strong>Send inn alle delsvar</strong>.", "question.show steps no penalty": "Din score vil ikke bli p\u00e5virket.", "scorm.no part suspend data": "Ingen sesjonsdata for delen", "jme.typecheck.function not defined": "Operasjon {{op}} er ikke definert. Mente du <br/><code>{{suggestion}}*(...)</code>?", "part.marking.revealed steps with penalty": "Du valgte \u00e5 se svarforslag. Maksimal poengsum for denne oppgaven er <strong>{{count}}</strong> $t(mark). Din poengsum blir dermed redusert.", "question.unsubmitted changes": "Du har gjort endring i svaret, men ikke sendt det inn. Vennligst sjekk svaret og klikk <strong>Send inn svar</strong>.", "ruleset.circular reference": "Circular reference in definition of ruleset <code>{{name}}</code>", "math.combinations.n less than zero": "Kan ikke utregne kombinasjoner: n er mindre enn null", "part.marking.incorrect": "Svaret er feil.", "jme.variables.empty definition": "Definisjonen av variabel {{name}} er tom.", "question.preamble.syntax error": "Syntaks feil i startkoden", "util.equality not defined for type": "Equality not defined for type {{type}}", "ruleset.set not defined": "Ruleset {{name}} has not been defined", "result.question review title": "G\u00e5 igjennom dette sp\u00f8rsm\u00e5let", "jme.shunt.no right bracket": "H\u00f8yre parentes mangler", "die.sorry": "Beklager, det har oppst\u00e5tt en feil, og Numbas kan ikke fortsette. Nedenfor er en beskrivelse av feilen.", "control.end exam": "Avslutt eksamen", "vectormath.cross.not 3d": "Kan bare beregne kryssprodukt til 3-dimensjonale vektorer.", "part.mcq.matrix not a list": "Score matrise for flervalg oppgave definert som JME uttrykk er ikke en liste slik den skal v\u00e6re.", "part.marking.nothing entered": "Du svarte ikke.", "part.numberentry.give your answer as a reduced fraction": "Reduce your answer to lowest terms.", "mark_plural": "poeng", "question.hide steps no penalty": "Din score vil ikke bli p\u00e5virket.", "step": "steg", "part.numberentry.correct except decimal": "Svaret er i riktig intervall, men desimaltall er ikke tillatt.", "question.can not submit": "Kan ikke sende inn svar - sjekk mulige feil.", "math.choose.empty selection": "Slumpfunksjon har tomt tallomr\u00e5de", "part.jme.answer too long": "Svaret er for langt.", "mathjax.error": "MathJax processing error: {{message}}", "control.submit answer": "Send inn svar", "exam.failed": "Ikke best\u00e5tt", "part.jme.not-allowed one": "Svaret m\u00e5 ikke inneholde: {{strings}}", "jme.shunt.not enough arguments": "Det mangler argumenter for \u00e5 utf\u00f8re {{op}}", "question.answer submitted": "Svaret er sendt inn", "part.jme.must-have one": "Svaret m\u00e5 inneholde: {{strings}}", "part.correct answer": "Riktig svar:", "part.numberentry.answer not reduced": "Your answer is not reduced to lowest terms.", "control.next": "Neste", "part.mcq.marking matrix string empty": "The custom marking matrix expression is empty.", "matrixmath.abs.too big": "Kan ikke beregne determinanten til en matrise st\u00f8rre enn 3x3.", "jme.texsubvars.no right bracket": "Ingen samsvarende <code>]</code> i {{op}} argumenter.", "mathjax.math processing error": "\"{{message}}\" when texifying <code>{{expression}}</code>", "jme.matrix.reports bad size": "Matrix reports its size incorrectly - must be an error in constructor function", "part.marking.steps change": "Du oppn\u00e5dde <strong>{{count}}</strong> $t(mark) for delsvarene", "part.mcq.choices": "valg", "part.jme.answer invalid": "Svaret er ikke et gyldig matematisk uttrykk.<br/>{{message}}", "jme.shunt.list mixed argument types": "Can't parse {{mode}}: mix of dictionary and list elements", "jme.func.except.continuous range": "Kan ikke bruke operator 'except' p\u00e5 et kontinuerlig omr\u00e5de.", "exam.marks available": "Mulige poeng:", "math.combinations.k less than zero": "Kan ikke utregne kombinasjoner: k er mindre enn null", "result.question number": "Sp\u00f8rsm\u00e5l nummer", "control.submit all parts": "Send inn alle delsvar", "jme.func.listval.not a list": "Objektet kan ikke indekseres", "part.numberentry.give your answer to precision": "Round your answer to {{count,niceNumber}} {{precisionType}}.", "part.mcq.wrong number of choices": "Du merket av feil antall valg.", "jme.variables.syntax error in function definition": "Syntax feil i definisjonen av funksjon", "page.saving": "<p>Lagrer.</p> <p>Dette kan ta noen sekunder.</p>", "math.gcf.complex": "Kan ikke beregne GCF for komplekse tall", "part.matrix.some incorrect": "En eller flere av cellene i ditt svar er ikke riktig besvart, men du har f\u00e5tt poeng for resten", "math.combinations.complex": "Kan ikke beregne kombinasjoner for komplekse tall", "control.total": "Totalt", "jme.user javascript.error": "Feil i brukerdefinert javascript funksjon <code>{{name}}</code><br/>{{message}}", "part.matrix.invalid cell": "En eller flere av cellene i ditt svar er tomme eller ugyldige", "scorm.error loading question": "Feil ved lasting av sp\u00f8rsm\u00e5l {{number}}: {{message}}", "part.numberentry.give your answer to precision_0": "Avrund svaret ditt til n\u00e6rmeste heltall.", "jme.shunt.no right square bracket": "H\u00f8yre parentes mangler i slutten av liste", "control.not all questions answered": "Du har ikke svart p\u00e5 alle sp\u00f8rsm\u00e5lene i denne eksamen.", "jme.display.unknown token type": "Kan ikke lage tekstbilde av token type {{type}}", "part.numberentry.answer invalid": "Du svarte ikke med et gyldig tall.", "jme.user javascript.returned undefined": "Brukerdefinert javascript funksjon <code>{{name}}</code> returnerte <code>undefined</code>.", "question.hide steps": "Skjul tips", "part.mcq.matrix wrong type": "Element av ugyldig type '%s' er brukt i score matrise.", "math.combinations.n less than k": "Kan ikke utregne kombinasjoner: n er mindre enn k", "mark": "poeng", "suspend.you can resume": "Du kan fortsette eksamen neste gang du starter denne aktiviteten.", "scorm.error loading suspend data": "Feil ved lasting av sesjonsdata: {{message}}", "result.result": "Resultat:", "question.show steps": "Vis tips", "question.submit part": "Send inn svar", "part.jme.unexpected variable name": "Svaret ditt er tolket til \u00e5 bruke det uventede variabelnavnet <code>{{name}}</code>.", "part.matrix.empty cell": "En eller flere av cellene i ditt svar er tomme.", "control.regen": "Pr\u00f8v et lignende sp\u00f8rsm\u00e5l", "control.advice": "Svarforslag", "xml.could not load": "Kan ikke laste et XML dokument: {{message}}", "part.marking.uncaught error": "Error when marking {{part}}: {{message}}", "question.score feedback.score total actual": "Poengsum: {{score}}/{{marks}}", "result.print": "Skriv ut denne oversikten", "math.siground.complex": "Kan ikke avrunde til antall signifikante siffer gitt som komplekst tall", "question.header": "Sp\u00f8rsm\u00e5l {{number}}", "math.permutations.k less than zero": "Kan ikke utregne permutasjonene: k er mindre enn null", "question.preamble.error": "Feil i startkoden: {{message}}", "suspend.resume": "Fortsett", "part.mcq.correct choice": "Du valgte riktig svar.", "part.numberentry.answer not integer": "Ditt svar er ikke gyldig. Tast inn et heltall, ikke desimaltall.", "part.jme.not-allowed several": "Svaret m\u00e5 ikke inneholde disse: {{strings}}", "part.numberentry.precision type.dp_plural": "decimal places", "question.unsupported part type": "Ikke gyldig svartype", "jme.variables.error evaluating variable": "Feil ved evaluering av variabel {{name}}: {{message}}", "jme.func.listval.key not in dict": "Dictionary does not contain the key <code>{{key}}</code>", "part.mcq.answers": "svar", "jme.typecheck.map not on enumerable": "<code>map</code> operasjonen m\u00e5 gjelde en liste eller range, ikke {{type}}", "jme.substituteTree.undefined variable": "Udefinert variabel: <code>{{name}}</code>", "modal.cancel": "Avbryt", "scorm.failed save": "<p>Skriving av data til serveren feilet. Klikk <b>OK</b> og pr\u00f8v en gang til.</p>\n<p>Hvis denne feilen gjentar seg ofte b\u00f8r du sjekke forbindelsen til internet eller pr\u00f8ve en annen datamaskin. Dine tidligere innsendte svar er lagret og blir gjentatt hvis du fortsette \u00f8kten p\u00e5 en annen datamaskin.</p>\n<p> Hvis denne gjentar seg ofte og du kan ikke lagre <em>noen</em> svar b\u00f8r du ta kontakt med din l\u00e6rer.</p>", "jme.typecheck.function maybe implicit multiplication": "Operasjon {{name}} er ikke definert. Mente du <br/><code>{{first}}*{{possibleOp}}(...)</code>?", "part.jme.answer too short": "Svaret er for kort.", "matrixmath.mul.different sizes": "Kan ikke multiplisere matriser med ulike dimensjoner.", "jme.func.switch.no default case": "Switch-setning mangler standardverdi", "part.numberentry.zero sig fig": "This part is set up to round the student's answer to zero significant figures, which has no meaning.", "frontpage.start": "Start", "result.question score": "Poengsum", "part.mcq.choices missing": "Svarmuligheter mangler i flervalgstesten (%s)", "question.score feedback.correct": "Ditt svar er riktig", "part.feedback": "tilbakemelding", "question.score feedback.answered": "Besvart.", "math.permutations.n less than k": "Kan ikke utregne permutasjonene: n er mindre enn k", "part.gapfill.feedback header": "<strong>Boks {{index}}</strong>", "question.advice": "Svarforslag", "vectormath.cross.matrix too big": "Kan ikke beregne kryssproduktet til en matrise som ikke er $1 \\times N$ eller $N \\times 1$.", "part.jme.not-allowed bits": "<span class=\"monospace\">{{string}}</span>", "display.part.jme.error making maths": "Feil i visning av matematisk uttrykk", "part.prompt": "prompt", "control.proceed anyway": "Fortsett likevel?", "gap": "mellomrom", "jme.tokenise.invalid": "Ugyldig uttrykk: <code>{{expression}}</code>", "result.score": "Poengsum:", "math.lcm.complex": "Kan ikke beregne LCM for komplekse tall", "exam.random seed": "Sesjon ID:", "modal.ok": "OK", "was": "var", "jme.thtml.not html": "Passed a non-HTML value into the THTML constructor.", "question.score feedback.partial": "Ditt svar er delvis riktig", "mathjax.error with context": "MathJax processing error in {{context}}: {{message}}", "question.score feedback.wrong": "Ditt svar er feil", "question.score feedback.score actual": "Poengsum: {{scoreString}}", "part.numberentry.correct except fraction": "Ditt svar er innenfor riktig omr\u00e5de, men br\u00f8k er ikke tillatt som svar.", "question.error": "Sp\u00f8rsm\u00e5l {{number}}: {{message}}", "jme.evaluate.no scope given": "Numbas.jme.evaluate must be given a Scope", "question.show steps already penalised": "Du har allerede vist tips. Du kan se tips p\u00e5 nytt uten \u00e5 tape poeng.", "part.jme.answer missing": "Korrekt svar for et JME felt mangler (%s)", "part.mcq.no choices selected": "Ingen av valgene er merket.", "die.script not loaded": "Numbas couldn't start because the file <code>{{file}}</code> was not loaded. Check that it's included in <code>scripts.js</code>.", "part.numberentry.precision type.dp": "decimal place", "part.matrix.answer invalid": "Svaret ditt er ugyldig.", "jme.variables.question took too many runs to generate variables": "Et gyldig sett med variabler i sp\u00f8rsm\u00e5l ble ikke generert p\u00e5 normal tid", "jme.texsubvars.no right brace": "Ingen samsvarende <code>}</code> i {{op}}.", "page.loading": "Laster...", "part.jme.marking.correct": "Svaret er numerisk korrekt.", "part.marking.correct": "Svaret er riktig.", "part.matrix.size mismatch": "The question author hasn't allowed the student to decide the dimensions of their answer, but the correct answer is {{correct_dimensions}} while the answer input is {{input_dimensions}}", "exam.feedback": "Exam feedback message", "part.marking.used variable replacements": "This part was marked using your answers to previous parts.", "control.submit": "Send inn", "jme.shunt.no left square bracket": "Venstre parentes mangler", "jme.func.listval.invalid index": "Ugyldig listeindeks {{index}} for en liste med st\u00f8rrelse {{size}}", "question.score feedback.hide": "Skjul vurdering", "jme.variables.circular reference": "Sirkul\u00e6r referanse til variabel <code>{{name}}</code>", "result.time spent": "Tidsbruk:", "die.error": "Feil", "timing.time remaining": "Tid igjen: %s", "part.numberentry.negative decimal places": "This part is set up to round the student's answer to a negative number of decimal places, which has no meaning.", "part.with steps answer prompt": "Svar: ", "control.confirm leave": "Du har ikke levert besvarelse.", "jme.typecheck.op not defined": "Operasjon '{{op}}' er ikke definert.", "part": "del", "control.submit again": "Send inn p\u00e5 nytt", "xml.error in variable definition": "Feil ved definisjon av variabel <code>{{name}}</code>", "exam.changeQuestion.no questions": "Eksamen inneholder ingen sp\u00f8rsm\u00e5l! Sjekk .exam-fila for feil.", "part.jme.must-have bits": "<span class=\"monospace\">{{string}}</span>", "part.marking.total score": "Du fikk <strong>{{count}}</strong> $t(mark) for denne oppgaven.", "exam.introduction": "Exam introduction", "control.confirm regen": "Vil du lage nye tilfeldige tall i denne oppgaven? Hvis du klikker OK vil svarene og oppn\u00e5dde poeng bli annullert.", "jme.evaluate.undefined variable": "Variabel {{name}} er udefinert", "jme.display.simplifyTree.no scope given": "Numbas.jme.display.simplifyTree m\u00e5 f\u00e5 angitt et Scope", "timing.no accumulator": "no timing accumulator {{name}}", "util.product.non list": "Passed a non-list to <code>Numbas.util.product</code>", "part.marking.revealed steps no penalty": "Du valgte \u00e5 se svarforslag.", "part.jme.unexpected variable name suggestion": "Svaret ditt er tolket til \u00e5 bruke det uventede variabelnavnet <code>{{name}}</code>. Mente du <code>{{suggestion}}</code>?", "jme.display.collectRuleset.set not defined": "Regelsett {{name}} er ikke definert", "was_plural": "var", "part.marking.no result": "Denne delen kunne ikke merkes.", "part.setting not present": "Egenskap '{{property}}' er ikke angitt", "exam.number of questions": "Antall sp\u00f8rsm\u00e5l:", "part.numberentry.answer not integer or decimal": "Ditt svar er ikke gyldig. Tast inn et heltall eller et desimaltall.", "question.selector.unsubmitted changes": "Endringer som ikke er sendt inn.", "vectormath.dot.matrix too big": "Kan ikke beregne prikkproduktet til en matrise som ikke er $1 \\times N$ eller $N \\times 1$.", "scorm.no exam suspend data": "Kan ikke fortsette: finner ikke sesjonsdata.", "math.permutations.n less than zero": "Kan ikke utregne permutasjonene: n er mindre enn null", "part.matrix.empty": "Du har ikke gitt noe svar.", "part.jme.must-have several": "Svaret m\u00e5 inneholde alle: {{strings}}", "part.patternmatch.display answer missing": "Display answer is missing from a Pattern Match part (%s)", "math.precround.complex": "Kan ikke avrunde til antall desimaler gitt som komplekst tall", "jme.func.matrix.invalid row type": "Kan ikke danne matrise ut fra rader av type {{type}}", "jme.tokenise.keypair key not a string": "Dictionary key should be a string, not {{type}}.", "jme.shunt.no left bracket": "Venstre parentes mangler", "result.exam summary": "Eksamen oversikt", "jme.typecheck.no right type definition": "Finner ikke definisjon av '{{op}}' med korrekt type.", "exam.time allowed": "Tillatt tid:", "question.statement": "Statement", "xml.property not number": "Egenskap {{name}} m\u00e5 v\u00e6re et tall, men er ikke ({{value}}), i node {{element}}", "exam.exam name": "Eksamen navn:", "control.previous": "Forrige"}}, "ko-kr": {"translation": {"jme.typecheck.no right type unbound name": "Variable <code>{{name}}</code> is not defined.", "control.pause": "Pause", "feedback.taken away": "<strong>{{count,niceNumber}}</strong> $t(mark) $t(was) taken away.", "question.score feedback.unanswered": "Unanswered.", "control.reveal": "Reveal answers", "part.marking.steps no matter": "Because you received full marks for the part, your answers to the steps aren't counted.", "part.marking.resubmit because of variable replacement": "This part's marking depends on your answers to other parts, which you have changed. Submit this part again to update your score.", "question.no such part": "Can't find part {{path}}", "control.back to results": "Go back to results", "part.unknown type": "{{part}}: Unrecognised part type {{type}}", "result.click a question to review": "Click on a question number to see how your answers were marked and, where available, full solutions.", "part.missing type attribute": "{{part}}: Missing part type attribute", "matrixmath.abs.non-square": "Can't compute the determinant of a matrix which isn't square.", "result.performance summary": "Performance Summary", "die.numbas failed": "Numbas has failed", "jme.shunt.no left bracket in function": "No matching left bracket in function application or tuple", "part.mcq.matrix cell empty": "Part {{part}} marking matrix cell ({{row}},{{column}}) is empty", "question.score feedback.show": "Show feedback", "part.script.error": "Error in part {{path}} custom script {{script}}: {{message}}", "part.numberentry.precision type.sigfig": "significant figure", "jme.variables.error computing dependency": "Error computing referenced variable <code>{{name}}</code>", "exam.passed": "\ud569\uaca9", "result.questions attempted": "Questions Attempted:", "control.not all questions submitted": "You have made changes to one or more answers but not submitted them. Please check each question has been submitted.", "exam.student name": "\ud559\uc0dd \uc774\ub984:", "scorm.no question suspend data": "No question suspend data", "result.exam start": "Exam Start:", "part.extension.not implemented": "Part hasn't implemented the <code>{{name}}</code> method.", "xml.property not boolean": "Property {{name}} should be a boolean, but isn't ({{value}}), in node {{element}}", "feedback.you were awarded": "You were awarded <strong>{{count,niceNumber}}</strong> $t(mark).", "jme.variables.variable not defined": "Variable <code>{{name}}</code> is not defined.", "question.loaded name mismatch": "Can't resume this attempt - the package has changed since the last session.", "control.confirm end": "Are you sure you want to end the exam? After you end the exam, you will not be able to change any of your answers.", "result.exam stop": "Exam Stop:", "exam.review header": "Review: ", "jme.display.collectRuleset.no sets": "No sets given to collectRuleset!", "result.exit": "\uc2dc\ud5d8 \uc885\ub8cc", "scorm.error initialising": "Error initialising SCORM protocol: {{message}}", "exam.pass percentage": "\ud569\uaca9 \ud37c\uc13c\ud2b8:", "math.permutations.complex": "Can't compute permutations of complex numbers", "scorm.error loading part": "Error loading part {{part}}: {{message}}", "part.mcq.options def not a list": "The expression defining the {{properties}} is not a list.", "part.mcq.matrix mix of numbers and lists": "Mix of numbers and lists used in marking matrix.", "part.marking.variable replacement part not answered": "You must answer {{part}} first", "part.marking.did not answer": "You did not answer this question.", "jme.shunt.missing operator": "Expression can't be evaluated -- missing an operator.", "suspend.paused header": "\uc77c\uc2dc\uc815\uc9c0", "part.mcq.matrix wrong size": "Marking matrix is the wrong size.", "part.mcq.matrix jme error": "Part {{part}} marking matrix cell ({{row}},{{column}}) gives a JME error: {{error}}", "end.exam has finished": "The exam has finished. You may now close this window.", "suspend.exam suspended": "\uc2dc\ud5d8\uc774 \uc77c\uc2dc\uc815\uc9c0\ub418\uc5c8\uc2b5\ub2c8\ub2e4. <em>\uacc4\uc18d\ud558\uae30</em>\ub97c \ub20c\ub7ec \uacc4\uc18d\ud558\uc2ed\uc2dc\uc624.", "jme.texsubvars.missing parameter": "Missing parameter in {{op}}: {{parameter}}", "part.numberentry.precision type.sigfig_plural": "significant figures", "math.lt.order complex numbers": "Can't order complex numbers", "control.confirm reveal": "Would you like to reveal the answer to this question? Any marks you have received so far will be locked and you will not be able to answer this question later.", "part.patternmatch.correct except case": "Your answer is correct, except for the case.", "part.marking.not submitted": "No answer submitted", "jme.variables.error making function": "Error making function <code>{{name}}</code>: {{message}}", "exam.xml.bad root": "Root element of exam XML should be 'exam'", "part.mcq.matrix not a number": "Part {{part}} marking matrix cell ({{row}},{{column}}) does not evaluate to a number", "question.score feedback.score total": "{{marksString}}. Answered.", "question.show steps penalty": "You will lose <strong>{{count,niceNumber}}</strong> $t(mark).", "question.unsubmitted changes_plural": "You have made changes to your answers but not submitted them. Please check your answers to each part and then press the <strong>Submit all parts</strong> button.", "question.show steps no penalty": "Your score will not be affected.", "scorm.no part suspend data": "No part suspend data", "jme.typecheck.function not defined": "Operation <code>{{op}}</code> is not defined. Is <code>{{op}}</code> a variable, and did you mean <code>{{suggestion}}*(...)</code>?", "part.marking.revealed steps with penalty": "You revealed the steps. The maximum you can score for this part is <strong>{{count,niceNumber}}</strong> $t(mark). Your scores will be scaled down accordingly.", "question.unsubmitted changes": "You have made a change to your answer but not submitted it. Please check your answer and then press the <strong>Submit answer</strong> button.", "ruleset.circular reference": "Circular reference in definition of ruleset <code>{{name}}</code>", "math.combinations.n less than zero": "Can't compute combinations: n is less than zero", "part.marking.incorrect": "Your answer is incorrect.", "jme.variables.empty definition": "Definition of variable <code>{{name}}</code> is empty.", "question.preamble.syntax error": "Syntax error in preamble", "util.equality not defined for type": "Equality not defined for type {{type}}", "ruleset.set not defined": "Ruleset {{name}} has not been defined", "result.question review title": "Review this question", "jme.shunt.no right bracket": "No matching right bracket", "die.sorry": "Sorry, Numbas has encountered an error which means it can't continue. Below is a description of the error.", "control.end exam": "End Exam", "vectormath.cross.not 3d": "Can only take the cross product of 3-dimensional vectors.", "part.mcq.matrix not a list": "Marking matrix, defined by JME expression, is not a list but it should be.", "part.marking.nothing entered": "You did not enter an answer.", "part.numberentry.give your answer as a reduced fraction": "Reduce your answer to lowest terms.", "mark_plural": "marks", "question.hide steps no penalty": "Your score will not be affected.", "step": "step", "part.numberentry.correct except decimal": "Your answer is within the allowed range, but decimal numbers are not allowed.", "question.can not submit": "Can not submit answer - check for errors.", "math.choose.empty selection": "Empty selection given to random function", "part.jme.answer too long": "Your answer is too long.", "mathjax.error": "MathJax processing error: {{message}}", "control.submit answer": "Submit answer", "exam.failed": "\ubd88\ud569\uaca9", "part.jme.not-allowed one": "Your answer must not contain: {{strings}}", "jme.shunt.not enough arguments": "Not enough arguments for operation {{op}}", "question.answer submitted": "Answer submitted", "part.jme.must-have one": "Your answer must contain: {{strings}}", "part.correct answer": "Expected answer:", "part.numberentry.answer not reduced": "Your answer is not reduced to lowest terms.", "control.next": "Next", "part.mcq.marking matrix string empty": "The custom marking matrix expression is empty.", "matrixmath.abs.too big": "Sorry, can't compute the determinant of a matrix bigger than 3x3 yet.", "question.score feedback.ascore total actual": "Score: {{score,niceNumber}}/{{marks,niceNumber}}", "jme.texsubvars.no right bracket": "No matching <code>]</code> in {{op}} arguments.", "mathjax.math processing error": "\"{{message}}\" when texifying <code>{{expression}}</code>", "jme.matrix.reports bad size": "Matrix reports its size incorrectly - must be an error in constructor function", "part.marking.steps change": "You were awarded <strong>{{count,niceNumber}}</strong> $t(mark) for your answers to the steps.", "part.mcq.choices": "choices", "part.jme.answer invalid": "Your answer is not a valid mathematical expression.<br/>{{message}}.", "jme.shunt.list mixed argument types": "Can't parse {{mode}}: mix of dictionary and list elements", "jme.func.except.continuous range": "Can't use the 'except' operator on continuous ranges.", "exam.marks available": "Marks Available:", "math.combinations.k less than zero": "Can't compute combinations: k is less than zero", "result.question number": "\ubb38\uc81c \ubc88\ud638", "control.submit all parts": "Submit all parts", "jme.func.listval.not a list": "Object is not subscriptable", "part.numberentry.give your answer to precision": "Round your answer to {{count,niceNumber}} {{precisionType}}.", "part.mcq.wrong number of choices": "You selected the wrong number of choices.", "jme.variables.syntax error in function definition": "Syntax error in function definition", "page.saving": "<p>\uc800\uc7a5 \uc911.</p>\n<p>\uc7a0\uc2dc\ub9cc \uae30\ub2e4\ub824 \uc8fc\uc2ed\uc2dc\uc624.</p>", "math.gcf.complex": "Can't compute GCF of complex numbers", "part.matrix.some incorrect": "One or more of the cells in your answer is incorrect, but you have been awarded marks for the rest.", "math.combinations.complex": "Can't compute combinations of complex numbers", "control.total": "Total", "jme.user javascript.error": "Error in user-defined javascript function <code>{{name}}</code>: {{message}}", "part.matrix.invalid cell": "One or more of the cells in your answer is empty or invalid.", "scorm.error loading question": "Error loading question {{number}}: {{message}}", "part.numberentry.give your answer to precision_0": "Round your answer to the nearest integer.", "jme.shunt.no right square bracket": "No matching right square bracket to end list", "control.not all questions answered": "You have not completed every question in this exam.", "jme.display.unknown token type": "Can't texify token type {{type}}", "part.numberentry.answer invalid": "You did not enter a valid number.", "jme.user javascript.returned undefined": "User-defined javascript function <code>{{name}}</code> returned <code>undefined</code>.", "question.hide steps": "Hide steps", "part.mcq.matrix wrong type": "Element of invalid type '{{type}}' used in marking matrix.", "math.combinations.n less than k": "Can't compute combinations: n is less than k", "mark": "mark", "suspend.you can resume": "You will be able to resume this session the next time you start this activity.", "scorm.error loading suspend data": "Error loading suspend data: {{message}}", "result.result": "\uacb0\uacfc:", "question.show steps": "Show steps", "question.submit part": "Submit part", "part.jme.unexpected variable name": "Your answer was interpreted to use the unexpected variable name <code>{{name}}</code>.", "part.matrix.empty cell": "One or more of the cells in your answer is empty.", "control.regen": "Try another question like this one", "control.advice": "Advice", "xml.could not load": "Couldn't load an XML document: {{message}}", "part.marking.uncaught error": "Error when marking {{part}}: {{message}}", "result.print": "Print this results summary", "math.siground.complex": "Can't round to a complex number of sig figs", "question.header": "Question {{number}}", "math.permutations.k less than zero": "Can't compute permutations: k is less than zero", "question.preamble.error": "Error in preamble: {{message}}", "suspend.resume": "\uc7ac\uac1c", "part.mcq.correct choice": "You chose the correct answer.", "part.numberentry.answer not integer": "Your answer is invalid. You must enter a whole number, not a decimal.", "part.jme.not-allowed several": "Your answer must not contain any of: {{strings}}", "part.numberentry.precision type.dp_plural": "decimal places", "question.unsupported part type": "Unsupported part type", "jme.variables.error evaluating variable": "Error evaluating variable {{name}}: {{message}}", "jme.func.listval.key not in dict": "Dictionary does not contain the key <code>{{key}}</code>", "part.mcq.answers": "answers", "jme.typecheck.map not on enumerable": "<code>map</code> operation must work over a list or a range, not {{type}}", "jme.substituteTree.undefined variable": "Undefined variable: <code>{{name}}</code>", "modal.cancel": "\ucde8\uc18c", "scorm.failed save": "<p>The request to save data to the server failed. Press <b>OK</b> to try again.</p>\n<p>If you get this message repeatedly, check your internet connection or use a different computer. Your previously submitted answers have been successfully saved and will be restored if you resume this session on a different computer.</p>\n<p>If this message appears persistently and you can't save <em>any</em> answers, please contact your lecturer or teacher.</p>", "jme.typecheck.function maybe implicit multiplication": "Operation {{name}} is not defined. Did you mean <br/><code>{{first}}*{{possibleOp}}(...)</code>?", "part.jme.answer too short": "Your answer is too short.", "matrixmath.mul.different sizes": "Can't multiply matrices of different sizes.", "jme.func.switch.no default case": "No default case for Switch statement", "part.numberentry.zero sig fig": "This part is set up to round the student's answer to zero significant figures, which has no meaning.", "frontpage.start": "\uc2dc\uc791", "result.question score": "\uc810\uc218", "part.mcq.choices missing": "Definition of choices is missing", "question.score feedback.correct": "Your answer is correct", "part.feedback": "feedback", "question.score feedback.answered": "Answered.", "math.permutations.n less than k": "Can't compute permutations: n is less than k", "part.gapfill.feedback header": "<strong>Gap {{index}}</strong>", "question.advice": "Advice", "vectormath.cross.matrix too big": "Can't calculate cross product of a matrix which isn't $1 \\times N$ or $N \\times 1$.", "part.jme.not-allowed bits": "<span class=\"monospace\">{{string}}</span>", "display.part.jme.error making maths": "Error making maths display", "part.prompt": "prompt", "control.proceed anyway": "Proceed anyway?", "gap": "gap", "jme.tokenise.invalid": "Invalid expression: <code>{{expression}}</code>", "result.score": "\uc810\uc218:", "math.lcm.complex": "Can't compute LCM of complex numbers", "exam.random seed": "Session ID:", "modal.ok": "\ud655\uc778", "was": "was", "jme.thtml.not html": "Passed a non-HTML value into the THTML constructor.", "question.score feedback.partial": "Your answer is partially correct", "mathjax.error with context": "MathJax processing error in {{context}}: {{message}}", "question.score feedback.wrong": "Your answer is incorrect", "question.score feedback.score actual": "Score: {{scoreString}}", "part.numberentry.correct except fraction": "Your answer is within the allowed range, but fractions are not allowed.", "question.error": "Question {{number}}: {{message}}", "jme.evaluate.no scope given": "Numbas.jme.evaluate must be given a Scope", "question.show steps already penalised": "You have already shown steps. You can show them again with no further penalty.", "part.jme.answer missing": "Correct answer is missing", "part.mcq.no choices selected": "No choices selected.", "die.script not loaded": "Numbas couldn't start because the file <code>{{file}}</code> was not loaded. Check that it's included in <code>scripts.js</code>.", "part.numberentry.precision type.dp": "decimal place", "part.matrix.answer invalid": "Your answer is not valid.", "jme.variables.question took too many runs to generate variables": "A valid set of question variables was not generated in time.", "jme.texsubvars.no right brace": "No matching <code>}</code> in {{op}}", "page.loading": "\ubd88\ub7ec\uc624\ub294 \uc911...", "part.jme.marking.correct": "Your answer is numerically correct.", "part.marking.correct": "Your answer is correct.", "part.matrix.size mismatch": "The question author hasn't allowed the student to decide the dimensions of their answer, but the correct answer is {{correct_dimensions}} while the answer input is {{input_dimensions}}", "exam.feedback": "Exam feedback message", "part.marking.used variable replacements": "This part was marked using your answers to previous parts.", "control.submit": "Submit", "jme.shunt.no left square bracket": "No matching left bracket", "jme.func.listval.invalid index": "Invalid list index {{index}} on list of size {{size}}", "question.score feedback.hide": "Hide feedback", "jme.variables.circular reference": "Circular variable reference in definition of <code>{{name}}</code>", "result.time spent": "Time Spent:", "die.error": "\uc624\ub958", "timing.time remaining": "Time remaining:", "part.numberentry.negative decimal places": "This part is set up to round the student's answer to a negative number of decimal places, which has no meaning.", "part.with steps answer prompt": "Answer: ", "control.confirm leave": "You haven't finished the exam.", "jme.typecheck.op not defined": "Operation '{{op}}' is not defined.", "part": "part", "control.submit again": "Submit again", "xml.error in variable definition": "Error in definition of variable <code>{{name}}</code>", "exam.changeQuestion.no questions": "This exam contains no questions! Check the .exam file for errors.", "part.jme.must-have bits": "<span class=\"monospace\">{{string}}</span>", "part.marking.total score": "You scored <strong>{{count,niceNumber}}</strong> $t(mark) for this part.", "exam.introduction": "Exam introduction", "control.confirm regen": "Would you like to re-randomise this question? If you click OK, all your answers and marks for the current question will be lost.", "jme.evaluate.undefined variable": "Variable {{name}} is undefined", "jme.display.simplifyTree.no scope given": "Numbas.jme.display.simplifyTree must be given a Scope", "timing.no accumulator": "no timing accumulator {{name}}", "util.product.non list": "Passed a non-list to <code>Numbas.util.product</code>", "part.marking.revealed steps no penalty": "You revealed the steps.", "part.jme.unexpected variable name suggestion": "Your answer was interpreted to use the unexpected variable name <code>{{name}}</code>. Did you mean <code>{{suggestion}}</code>?", "jme.display.collectRuleset.set not defined": "Ruleset {{name}} has not been defined", "was_plural": "were", "part.marking.no result": "This part could not be marked.", "part.setting not present": "Property '{{property}}' not set", "exam.number of questions": "\uc9c8\ubb38\uc758 \uc218:", "part.numberentry.answer not integer or decimal": "Your answer is invalid. You must enter an integer or a decimal.", "question.selector.unsubmitted changes": "Unsubmitted changes.", "vectormath.dot.matrix too big": "Can't calculate dot product of a matrix which isn't $1 \\times N$ or $N \\times 1$.", "scorm.no exam suspend data": "Failed to resume: no exam suspend data.", "math.permutations.n less than zero": "Can't compute permutations: n is less than zero", "part.matrix.empty": "You have not entered an answer.", "part.jme.must-have several": "Your answer must contain all of: {{strings}}", "part.patternmatch.display answer missing": "Display answer is missing", "math.precround.complex": "Can't round to a complex number of decimal places", "jme.func.matrix.invalid row type": "Can't construct a matrix from rows of type {{type}}", "jme.tokenise.keypair key not a string": "Dictionary key should be a string, not {{type}}.", "jme.shunt.no left bracket": "No matching left bracket", "result.exam summary": "Exam Summary", "jme.typecheck.no right type definition": "No definition of '{{op}}' of correct type found.", "exam.time allowed": "Time Allowed:", "question.statement": "Statement", "xml.property not number": "Property {{name}} should be a number, but isn't ({{value}}), in node {{element}}", "exam.exam name": "\uc2dc\ud5d8 \uc774\ub984:", "control.previous": "Previous"}}, "en-school": {"translation": {"jme.typecheck.no right type unbound name": "Variable <code>{{name}}</code> is not defined.", "control.pause": "Pause", "feedback.taken away": "<strong>{{count,niceNumber}}</strong> $t(mark) $t(was) taken away.", "question.score feedback.unanswered": "Unanswered.", "control.reveal": "Reveal answers", "part.marking.steps no matter": "Because you received full marks for the part, your answers to the steps aren't counted.", "part.marking.resubmit because of variable replacement": "This part's marking depends on your answers to other parts, which you have changed. Submit this part again to update your score.", "question.no such part": "Can't find part {{path}}", "control.back to results": "Go back to results", "result.click a question to review": "Click on a question number to see how your answers were marked.", "part.missing type attribute": "{{part}}: Missing part type attribute", "matrixmath.abs.non-square": "Can't compute the determinant of a matrix which isn't square.", "result.performance summary": "Performance Summary", "die.numbas failed": "Numbas has failed", "jme.shunt.no left bracket in function": "No matching left bracket in function application or tuple", "part.mcq.matrix cell empty": "Part {{part}} marking matrix cell ({{row}},{{column}}) is empty", "part.numberentry.give your answer to precision_0": "Round your answer to the nearest integer.", "part.script.error": "Error in part {{path}} custom script {{script}}: {{message}}", "part.numberentry.precision type.sigfig": "significant figure", "jme.variables.error computing dependency": "Error computing referenced variable <code>{{name}}</code>", "exam.passed": "Passed", "result.questions attempted": "Questions Attempted:", "control.not all questions submitted": "You have changed one of your answers but not submitted it. Please check each question has been submitted.", "exam.student name": "Student's Name:", "scorm.no question suspend data": "No question suspend data", "part.marking.variable replacement part not answered": "You must answer {{part}} first", "part.extension.not implemented": "Part hasn't implemented the <code>{{name}}</code> method.", "xml.property not boolean": "Property {{name}} should be a boolean, but isn't ({{value}}), in node {{element}}", "feedback.you were awarded": "You were awarded <strong>{{count,niceNumber}}</strong> $t(mark).", "jme.variables.variable not defined": "Variable <code>{{name}}</code> is not defined.", "question.loaded name mismatch": "Can't resume this attempt - the package has changed since the last session.", "control.confirm end": "Are you sure you want to end the test?<br>After you end the test, you will not be able to change any of your answers.", "result.exam stop": "Test Stop:", "exam.review header": "Review: ", "jme.display.collectRuleset.no sets": "No sets given to collectRuleset!", "result.exit": "Exit Test", "scorm.error initialising": "Error initialising SCORM protocol: {{message}}", "exam.pass percentage": "Pass Percentage:", "math.permutations.complex": "Can't compute permutations of complex numbers", "scorm.error loading part": "Error loading part {{part}}: {{message}}", "part.mcq.options def not a list": "The expression defining the {{properties}} is not a list.", "part.mcq.matrix mix of numbers and lists": "Mix of numbers and lists used in marking matrix.", "result.exam start": "Test Start:", "part.marking.did not answer": "You did not answer this question.", "jme.shunt.missing operator": "Expression can't be evaluated -- missing an operator.", "suspend.paused header": "Paused", "part.mcq.matrix wrong size": "Marking matrix is the wrong size.", "question.score feedback.show": "Show feedback", "part.mcq.matrix jme error": "Part {{part}} marking matrix cell ({{row}},{{column}}) gives a JME error, {{error}}", "end.exam has finished": "The test has finished. You can close this window now.", "suspend.exam suspended": "The test is paused. Press <em>Resume</em> to continue.", "part.mcq.no choices selected": "No choices selected.", "jme.texsubvars.missing parameter": "Missing parameter in {{op}}: {{parameter}}", "part.numberentry.precision type.sigfig_plural": "significant figures", "control.confirm reveal": "Would you like to reveal the answer to this question?<br>Any marks you have received so far will be locked and you will not be able to answer this question later.", "part.patternmatch.correct except case": "Your answer is correct, except for the case.", "part.marking.not submitted": "No answer submitted", "jme.variables.error making function": "Error making function <code>{{name}}</code>: {{message}}", "exam.xml.bad root": "Root element of exam XML should be 'exam'", "part.mcq.matrix not a number": "Part {{part}} marking matrix cell ({{row}},{{column}}) does not evaluate to a number", "question.score feedback.score total": "{{marksString}}. Answered.", "question.show steps penalty": "You will lose <strong>{{count,niceNumber}}</strong> $t(mark).", "question.unsubmitted changes_plural": "You have made changes to your answers but not submitted them. Please check your answers to each part and then press the <strong>Submit all parts</strong> button.", "question.show steps no penalty": "Your score will not be affected.", "scorm.no part suspend data": "No part suspend data", "jme.typecheck.function not defined": "Operation {{op}} is not defined. Did you mean <br/><code>{{suggestion}}*(...)</code>?", "part.marking.revealed steps with penalty": "You revealed the steps. The maximum you can score for this part is <strong>{{count,niceNumber}}</strong> $t(mark). Your scores will be scaled down accordingly.", "question.unsubmitted changes": "You have made a change to your answer but not submitted it. Please check your answer and then press the <strong>Submit answer</strong> button.", "part.marking.incorrect": "Your answer is incorrect.", "jme.variables.empty definition": "Definition of variable <code>{{name}}</code> is empty.", "question.preamble.syntax error": "Syntax error in preamble", "util.equality not defined for type": "Equality not defined for type {{type}}", "result.question review title": "Look at this question again", "jme.shunt.no right bracket": "No matching right bracket", "die.sorry": "Sorry, Numbas has encountered an error which means it can't continue. Below is a description of the error.", "control.end exam": "End Test", "vectormath.cross.not 3d": "Can only take the cross product of 3-dimensional vectors.", "part.mcq.matrix not a list": "Marking matrix, defined by JME expression, is not a list but it should be.", "part.marking.nothing entered": "You did not enter an answer.", "mark_plural": "marks", "question.hide steps no penalty": "Your score will not be affected.", "step": "step", "part.correct answer": "Expected answer:", "part.numberentry.correct except decimal": "Your answer is within the allowed range, but decimal numbers are not allowed.", "question.can not submit": "Can not submit answer - check for errors.", "math.choose.empty selection": "Empty selection given to random function", "part.jme.answer too long": "Your answer is too long.", "part.jme.unexpected variable name": "Your answer was interpreted to use the unexpected variable name <code>{{name}}</code>.", "exam.failed": "Failed", "part.jme.not-allowed one": "Your answer must not contain: {{strings}}", "was_plural": "were", "jme.shunt.not enough arguments": "Not enough arguments for operation {{op}}", "question.answer submitted": "Answer submitted", "part.jme.must-have one": "Your answer must contain: {{strings}}", "math.combinations.n less than zero": "Can't compute combinations: n is less than zero", "control.next": "Next", "part.mcq.marking matrix string empty": "The custom marking matrix expression is empty.", "matrixmath.abs.too big": "Sorry, can't compute the determinant of a matrix bigger than 3x3 yet.", "jme.texsubvars.no right bracket": "No matching <code>]</code> in {{op}} arguments.", "mathjax.math processing error": "MathJax processing error: \"{{message}}\" when texifying <code>{{expression}}</code>", "part.numberentry.precision type.dp_plural": "decimal places", "part.marking.steps change": "You were awarded <strong>{{count,niceNumber}}</strong> $t(mark) for your answers to the steps", "part.jme.answer invalid": "Your answer is not a valid mathematical expression.<br/>{{message}}.", "jme.func.except.continuous range": "Can't use the 'except' operator on continuous ranges.", "exam.marks available": "Marks Available:", "math.combinations.k less than zero": "Can't compute combinations: k is less than zero", "control.submit all parts": "Check every part", "jme.func.listval.not a list": "Object is not subscriptable", "part.numberentry.give your answer to precision": "Round your answer to {{count,niceNumber}} {{precisionType}}.", "part.mcq.wrong number of choices": "You selected the wrong number of choices.", "jme.variables.syntax error in function definition": "Syntax error in function definition", "page.saving": "<p>Saving.</p>\n<p>This might take a few seconds.</p>", "math.gcf.complex": "Can't compute GCF of complex numbers", "part.unknown type": "{{part}}: Unrecognised part type {{type}}", "math.combinations.complex": "Can't compute combinations of complex numbers", "control.total": "Total score", "jme.user javascript.error": "Error in user-defined javascript function <code>{{name}}</code>: {{message}}", "part.matrix.invalid cell": "One or more of the cells in your answer is empty or invalid.", "scorm.error loading question": "Error loading question {{number}}: {{message}}", "jme.shunt.no right square bracket": "No matching right square bracket to end list", "control.not all questions answered": "You have not completed every question in this test.", "jme.display.unknown token type": "Can't texify token type {{type}}", "part.numberentry.answer invalid": "You did not enter a valid number.", "jme.user javascript.returned undefined": "User-defined javascript function <code>{{name}}</code> returned <code>undefined</code>.", "question.hide steps": "Hide steps", "part.mcq.matrix wrong type": "Element of invalid type '{{type}}' used in marking matrix.", "math.combinations.n less than k": "Can't compute combinations: n is less than k", "gap": "gap", "mark": "mark", "suspend.you can resume": "You will be able to resume this session the next time you start this activity.", "scorm.error loading suspend data": "Error loading suspend data: {{message}}", "result.result": "Result:", "question.show steps": "Show steps", "question.submit part": "Check answer", "control.submit answer": "Check my answer", "part.matrix.empty cell": "One or more of the cells in your answer is empty.", "control.regen": "Try another question like this one", "control.advice": "Worked solution", "xml.could not load": "Couldn't load an XML document: {{message}}", "part.marking.uncaught error": "Error when marking {{part}}: {{message}}", "question.score feedback.score total actual": "Score: {{score,niceNumber}}/{{marks,niceNumber}}", "result.print": "Print this results summary", "math.siground.complex": "Can't round to a complex number of sig figs", "question.header": "Question {{number}}", "math.permutations.k less than zero": "Can't compute permutations: k is less than zero", "question.preamble.error": "Error in preamble: {{message}}", "suspend.resume": "Resume", "jme.substituteTree.undefined variable": "Undefined variable: <code>{{name}}</code>", "part.numberentry.answer not integer": "Your answer is invalid. You must enter a whole number, not a decimal.", "part.jme.not-allowed several": "Your answer must not contain any of: {{strings}}", "jme.matrix.reports bad size": "Matrix reports its size incorrectly - must be an error in constructor function", "question.unsupported part type": "Unsupported part type", "jme.variables.error evaluating variable": "Error evaluating variable {{name}}: {{message}}", "jme.typecheck.map not on enumerable": "<code>map</code> operation must work over a list or a range, not {{type}}", "part.mcq.correct choice": "You chose the correct answer.", "modal.cancel": "Cancel", "scorm.failed save": "<p>The request to save data to the server failed. Press <b>OK</b> to try again.</p>\n<p>If you get this message repeatedly, check your internet connection or use a different computer. Your previously submitted answers have been successfully saved and will be restored if you resume this session on a different computer.</p>\n<p>If this message appears persistently and you can't save <em>any</em> answers, please contact your lecturer or teacher.</p>", "jme.typecheck.function maybe implicit multiplication": "Operation {{name}} is not defined. Did you mean <br/><code>{{first}}*{{possibleOp}}(...)</code>?", "part.jme.answer too short": "Your answer is too short.", "matrixmath.mul.different sizes": "Can't multiply matrices of different sizes.", "jme.func.switch.no default case": "No default case for Switch statement", "part.numberentry.zero sig fig": "This part is set up to round the student's answer to zero significant figures, which has no meaning.", "frontpage.start": "Start the test", "result.question score": "Score", "part.mcq.choices missing": "Definition of choices is missing", "question.score feedback.correct": "Your answer is correct", "question.score feedback.answered": "Answered.", "math.permutations.n less than k": "Can't compute permutations: n is less than k", "part.gapfill.feedback header": "<strong>Answer {{index}}</strong>", "question.advice": "Advice", "vectormath.cross.matrix too big": "Can't calculate cross product of a matrix which isn't $1 \\times N$ or $N \\times 1$.", "part.jme.not-allowed bits": "<span class=\"monospace\">{{string}}</span>", "display.part.jme.error making maths": "Error making maths display", "control.proceed anyway": "Proceed anyway?", "part.matrix.empty": "You have not entered an answer.", "jme.tokenise.invalid": "Invalid expression: <code>{{expression}}</code>", "result.score": "Score:", "math.lcm.complex": "Can't compute LCM of complex numbers", "result.question number": "Question Number", "modal.ok": "OK", "was": "was", "jme.thtml.not html": "Passed a non-HTML value into the THTML constructor.", "question.score feedback.partial": "Your answer is partially correct", "question.score feedback.wrong": "Your answer is incorrect", "question.score feedback.score actual": "Score: {{scoreString}}", "part.numberentry.correct except fraction": "Your answer is within the allowed range, but fractions are not allowed.", "question.error": "Question {{number}}: {{message}}", "question.show steps already penalised": "You have already shown steps. You can show them again with no further penalty.", "part.jme.answer missing": "Correct answer is missing", "math.lt.order complex numbers": "Can't order complex numbers", "die.script not loaded": "Numbas couldn't start because the file <code>{{file}}</code> was not loaded. Check that it's included in <code>scripts.js</code>.", "jme.variables.question took too many runs to generate variables": "A valid set of question variables was not generated in time.", "part.matrix.answer invalid": "Your answer is not valid.", "part.numberentry.precision type.dp": "decimal place", "jme.texsubvars.no right brace": "No matching <code>}</code> in {{op}}", "page.loading": "Loading...", "part.jme.marking.correct": "Your answer is numerically correct.", "part.marking.correct": "Your answer is correct.", "part.matrix.size mismatch": "The question author hasn't allowed the student to decide the dimensions of their answer, but the correct answer is {{correct_dimensions}} while the answer input is {{input_dimensions}}", "part.marking.used variable replacements": "This part was marked using your answers to previous parts.", "control.submit": "Check", "jme.shunt.no left square bracket": "No matching left bracket", "jme.func.listval.invalid index": "Invalid list index {{index}} on list of size {{size}}", "question.score feedback.hide": "Hide feedback", "jme.variables.circular reference": "Circular variable reference in definition of <code>{{name}}</code>", "result.time spent": "Time Spent:", "die.error": "Error", "timing.time remaining": "Time remaining:", "part.with steps answer prompt": "Answer: ", "control.confirm leave": "You haven't finished the test.", "jme.typecheck.op not defined": "Operation '{{op}}' is not defined.", "part": "part", "control.submit again": "Check again", "xml.error in variable definition": "Error in definition of variable <code>{{name}}</code>", "exam.changeQuestion.no questions": "This test contains no questions! Check the .exam file for errors.", "part.jme.must-have bits": "<span class=\"monospace\">{{string}}</span>", "part.marking.total score": "You scored <strong>{{count,niceNumber}}</strong> $t(mark) for this part.", "result.detailed question breakdown": "Detailed Question Breakdown and Feedback", "control.confirm regen": "Would you like to re-randomise this question?<br> If you click OK, all your answers and marks for the current question will be lost.", "jme.evaluate.undefined variable": "Variable {{name}} is undefined", "jme.display.simplifyTree.no scope given": "Numbas.jme.display.simplifyTree must be given a Scope", "result.review": "Review", "timing.no accumulator": "no timing accumulator {{name}}", "util.product.non list": "Passed a non-list to <code>Numbas.util.product</code>", "part.marking.revealed steps no penalty": "You revealed the steps.", "part.jme.unexpected variable name suggestion": "Your answer was interpreted to use the unexpected variable name <code>{{name}}</code>. Did you mean <code>{{suggestion}}</code>?", "jme.display.collectRuleset.set not defined": "Ruleset {{name}} has not been defined", "part.matrix.some incorrect": "One or more of the cells in your answer is incorrect, but you have been awarded marks for the rest.", "part.marking.no result": "This part could not be marked.", "part.setting not present": "Property '{{property}}' not set", "exam.number of questions": "Number of Questions:", "part.numberentry.answer not integer or decimal": "Your answer is invalid. You must enter a whole number or a decimal.", "question.selector.unsubmitted changes": "Answer changed.", "vectormath.dot.matrix too big": "Can't calculate dot product of a matrix which isn't $1 \\times N$ or $N \\times 1$.", "scorm.no exam suspend data": "Failed to resume: no exam suspend data.", "math.permutations.n less than zero": "Can't compute permutations: n is less than zero", "exam.random seed": "Session ID:", "part.jme.must-have several": "Your answer must contain all of: {{strings}}", "part.patternmatch.display answer missing": "Display answer is missing", "math.precround.complex": "Can't round to a complex number of decimal places", "jme.func.matrix.invalid row type": "Can't construct a matrix from rows of type {{type}}", "jme.shunt.no left bracket": "No matching left bracket", "result.exam summary": "Test Summary", "jme.typecheck.no right type definition": "No definition of '{{op}}' of correct type found.", "exam.time allowed": "Time Allowed:", "xml.property not number": "Property {{name}} should be a number, but isn't ({{value}}), in node {{element}}", "exam.exam name": "Test Name:", "control.previous": "Previous"}}, "de-de": {"translation": {"jme.typecheck.no right type unbound name": "Variable <code>{{name}}</code> ist nicht definiert.", "control.pause": "Pause", "feedback.taken away": "<strong>{{count,niceNumber}}</strong> $t(mark) $t(was) abgezogen.", "question.score feedback.unanswered": "Unbeantwortet.", "control.reveal": "Antworten aufdecken", "part.marking.steps no matter": "Da sie die volle Punktzahl f\u00fcr diesen Abschnitt erhalten haben, werden ihre Antworten zu den Teilschritten nicht gez\u00e4hlt.", "part.marking.resubmit because of variable replacement": "Die Bewertung dieses Abschnitts h\u00e4ngt von ihren Antworten aus anderen Abschnitten, die sie g\u00e4ndert haben, ab. Reichen sie diesen Abschnitt erneut ein, um ihren Punktestand zu aktualisieren.", "question.no such part": "Aufgabenteil {{path}} kann nicht gefunden werden", "control.back to results": "Zur\u00fcck zu den Ergebnissen", "part.unknown type": "{{part}}: Unbekanntet Typ des Abschnitts {{type}}", "result.click a question to review": "Klicke auf eine Aufgabennummer, um die Bewertung ihrer Antworten und, wenn vorhanden, die L\u00f6sungen zu sehen.", "part.missing type attribute": "{{part}}: Fehlendes Attribut f\u00fcr den Typ des Abschnitts", "matrixmath.abs.non-square": "Determinanten k\u00f6nnen nur von quadratischen Matrizen berechnet werden.", "result.performance summary": "Zusammenfassung der Leistung", "die.numbas failed": "Numbas konnte nicht gestartet werden", "jme.shunt.no left bracket in function": "Fehlende linke Klammer in der Funktion oder dem Tupel", "part.mcq.matrix cell empty": "Teil {{part}} Bewertungsmatrix Zelle ({{row}},{{column}}) ist leer.", "question.score feedback.show": "Zeige Wertung", "part.script.error": "Fehler im Abschnitt {{path}} des Benutzerscripts {{script}}: {{message}} ", "part.numberentry.precision type.sigfig": "signifikante Stelle", "jme.variables.error computing dependency": "Fehler bei der Berechnung der referenzierten Variblen <code>{{name}}</code>", "exam.passed": "Bestanden", "result.questions attempted": "Bearbeitete Aufgaben:", "control.not all questions submitted": "Sie haben eine oder mehrere Antworten ge\u00e4ndert, aber nicht eingereicht. \u00dcberpr\u00fcfen Sie bitte, dass alle Antworten eingereicht wurden.", "exam.student name": "Name Student/in:", "scorm.no question suspend data": "Keine Daten zur unterbrochenen Aufgabe", "result.exam start": "Test begonnen:", "part.extension.not implemented": "Abschnitt hat nicht die Methode <code>{{name}}</code> implementiert.", "xml.property not boolean": "Einstellung {{name}} sollte ein boolscher Wert sein, aber es ist es nicht ({{value}}), im Knoten {{element}} ", "feedback.you were awarded": "Sie werden ausgezeichnet mit<strong>{{count,niceNumber}}</strong> $t(mark).", "jme.variables.variable not defined": "Variable  <code>{{name}}</code> ist nicht definiert.", "question.loaded name mismatch": "Der L\u00f6sungsversuch kann nicht wieder aufgenommen werden - das Paket hat sich seit der letzten Sitzung ge\u00e4ndert.", "control.confirm end": "Sind sie sich sicher den Test zu beenden? Nach Beendigung des Tests k\u00f6nnen sie ihre Antworten nicht mehr \u00e4ndern.", "result.exam stop": "Test beendet:", "exam.review header": "\u00dcberblick: ", "jme.display.collectRuleset.no sets": "Keine Daten gegeben zum Erstellen von Regels\u00e4tzen!", "result.exit": "Test beenden", "scorm.error initialising": "Fehler bei der Initialisierung des SCORM Protocols: {{message}} ", "exam.pass percentage": "Bestanden (in Prozent):", "math.permutations.complex": "Permutationen k\u00f6nnen nicht von komplexen Zahlen angegeben werden", "scorm.error loading part": "Fehler beim Laden des Abschnitts {{part}}: {{message}}", "part.mcq.options def not a list": "Der Ausdruck der {{properties}} definiert ist keine Liste.", "part.mcq.matrix mix of numbers and lists": "Mix von Zahlen und Listen in Bewertungsmatrix verwendet.", "part.marking.variable replacement part not answered": "Sie m\u00fcssen zuerst {{part}} beantworten", "part.marking.did not answer": "Sie haben diese Aufgabe nicht beantwortet.", "jme.shunt.missing operator": "Ausdruck kann nicht ausgewertet werden - ein Operator fehlt.", "suspend.paused header": "Angehalten", "part.mcq.matrix wrong size": "Bewertungsmatrix hat falsche Gr\u00f6\u00dfe.", "part.mcq.matrix jme error": "Teil {{part}} Bewertungsmatrix Zelle ({{row}},{{column}}) f\u00fchrt zu einem JME Fehler: {{error}}", "end.exam has finished": "Der Test wurde beendet. Sie k\u00f6nnen das Fenster nun schlie\u00dfen.", "suspend.exam suspended": "Der Test wurde unterbrochen. Dr\u00fccke <em>Fortfahren</em> um weiter zu gehen.", "jme.texsubvars.missing parameter": "Fehlende Parameter in {{op}}: {{parameter}}", "part.numberentry.precision type.sigfig_plural": "signifikante Stellen", "math.lt.order complex numbers": "Komplexe Zahlen k\u00f6nnen nicht sortiert werden", "control.confirm reveal": "Wollen Sie die L\u00f6sung zu dieser Aufgabe ansehen? Alle bisher erreichten Punkte bleiben erhalten und sie k\u00f6nnen diese Aufgabe sp\u00e4ter nicht nochmal bearbeiten.", "part.patternmatch.correct except case": "Ihre Antwort ist bis auf Gro\u00df-/Kleinschreibung richtig.", "part.marking.not submitted": "Keine Antworten eingereicht", "jme.variables.error making function": "Fehler beim Erstellen der Funktion <code>{{name}}</code>: {{message}}", "exam.xml.bad root": "Grundelement des Test XML sollte ein 'Test' sein", "part.mcq.matrix not a number": "Teil {{part}} Zelle ({{row}},{{column}}) der Bewertungsmatrix wird nicht mit einer Zahl belegt", "question.score feedback.score total": "{{marksString}}. Beantwortet.", "question.show steps penalty": "Sie verlieren <strong>{{count,niceNumber}}</strong> $t(mark).", "question.unsubmitted changes_plural": "Sie haben \u00c4nderungen an ihren Antworten vorgenommen ohne sie einzureichen. Bitte pr\u00fcfen sie ihre Antworten und klicken sie <strong>Alle Teile einreichen</strong>.", "question.show steps no penalty": "Ihr Punktestand wird nicht ver\u00e4ndert.", "scorm.no part suspend data": "Keine Daten von der Unterbrechung des Abschnitts", "jme.typecheck.function not defined": "Operation <code>{{op}}</code> ist nicht definiert. Ist <code>{{op}}</code> eine Variable, und meinen sie <code>{{suggestion}}*(...)</code>?", "part.marking.revealed steps with penalty": "Sie haben sich L\u00f6sungsschritte anzeigen lassen. F\u00fcr diesen Aufgabenteil k\u00f6nnen sie <strong>{{count,niceNumber}}</strong> $t(mark) erhalten. Ihr Punktestand wird entsprechend reduziert.", "question.unsubmitted changes": "Sie haben ihre Antwort ge\u00e4ndert ohne sie einzureichen. Bitte pr\u00fcfen sie ihre Antwort und klicken den <strong>Antwort einreichen<strong>.", "ruleset.circular reference": "Zirkulare Referenz in der Definition des Regelsatzes <code>{{name}}</code>", "math.combinations.n less than zero": "Kombinationen konnten nicht berechnet werden: n ist kleiner als null", "part.marking.incorrect": "Ihre Antwort ist nicht richtig.", "jme.variables.empty definition": "Definition der Variable  <code>{{name}}</code> ist leer.", "question.preamble.syntax error": "Syntaxfehler in der Pr\u00e4ambel", "util.equality not defined for type": "Der Gleichheitsoperator ist f\u00fcr den Typ {{type}} nicht definiert", "ruleset.set not defined": "Regelsatz {{name}} wurde nicht definiert", "result.question review title": "Aufgabe nochmals durchsehen", "jme.shunt.no right bracket": "Keine passende rechte Klammer", "die.sorry": "Entschuldigung, Numbas hat einen Fehler festgestellt, der eine weiter Bearbeitung unm\u00f6glich macht. Es folgt eine Beschreibung des Fehlers.", "control.end exam": "Test beenden", "vectormath.cross.not 3d": "Nur Kreuzprodukte von 3-dimensionalen Vektoren m\u00f6glich.", "part.mcq.matrix not a list": "Bewertungsmatrix, definiert durch JME Ausdruck, ist keine Liste, welche sie sein sollte.", "part.marking.nothing entered": "Sie haben keine Antwort eingegeben.", "part.numberentry.give your answer as a reduced fraction": "Vereinfachen sie ihre Antwort vollst\u00e4ndig.", "mark_plural": "Punkte", "question.hide steps no penalty": "Ihr Punktestand wird nicht ver\u00e4ndert.", "step": "Schritt", "part.numberentry.correct except decimal": "Ihre Antwort ist im erlaubten Intervall, aber Dezimalzahlen sind nicht erlaubt.", "question.can not submit": "Antwort kann nicht eingereicht werden - \u00fcberpr\u00fcfen auf Fehler.", "math.choose.empty selection": "Leere Auswahl wurde der Zufallsfunktion \u00fcbergeben", "part.jme.answer too long": "Ihre Antwort ist zu lang.", "mathjax.error": "MathJax Verarbeitungsfehler: {{message}}", "control.submit answer": "Antwort einreichen", "exam.failed": "Nicht bestanden", "part.jme.not-allowed one": "Ihre Antwort darf nicht enthalten: {{strings}}", "jme.shunt.not enough arguments": "Nicht gen\u00fcgend Argumente f\u00fcr die Funktion  {{op}}", "question.answer submitted": "Antwort eingereicht", "part.jme.must-have one": "Ihre Antwort muss enthalten: {{strings}}", "part.correct answer": "Erwartete Antwort:", "part.numberentry.answer not reduced": "Ihre Antwort ist nicht vollst\u00e4ndig vereinfacht.", "control.next": "N\u00e4chste", "part.mcq.marking matrix string empty": "Die angepasste Bewertungsmatrix ist leer.", "matrixmath.abs.too big": "Sorry, Determinanten k\u00f6nnen im Moment nur f\u00fcr Matrizen gr\u00f6\u00dfer als 3x3 bestimmt werden.", "jme.texsubvars.no right bracket": "Keine passende <code>]</code> in {{op}} Argumenten.", "mathjax.math processing error": "\"{{message}}\" beim TeXen von <code>{{expression}}</code>", "jme.matrix.reports bad size": "Matrix meldet ihre Gr\u00f6\u00dfe falsch - es muss ein Fehler im Konstruktor vorliegen", "part.marking.steps change": "Sie erhielten <strong>{{count,niceNumber}}</strong> $t(mark) f\u00fcr ihre Antworten in den L\u00f6sungsschritten.", "part.mcq.choices": "M\u00f6glichkeiten", "part.jme.answer invalid": "Ihre Antwort ist kein g\u00fcltiger mathematischer Ausdruck.<br/>{{message}}. ", "jme.shunt.list mixed argument types": "Kann nicht parsen {{mode}}: Mischung von Dictionary- und Listenelementen", "jme.func.except.continuous range": "'Exklusiv' Operator kann nicht kontinuierliche Bereiche angewendet werden.", "exam.marks available": "Erreichbare Punkte:", "math.combinations.k less than zero": "Kombinationen konnten nicht berechnet werden: k ist kleiner als null", "result.question number": "Aufgabennummer", "control.submit all parts": "Alle Abschnitte einreichen", "jme.func.listval.not a list": "Objekt ist nicht indizierbar", "part.numberentry.give your answer to precision": "Runden Sie ihre Antwort auf {{count,niceNumber}} {{precisionType}}.", "part.mcq.wrong number of choices": "Sie haben die falsche Anzahl von Auswahlm\u00f6glichkeiten gew\u00e4hlt.", "jme.variables.syntax error in function definition": "Syntaxfehler in der Definition der Funktion", "page.saving": "<p>Speichere.</p>\n<p>Dies kann einen Moment dauern.</p>", "math.gcf.complex": "ggT kann nicht von komplexen Zahlen berechnet werden", "part.matrix.some incorrect": "Eine oder mehrere Zellen in ihrer Antwort sind nicht richtig, aber sie haben f\u00fcr den Rest Punkte erhalten.", "math.combinations.complex": "Kombinationen k\u00f6nnen nicht von komplexen Zahlen berechnet werden", "control.total": "Total", "jme.user javascript.error": "Fehler in Benutzer-definierter Javascript Funktion <code>{{name}}</code>: {{message}}", "part.matrix.invalid cell": "Eine oder mehrere Zellen in ihren Antworten sind leer oder ung\u00fcltig.", "scorm.error loading question": "Fehler beim Laden der Aufgabe {{number}}: {{message}}", "part.numberentry.give your answer to precision_0": "Runden sie ihre Antwort auf die n\u00e4chste ganze Zahl.", "jme.shunt.no right square bracket": "Keine passende rechte eckige Klammer", "control.not all questions answered": "Sie haben nicht alle Aufgaben in diesem Test bearbeitet.", "jme.display.unknown token type": "Token vom Typ {{type}} konnte nicht mit TeX dargestellt werden", "part.numberentry.answer invalid": "Sie haben nicht eine g\u00fcltige Zahl eingegeben.", "jme.user javascript.returned undefined": "Benutzerdefinierte Javascriptfunktion <code>{{name}}</code> liefert <code>undefined</code>.", "question.hide steps": "Verberge L\u00f6sungsschritte", "part.mcq.matrix wrong type": "Element mit ung\u00fcltigen Typ '{{type}}' in Bewertungsmatrix verwendet.", "math.combinations.n less than k": "Kombinationen konnten nicht berechnet werden: n ist kleiner als k", "mark": "Punkt", "suspend.you can resume": "Sie k\u00f6nnen diese Sitzung beim n\u00e4chsten Start fortfahren.", "scorm.error loading suspend data": "Fehler beim Laden der eingefrorenen Daten {{message}}", "result.result": "Ergebnis:", "question.show steps": "Zeige L\u00f6sungsschritte", "question.submit part": "Teil einreichen", "part.jme.unexpected variable name": "Ihre Antwort hat Bezug zu einer unerwarteten Variablen <code>{{name}}</code>.", "part.matrix.empty cell": "Eine oder mehrere Zellen in ihrer Antwort sind leer.", "control.regen": "Probiere eine andere Aufgabe von dieser Art", "control.advice": "Hinweis", "xml.could not load": "Ein XML Dokument kann nicht geladen werden: {{message}}", "part.marking.uncaught error": "Fehler bei der Bewertung von {{part}}: {{message}}", "question.score feedback.score total actual": "Punktestand: {{score,niceNumber}}/{{marks,niceNumber}}", "result.print": "Drucken der Ergebnisse", "math.siground.complex": "Beim Runden darf die Anzahl der signifikante Ziffern nicht komplex sein", "question.header": "Aufgabe {{number}}", "math.permutations.k less than zero": "Permutationen konnten nicht berechnet werden: k ist kleiner als null", "question.preamble.error": "Fehler in der Pr\u00e4ambel : {{message}}", "suspend.resume": "Fortfahren", "part.mcq.correct choice": "Sie haben die richtige Antwort gew\u00e4hlt.", "part.numberentry.answer not integer": "Ihre Antwort ist ung\u00fcltig. Sie m\u00fcssen eine ganze Zahl, nicht eine Dezimalzahl angeben.", "part.jme.not-allowed several": "Ihre Antwort darf nichts enthalten von: {{strings}}", "part.numberentry.precision type.dp_plural": "Dezimalstellen", "question.unsupported part type": "Nicht unterst\u00fctzer Typ der Teilaufgabe", "jme.variables.error evaluating variable": "Fehler beim Auswerten der Variable {{name}}: {{message}}", "jme.func.listval.key not in dict": "Dictionary enth\u00e4lt keinen key <code>{{key}}</code>", "part.mcq.answers": "Antworten", "jme.typecheck.map not on enumerable": "<code>map</code> operiert auf einer Liste oder Bereich nicht auf {{type}}", "jme.substituteTree.undefined variable": "Nicht definierte Variable: <code>{{name}}</code>", "modal.cancel": "Abbrechen", "scorm.failed save": "<p>Das Speichern der Daten auf dem Server schlug fehl. Dr\u00fccken sie <b>OK</b> um es nochmal zu versuchen.</p>\n<p>Wenn sie diese Meldung wiederholt erhalten, pr\u00fcfen sie die Internetverbindung oder benutzen sie einen anderen Computer. Ihre vorher eingereichte Antwort wurde erfolgreich gespeichert und wird wierderhergestellt, wenn sie die Sitzung an einem anderen Computer fortsetzen.</p>\n<p>Wenn diese Meldung dauerhaft erscheint und sie k\u00f6nnen <em>gar keine</em> Antworten speichern, kontaktieren sie bitte ihren Dozenten oder Lehrer.</p>", "jme.typecheck.function maybe implicit multiplication": "Operation {{name}} ist nichtdefiniert. Meinen sie <br/><code>{{first}}*{{possibleOp}}(...)</code>?", "part.jme.answer too short": "Ihre Antwort ist zu kurz.", "matrixmath.mul.different sizes": "Matrizen mit verschiedenen Gr\u00f6\u00dfen k\u00f6nnen nicht multipliziert werden.", "jme.func.switch.no default case": "Kein Standardwert f\u00fcr Switch Anweisung", "part.numberentry.zero sig fig": "Dieser Abschnitt ist so eingestellt, dass die Antwort der Studenten auf null signifikante Stellen gerundet werden. Dies macht keinen Sinn.", "frontpage.start": "Start", "result.question score": "Punkte", "part.mcq.choices missing": "Definition der Auswahlm\u00f6glichkeiten fehlt", "question.score feedback.correct": "Ihre Antwort ist richtig", "part.feedback": "Wertung", "question.score feedback.answered": "Beantwortet.", "math.permutations.n less than k": "Permutationen konnten nicht berechnet werden: n ist kleiner als k", "part.gapfill.feedback header": "<strong>L\u00fccke {{index}}</strong>", "question.advice": "Hinweise", "vectormath.cross.matrix too big": "Das Kreuzprodukt von Matrizen ist nur f\u00fcr  $1 \\times N$ or $N \\times 1$ definiert.", "part.jme.not-allowed bits": "<span class=\"monospace\">{{string}}</span>", "display.part.jme.error making maths": "Fehler bei der mathematischen Darstellung", "part.prompt": "prompt", "control.proceed anyway": "Dennoch fortfahren?", "gap": "L\u00fccke", "jme.tokenise.invalid": "Ung\u00fcltiger Ausdruck: <code>{{expression}}</code>", "result.score": "Punktzahl:", "math.lcm.complex": "kgV kann nicht von komplexen Zahlen berechnet werden", "exam.random seed": "Session ID:", "modal.ok": "OK", "was": "wurde", "jme.thtml.not html": "Ein nicht-HTML Wert wurde an einen THTML Konstruktor \u00fcbergeben.", "question.score feedback.partial": "Ihre Antwort ist teilweise richtig", "mathjax.error with context": "MathJax Verarbeitungsfehler bei {{context}}: {{message}}", "question.score feedback.wrong": "Ihre Antwort ist nicht richtig", "question.score feedback.score actual": "Punktestand: {{scoreString}}", "part.numberentry.correct except fraction": "Ihre Antwort ist im erlaubten Intervall, aber Br\u00fcche sind nicht erlaubt.", "question.error": "Aufgabe {{number}}: {{message}}", "jme.evaluate.no scope given": "Numbas.jme.evaluate muss ein Geltungsbereich gegeben werden", "question.show steps already penalised": "Sie haben die L\u00f6sungsschritte schon gesehen. Sie k\u00f6nnen sie sich noch einmal ohne weiteren Punktabzug ansehen.", "part.jme.answer missing": "Korrekte Antwort fehlt", "part.mcq.no choices selected": "Keine Auswahl get\u00e4tigt.", "die.script not loaded": "Numbas konnte nicht starten da die Datei <code>{{file}}</code> nicht geladen wurde. \u00dcberpr\u00fcfen sie, dass sie in <code>scripts.js</code> enthalten ist.", "part.numberentry.precision type.dp": "Dezimalstelle", "part.matrix.answer invalid": "Ihre Antwort ist nicht g\u00fcltig.", "jme.variables.question took too many runs to generate variables": "Es konnte kein g\u00fcltiger Variablensatz in angemessener Zeit gebildet werden.", "jme.texsubvars.no right brace": "Keine passende <code>}</code> in {{op}}", "page.loading": "Lade...", "part.jme.marking.correct": "Ihre Antwort ist numerisch korrekt.", "part.marking.correct": "Ihre Antwort ist richtig.", "part.matrix.size mismatch": "Der Aufgabensteller erwartet eine bestimmte Dimension der L\u00f6sung. Die korrekte Dimension ist {{correct_dimensions}}, w\u00e4hrend die Antwort die Dimension {{input_dimensions}} hat", "exam.feedback": "Test Bewertungsnachricht", "part.marking.used variable replacements": "Dieser Abschnitt wurde durch ihre Antworten in vorhergehenden Abschnitten bewertet.", "control.submit": "Einreichen", "jme.shunt.no left square bracket": "Keine passende linke eckige Klammer", "jme.func.listval.invalid index": "Ung\u00fcltiger Listenindex {{index}} f\u00fcr eine Liste der Gr\u00f6\u00dfe {{size}}", "question.score feedback.hide": "Blende Wertung aus", "jme.variables.circular reference": "Zirkul\u00e4re Definition der Variable <code>{{name}}</code>", "result.time spent": "Vergangene Zeit:", "die.error": "Fehler", "timing.time remaining": "Verbleibende Zeit:", "part.numberentry.negative decimal places": "Dieser Abschnitt ist so eingestellt, dass die Antwort der Stundenten auf eine negative Zahl von Dezimalstellen gerundet wird. Dies macht keinen Sinn.", "part.with steps answer prompt": "Antwort: ", "control.confirm leave": "Sie haben den Test noch nicht beendet.", "jme.typecheck.op not defined": "Operation '{{op}}' ist nicht definiert.", "part": "Abschnitt", "control.submit again": "Erneut einreichen", "xml.error in variable definition": "Fehler in der Definition der Variablen <code>{{name}}</code> ", "exam.changeQuestion.no questions": "Dieser Test enth\u00e4lt keine Aufgaben! \u00dcberpr\u00fcfen sie die .exam Datei auf Fehler.", "part.jme.must-have bits": "<span class=\"monospace\">{{string}}</span>", "part.marking.total score": "Sie erhalten <strong>{{count,niceNumber}}</strong> $t(mark) f\u00fcr diesen Aufgabenteil.", "exam.introduction": "Test Einf\u00fchrung", "control.confirm regen": "Wollen Sie diese Aufgabe mit neuen zuf\u00e4lligen Werten bearbeiten? Wenn Sie OK klicken, gehen alle ihre Antworten und Punkte f\u00fcr die aktuelle Aufgabe verloren.", "jme.evaluate.undefined variable": "Variable {{name}} ist nicht definiert.", "jme.display.simplifyTree.no scope given": "Numbas.jme.display.simplifyBaum muss ein Geltungsbereich gegeben werden", "timing.no accumulator": "kein Zeitregister {{name}}", "util.product.non list": "Keine Liste \u00fcbergeben an <code>Numbas.util.product</code>", "part.marking.revealed steps no penalty": "Sie haben die Teilschritte aufgedeckt.", "part.jme.unexpected variable name suggestion": "Ihre Antwort hat Bezug zu einer unerwarteten Variablen <code>{{name}}</code>. Meinen sie <code>{{suggestion}}</code>?", "jme.display.collectRuleset.set not defined": "Regelsatz {{name}} wurde nicht definiert", "was_plural": "wurden", "part.marking.no result": "Dieser Teil kann nicht bewertet werden.", "part.setting not present": "Einstellung '{{property}}' not set", "exam.number of questions": "Anzahl der Aufgaben:", "part.numberentry.answer not integer or decimal": "Ihre Antwort ist ung\u00fcltig. Sie m\u00fcssen eine ganze oder eine Dezimalzahl angeben.", "question.selector.unsubmitted changes": "Nicht eingereichte \u00c4nderungen.", "vectormath.dot.matrix too big": "Das Skalarprodukt von Matrizen ist nur f\u00fcr  $1 \\times N$ or $N \\times 1$ definiert.", "scorm.no exam suspend data": "Fortsetzung fehlgeschlagen: keine Daten vom unterbrochenen Test.", "math.permutations.n less than zero": "Permutationen konnten nicht berechnet werden: n ist kleiner als null", "part.matrix.empty": "Sie haben keine Antwort angegeben.", "part.jme.must-have several": "Ihres Antwort muss alle enthalten von: {{strings}}", "part.patternmatch.display answer missing": "Anzeigeantwort fehlt", "math.precround.complex": "Beim Runden darf die Anzahl der Dezimalstellen nicht komplex sein.", "jme.func.matrix.invalid row type": "Matrix kann nicht mit Zeilen vom Typ {{type}} erstellt werden", "jme.tokenise.keypair key not a string": "Dictionary key muss eine Zeichenkette sein, nicht {{type}}.", "jme.shunt.no left bracket": "Keine passende linke Klammer", "result.exam summary": "Zusammenfassung des Tests", "jme.typecheck.no right type definition": "Keine Definition von '{{op}}' mit korrektem Typ gefunden.", "exam.time allowed": "Erlaubte Zeit:", "question.statement": "Beschreibung", "xml.property not number": "Einstellung {{name}} sollte eine Zahl sein, aber es ist es nicht ({{value}}), im Knoten {{element}} ", "exam.exam name": "Test Name:", "control.previous": "Vorhergehend"}}, "sv-se": {"translation": {"jme.typecheck.no right type unbound name": "Variabeln <code>{{name}}</code> \u00e4r inte definierad.", "control.pause": "Paus", "feedback.taken away": "<strong>{{count,niceNumber}}</strong> $t(mark) $t(was) tagits bort", "question.score feedback.unanswered": "Obesvarad.", "control.reveal": "Visa svar", "part.marking.steps no matter": "Eftersom du redan r\u00e4ttat delen kan du inte f\u00e5 po\u00e4ng f\u00f6r nya svar.", "part.marking.resubmit because of variable replacement": "Denna dels po\u00e4ng beror p\u00e5 svar p\u00e5 andra delar, dessa svar \u00e4r \u00e4ndrade s\u00e5 spara igen f\u00f6r att uppdatera din po\u00e4ng.", "question.no such part": "Kan inte hitta del {{path}}", "control.back to results": "G\u00e5 tillbaka till resultat", "part.unknown type": " {{part}}: Icke-l\u00e4sbar del {{type}}", "result.click a question to review": "Klicka p\u00e5 en fr\u00e5ga f\u00f6r att se hur dina svar \u00e4r bed\u00f6mda samt f\u00f6r att se eventuella l\u00f6sningar.", "part.missing type attribute": "{{part}}: det saknas en attribut", "matrixmath.abs.non-square": "Kan inte ber\u00e4kna determinanten av en matrix som inte \u00e4r fyrkantig", "result.performance summary": "Summering utfall", "die.numbas failed": "Numbas kunde inte starta", "jme.shunt.no left bracket in function": "Ingen matchande v\u00e4nster-bracket i funktion eller serie", "part.mcq.matrix cell empty": "Del {{part}} r\u00e4ttnings-matris cell ({{row}},{{column}}) \u00e4r tom.", "question.score feedback.show": "Visa Feedback", "part.script.error": "Fel i del {{path}} script {{script}}: {{message}}", "part.numberentry.precision type.sigfig": "v\u00e4rdesiffra", "jme.variables.error computing dependency": "Fel i ber\u00e4kning av referens variabeln <code>{{name}}</code>", "exam.passed": "Godk\u00e4nd", "result.questions attempted": "Fr\u00e5gor ", "control.not all questions submitted": "Du har \u00e4ndrat n\u00e5got eller n\u00e5gra svar men inte sparat dina \u00e4ndringar. Var sn\u00e4ll och se s\u00e5 alla fr\u00e5gor har sparats.", "exam.student name": "Studentens namn", "scorm.no question suspend data": "Ingen fr\u00e5ga, stannar", "result.exam start": "Prov start:", "part.extension.not implemented": "Delen har inte anv\u00e4nt <code>{{name}}</code> metoden.", "xml.property not boolean": "Egenskap {{name}} borde vara en boolean, men \u00e4r det inte ({{value}}), i node {{element}}", "feedback.you were awarded": "Du har f\u00e5tt <strong>{{count,niceNumber}}</strong> $t(mark).", "jme.variables.variable not defined": "Variable <code>{{name}}</code> is not defined.", "question.loaded name mismatch": "Kan inte \u00e5teruppta detta f\u00f6rs\u00f6k. objektet har \u00e4ndrats sen du arbetade med det sist.", "control.confirm end": "\u00c4r du s\u00e4ker p\u00e5 att du vill avsluta ditt prov? Efter du avslutat kan du inte g\u00e5 tillbaka och \u00e4ndra dina svar.", "result.exam stop": "Prov avslutning:", "exam.review header": "Review:", "jme.display.collectRuleset.no sets": "Inga sets \u00e4r givna till Samlade-Regler-setet!", "result.exit": "Avsluta prov", "scorm.error initialising": "Ett fel uppstod i SCORM protokollet: {{message}}", "exam.pass percentage": "Godk\u00e4nd percentil", "math.permutations.complex": "Kan inte ber\u00e4kna permutationer av komplexa tal", "scorm.error loading part": "Fel i laddning av del {{part}}: {{message}}", "part.mcq.options def not a list": "Uttrycket som definierar {{properties}} \u00e4r inte en lista.", "part.mcq.matrix mix of numbers and lists": "En blandning av siffror och listor anv\u00e4nds i r\u00e4ttnings-matrisen.", "part.marking.variable replacement part not answered": "Du m\u00e5ste svara p\u00e5 {{part}} f\u00f6rst", "part.marking.did not answer": "Du svarade inte p\u00e5 denna fr\u00e5ga", "jme.shunt.missing operator": "Uttrycket kan inte utv\u00e4rderas -- Det saknas en operator.", "suspend.paused header": "Pausad", "part.mcq.matrix wrong size": "Matrisen \u00e4r av fel storlek", "part.mcq.matrix jme error": "Del {{part}} r\u00e4ttnings-matris cell ({{row}},{{column}}) ger ett JME error: {{error}}", "end.exam has finished": "Provet har nu avslutats. Du kan st\u00e4nga detta f\u00f6nster.", "suspend.exam suspended": "Provet har pausats. Tryck p\u00e5 <em>\u00c5teruppta</em> f\u00f6r att forts\u00e4tta.", "jme.texsubvars.missing parameter": "Parameter saknas i {{op}}: {{parameter}}", "part.numberentry.precision type.sigfig_plural": "v\u00e4rdesiffror", "math.lt.order complex numbers": "Kan inte sortera complexa tal", "control.confirm reveal": "Vill du visa svaret till denna fr\u00e5ga? Eventuella po\u00e4ng kommer l\u00e5sas samt du kommer inte kunna svara p\u00e5 fr\u00e5gan i efterhand. ", "part.patternmatch.correct except case": "Ditt svar \u00e4r korrekt, f\u00f6rutom enheten.", "part.marking.not submitted": "Inget svar inskickat", "jme.variables.error making function": "Del uppstod n\u00e4r funktionen skapades <code>{{name}}</code>: {{message}}", "exam.xml.bad root": "Rot elementet av prov XML borde vara 'prov'", "part.mcq.matrix not a number": "Del {{part}} r\u00e4ttnings-matrisen cell ({{row}},{{column}}) blir inget nummer", "question.score feedback.score total": "{{marksString}}. Besvarade.", "question.show steps penalty": "Du kommer f\u00f6rlora <strong>{{count,niceNumber}}</strong> $t(mark).", "question.unsubmitted changes_plural": "Du har \u00e4ndrat svaret men inte sparat. Var sn\u00e4ll och <strong>Spara svar</strong> button. efter att du kontrollerat svaret till alla delar.", "question.show steps no penalty": "Dina po\u00e4ng kommer inte p\u00e5verkas.", "scorm.no part suspend data": "Ingen del, stannar", "jme.typecheck.function not defined": "Operationen {{op}} \u00e4r inte definierad. Menade du <br/><code>{{suggestion}}*(...)</code>?", "part.marking.revealed steps with penalty": "Du visade l\u00f6snings-stegen. Ditt maxpo\u00e4ng f\u00f6r denna delen \u00e4r <strong>{{count,niceNumber}}</strong> $t(mark). Dina po\u00e4ng skalas ned p\u00e5 grund av l\u00f6sningen.", "question.unsubmitted changes": "Du har \u00e4ndrat svaret men inte sparat. Var sn\u00e4ll och <strong>Spara svar</strong> button. efter att du kontrollerat svaret.", "ruleset.circular reference": "Cirkul\u00e4r referens i definitionen av regelsetet <code>{{name}}</code>", "math.combinations.n less than zero": "Kan inte ber\u00e4kna kombinationer: n \u00e4r mindre \u00e4n 0", "part.marking.incorrect": "Ditt svar \u00e4r inkorrekt.", "jme.variables.empty definition": "Variabelns definition <code>{{name}}</code> \u00e4r tom.", "question.preamble.syntax error": "Syntax error i inledningen", "util.equality not defined for type": "Ekvivalens \u00e4r inte definierat f\u00f6r text {{type}}", "ruleset.set not defined": "refelsetet {{name}} har inte definierats", "result.question review title": "\u00c5terkoppla denna fr\u00e5ga", "jme.shunt.no right bracket": "Ingen matchande h\u00f6ger-bracket", "die.sorry": "Numbas fick ett fel som stannade programmet. Underliggande finns en beskrivning av felet.", "control.end exam": "Avsluta prov", "vectormath.cross.not 3d": "Kan bara ta kryssprodukten av tre dimensions vektorer.", "part.mcq.matrix not a list": "R\u00e4ttnings-matrisen, definierad av JME uttrycket, m\u00e5ste vara en lista.", "part.marking.nothing entered": "Du har inte skrivit in ett svar.", "part.numberentry.give your answer as a reduced fraction": "F\u00f6renkla ditt svar till enklaste form.", "mark_plural": "po\u00e4ng", "question.hide steps no penalty": "Dina po\u00e4nk kommer inte p\u00e5verkas.", "step": "steg", "part.numberentry.correct except decimal": "Ditt svar \u00e4r i r\u00e4tt intervall, dock till\u00e5ts inte decimaler.", "question.can not submit": "Kan inte spara svar - unders\u00f6k eventuella fel", "math.choose.empty selection": "tom sektion given till random-funktionen ", "part.jme.answer too long": "Ditt svar \u00e4r f\u00f6r l\u00e5ngt", "mathjax.error": "Ett fel uppstod i MathJax {{context}}: {{message}}", "control.submit answer": "Skicka in svar", "exam.failed": "Icke godk\u00e4nt", "part.jme.not-allowed one": "Ditt svar kan inte inneh\u00e5lla: {{strings}}", "jme.shunt.not enough arguments": "inte nog med argument f\u00f6r operationen {{op}}", "question.answer submitted": "Svar sparat", "part.jme.must-have one": "Ditt svar m\u00e5ste inneh\u00e5lla: {{strings}}", "part.correct answer": "F\u00f6rv\u00e4ntat svar.", "part.numberentry.answer not reduced": "Ditt svar \u00e4r inte i enklaste form.", "control.next": "N\u00e4sta", "part.mcq.marking matrix string empty": "R\u00e4ttnings-matrisen \u00e4r tom", "matrixmath.abs.too big": "Urs\u00e4kta, systemet kan inte ber\u00e4kna determinanter av matriser st\u00f6rre \u00e4n 3x3.", "jme.texsubvars.no right bracket": "Inga matchande <code>]</code> i {{op}} argumenten.", "mathjax.math processing error": "\"{{message}}\" n\u00e4r Numbas konverterade <code>{{expression}}</code> till LaTeX", "jme.matrix.reports bad size": "Matrisen visar fel storlek - det m\u00e5ste vara n\u00e5got fel i funtionen som konstruerade den.", "part.marking.steps change": "Du fick  <strong>{{count,niceNumber}}</strong> $t(mark) po\u00e4ng f\u00f6r dina svar p\u00e5 denna del.", "part.mcq.choices": "Val", "part.jme.answer invalid": "Ditt svar \u00e4r inte ett korrekt matematiskt uttryck.<br/>{{message}}.", "jme.shunt.list mixed argument types": "Kan inte f\u00f6rst\u00e5 {{mode}}: en mix av olika typer av element (listor och ord).", "jme.func.except.continuous range": "Kan inte anv\u00e4nda 'except' operatorn p\u00e5 kontinuerliga intervall", "exam.marks available": "Po\u00e4ng tillg\u00e4ngliga", "math.combinations.k less than zero": "Kan inte ber\u00e4kna kombinationer: k \u00e4r mindre \u00e4n 0", "result.question number": "Fr\u00e5ga", "control.submit all parts": "Skicka in alla delar", "jme.func.listval.not a list": "Objektet \u00e4r inte prenumereringsbart", "part.numberentry.give your answer to precision": "Avrunda ditt svar till {{count,niceNumber}} {{precisionType}}.", "part.mcq.wrong number of choices": "Du valde fel antal svar.", "jme.variables.syntax error in function definition": "Syntaxfel i funktionens definition", "page.saving": "<p>Sparar.</p>\n<p>Detta kan ta n\u00e5gra sekunder</p>", "math.gcf.complex": "Kan inte ber\u00e4kna SGF av komplexa tal ", "part.matrix.some incorrect": "En eller flera av cellerna i ditt svar \u00e4r inte korrekta, Du har dock f\u00e5tt po\u00e4ng f\u00f6r resterande svar.", "math.combinations.complex": "Kan inte ber\u00e4kna kombinationen av komplexa tal", "control.total": "Totalpo\u00e4ng", "jme.user javascript.error": "Fel i anv\u00e4ndar-definierad javascript funktion <code>{{name}}</code>: {{message}}", "part.matrix.invalid cell": "En eller fler av cellerna i ditt svar \u00e4r tomma eller ogiltiga.", "scorm.error loading question": "Ett fel uppstod vid laddning av fr\u00e5ga {{number}}: {{message}}", "part.numberentry.give your answer to precision_0": "Avrunda dina svar till n\u00e4rmsta heltal.", "jme.shunt.no right square bracket": "Ingen matchande h\u00f6ger-klammer som avslutar listan", "control.not all questions answered": "Du har inte svarat p\u00e5 alla fr\u00e5gor i detta prov.", "jme.display.unknown token type": "Kan inte textifiera token skrift {{type}}", "part.numberentry.answer invalid": "Du skrev inte en siffra", "jme.user javascript.returned undefined": "Javascript funktionen gav en felkod: <code>{{name}}</code> returned <code>undefined</code>.", "question.hide steps": "G\u00f6m steg", "part.mcq.matrix wrong type": "Element av ogiltig typ '{{type}}' anv\u00e4nds i r\u00e4ttnings-matrisen", "math.combinations.n less than k": "Kan inte ber\u00e4kna kombinationer: n \u00e4r mindre \u00e4n k", "mark": "po\u00e4ng", "suspend.you can resume": "Du kan forts\u00e4tta n\u00e4sta g\u00e5ng du startar denna aktivitet", "scorm.error loading suspend data": "Fel i laddning av data: {{message}}", "result.result": "Resultat:", "question.show steps": "Visa steg", "question.submit part": "Spara del", "part.jme.unexpected variable name": "Ditt svar verkar inneh\u00e5lla en ogiltigt variabelnamn <code>{{name}}</code>.", "part.matrix.empty cell": "En eller fler celler i ditt svar \u00e4r tomma.", "control.regen": "F\u00f6rs\u00f6k med en liknande fr\u00e5ga", "control.advice": "R\u00e5d", "xml.could not load": "Kunder inte ladda XML dokumentet: {{message}}", "part.marking.uncaught error": "Fel i skapning av {{part}}: {{message}}", "question.score feedback.score total actual": "Po\u00e4ng: {{score,niceNumber}}/{{marks,niceNumber}}", "result.print": "Skriv ut resultat-statistik", "math.siground.complex": "Kan inte avrunda till ett komplext tal av signifikant v\u00e4rde", "question.header": "Fr\u00e5ga {{number}}", "math.permutations.k less than zero": "Kan inte ber\u00e4kna permutationer: k \u00e4r mindre \u00e4n 0", "question.preamble.error": "Fel i inledningen: {{message}}", "suspend.resume": "\u00c5teruppta", "part.mcq.correct choice": "Du valde r\u00e4tt svar.", "part.numberentry.answer not integer": "Ditt svar \u00e4r felaktigt. Du m\u00e5ste anv\u00e4nda positiva heltal, inte decimaler.", "part.jme.not-allowed several": "Ditt svar kan inte inneh\u00e5lla n\u00e5gon av: {{strings}}", "part.numberentry.precision type.dp_plural": "decimaler", "question.unsupported part type": "Ogiltig del typ", "jme.variables.error evaluating variable": "Fel i evaluering av variabel {{name}}: {{message}}", "jme.func.listval.key not in dict": "Ordboken inneh\u00e5ller inte nyckeln  <code>{{key}}</code>", "part.mcq.answers": "Svar", "jme.typecheck.map not on enumerable": "<code>map</code> operationen m\u00e5ste arbeta med en lista eller ett intervall, inte {{type}}", "jme.substituteTree.undefined variable": "Odefinierad variabel: <code>{{name}}</code>", "modal.cancel": "Avbryt", "scorm.failed save": "<p> Sparnings-f\u00f6rfr\u00e5gan har misslyckats. Tryck <b>OK</b> f\u00f6r att f\u00f6rs\u00f6ka igen.</p> <p>Om du vid upprepade tillf\u00e4llen f\u00e5r detta meddelande kontrollera din internet-uppkoppling eller dator. Dina f\u00f6reg\u00e5ende sparade svar \u00e4r kvar och kan laddas p\u00e5 en annan dator</p>\n<p>Om du har problem med att svara <em>any</em> var sn\u00e4ll och kontakta din l\u00e4rare f\u00f6r hj\u00e4lp.</p>", "jme.typecheck.function maybe implicit multiplication": "Operationen {{name}} \u00e4r inte definierad. Menade du <br/><code>{{first}}*{{possibleOp}}(...)</code>?", "part.jme.answer too short": "Ditt svar \u00e4r f\u00f6r kort", "matrixmath.mul.different sizes": "Kan inte multiplicera matriser av olika storlekar.", "jme.func.switch.no default case": "Inget standardstatement fall f\u00f6r switch uttryck", "part.numberentry.zero sig fig": "Du kan inte avrunda ett svar till noll v\u00e4rdesiffror.", "frontpage.start": "Start", "result.question score": "Resultat", "part.mcq.choices missing": "Definition av valen saknas.", "question.score feedback.correct": "Ditt svar \u00e4r korrekt", "part.feedback": "Feedback", "question.score feedback.answered": "Besvarad.", "math.permutations.n less than k": "Kan inte ber\u00e4kna permutationer: n \u00e4r mindre \u00e4n k", "part.gapfill.feedback header": "<strong>Mellanrum {{index}}</strong>", "question.advice": "Tips", "vectormath.cross.matrix too big": "Kan inte ber\u00e4kna kors produkten av en matrix som inte \u00e4r $1 \\g\u00e5nger N$ eller $N \\g\u00e5nger 1$.", "part.jme.not-allowed bits": " <span class=\"monospace\">{{string}}</span>", "display.part.jme.error making maths": "Ett fel uppstod n\u00e4r math display skulle skapas", "part.prompt": "Meddelande", "control.proceed anyway": "Forts\u00e4tt \u00e4nd\u00e5?", "gap": "mellanrum", "jme.tokenise.invalid": "Ogiltigt uttryck: <code>{{expression}}</code>", "result.score": "Po\u00e4ng", "math.lcm.complex": "Kan inte ber\u00e4kna MGM av komplexa tal ", "exam.random seed": "Sessions ID:", "modal.ok": "OK", "was": "var", "jme.thtml.not html": "THTML konstrukt\u00f6ren fick ett icke HTML v\u00e4rde.", "question.score feedback.partial": "Ditt svar \u00e4r delvis korrekt", "mathjax.error with context": "MathJax felaktig process i {{context}}: {{message}}", "question.score feedback.wrong": "Ditt svar \u00e4r inkorrekt", "question.score feedback.score actual": "Po\u00e4ng: {{scoreString}}", "part.numberentry.correct except fraction": "Ditt svar \u00e4r i r\u00e4tt intervall, dock till\u00e5ts inte br\u00e5k.", "question.error": "Fr\u00e5ga {{number}}: {{message}}", "jme.evaluate.no scope given": "Numbas.jme.evaluate m\u00e5ste ges ett intervall.", "question.show steps already penalised": "Du har redan visat stegen. Du kan nu \u00f6ppna dem igen utan po\u00e4ngavdrag.", "part.jme.answer missing": "Korrekt svar saknas", "part.mcq.no choices selected": "Inga svar \u00e4r valda.", "die.script not loaded": "Numbas kunde inte startas f\u00f6r att filen <code>{{file}}</code> inte laddades. Unders\u00f6k om filen finns med i <code>scripts.js</code>.", "part.numberentry.precision type.dp": "decimal", "part.matrix.answer invalid": "Ditt svar \u00e4r inte giltigt.", "jme.variables.question took too many runs to generate variables": "Ett set av fr\u00e5gevariabler kunde inte genereras i tid", "jme.texsubvars.no right brace": "Ingen matchande <code>}</code> in {{op}}", "page.loading": "Laddar...", "part.jme.marking.correct": "Ditt svar \u00e4r numeriskt korrekt.", "part.marking.correct": "Ditt svar \u00e4r korrekt.", "part.matrix.size mismatch": "Dimensionerna p\u00e5 svaret \u00e4r inte \u00f6ppna f\u00f6r \u00e4ndring, det korrekta dimensionen \u00e4r: \n{{correct_dimensions}} medan svaret givet \u00e4r: {{input_dimensions}}", "exam.feedback": "Prov, feedback meddelande", "part.marking.used variable replacements": "Denna del r\u00e4ttades enligt dina tidigare svar", "control.submit": "Skicka", "jme.shunt.no left square bracket": "Ingen matchande v\u00e4nster-bracket", "jme.func.listval.invalid index": "index f\u00f6r lista \u00e4r ogiltig  {{index}} p\u00e5 lista av storlek {{size}}", "question.score feedback.hide": "G\u00f6m feedback", "jme.variables.circular reference": "Circular variable reference in definition of <code>{{name}}</code>", "result.time spent": "Tid anv\u00e4nt:", "die.error": "Fel", "timing.time remaining": "Tid Kvar:", "part.numberentry.negative decimal places": "Denna del avrundar studentens svar till ett negativt nummer decimaler. Ogiltigt kommando.", "part.with steps answer prompt": "Svar: ", "control.confirm leave": "Du har inte avslutat ditt prov", "jme.typecheck.op not defined": "Operationen {{op}} \u00e4r inte definierad.", "part": "del", "control.submit again": "Skicka in igen", "xml.error in variable definition": "En variabel kunde inte definieras:  <code>{{name}}</code>", "exam.changeQuestion.no questions": "Detta prov inneh\u00e5ller inga fr\u00e5gor! Unders\u00f6k .exam filen f\u00f6r att hitta fel.", "part.jme.must-have bits": "<span class=\"monospace\">{{string}}</span>", "part.marking.total score": "Du fick <strong>{{count,niceNumber}}</strong> $t(mark) po\u00e4ng f\u00f6r denna del.", "exam.introduction": "Prov introduktion", "control.confirm regen": "Vill du skapa en ny version av fr\u00e5gan? Om du v\u00e4ljer OK f\u00f6rsvinner alla dina eventuella svar och po\u00e4ng samt fr\u00e5gan \u00e4ndras.", "jme.evaluate.undefined variable": "Variabeln {{name}} \u00e4r odefinierad", "jme.display.simplifyTree.no scope given": "Numbas.jme.display.simplify Tr\u00e4det m\u00e5ste ges en omfattning", "timing.no accumulator": "Ingen tids-ackumulator {{name}}", "util.product.non list": "En icke lista gavs till <code>Numbas.util.product</code>", "part.marking.revealed steps no penalty": "Du har \u00f6ppnat steg l\u00f6sningen.", "part.jme.unexpected variable name suggestion": "Ditt svar verkar inneh\u00e5lla en ogiltigt variabelnamn <code>{{name}}</code>. Menade du <code>{{suggestion}}</code>?", "jme.display.collectRuleset.set not defined": "Regelsamlingen {{name}} har inte definierats", "was_plural": "var", "part.marking.no result": "Denna del kunde inte r\u00e4ttas", "part.setting not present": "Egenskap '{{property}}' inte satt", "exam.number of questions": "Antal fr\u00e5gor:", "part.numberentry.answer not integer or decimal": "Ditt svar \u00e4r felaktigt. Du m\u00e5ste anv\u00e4nda heltal eller decimaler.", "question.selector.unsubmitted changes": "Ickesparade \u00e4ndringar", "vectormath.dot.matrix too big": "Kan inte ber\u00e4kna dot produkten av en matrix som inte \u00e4r $1 \\times N$ eller $N \\times 1$.", "scorm.no exam suspend data": "Kunde inte \u00e5teruppta: ingen tidigare data hittades.", "math.permutations.n less than zero": "Kan inte ber\u00e4kna permutationer: n \u00e4r mindre \u00e4n 0", "part.matrix.empty": "Du har inte skrivit n\u00e5got svar.", "part.jme.must-have several": "Ditt svar m\u00e5ste inneh\u00e5lla alla: {{strings}}", "part.patternmatch.display answer missing": "visat svar saknas", "math.precround.complex": "Kan inte avrunda till ett komplext tal", "jme.func.matrix.invalid row type": "Kan inte konstruera ett matrix fr\u00e5n rader av text {{type}}", "jme.tokenise.keypair key not a string": "Ordboks nyckeln b\u00f6r vara en \"string\" inte {{type}}.", "jme.shunt.no left bracket": "Ingen matchande v\u00e4nster-bracket", "result.exam summary": "Summering prov", "jme.typecheck.no right type definition": "Ingen definition av '{{op}}' av korrekt typ hittades", "exam.time allowed": "Till\u00e5ten tid", "question.statement": "P\u00e5st\u00e5ende", "xml.property not number": "Egenskap {{name}} borde vara en siffra, men \u00e4r det inte ({{value}}), i node {{element}}", "exam.exam name": "Namn p\u00e5 prov:", "control.previous": "F\u00f6reg\u00e5ende"}}, "ar-sa": {"translation": {"jme.typecheck.no right type unbound name": "Variable <code>{{name}}</code> is not defined.", "control.pause": "\u0625\u064a\u0642\u0627\u0641 \u0645\u0624\u0642\u062a", "feedback.taken away": "<strong>{{count,niceNumber}}</strong> $t(mark) $t(was) taken away.", "question.score feedback.unanswered": "Unanswered.", "control.reveal": "\u0643\u0634\u0641 \u0627\u0644\u0625\u062c\u0627\u0628\u0627\u062a", "part.marking.steps no matter": "\u0628\u0633\u0628\u0628 \u062d\u0635\u0648\u0644\u0643 \u0639\u0644\u0649 \u0639\u0644\u0627\u0645\u0627\u062a \u0643\u0627\u0645\u0644\u0629 \u0644\u0644\u062c\u0632\u0621\u060c \u0625\u062c\u0627\u0628\u0627\u062a\u0643 \u0639\u0644\u0649 \u0627\u0644\u062e\u0637\u0648\u0627\u062a \u0644\u0646 \u062a\u062d\u062a\u0633\u0628.", "part.marking.resubmit because of variable replacement": "This part's marking depends on your answers to other parts, which you have changed. Submit this part again to update your score.", "question.no such part": "Can't find part {{path}}", "control.back to results": "\u0627\u0644\u0639\u0648\u062f\u0629 \u0625\u0644\u0649 \u0627\u0644\u0646\u062a\u0627\u0626\u062c", "part.unknown type": "{{part}}: Unrecognised part type {{type}}", "result.click a question to review": "\u0627\u0636\u063a\u0637 \u0639\u0644\u0649 \u0631\u0642\u0645 \u0633\u0624\u0627\u0644 \u0644\u0631\u0624\u064a\u0629 \u0643\u064a\u0641\u064a\u0629 \u062a\u0642\u064a\u064a\u0645 \u0627\u062c\u0627\u0628\u0627\u062a\u0643\u060c \u0648\u0627\u0644\u062d\u0644\u0648\u0644 \u0627\u0644\u0643\u0627\u0645\u0644\u0629 \u0627\u0644\u0645\u062a\u0648\u0641\u0631\u0629.", "part.missing type attribute": "{{part}}: Missing part type attribute", "matrixmath.abs.non-square": "Can't compute the determinant of a matrix which isn't square.", "result.performance summary": "Performance Summary", "die.numbas failed": "\u0641\u0634\u0644 Numbas ", "jme.shunt.no left bracket in function": "No matching left bracket in function application or tuple", "part.mcq.matrix cell empty": "Part {{part}} marking matrix cell ({{row}},{{column}}) is empty", "question.score feedback.show": "Show feedback", "part.script.error": "Error in part {{path}} custom script {{script}}: {{message}}", "part.numberentry.precision type.sigfig": "significant figure", "jme.variables.error computing dependency": "Error computing referenced variable <code>{{name}}</code>", "exam.passed": "\u0646\u062c\u0627\u062d", "result.questions attempted": "Questions Attempted:", "control.not all questions submitted": "\u0644\u0642\u062f \u0642\u0645\u062a \u0628\u062a\u0639\u062f\u064a\u0644 \u0625\u062c\u0627\u0628\u0629 \u0623\u0648 \u0623\u0643\u062b\u0631 \u0648\u0644\u0645 \u062a\u0642\u0645 \u0628\u062a\u0623\u0643\u064a\u062f \u0627\u0644\u062a\u0639\u062f\u064a\u0644. \u064a\u0631\u062c\u0649 \u062a\u0623\u0643\u064a\u062f \u062a\u0639\u062f\u064a\u0644\u0627\u062a\u0643 \u0644\u0643\u0644 \u0627\u0644\u0623\u0633\u0626\u0644\u0629.", "exam.student name": "\u0627\u0633\u0645 \u0627\u0644\u0637\u0627\u0644\u0628", "scorm.no question suspend data": "No question suspend data", "result.exam start": "\u0628\u062f\u0621 \u0627\u0644\u0627\u0645\u062a\u062d\u0627\u0646:", "part.extension.not implemented": "Part hasn't implemented the <code>{{name}}</code> method.", "xml.property not boolean": "Property {{name}} should be a boolean, but isn't ({{value}}), in node {{element}}", "feedback.you were awarded": "You were awarded <strong>{{count,niceNumber}}</strong> $t(mark).", "jme.variables.variable not defined": "Variable <code>{{name}}</code> is not defined.", "question.loaded name mismatch": "Can't resume this attempt - the package has changed since the last session.", "control.confirm end": "Are you sure you want to end the exam? After you end the exam, you will not be able to change any of your answers.", "result.exam stop": "\u0627\u0646\u062a\u0647\u0627\u0621 \u0627\u0644\u0627\u0645\u062a\u062d\u0627\u0646:", "exam.review header": "\u0645\u0631\u0627\u062c\u0639\u0629", "jme.display.collectRuleset.no sets": "No sets given to collectRuleset!", "result.exit": "Exit Exam", "scorm.error initialising": "Error initialising SCORM protocol: {{message}}", "exam.pass percentage": "\u0646\u0633\u0628\u0629 \u0627\u0644\u0646\u062c\u0627\u062d", "math.permutations.complex": "Can't compute permutations of complex numbers", "scorm.error loading part": "Error loading part {{part}}: {{message}}", "part.mcq.options def not a list": "The expression defining the {{properties}} is not a list.", "part.mcq.matrix mix of numbers and lists": "Mix of numbers and lists used in marking matrix.", "part.marking.variable replacement part not answered": "You must answer {{part}} first", "part.marking.did not answer": "You did not answer this question.", "jme.shunt.missing operator": "Expression can't be evaluated -- missing an operator.", "suspend.paused header": "Paused", "part.mcq.matrix wrong size": "Marking matrix is the wrong size.", "part.mcq.matrix jme error": "Part {{part}} marking matrix cell ({{row}},{{column}}) gives a JME error: {{error}}", "end.exam has finished": "\u0647\u0630\u0627 \u0627\u0644\u0627\u0645\u062a\u062d\u0627\u0646 \u0642\u062f \u0627\u0646\u062a\u0647\u0649. \u0628\u0625\u0645\u0643\u0627\u0646\u0643 \u0627\u063a\u0644\u0627\u0642 \u0647\u0630\u0647 \u0627\u0644\u0646\u0627\u0641\u0630\u0629.", "suspend.exam suspended": "\u0627\u0644\u0627\u0645\u062a\u062d\u0627\u0646 \u0645\u062a\u0648\u0642\u0641 \u0628\u0634\u0643\u0644 \u0645\u0624\u0642\u062a. \u0627\u0636\u063a\u0637 <em>\u0645\u062a\u0627\u0628\u0639\u0629</em> \u0644\u0644\u0627\u0633\u062a\u0645\u0631\u0627\u0631.", "jme.texsubvars.missing parameter": "Missing parameter in {{op}}: {{parameter}}", "part.numberentry.precision type.sigfig_plural": "significant figures", "math.lt.order complex numbers": "Can't order complex numbers", "control.confirm reveal": "Would you like to reveal the answer to this question? Any marks you have received so far will be locked and you will not be able to answer this question later.", "part.patternmatch.correct except case": "Your answer is correct, except for the case.", "part.marking.not submitted": "No answer submitted", "jme.variables.error making function": "Error making function <code>{{name}}</code>: {{message}}", "exam.xml.bad root": "Root element of exam XML should be 'exam'", "part.mcq.matrix not a number": "Part {{part}} marking matrix cell ({{row}},{{column}}) does not evaluate to a number", "question.score feedback.score total": "{{marksString}}. Answered.", "question.show steps penalty": "You will lose <strong>{{count,niceNumber}}</strong> $t(mark).", "question.unsubmitted changes_plural": "You have made changes to your answers but not submitted them. Please check your answers to each part and then press the <strong>Submit all parts</strong> button.", "question.show steps no penalty": "Your score will not be affected.", "scorm.no part suspend data": "No part suspend data", "jme.typecheck.function not defined": "Operation <code>{{op}}</code> is not defined. Is <code>{{op}}</code> a variable, and did you mean <code>{{suggestion}}*(...)</code>?", "part.marking.revealed steps with penalty": "You revealed the steps. The maximum you can score for this part is <strong>{{count,niceNumber}}</strong> $t(mark). Your scores will be scaled down accordingly.", "question.unsubmitted changes": "You have made a change to your answer but not submitted it. Please check your answer and then press the <strong>Submit answer</strong> button.", "ruleset.circular reference": "Circular reference in definition of ruleset <code>{{name}}</code>", "math.combinations.n less than zero": "Can't compute combinations: n is less than zero", "part.marking.incorrect": "Your answer is incorrect.", "jme.variables.empty definition": "Definition of variable <code>{{name}}</code> is empty.", "question.preamble.syntax error": "Syntax error in preamble", "util.equality not defined for type": "Equality not defined for type {{type}}", "ruleset.set not defined": "Ruleset {{name}} has not been defined", "result.question review title": "\u0645\u0631\u0627\u062c\u0639\u0629 \u0647\u0630\u0627 \u0627\u0644\u0633\u0624\u0627\u0644", "jme.shunt.no right bracket": "No matching right bracket", "die.sorry": "\u0639\u0630\u0631\u0627\u064b\u060c \u062d\u0635\u0644 \u062e\u0637\u0623 \u0641\u064a Numbas \u0648\u0644\u0627 \u064a\u0645\u0643\u0646 \u0627\u0644\u0645\u062a\u0627\u0628\u0639\u0629.\n\u0641\u064a\u0645\u0627 \u064a\u0644\u064a \u0648\u0635\u0641 \u0627\u0644\u062e\u0637\u0623.", "control.end exam": "\u0625\u0646\u0647\u0627\u0621 \u0627\u0644\u0627\u0645\u062a\u062d\u0627\u0646", "vectormath.cross.not 3d": "Can only take the cross product of 3-dimensional vectors.", "part.mcq.matrix not a list": "Marking matrix, defined by JME expression, is not a list but it should be.", "part.marking.nothing entered": "You did not enter an answer.", "part.numberentry.give your answer as a reduced fraction": "Reduce your answer to lowest terms.", "mark_plural": "marks", "question.hide steps no penalty": "Your score will not be affected.", "step": "step", "part.numberentry.correct except decimal": "Your answer is within the allowed range, but decimal numbers are not allowed.", "question.can not submit": "Can not submit answer - check for errors.", "math.choose.empty selection": "Empty selection given to random function", "part.jme.answer too long": "Your answer is too long.", "mathjax.error": "MathJax processing error: {{message}}", "control.submit answer": "\u0623\u0631\u0633\u0644 \u0627\u0644\u0625\u062c\u0627\u0628\u0629", "exam.failed": "\u0641\u0634\u0644", "part.jme.not-allowed one": "Your answer must not contain: {{strings}}", "jme.shunt.not enough arguments": "Not enough arguments for operation {{op}}", "question.answer submitted": "Answer submitted", "part.jme.must-have one": "Your answer must contain: {{strings}}", "part.correct answer": "Expected answer:", "part.numberentry.answer not reduced": "Your answer is not reduced to lowest terms.", "control.next": "\u0627\u0644\u062a\u0627\u0644\u064a", "part.mcq.marking matrix string empty": "The custom marking matrix expression is empty.", "matrixmath.abs.too big": "Sorry, can't compute the determinant of a matrix bigger than 3x3 yet.", "question.score feedback.ascore total actual": "Score: {{score,niceNumber}}/{{marks,niceNumber}}", "jme.texsubvars.no right bracket": "No matching <code>]</code> in {{op}} arguments.", "mathjax.math processing error": "\"{{message}}\" when texifying <code>{{expression}}</code>", "jme.matrix.reports bad size": "Matrix reports its size incorrectly - must be an error in constructor function", "part.marking.steps change": "You were awarded <strong>{{count,niceNumber}}</strong> $t(mark) for your answers to the steps.", "part.mcq.choices": "choices", "part.jme.answer invalid": "Your answer is not a valid mathematical expression.<br/>{{message}}.", "jme.shunt.list mixed argument types": "Can't parse {{mode}}: mix of dictionary and list elements", "jme.func.except.continuous range": "Can't use the 'except' operator on continuous ranges.", "exam.marks available": "\u0627\u0644\u062f\u0631\u062c\u0627\u062a \u0627\u0644\u0645\u062a\u0627\u062d\u0629", "math.combinations.k less than zero": "Can't compute combinations: k is less than zero", "result.question number": "\u0631\u0642\u0645 \u0627\u0644\u0633\u0624\u0627\u0644", "control.submit all parts": "\u0623\u0631\u0633\u0644 \u0643\u0644 \u0627\u0644\u0623\u062c\u0632\u0627\u0621", "jme.func.listval.not a list": "Object is not subscriptable", "part.numberentry.give your answer to precision": "Round your answer to {{count,niceNumber}} {{precisionType}}.", "part.mcq.wrong number of choices": "You selected the wrong number of choices.", "jme.variables.syntax error in function definition": "Syntax error in function definition", "page.saving": "<p>Saving.</p>\n<p>This might take a few seconds.</p>", "math.gcf.complex": "Can't compute GCF of complex numbers", "part.matrix.some incorrect": "One or more of the cells in your answer is incorrect, but you have been awarded marks for the rest.", "math.combinations.complex": "Can't compute combinations of complex numbers", "control.total": "\u0627\u0644\u0645\u062c\u0645\u0648\u0639", "jme.user javascript.error": "Error in user-defined javascript function <code>{{name}}</code>: {{message}}", "part.matrix.invalid cell": "One or more of the cells in your answer is empty or invalid.", "scorm.error loading question": "Error loading question {{number}}: {{message}}", "part.numberentry.give your answer to precision_0": "Round your answer to the nearest integer.", "jme.shunt.no right square bracket": "No matching right square bracket to end list", "control.not all questions answered": "\u0644\u0645 \u062a\u0642\u0645 \u0628\u0625\u0643\u0645\u0627\u0644 \u0643\u0644 \u0627\u0644\u0623\u0633\u0626\u0644\u0629 \u0641\u064a \u0647\u0630\u0627 \u0627\u0644\u0627\u0645\u062a\u062d\u0627\u0646.", "jme.display.unknown token type": "Can't texify token type {{type}}", "part.numberentry.answer invalid": "You did not enter a valid number.", "jme.user javascript.returned undefined": "User-defined javascript function <code>{{name}}</code> returned <code>undefined</code>.", "question.hide steps": "Hide steps", "part.mcq.matrix wrong type": "Element of invalid type '{{type}}' used in marking matrix.", "math.combinations.n less than k": "Can't compute combinations: n is less than k", "mark": "mark", "suspend.you can resume": "You will be able to resume this session the next time you start this activity.", "scorm.error loading suspend data": "Error loading suspend data: {{message}}", "result.result": "\u0627\u0644\u0646\u062a\u064a\u062c\u0629:", "question.show steps": "Show steps", "question.submit part": "Submit part", "part.jme.unexpected variable name": "Your answer was interpreted to use the unexpected variable name <code>{{name}}</code>.", "part.matrix.empty cell": "One or more of the cells in your answer is empty.", "control.regen": "Try another question like this one", "control.advice": "Advice", "xml.could not load": "Couldn't load an XML document: {{message}}", "part.marking.uncaught error": "Error when marking {{part}}: {{message}}", "result.print": "Print this results summary", "math.siground.complex": "Can't round to a complex number of sig figs", "question.header": "Question {{number}}", "math.permutations.k less than zero": "Can't compute permutations: k is less than zero", "question.preamble.error": "Error in preamble: {{message}}", "suspend.resume": "\u0645\u062a\u0627\u0628\u0639\u0629", "part.mcq.correct choice": "You chose the correct answer.", "part.numberentry.answer not integer": "Your answer is invalid. You must enter a whole number, not a decimal.", "part.jme.not-allowed several": "Your answer must not contain any of: {{strings}}", "part.numberentry.precision type.dp_plural": "decimal places", "question.unsupported part type": "Unsupported part type", "jme.variables.error evaluating variable": "Error evaluating variable {{name}}: {{message}}", "jme.func.listval.key not in dict": "Dictionary does not contain the key <code>{{key}}</code>", "part.mcq.answers": "answers", "jme.typecheck.map not on enumerable": "<code>map</code> operation must work over a list or a range, not {{type}}", "jme.substituteTree.undefined variable": "Undefined variable: <code>{{name}}</code>", "modal.cancel": "\u0627\u0644\u063a\u0627\u0621", "scorm.failed save": "<p>The request to save data to the server failed. Press <b>OK</b> to try again.</p>\n<p>If you get this message repeatedly, check your internet connection or use a different computer. Your previously submitted answers have been successfully saved and will be restored if you resume this session on a different computer.</p>\n<p>If this message appears persistently and you can't save <em>any</em> answers, please contact your lecturer or teacher.</p>", "jme.typecheck.function maybe implicit multiplication": "Operation {{name}} is not defined. Did you mean <br/><code>{{first}}*{{possibleOp}}(...)</code>?", "part.jme.answer too short": "Your answer is too short.", "matrixmath.mul.different sizes": "\u0644\u0627 \u064a\u0645\u0643\u0646 \u062c\u062f\u0627\u0621 \u0645\u0635\u0641\u0648\u0641\u0627\u062a \u0645\u062e\u062a\u0644\u0641\u0629 \u0627\u0644\u0623\u062d\u062c\u0627\u0645.", "jme.func.switch.no default case": "No default case for Switch statement", "part.numberentry.zero sig fig": "This part is set up to round the student's answer to zero significant figures, which has no meaning.", "frontpage.start": "\u0627\u0644\u0628\u062f\u0621", "result.question score": "Score", "part.mcq.choices missing": "Definition of choices is missing", "question.score feedback.correct": "Your answer is correct", "part.feedback": "feedback", "question.score feedback.answered": "Answered.", "math.permutations.n less than k": "Can't compute permutations: n is less than k", "part.gapfill.feedback header": "<strong>Gap {{index}}</strong>", "question.advice": "Advice", "vectormath.cross.matrix too big": "Can't calculate cross product of a matrix which isn't $1 \\times N$ or $N \\times 1$.", "part.jme.not-allowed bits": "<span class=\"monospace\">{{string}}</span>", "display.part.jme.error making maths": "Error making maths display", "part.prompt": "prompt", "control.proceed anyway": "Proceed anyway?", "gap": "gap", "jme.tokenise.invalid": "Invalid expression: <code>{{expression}}</code>", "result.score": "Score:", "math.lcm.complex": "Can't compute LCM of complex numbers", "exam.random seed": "Session ID:", "modal.ok": "\u0645\u0648\u0627\u0641\u0642", "was": "was", "jme.thtml.not html": "Passed a non-HTML value into the THTML constructor.", "question.score feedback.partial": "Your answer is partially correct", "mathjax.error with context": "MathJax processing error in {{context}}: {{message}}", "question.score feedback.wrong": "Your answer is incorrect", "question.score feedback.score actual": "Score: {{scoreString}}", "part.numberentry.correct except fraction": "Your answer is within the allowed range, but fractions are not allowed.", "question.error": "Question {{number}}: {{message}}", "jme.evaluate.no scope given": "Numbas.jme.evaluate must be given a Scope", "question.show steps already penalised": "You have already shown steps. You can show them again with no further penalty.", "part.jme.answer missing": "Correct answer is missing", "part.mcq.no choices selected": "No choices selected.", "die.script not loaded": "Numbas couldn't start because the file <code>{{file}}</code> was not loaded. Check that it's included in <code>scripts.js</code>.", "part.numberentry.precision type.dp": "decimal place", "part.matrix.answer invalid": "Your answer is not valid.", "jme.variables.question took too many runs to generate variables": "A valid set of question variables was not generated in time.", "jme.texsubvars.no right brace": "No matching <code>}</code> in {{op}}", "page.loading": "\u062a\u062d\u0645\u064a\u0644...\n\u062a\u062d\u0645\u064a\u0644 \u0627\u0644\u0635\u0641\u062d\u0629", "part.jme.marking.correct": "Your answer is numerically correct.", "part.marking.correct": "Your answer is correct.", "part.matrix.size mismatch": "The question author hasn't allowed the student to decide the dimensions of their answer, but the correct answer is {{correct_dimensions}} while the answer input is {{input_dimensions}}", "exam.feedback": "Exam feedback message", "part.marking.used variable replacements": "This part was marked using your answers to previous parts.", "control.submit": "\u0623\u0631\u0633\u0644", "jme.shunt.no left square bracket": "No matching left bracket", "jme.func.listval.invalid index": "Invalid list index {{index}} on list of size {{size}}", "question.score feedback.hide": "Hide feedback", "jme.variables.circular reference": "Circular variable reference in definition of <code>{{name}}</code>", "result.time spent": "\u0627\u0644\u0648\u0642\u062a \u0627\u0644\u0645\u0646\u0642\u0636\u064a:", "die.error": "\u062e\u0637\u0623", "timing.time remaining": "Time remaining:", "part.numberentry.negative decimal places": "This part is set up to round the student's answer to a negative number of decimal places, which has no meaning.", "part.with steps answer prompt": "\u0627\u0644\u0625\u062c\u0627\u0628\u0629:", "control.confirm leave": "\u0644\u0645 \u062a\u0646\u0647\u064a \u0627\u0644\u0627\u0645\u062a\u062d\u0627\u0646.", "jme.typecheck.op not defined": "Operation '{{op}}' is not defined.", "part": "part", "control.submit again": "\u0623\u0631\u0633\u0644 \u0645\u0631\u0629 \u062b\u0627\u0646\u064a\u0629", "xml.error in variable definition": "Error in definition of variable <code>{{name}}</code>", "exam.changeQuestion.no questions": "\u0647\u0630\u0627 \u0627\u0644\u0627\u0645\u062a\u062d\u0627\u0646 \u0644\u0627 \u064a\u062d\u0648\u064a \u0623\u064a \u0623\u0633\u0626\u0644\u0629! \u062a\u0623\u0643\u062f \u0645\u0646 \u062e\u0644\u0648 \u0645\u0644\u0641 exam. \u0645\u0646 \u0627\u0644\u0623\u062e\u0637\u0627\u0621.", "part.jme.must-have bits": "<span class=\"monospace\">{{string}}</span>", "part.marking.total score": "You scored <strong>{{count,niceNumber}}</strong> $t(mark) for this part.", "exam.introduction": "Exam introduction", "control.confirm regen": "Would you like to re-randomise this question? If you click OK, all your answers and marks for the current question will be lost.", "jme.evaluate.undefined variable": "Variable {{name}} is undefined", "jme.display.simplifyTree.no scope given": "Numbas.jme.display.simplifyTree must be given a Scope", "timing.no accumulator": "no timing accumulator {{name}}", "util.product.non list": "Passed a non-list to <code>Numbas.util.product</code>", "part.marking.revealed steps no penalty": "You revealed the steps.", "part.jme.unexpected variable name suggestion": "Your answer was interpreted to use the unexpected variable name <code>{{name}}</code>. Did you mean <code>{{suggestion}}</code>?", "jme.display.collectRuleset.set not defined": "Ruleset {{name}} has not been defined", "was_plural": "were", "part.marking.no result": "This part could not be marked.", "part.setting not present": "Property '{{property}}' not set", "exam.number of questions": "\u0639\u062f\u062f \u0627\u0644\u0623\u0633\u0626\u0644\u0629", "part.numberentry.answer not integer or decimal": "Your answer is invalid. You must enter an integer or a decimal.", "question.selector.unsubmitted changes": "Unsubmitted changes.", "vectormath.dot.matrix too big": "Can't calculate dot product of a matrix which isn't $1 \\times N$ or $N \\times 1$.", "scorm.no exam suspend data": "Failed to resume: no exam suspend data.", "math.permutations.n less than zero": "Can't compute permutations: n is less than zero", "part.matrix.empty": "You have not entered an answer.", "part.jme.must-have several": "Your answer must contain all of: {{strings}}", "part.patternmatch.display answer missing": "Display answer is missing", "math.precround.complex": "Can't round to a complex number of decimal places", "jme.func.matrix.invalid row type": "\u0644\u0627 \u064a\u0645\u0643\u0646 \u0625\u0646\u0634\u0627\u0621 \u0645\u0635\u0641\u0648\u0641\u0629 \u0645\u0646 \u0623\u0633\u0637\u0631 \u0645\u0646 \u0627\u0644\u0646\u0648\u0639 {{type}}.", "jme.tokenise.keypair key not a string": "Dictionary key should be a string, not {{type}}.", "jme.shunt.no left bracket": "No matching left bracket", "result.exam summary": "Exam Summary", "jme.typecheck.no right type definition": "No definition of '{{op}}' of correct type found.", "exam.time allowed": "\u0627\u0644\u0648\u0642\u062a \u0627\u0644\u0645\u062a\u0627\u062d", "question.statement": "Statement", "xml.property not number": "Property {{name}} should be a number, but isn't ({{value}}), in node {{element}}", "exam.exam name": "\u0627\u0633\u0645 \u0627\u0644\u0627\u0645\u062a\u062d\u0627\u0646", "control.previous": "\u0627\u0644\u0633\u0627\u0628\u0642"}}, "en-gb": {"translation": {"jme.typecheck.no right type unbound name": "Variable <code>{{name}}</code> is not defined.", "control.pause": "Pause", "answer.number.not a number": "Your answer is not a valid number.", "question.score feedback.unanswered": "Unanswered", "part.numberentry.give your answer as a reduced fraction": "Reduce your answer to lowest terms.", "jme.tokenise.number.object not complex": "Invalid object passed into number constructor.", "answer.jme.invalid expression": "{{-message}}", "control.reveal": "Reveal answers", "math.permutations.complex": "Can't compute permutations of complex numbers", "part.marking.resubmit because of variable replacement": "This part's marking depends on your answers to other parts, which you have changed. Submit this part again to update your score.", "variable.error in variable definition": "Error in definition of variable <code>{{name}}</code>", "question.no such part": "Can't find part {{path}}", "control.back to results": "Go back to results", "xml.property not number": "Property {{name}} should be a number, but isn't ({{value}}), in node {{element}}", "part.numberentry.zero sig fig": "This part is set up to round the student's answer to zero significant figures, which has no meaning.", "result.click a question to review": "Click on a question number to see how your answers were marked and, where available, full solutions.", "part.missing type attribute": "{{part}}: Missing part type attribute", "matrixmath.abs.non-square": "Can't compute the determinant of a matrix which isn't square.", "result.performance summary": "Performance Summary", "die.numbas failed": "Numbas has failed", "jme.shunt.no left bracket in function": "No matching left bracket in function application or tuple", "part.mcq.matrix cell empty": "Part {{part}} marking matrix cell ({{row}},{{column}}) is empty", "feedback.taken away": "<strong>{{count,niceNumber}}</strong> $t(mark) $t(was) taken away.", "part.script.error": "Error in part {{path}} custom script {{script}}: {{-message}}", "part.numberentry.precision type.sigfig": "significant figure", "jme.variables.error computing dependency": "Error computing referenced variable <code>{{name}}</code>", "exam.passed": "Passed", "result.questions attempted": "Questions Attempted:", "control.not all questions submitted": "You have made changes to one or more answers but not submitted them. Please check each question has been submitted.", "exam.student name": "Student's Name:", "scorm.no question suspend data": "No question suspend data", "part.marking.variable replacement part not answered": "You must answer {{part}} first", "control.confirm reveal no marks": "Would you like to reveal the answer to this question?", "xml.property not boolean": "Property {{name}} should be a boolean, but isn't ({{value}}), in node {{element}}", "feedback.you were awarded": "You were awarded <strong>{{count,niceNumber}}</strong> $t(mark).", "jme.variables.variable not defined": "Variable <code>{{name}}</code> is not defined.", "right brace": "}", "part.custom.error evaluating input option": "Error evaluating input option <code>{{option}}</code>: {{-error}}", "part.marking.did not answer": "You did not answer this question.", "result.exam stop": "Exam Stop:", "part.marking.missing required note": "The marking algorithm does not define the note <code>{{note}}</code>", "part.jme.answer too long": "Your answer is too long.", "jme.display.collectRuleset.no sets": "No sets given to collectRuleset!", "jme.tokenise.keypair key not a string": "Dictionary key should be a string, not {{type}}.", "scorm.error initialising": "Error initialising SCORM protocol: {{-message}}", "exam.pass percentage": "Pass Percentage:", "part.marking.steps no matter": "Because you received full marks for the part, your answers to the steps aren't counted.", "part.marking.error in marking script": "There was an error in this part's marking algorithm. Please report this. {{-message}}", "part.mcq.incorrect choice": "You chose an incorrect answer.", "part.mcq.options def not a list": "The expression defining the {{properties}} is not a list.", "jme.display.simplifyTree.empty expression": "Expression is empty", "part.jme.not-allowed bits": "<span class=\"monospace\">{{string}}</span>", "result.exam start": "Exam Start:", "control.confirm end": "Are you sure you want to end the exam? After you end the exam, you will not be able to change any of your answers.", "jme.shunt.missing operator": "Expression can't be evaluated -- missing an operator.", "suspend.paused header": "Paused", "marking.note.empty expression": "The note <code>{{name}}</code> is empty.", "question.score feedback.show": "Show feedback", "part.mcq.matrix jme error": "Part {{part}} marking matrix cell ({{row}},{{column}}) gives a JME error: {{-error}}", "end.exam has finished": "The exam has finished. You may now close this window.", "part.mcq.matrix mix of numbers and lists": "Mix of numbers and lists used in marking matrix.", "scorm.no part suspend data": "No part suspend data", "suspend.exam suspended": "The Exam has been suspended. Press <em>Resume</em> to continue.", "part.mcq.no choices selected": "No choices selected.", "jme.texsubvars.missing parameter": "Missing parameter in {{op}}: {{parameter}}", "part.numberentry.precision type.sigfig_plural": "significant figures", "part.custom.input option missing": "Definition of input option <code>{{option}}</code> is missing.", "control.confirm reveal": "Would you like to reveal the answer to this question? Any marks you have received so far will be locked and you will not be able to answer this question later.", "part.patternmatch.correct except case": "Your answer is correct, except for the case.", "part.marking.not submitted": "No answer submitted.", "jme.variables.error making function": "Error making function <code>{{name}}</code>: {{-message}}", "exam.xml.bad root": "Root element of exam XML should be 'exam'", "part.mcq.matrix not a number": "Part {{part}} marking matrix cell ({{row}},{{column}}) does not evaluate to a number", "question.score feedback.score total": "{{marksString}}", "question.show steps penalty": "You will lose <strong>{{count,niceNumber}}</strong> $t(mark).", "question.unsubmitted changes_plural": "You have made changes to your answers but not submitted them. Please check your answers to each part and then press the <strong>Submit all parts</strong> button.", "question.show steps no penalty": "Your score will not be affected.", "jme.user javascript.returned undefined": "User-defined javascript function <code>{{name}}</code> returned <code>undefined</code>.", "math.niceNumber.undefined": "Was expecting a number, but got <code>undefined</code>", "jme.typecheck.function not defined": "Operation <code>{{op}}</code> is not defined. Is <code>{{op}}</code> a variable, and did you mean <code>{{suggestion}}*(...)</code>?", "part.marking.revealed steps with penalty": "You revealed the steps. The maximum you can score for this part is <strong>{{count,niceNumber}}</strong> $t(mark). Your scores will be scaled down accordingly.", "question.unsubmitted changes": "You have made a change to your answer but not submitted it. Please check your answer and then press the <strong>Submit answer</strong> button.", "ruleset.circular reference": "Circular reference in definition of ruleset <code>{{name}}</code>", "exam.feedback": "Exam feedback message", "part.marking.incorrect": "Your answer is incorrect.", "answer.number.fractions not allowed": "You may not enter a fraction.", "part.mcq.matrix wrong size": "Marking matrix is the wrong size.", "jme.variables.empty definition": "Definition of variable <code>{{name}}</code> is empty.", "question.preamble.syntax error": "Syntax error in preamble", "util.equality not defined for type": "Equality not defined for type {{type}}", "result.question review title": "Review this question", "jme.shunt.no right bracket": "No matching right bracket", "control.proceed anyway": "Proceed anyway?", "control.end exam": "End Exam", "vectormath.cross.not 3d": "Can only take the cross product of 3-dimensional vectors.", "part.marking.minimum score applied": "The minimum score for this part is <strong>{{score,niceNumber}}</strong>.", "part.mcq.matrix not a list": "Marking matrix, defined by JME expression, is not a list but it should be.", "part.marking.nothing entered": "You did not enter an answer.", "part.feedback out of date": "This feedback is based on your last submitted answer. Submit your changed answer to get updated feedback.", "mark_plural": "marks", "question.hide steps no penalty": "Your score will not be affected.", "step": "step", "marking.script.error parsing notes": "Error parsing marking script: {{- message}}", "question.score feedback.partially answered": "Partially answered", "part.numberentry.correct except decimal": "Your answer is within the allowed range, but decimal numbers are not allowed.", "question.can not submit": "Can not submit answer - check for errors.", "scorm.error loading part": "Error loading part {{part}}: {{-message}}", "part.marking.total score": "You scored <strong>{{count,niceNumber}}</strong> $t(mark) for this part.", "exam.review header": "Review: ", "mathjax.error": "MathJax processing error: {{-message}}", "die.script not loaded": "Numbas couldn't start because the file <code>{{file}}</code> was not loaded. Check that it's included in <code>scripts.js</code>.", "exam.failed": "Failed", "part.jme.not-allowed one": "Your answer must not contain: {{strings}}", "was_plural": "were", "jme.shunt.not enough arguments": "Not enough arguments for operation <code>{{op}}</code>", "question.answer submitted": "Answer submitted", "marking.note.compilation error": "Error compiling note <code>{{name}}</code>: {{-message}}", "math.choose.empty selection": "Empty selection given to random function", "part.correct answer": "Expected answer:", "part.numberentry.answer not reduced": "Your answer is not reduced to lowest terms.", "control.next": "Next", "part.mcq.marking matrix string empty": "The custom marking matrix expression is empty.", "question.show steps already penalised": "You have already shown steps. You can show them again with no further penalty.", "matrixmath.abs.too big": "Sorry, can't compute the determinant of a matrix bigger than 3x3 yet.", "part.error": "{{path}}: {{-message}}", "jme.texsubvars.no right bracket": "No matching <code>]</code> in {{op}} arguments.", "question.loaded name mismatch": "Can't resume this attempt - the package has changed since the last session.", "mathjax.math processing error": "\"{{-message}}\" when texifying <code>{{expression}}</code>", "jme.matrix.reports bad size": "Matrix reports its size incorrectly - must be an error in constructor function", "left brace": "{", "part.jme.must-have bits": "<span class=\"monospace\">{{string}}</span>", "part.marking.steps change": "You were awarded <strong>{{count,niceNumber}}</strong> $t(mark) for your answers to the steps.", "part.mcq.choices": "choices", "question.error creating question": "Error while creating question {{number}}: {{-message}}", "part.jme.answer invalid": "Your answer is not a valid mathematical expression.<br/>{{-message}}.", "jme.shunt.list mixed argument types": "Can't parse {{mode}}: mix of dictionary and list elements", "jme.func.except.continuous range": "Can't use the 'except' operator on continuous ranges.", "exam.marks available": "Marks Available:", "math.combinations.k less than zero": "Can't compute combinations: k is less than zero", "control.submit all parts": "Submit all parts", "jme.func.listval.not a list": "Object is not subscriptable", "part.numberentry.give your answer to precision": "Round your answer to {{count,niceNumber}} {{precisionType}}.", "part.mcq.wrong number of choices": "You selected the wrong number of choices.", "jme.variables.syntax error in function definition": "Syntax error in function definition", "page.saving": "<p>Saving.</p>\n<p>This might take a few seconds.</p>", "jme.tokenise.invalid near": "Invalid expression: <code>{{expression}}</code> at position {{position}} near <code>{{nearby}}</code>", "math.gcf.complex": "Can't compute GCF of complex numbers", "part.unknown type": "{{part}}: Unrecognised part type {{type}}", "frontpage.scorm.lms not connected": "This exam is running in standalone mode. Your answers and marks will not be saved!", "math.combinations.complex": "Can't compute combinations of complex numbers", "control.total": "Total", "jme.user javascript.error": "Error in user-defined javascript function <code>{{name}}</code>: {{-message}}", "part.matrix.invalid cell": "One or more of the cells in your answer is empty or invalid.", "scorm.error loading question": "Error loading question {{number}}: {{-message}}", "part.numberentry.give your answer to precision_0": "Round your answer to the nearest integer.", "jme.shunt.no right square bracket": "No matching right square bracket to end list", "control.not all questions answered": "You have not completed every question in this exam.", "part.jme.must-have one": "Your answer must contain: {{strings}}", "jme.display.unknown token type": "Can't texify token type {{type}}", "part.numberentry.answer invalid": "You did not enter a valid number.", "part.jme.unexpected variable name": "Your answer was interpreted to use the unexpected variable name <code>{{name}}</code>.", "jme.subvars.null substitution": "Empty variable substitution: <code>$t(left brace){{str}}$t(right brace)", "answer.matrix.fractions not allowed": "You may not enter fractions.", "question.hide steps": "Hide steps", "part.mcq.matrix wrong type": "Element of invalid type '{{type}}' used in marking matrix.", "math.combinations.n less than k": "Can't compute combinations: n is less than k", "marking.note.error evaluating note": "Error evaluating note <code>{{name}}</code> - {{-message}}", "mark": "mark", "suspend.you can resume": "You will be able to resume this session the next time you start this activity.", "scorm.error loading suspend data": "Error loading suspend data: {{-message}}", "result.result": "Result:", "question.show steps": "Show steps", "question.submit part": "Submit part", "control.submit answer": "Submit answer", "part.matrix.empty cell": "One or more of the cells in your answer is empty.", "control.regen": "Try another question like this one", "control.advice": "Advice", "xml.could not load": "Couldn't load an XML document: {{-message}}", "part.marking.uncaught error": "Error when marking {{part}}: {{-message}}", "question.score feedback.score total actual": "Score: {{score,niceNumber}}/{{marks,niceNumber}}", "result.print": "Print this results summary", "question.score feedback.not marked": "Not marked", "math.siground.complex": "Can't round to a complex number of sig figs", "question.header": "Question {{number}}", "part.numberentry.correct except fraction": "Your answer is within the allowed range, but fractions are not allowed.", "part.custom.unrecognised input type": "Unrecognised setting type <code>{{input_type}}</code>", "question.preamble.error": "Error in preamble: {{-message}}", "suspend.resume": "Resume", "jme.substituteTree.undefined variable": "Undefined variable: <code>{{name}}</code>", "part.jme.answer too short": "Your answer is too short.", "part.jme.not-allowed several": "Your answer must not contain any of: {{strings}}", "part.numberentry.precision type.dp_plural": "decimal places", "question.unsupported part type": "Unsupported part type", "part.custom.error evaluating setting": "Error evaluating setting <code>{{setting}}</code>: {{-error}}", "jme.variables.error evaluating variable": "Error evaluating variable {{name}}: {{-message}}", "part.mcq.answers": "answers", "jme.typecheck.map not on enumerable": "<code>map</code> operation must work over a list or a range, not {{type}}", "part.mcq.correct choice": "You chose a correct answer.", "modal.cancel": "Cancel", "marking.apply marking script.script not found": "Marking script <code>{{name}}</code> not found", "part.jme.answer missing": "Correct answer is missing", "part.numberentry.answer not integer": "Your answer is invalid. You must enter a whole number, not a decimal.", "gap": "gap", "matrixmath.mul.different sizes": "Can't multiply matrices of different sizes.", "control.previous": "Previous", "answer.matrix.some cell not a number": "One or more of the cells in your answer is not a valid number.", "marking.note.invalid definition": "Invalid note definition: <code>{{source}}</code>. {{-hint}}", "frontpage.start": "Start", "result.question score": "Score", "part.mcq.choices missing": "Definition of choices is missing", "question.score feedback.correct": "Your answer is correct", "part.feedback": "feedback", "question.score feedback.answered": "Answered", "math.permutations.n less than k": "Can't compute permutations: n is less than k", "part.gapfill.feedback header": "<strong>Gap {{index}}</strong>", "question.advice": "Advice", "scorm.failed save": "<p>The request to save data to the server failed. Press <b>OK</b> to try again.</p>\n<p>If you get this message repeatedly, check your internet connection or use a different computer. Your previously submitted answers have been successfully saved and will be restored if you resume this session on a different computer.</p>\n<p>If this message appears persistently and you can't save <em>any</em> answers, please contact your lecturer or teacher.</p>", "vectormath.cross.matrix too big": "Can't calculate cross product of a matrix which isn't $1 \\times N$ or $N \\times 1$.", "jme.func.listval.key not in dict": "Dictionary does not contain the key <code>{{key}}</code>", "display.part.jme.error making maths": "Error making maths display", "ruleset.set not defined": "Ruleset {{name}} has not been defined", "die.sorry": "Sorry, Numbas has encountered an error which means it can't continue. Below is a description of the error.", "part.matrix.not all cells same precision": "You have not given every cell in your answer to the same precision.", "part.matrix.empty": "You have not entered an answer.", "math.combinations.n less than zero": "Can't compute combinations: n is less than zero", "result.score": "Score:", "math.lcm.complex": "Can't compute LCM of complex numbers", "result.question number": "Question Number", "modal.ok": "OK", "was": "was", "jme.thtml.not html": "Passed a non-HTML value into the THTML constructor.", "question.score feedback.partial": "Your answer is partially correct", "marking.note.invalid definition.missing colon": "You might be missing a colon after the name and description", "question.score feedback.wrong": "Your answer is incorrect", "question.score feedback.score actual": "Score: {{scoreString}}", "math.permutations.k less than zero": "Can't compute permutations: k is less than zero", "question.error": "Question {{number}}: {{-message}}", "jme.evaluate.no scope given": "Numbas.jme.evaluate must be given a Scope", "part.custom.empty setting": "No value given.", "jme.typecheck.function maybe implicit multiplication": "Operation <code>{{name}}</code> is not defined. Did you mean <code>{{first}}*{{possibleOp}}(...)</code>?", "math.lt.order complex numbers": "Can't order complex numbers", "part.numberentry.precision type.dp": "decimal place", "part.extension.not implemented": "Part hasn't implemented the <code>{{name}}</code> method.", "part.matrix.answer invalid": "Your answer is not valid.", "jme.variables.question took too many runs to generate variables": "A valid set of question variables was not generated in time.", "jme.texsubvars.no right brace": "No matching <code>}</code> in {{op}}", "page.loading": "Loading...", "part.jme.marking.correct": "Your answer is numerically correct.", "mathjax.error with context": "MathJax processing error in {{-context}}: {{-message}}", "part.matrix.size mismatch": "The question author hasn't allowed the student to decide the dimensions of their answer, but the correct answer is {{correct_dimensions}} while the answer input is {{input_dimensions}}", "part.marking.used variable replacements": "This part was marked using your answers to previous parts.", "control.submit": "Submit", "jme.shunt.no left square bracket": "No matching left bracket", "jme.func.listval.invalid index": "Invalid list index {{index}} on list of size {{size}}", "question.score feedback.hide": "Hide feedback", "jme.variables.circular reference": "Circular variable reference in definition of <code>{{name}}</code>", "result.time spent": "Time Spent:", "die.error": "Error", "timing.time remaining": "Time remaining:", "part.numberentry.negative decimal places": "This part is set up to round the student's answer to a negative number of decimal places, which has no meaning.", "part.with steps answer prompt": "Answer: ", "marking.note.invalid definition.description missing closing bracket": "You might be missing a closing bracket", "control.confirm leave": "You haven't finished the exam.", "jme.typecheck.op not defined": "Operation '{{op}}' is not defined.", "part": "part", "control.confirm regen no marks": "Would you like to re-randomise this question?", "control.submit again": "Submit again", "exam.changeQuestion.no questions": "This exam contains no questions! Check the .exam file for errors.", "part.marking.correct": "Your answer is correct.", "exam.introduction": "Exam introduction", "control.confirm regen": "Would you like to re-randomise this question? If you click OK, all your answers and marks for the current question will be lost.", "jme.evaluate.undefined variable": "Variable {{name}} is undefined", "jme.display.simplifyTree.no scope given": "Numbas.jme.display.simplifyTree must be given a Scope", "part.marking.no result after replacement": "This part could not be marked using your answers to previous parts.", "timing.no accumulator": "no timing accumulator {{name}}", "util.product.non list": "Passed a non-list to <code>Numbas.util.product</code>", "part.marking.revealed steps no penalty": "You revealed the steps.", "part.jme.unexpected variable name suggestion": "Your answer was interpreted to use the unexpected variable name <code>{{name}}</code>. Did you mean <code>{{suggestion}}</code>?", "jme.display.collectRuleset.set not defined": "Ruleset {{name}} has not been defined", "part.matrix.some incorrect": "One or more of the cells in your answer is incorrect, but you have been awarded marks for the rest.", "marking.apply.not a list": "The first argument to <code>apply</code> must be a list, and isn't", "part.setting not present": "Property '{{property}}' not set", "exam.number of questions": "Number of Questions:", "part.numberentry.answer not integer or decimal": "Your answer is invalid. You must enter an integer or a decimal.", "question.selector.unsubmitted changes": "Unsubmitted changes.", "vectormath.dot.matrix too big": "Can't calculate dot product of a matrix which isn't $1 \\times N$ or $N \\times 1$.", "scorm.no exam suspend data": "Failed to resume: no exam suspend data.", "math.permutations.n less than zero": "Can't compute permutations: n is less than zero", "exam.random seed": "Session ID:", "part.jme.must-have several": "Your answer must contain all of: {{strings}}", "part.patternmatch.display answer missing": "Display answer is missing", "math.precround.complex": "Can't round to a complex number of decimal places", "jme.func.matrix.invalid row type": "Can't construct a matrix from rows of type {{type}}", "result.exit": "Exit Exam", "jme.shunt.no left bracket": "No matching left bracket", "result.exam summary": "Exam Summary", "jme.typecheck.no right type definition": "No definition of '{{op}}' of correct type found.", "exam.time allowed": "Time Allowed:", "question.statement": "Statement", "part.prompt": "prompt", "exam.exam name": "Exam Name:", "jme.func.switch.no default case": "No default case for Switch statement"}}, "it-it": {"translation": {"jme.typecheck.no right type unbound name": "Variable <code>{{name}}</code> is not defined.", "control.pause": "Pause", "feedback.taken away": "<strong>{{count,niceNumber}}</strong> $t(mark) $t(was) taken away.", "question.score feedback.unanswered": "Unanswered.", "control.reveal": "Reveal answers", "part.marking.steps no matter": "Because you received full marks for the part, your answers to the steps aren't counted.", "part.marking.resubmit because of variable replacement": "This part's marking depends on your answers to other parts, which you have changed. Submit this part again to update your score.", "question.no such part": "Can't find part {{path}}", "control.back to results": "Go back to results", "part.unknown type": "{{part}}: Unrecognised part type {{type}}", "result.click a question to review": "Clicca sul numero di una domanda per visualizzare che voti hanno ricevuto le tue risposte e, dove possibile, le soluzioni complete.", "part.missing type attribute": "{{part}}: Missing part type attribute", "matrixmath.abs.non-square": "Can't compute the determinant of a matrix which isn't square.", "result.performance summary": "Riepilogo delle prestazioni", "die.numbas failed": "Numbas has failed", "jme.shunt.no left bracket in function": "No matching left bracket in function application or tuple", "part.mcq.matrix cell empty": "Part {{part}} marking matrix cell ({{row}},{{column}}) is empty", "question.score feedback.show": "Show feedback", "part.script.error": "Error in part {{path}} custom script {{script}}: {{message}}", "part.numberentry.precision type.sigfig": "significant figure", "jme.variables.error computing dependency": "Error computing referenced variable <code>{{name}}</code>", "exam.passed": "Superato", "result.questions attempted": "Domande tentate:", "control.not all questions submitted": "You have made changes to one or more answers but not submitted them. Please check each question has been submitted.", "exam.student name": "Nome studente:", "scorm.no question suspend data": "No question suspend data", "result.exam start": "Inizio test:", "part.extension.not implemented": "Part hasn't implemented the <code>{{name}}</code> method.", "xml.property not boolean": "Property {{name}} should be a boolean, but isn't ({{value}}), in node {{element}}", "feedback.you were awarded": "You were awarded <strong>{{count,niceNumber}}</strong> $t(mark).", "jme.variables.variable not defined": "Variable <code>{{name}}</code> is not defined.", "question.loaded name mismatch": "Can't resume this attempt - the package has changed since the last session.", "control.confirm end": "Are you sure you want to end the exam? After you end the exam, you will not be able to change any of your answers.", "result.exam stop": "Interrompi il test", "exam.review header": "Controllo: ", "jme.display.collectRuleset.no sets": "No sets given to collectRuleset!", "result.exit": "Esito esame", "scorm.error initialising": "Error initialising SCORM protocol: {{message}}", "exam.pass percentage": "Percentuale pass", "math.permutations.complex": "Can't compute permutations of complex numbers", "scorm.error loading part": "Error loading part {{part}}: {{message}}", "part.mcq.options def not a list": "The expression defining the {{properties}} is not a list.", "part.mcq.matrix mix of numbers and lists": "Mix of numbers and lists used in marking matrix.", "part.marking.variable replacement part not answered": "You must answer {{part}} first", "part.marking.did not answer": "You did not answer this question.", "jme.shunt.missing operator": "Expression can't be evaluated -- missing an operator.", "suspend.paused header": "In pausa", "part.mcq.matrix wrong size": "Marking matrix is the wrong size.", "part.mcq.matrix jme error": "Part {{part}} marking matrix cell ({{row}},{{column}}) gives a JME error: {{error}}", "end.exam has finished": "The exam has finished. You may now close this window.", "suspend.exam suspended": "Il test \u00e8 sospeso. Premi <em>Riprendi</em> per continuare", "jme.texsubvars.missing parameter": "Missing parameter in {{op}}: {{parameter}}", "part.numberentry.precision type.sigfig_plural": "significant figures", "math.lt.order complex numbers": "Can't order complex numbers", "control.confirm reveal": "Would you like to reveal the answer to this question? Any marks you have received so far will be locked and you will not be able to answer this question later.", "part.patternmatch.correct except case": "Your answer is correct, except for the case.", "part.marking.not submitted": "No answer submitted", "jme.variables.error making function": "Error making function <code>{{name}}</code>: {{message}}", "exam.xml.bad root": "Root element of exam XML should be 'exam'", "part.mcq.matrix not a number": "Part {{part}} marking matrix cell ({{row}},{{column}}) does not evaluate to a number", "question.score feedback.score total": "{{marksString}}. Answered.", "question.show steps penalty": "You will lose <strong>{{count,niceNumber}}</strong> $t(mark).", "question.unsubmitted changes_plural": "You have made changes to your answers but not submitted them. Please check your answers to each part and then press the <strong>Submit all parts</strong> button.", "question.show steps no penalty": "Your score will not be affected.", "scorm.no part suspend data": "No part suspend data", "jme.typecheck.function not defined": "Operation <code>{{op}}</code> is not defined. Is <code>{{op}}</code> a variable, and did you mean <code>{{suggestion}}*(...)</code>?", "part.marking.revealed steps with penalty": "You revealed the steps. The maximum you can score for this part is <strong>{{count,niceNumber}}</strong> $t(mark). Your scores will be scaled down accordingly.", "question.unsubmitted changes": "You have made a change to your answer but not submitted it. Please check your answer and then press the <strong>Submit answer</strong> button.", "ruleset.circular reference": "Circular reference in definition of ruleset <code>{{name}}</code>", "math.combinations.n less than zero": "Can't compute combinations: n is less than zero", "part.marking.incorrect": "Your answer is incorrect.", "jme.variables.empty definition": "Definition of variable <code>{{name}}</code> is empty.", "question.preamble.syntax error": "Syntax error in preamble", "util.equality not defined for type": "Equality not defined for type {{type}}", "ruleset.set not defined": "Ruleset {{name}} has not been defined", "result.question review title": "Rivedi questa domanda", "jme.shunt.no right bracket": "No matching right bracket", "die.sorry": "Mi spiace. Nunbas ha incontrato un errore e non pu\u00f2 continuare. In basso troverai una descrizione.", "control.end exam": "End Exam", "vectormath.cross.not 3d": "Can only take the cross product of 3-dimensional vectors.", "part.mcq.matrix not a list": "Marking matrix, defined by JME expression, is not a list but it should be.", "part.marking.nothing entered": "You did not enter an answer.", "part.numberentry.give your answer as a reduced fraction": "Reduce your answer to lowest terms.", "mark_plural": "marks", "question.hide steps no penalty": "Your score will not be affected.", "step": "step", "part.numberentry.correct except decimal": "Your answer is within the allowed range, but decimal numbers are not allowed.", "question.can not submit": "Can not submit answer - check for errors.", "math.choose.empty selection": "Empty selection given to random function", "part.jme.answer too long": "Your answer is too long.", "mathjax.error": "MathJax processing error: {{message}}", "control.submit answer": "Submit answer", "exam.failed": "Non superato", "part.jme.not-allowed one": "Your answer must not contain: {{strings}}", "jme.shunt.not enough arguments": "Not enough arguments for operation {{op}}", "question.answer submitted": "Answer submitted", "part.jme.must-have one": "Your answer must contain: {{strings}}", "part.correct answer": "Expected answer:", "part.numberentry.answer not reduced": "Your answer is not reduced to lowest terms.", "control.next": "Next", "part.mcq.marking matrix string empty": "The custom marking matrix expression is empty.", "matrixmath.abs.too big": "Sorry, can't compute the determinant of a matrix bigger than 3x3 yet.", "jme.texsubvars.no right bracket": "No matching <code>]</code> in {{op}} arguments.", "mathjax.math processing error": "Errore mathjax: \"{{message}}\" mentre compila <code>{{expression}}</code>", "jme.matrix.reports bad size": "Matrix reports its size incorrectly - must be an error in constructor function", "part.marking.steps change": "You were awarded <strong>{{count,niceNumber}}</strong> $t(mark) for your answers to the steps.", "part.mcq.choices": "choices", "part.jme.answer invalid": "Your answer is not a valid mathematical expression.<br/>{{message}}.", "jme.shunt.list mixed argument types": "Can't parse {{mode}}: mix of dictionary and list elements", "jme.func.except.continuous range": "Can't use the 'except' operator on continuous ranges.", "exam.marks available": "Marcatori disponibili", "math.combinations.k less than zero": "Can't compute combinations: k is less than zero", "result.question number": "Domanda numero", "control.submit all parts": "Submit all parts", "jme.func.listval.not a list": "Object is not subscriptable", "part.numberentry.give your answer to precision": "Round your answer to {{count,niceNumber}} {{precisionType}}.", "part.mcq.wrong number of choices": "You selected the wrong number of choices.", "jme.variables.syntax error in function definition": "Syntax error in function definition", "page.saving": "<p>Salvataggio in corso.</p>\n<p>Potrebbe richiedere qualche secondo.</p>", "math.gcf.complex": "Can't compute GCF of complex numbers", "part.matrix.some incorrect": "One or more of the cells in your answer is incorrect, but you have been awarded marks for the rest.", "math.combinations.complex": "Can't compute combinations of complex numbers", "control.total": "Total", "jme.user javascript.error": "Error in user-defined javascript function <code>{{name}}</code>: {{message}}", "part.matrix.invalid cell": "One or more of the cells in your answer is empty or invalid.", "scorm.error loading question": "Error loading question {{number}}: {{message}}", "part.numberentry.give your answer to precision_0": "Round your answer to the nearest integer.", "jme.shunt.no right square bracket": "No matching right square bracket to end list", "control.not all questions answered": "You have not completed every question in this exam.", "jme.display.unknown token type": "Can't texify token type {{type}}", "part.numberentry.answer invalid": "You did not enter a valid number.", "jme.user javascript.returned undefined": "User-defined javascript function <code>{{name}}</code> returned <code>undefined</code>.", "question.hide steps": "Hide steps", "part.mcq.matrix wrong type": "Element of invalid type '{{type}}' used in marking matrix.", "math.combinations.n less than k": "Can't compute combinations: n is less than k", "mark": "mark", "suspend.you can resume": "Puoi riprendere la sessione la prossima volta", "scorm.error loading suspend data": "Error loading suspend data: {{message}}", "result.result": "Risultato:", "question.show steps": "Show steps", "question.submit part": "Submit part", "part.jme.unexpected variable name": "Your answer was interpreted to use the unexpected variable name <code>{{name}}</code>.", "part.matrix.empty cell": "One or more of the cells in your answer is empty.", "control.regen": "Try another question like this one", "control.advice": "Advice", "xml.could not load": "Couldn't load an XML document: {{message}}", "part.marking.uncaught error": "Error when marking {{part}}: {{message}}", "question.score feedback.score total actual": "Score: {{score,niceNumber}}/{{marks,niceNumber}}", "result.print": "Stampa i risultati", "math.siground.complex": "Can't round to a complex number of sig figs", "question.header": "Question {{number}}", "math.permutations.k less than zero": "Can't compute permutations: k is less than zero", "question.preamble.error": "Error in preamble: {{message}}", "suspend.resume": "Riprendi", "part.mcq.correct choice": "You chose the correct answer.", "part.numberentry.answer not integer": "Your answer is invalid. You must enter a whole number, not a decimal.", "part.jme.not-allowed several": "Your answer must not contain any of: {{strings}}", "part.numberentry.precision type.dp_plural": "decimal places", "question.unsupported part type": "Unsupported part type", "jme.variables.error evaluating variable": "Error evaluating variable {{name}}: {{message}}", "jme.func.listval.key not in dict": "Dictionary does not contain the key <code>{{key}}</code>", "part.mcq.answers": "answers", "jme.typecheck.map not on enumerable": "<code>map</code> operation must work over a list or a range, not {{type}}", "jme.substituteTree.undefined variable": "Undefined variable: <code>{{name}}</code>", "modal.cancel": "Annulla", "scorm.failed save": "<p>The request to save data to the server failed. Press <b>OK</b> to try again.</p>\n<p>If you get this message repeatedly, check your internet connection or use a different computer. Your previously submitted answers have been successfully saved and will be restored if you resume this session on a different computer.</p>\n<p>If this message appears persistently and you can't save <em>any</em> answers, please contact your lecturer or teacher.</p>", "jme.typecheck.function maybe implicit multiplication": "Operation {{name}} is not defined. Did you mean <br/><code>{{first}}*{{possibleOp}}(...)</code>?", "part.jme.answer too short": "Your answer is too short.", "matrixmath.mul.different sizes": "Can't multiply matrices of different sizes.", "jme.func.switch.no default case": "No default case for Switch statement", "part.numberentry.zero sig fig": "This part is set up to round the student's answer to zero significant figures, which has no meaning.", "frontpage.start": "Inizio", "result.question score": "Punteggio", "part.mcq.choices missing": "Definition of choices is missing", "question.score feedback.correct": "Your answer is correct", "part.feedback": "feedback", "question.score feedback.answered": "Answered.", "math.permutations.n less than k": "Can't compute permutations: n is less than k", "part.gapfill.feedback header": "<strong>Gap {{index}}</strong>", "question.advice": "Advice", "vectormath.cross.matrix too big": "Can't calculate cross product of a matrix which isn't $1 \\times N$ or $N \\times 1$.", "part.jme.not-allowed bits": "<span class=\"monospace\">{{string}}</span>", "display.part.jme.error making maths": "Error making maths display", "part.prompt": "prompt", "control.proceed anyway": "Proceed anyway?", "gap": "gap", "jme.tokenise.invalid": "Invalid expression: <code>{{expression}}</code>", "result.score": "Puteggio:", "math.lcm.complex": "Can't compute LCM of complex numbers", "exam.random seed": "ID sessione:", "modal.ok": "OK", "was": "was", "jme.thtml.not html": "Passed a non-HTML value into the THTML constructor.", "question.score feedback.partial": "Your answer is partially correct", "mathjax.error with context": "MathJax processing error in {{context}}: {{message}}", "question.score feedback.wrong": "Your answer is incorrect", "question.score feedback.score actual": "Score: {{scoreString}}", "part.numberentry.correct except fraction": "Your answer is within the allowed range, but fractions are not allowed.", "question.error": "Question {{number}}: {{message}}", "jme.evaluate.no scope given": "Numbas.jme.evaluate must be given a Scope", "question.show steps already penalised": "You have already shown steps. You can show them again with no further penalty.", "part.jme.answer missing": "Correct answer is missing", "part.mcq.no choices selected": "No choices selected.", "die.script not loaded": "Numbas couldn't start because the file <code>{{file}}</code> was not loaded. Check that it's included in <code>scripts.js</code>.", "part.numberentry.precision type.dp": "decimal place", "part.matrix.answer invalid": "Your answer is not valid.", "jme.variables.question took too many runs to generate variables": "A valid set of question variables was not generated in time.", "jme.texsubvars.no right brace": "No matching <code>}</code> in {{op}}", "page.loading": "Sto caricando...", "part.jme.marking.correct": "Your answer is numerically correct.", "part.marking.correct": "Your answer is correct.", "part.matrix.size mismatch": "The question author hasn't allowed the student to decide the dimensions of their answer, but the correct answer is {{correct_dimensions}} while the answer input is {{input_dimensions}}", "exam.feedback": "Exam feedback message", "part.marking.used variable replacements": "This part was marked using your answers to previous parts.", "control.submit": "Submit", "jme.shunt.no left square bracket": "No matching left bracket", "jme.func.listval.invalid index": "Invalid list index {{index}} on list of size {{size}}", "question.score feedback.hide": "Hide feedback", "jme.variables.circular reference": "Circular variable reference in definition of <code>{{name}}</code>", "result.time spent": "Tempo impiegato:", "die.error": "Errore", "timing.time remaining": "Time remaining:", "part.numberentry.negative decimal places": "This part is set up to round the student's answer to a negative number of decimal places, which has no meaning.", "part.with steps answer prompt": "Answer: ", "control.confirm leave": "You haven't finished the exam.", "jme.typecheck.op not defined": "Operation '{{op}}' is not defined.", "part": "part", "control.submit again": "Submit again", "xml.error in variable definition": "Error in definition of variable <code>{{name}}</code>", "exam.changeQuestion.no questions": "This exam contains no questions! Check the .exam file for errors.", "part.jme.must-have bits": "<span class=\"monospace\">{{string}}</span>", "part.marking.total score": "You scored <strong>{{count,niceNumber}}</strong> $t(mark) for this part.", "exam.introduction": "Exam introduction", "control.confirm regen": "Would you like to re-randomise this question? If you click OK, all your answers and marks for the current question will be lost.", "jme.evaluate.undefined variable": "Variable {{name}} is undefined", "jme.display.simplifyTree.no scope given": "Numbas.jme.display.simplifyTree must be given a Scope", "timing.no accumulator": "no timing accumulator {{name}}", "util.product.non list": "Passed a non-list to <code>Numbas.util.product</code>", "part.marking.revealed steps no penalty": "You revealed the steps.", "part.jme.unexpected variable name suggestion": "Your answer was interpreted to use the unexpected variable name <code>{{name}}</code>. Did you mean <code>{{suggestion}}</code>?", "jme.display.collectRuleset.set not defined": "Ruleset {{name}} has not been defined", "was_plural": "were", "part.marking.no result": "This part could not be marked.", "part.setting not present": "Property '{{property}}' not set", "exam.number of questions": "Numero di domande", "part.numberentry.answer not integer or decimal": "Your answer is invalid. You must enter an integer or a decimal.", "question.selector.unsubmitted changes": "Unsubmitted changes.", "vectormath.dot.matrix too big": "Can't calculate dot product of a matrix which isn't $1 \\times N$ or $N \\times 1$.", "scorm.no exam suspend data": "Failed to resume: no exam suspend data.", "math.permutations.n less than zero": "Can't compute permutations: n is less than zero", "part.matrix.empty": "You have not entered an answer.", "part.jme.must-have several": "Your answer must contain all of: {{strings}}", "part.patternmatch.display answer missing": "Display answer is missing", "math.precround.complex": "Can't round to a complex number of decimal places", "jme.func.matrix.invalid row type": "Can't construct a matrix from rows of type {{type}}", "jme.tokenise.keypair key not a string": "Dictionary key should be a string, not {{type}}.", "jme.shunt.no left bracket": "No matching left bracket", "result.exam summary": "Argomenti del test", "jme.typecheck.no right type definition": "No definition of '{{op}}' of correct type found.", "exam.time allowed": "Tempo disponibile:", "question.statement": "Statement", "xml.property not number": "Property {{name}} should be a number, but isn't ({{value}}), in node {{element}}", "exam.exam name": "Nome esame:", "control.previous": "Previous"}}}
        }
        });
        
Numbas.queueScript('marking_scripts',['marking'],function() {
            Numbas.raw_marking_scripts = {"gapfill": "marked_original_order (Mark the gaps in the original order, mainly to establish if every gap has a valid answer):\n    map(\n        mark_part(gap[\"path\"],studentAnswer),\n        [gap,studentAnswer],\n        zip(gaps,studentAnswer)\n    )\n\ninterpreted_answers (The interpreted answers for each gap, in the original order):\n    map(\n        res[\"values\"][\"interpreted_answer\"],\n        res,\n        marked_original_order\n    )\n\nanswers (The student's answers to each gap):\n    if(settings[\"sortAnswers\"],\n        sort(interpreted_answers)\n    ,\n        interpreted_answers\n    )\n\ngap_order:\n    if(settings[\"sortAnswers\"],\n        sort_destinations(interpreted_answers)\n    ,\n        list(0..len(gaps))\n    )\n\ngap_feedback (Feedback on each of the gaps):\n  map(\n    let(result,submit_part(gaps[gap_number][\"path\"],answer),\n      feedback(translate('part.gapfill.feedback header',[\"index\":index]));\n      concat_feedback(result[\"feedback\"], if(marks>0,result[\"marks\"]/marks,1));\n      result\n    ),\n    [gap_number,answer,index],\n    zip(gap_order,studentAnswer,list(1..len(gaps)))\n  )\n\nall_valid (Are the answers to all of the gaps valid?):\n  all(map(res[\"valid\"],res,marked_original_order))\n\nmark:\n  assert(all_valid or not settings[\"sortAnswers\"], fail(translate(\"question.can not submit\")));\n  apply(all_valid);\n  apply(answers);\n  apply(gap_feedback);\n  assert(all_valid or settings[\"sortAnswers\"], fail(\"\"))\n\ninterpreted_answer:\n  answers\n\n", "multipleresponse": "numAnswers: len(settings[\"matrix\"])\n\nnumChoices: if(numAnswers=1,1,len(settings[\"matrix\"][0]))\n\nnumTicks (How many options did the student tick?):\n  sum(map(sum(row),row,studentAnswer))\n\nwrongNumber:\n  assert(numTicks >= settings[\"minAnswers\"] and (settings[\"maxAnswers\"]=0 or numTicks<=settings[\"maxAnswers\"]),\n    if(settings[\"warningType\"]=\"prevent\",\n        fail(translate(\"part.mcq.wrong number of choices\"))\n    ,\n        incorrect(translate(\"part.mcq.wrong number of choices\"));\n        end()\n    )\n  )\n\ntick_indexes (Indexes of choice/answer pairs):\n  product(list(0..(numAnswers-1)),list(0..(numChoices-1)))\n\nscore_ticks (The score for each choice/answer pair):\n  map(\n    if(studentAnswer[x][y],\n      let(distractor,settings[\"distractors\"][x][y], credit, if(marks=0,0,settings[\"matrix\"][x][y]/marks),\n        switch(\n          credit<>0,\n            if(not nonemptyhtml(distractor),\n              add_credit(credit,translate(if(credit>0,'part.mcq.correct choice','part.mcq.incorrect choice')))\n            ,\n              add_credit(credit,distractor)\n            )\n          ,\n            if(nonemptyhtml(distractor),feedback(distractor),if(marks<>0,feedback(translate('part.mcq.incorrect choice')),false))\n        );credit\n      )\n    ,\n      0\n    ),\n    [x,y],\n    tick_indexes\n  )\n\ntotal_score: sum(score_ticks)\n\nmark:\n  assert(marks>0,correct());  // any answer is correct when 0 marks are available\n  assert(numTicks>0,\n    warn(translate(\"part.marking.nothing entered\"));\n    fail(translate(\"part.marking.nothing entered\"))\n  );\n  apply(wrongNumber);\n  apply(score_ticks)\n\ninterpreted_answer (The student's answer, to be reused by other parts):\n  studentAnswer\n", "jme": "studentExpr (The student's answer, parsed): \n    assert(trim(studentAnswer)<>\"\",\n        warn(translate(\"part.marking.nothing entered\"));\n        fail(translate(\"part.marking.nothing entered\"))\n    );\n    try(\n        simplify(parse(studentAnswer),'basic')\n    , message,\n        warn(translate(\"part.jme.answer invalid\",[\"message\":message]));\n        fail(translate(\"part.jme.answer invalid\",[\"message\":message]))\n    )\n\ncleanedStudentString (The student's answer as a string, cleaned up): string(studentExpr)\n\nscope_vars (Variables already defined in the scope): \n    definedvariables()\n\nstudentVariables (Variables used in the student's answer): \n    set(findvars(studentExpr))\n\nunexpectedVariables (Unexpected variables used in the student's answer):\n    let(uvars, filter(not (x in settings[\"expectedVariableNames\"]),x,list(studentVariables)),\n        assert(len(settings[\"expectedVariableNames\"])=0 or len(uvars)=0,\n            warn(translate(\"part.jme.unexpected variable name\",[\"name\":uvars[0]]))\n        );\n        uvars\n    )\n\nfailMinLength (Is the student's answer too short?):\n    assert(settings[\"minLength\"]=0 or len(cleanedStudentString)>=settings[\"minLength\"],\n        multiply_credit(settings[\"minLengthPC\"],settings[\"minLengthMessage\"]);\n        true\n    )\n\nfailMaxLength:\n    assert(settings[\"maxLength\"]=0 or len(cleanedStudentString)<=settings[\"maxLength\"],\n        multiply_credit(settings[\"maxLengthPC\"],settings[\"maxLengthMessage\"]);\n        true\n    )\n\nforbiddenStrings:\n    filter(x in cleanedStudentString, x, settings[\"notAllowed\"])\n\nforbiddenStringsPenalty:\n    assert(len(forbiddenStrings)=0,\n        translate(\n          if(len(settings[\"notAllowed\"])=1, 'part.jme.not-allowed one', 'part.jme.not-allowed several'),\n          [\"strings\":map(translate('part.jme.not-allowed bits',[\"string\":str]),str,forbiddenStrings)]\n        );\n        multiply_credit(settings[\"notAllowedPC\"],settings[\"notAllowedMessage\"]);\n        warn(settings[\"notAllowedMessage\"])\n    )\n\nrequiredStrings:\n    filter(not (x in cleanedStudentString), x, settings[\"mustHave\"])\n\nrequiredStringsPenalty:\n    assert(len(requiredStrings)=0,\n        translate(\n          if(len(settings[\"mustHave\"])=1, 'part.jme.must-have one', 'part.jme.must-have several'),\n          [\"strings\":map(translate('part.jme.must-have bits',[\"string\":str]),str,forbiddenStrings)]\n        );\n        multiply_credit(settings[\"mustHavePC\"],settings[\"mustHaveMessage\"]);\n        warn(settings[\"mustHaveMessage\"])\n    )\n\ncorrectExpr (The correct answer, parsed): \n    parse(settings[\"correctAnswer\"])\n\ncorrectVars (Variables used in the correct answer): \n    set(findvars(correctExpr))\n\nvRange (The range to pick variable values from): \n    settings[\"vsetRangeStart\"]..settings[\"vsetRangeEnd\"]#0\n\nvset (The sets of variable values to test against):\n    repeat(\n        dict(map([x,random(vRange)],x,correctVars or studentVariables)),\n        settings[\"vsetRangePoints\"]\n    )\n\nagree (Do the student's answer and the expected answer agree on each of the sets of variable values?):\n    map(\n        try(\n            resultsEqual(unset(question_definitions,eval(studentexpr,vars)),unset(question_definitions,eval(correctexpr,vars)),settings[\"checkingType\"],settings[\"checkingAccuracy\"]),\n            message,\n            warn(translate(\"part.jme.answer invalid\",[\"message\":message]));\n            fail(translate(\"part.jme.answer invalid\",[\"message\":message]));\n            false\n        ),\n        vars,\n        vset\n    )\n\nnumFails (The number of times the student's answer and the expected answer disagree): \n    apply(agree);\n    len(filter(not x,x,agree))\n\nnumericallyCorrect (Is the student's answer numerically correct?):\n    apply(numFails);\n    if(numFails<settings[\"failureRate\"],\n        correct(translate(\"part.jme.marking.correct\"))\n    ,\n        incorrect()\n    )\n\nsameVars (Does the student use the same variables as the correct answer?):\n    if(studentVariables=correctVars,\n        true\n    ,\n        incorrect();\n        end();\n        false\n    )\n\nmark:\n    apply(studentExpr);\n    apply(unexpectedVariables);\n    apply(sameVars);\n    apply(numericallyCorrect);\n    apply(failMinLength);\n    apply(failMaxLength);\n    apply(forbiddenStringsPenalty);\n    apply(requiredStringsPenalty)\n\ninterpreted_answer (The student's answer, to be reused by other parts):\n    studentExpr\n\n", "numberentry": "studentNumber (The student's answer, parsed as a number):\n    if(settings[\"allowFractions\"],\n        parseNumber_or_fraction(studentAnswer,settings[\"notationStyles\"])\n    ,\n        parseNumber(studentAnswer,settings[\"notationStyles\"])\n    )\n\nisInteger (Is the student's answer an integer?):\n    countDP(studentAnswer)=0\n\nisFraction (Is the student's answer a fraction?):\n    \"/\" in studentAnswer\n\nnumerator (The numerator of the student's answer, or 0 if not a fraction):\n    if(isFraction,\n        parseNumber(split(studentAnswer,\"/\")[0],settings[\"notationStyles\"])\n    ,\n        0\n    )\n\ndenominator (The numerator of the student's answer, or 0 if not a fraction):\n    if(isFraction,\n        parseNumber(split(studentAnswer,\"/\")[1],settings[\"notationStyles\"])\n    ,\n        0\n    )\n\ncancelled (Is the student's answer a cancelled fraction?):\n    assert(isFraction and gcd(numerator,denominator)=1,\n        assert(not settings[\"mustBeReduced\"],\n            multiply_credit(settings[\"mustBeReducedPC\"],translate(\"part.numberentry.answer not reduced\"))\n        );\n        false\n    )\n\ncleanedStudentAnswer:\n    cleannumber(studentAnswer, settings[\"notationStyles\"])\n\nstudentPrecision:\n    switch(\n        settings[\"precisionType\"]=\"dp\", max(settings[\"precision\"],countDP(cleanedStudentAnswer)),\n        settings[\"precisionType\"]=\"sigfig\", max(settings[\"precision\"],countsigfigs(cleanedStudentAnswer)),\n        0\n    )\n\nminvalue:\n    switch(\n        settings[\"precisionType\"]=\"dp\", precround(settings[\"minvalue\"],studentPrecision),\n        settings[\"precisionType\"]=\"sigfig\", siground(settings[\"minvalue\"],studentPrecision),\n        settings[\"minvalue\"]\n    )\n\nmaxvalue:\n    switch(\n        settings[\"precisionType\"]=\"dp\", precround(settings[\"maxvalue\"],studentPrecision),\n        settings[\"precisionType\"]=\"sigfig\", siground(settings[\"maxvalue\"],studentPrecision),\n        settings[\"maxvalue\"]\n    )\n\nvalidNumber (Is the student's answer a valid number?):\n    if(isNaN(studentNumber),\n        warn(translate(\"part.numberentry.answer invalid\"));\n        fail(translate(\"part.numberentry.answer invalid\"))\n    ,\n        true\n    )\n\nnumberInRange (Is the student's number in the allowed range?):\n    if(studentNumber>=minvalue and studentNumber<=maxvalue,\n        correct()\n    ,\n        incorrect();\n        end()\n    )\n\ncorrectPrecision (Has the student's answer been given to the desired precision?):     \n    if(togivenprecision(studentanswer,settings['precisionType'],settings['precision'],settings[\"strictPrecision\"]),\n        true\n    ,\n        multiply_credit(settings[\"precisionPC\"],settings[\"precisionMessage\"]);\n        false\n    )\n\nmark (Mark the student's answer):\n    apply(validNumber);\n    apply(numberInRange);\n    assert(numberInRange,end());\n    if(isFraction,\n        apply(cancelled)\n    ,\n        apply(correctPrecision)\n    )\n \ninterpreted_answer (The student's answer, to be reused by other parts):\n    studentNumber\n\n", "matrixentry": "rows (The number of rows in the student's answer): len(studentanswer)\n\ncols (The number of columns in the student's answer): if(rows>0,len(studentanswer[0]),0)\n\ncorrect_rows (The number of rows in the correct answer): len(settings['correctAnswer'])\n\ncorrect_cols (The number of columns in the correct answer): len(settings['correctAnswer'][0])\n\nnum_cells (The number of cells in the student's answer): rows*cols\n\ncell_indexes (The index of each cell in the student's answer): \n    product(list(0..rows-1), list(0..cols-1))\n\nstudent_cell_precisions (Precision the student used in each cell):\n    switch(\n        settings[\"precisionType\"]=\"dp\",\n            map(map(countDP(cell),cell,row), row, studentAnswer)\n        ,\n        settings[\"precisionType\"]=\"sigfig\",\n            map(map(countsigfigs(cell),cell,row), row, studentAnswer)\n        ,\n        map(map(0,cell,row),row,studentAnswer)\n    )\n\nall_same_precision:\n    if(len(student_cell_precisions)=0 or all(map(all(map(toGivenPrecision(c,settings[\"precisionType\"],student_cell_precisions[0][0],settings[\"strictPrecision\"]),c,row)),row,studentAnswer)),\n        true\n    ,\n        feedback(translate(\"part.matrix.not all cells same precision\"));\n        false\n    )\n\nstudentPrecision (Maximum precision student used, or the required precision, whichever's higher):\n    max(settings[\"precision\"], max(map(max(row),row,student_cell_precisions)))\n\nallowFractions: settings[\"allowFractions\"]\n\nstudentNumbers:\n    if(settings[\"allowFractions\"],\n        map(map(parseNumber_or_fraction(c, \"en\"), c, row), row, studentAnswer)\n    ,\n        map(map(parseNumber(c, \"en\"), c, row), row, studentAnswer)\n    )\n\nstudentMatrix (The student's answer, with each cell parsed to numbers): \n    matrix(studentNumbers)\n\nempty_cells (The positions of the cells in the student's answer which have been left empty):\n  filter(trim(studentAnswer[p[0]][p[1]])=\"\", p, cell_indexes)\n\nany_empty (Are any of the cells empty?):\n  assert(len(empty_cells)=0,\n    warn(translate(\"part.matrix.empty cell\"));\n    fail(translate(\"part.matrix.empty cell\"));\n    true\n  )\n\ninvalid_cells (The positions of the cells in the student's answer which can't be interpreted as numbers):\n    filter(isnan(studentNumbers[p[0]][p[1]]), p, cell_indexes)\n\nany_invalid (Are any of the cells invalid?):\n    assert(len(invalid_cells)=0,\n        warn(translate(\"part.matrix.invalid cell\"));\n        fail(translate(\"part.matrix.invalid cell\"));\n        true\n    )\n\nwrong_precision_cells (The indexes of the cells which are given to the wrong precision):\n    filter(not toGivenPrecision(studentAnswer[p[0]][p[1]], settings[\"precisionType\"], settings[\"precision\"], settings[\"strictPrecision\"]), p, cell_indexes)\n\nwrong_precision (Has every cell been given to the correct precision?):\n    assert(len(wrong_precision_cells)=0,\n        multiply_credit(settings['precisionPC'], settings[\"precisionMessage\"])\n    )\n\nwrong_size (Does the student's answer have the wrong dimensions?):\n    assert(rows=correct_rows and cols=correct_cols,\n        incorrect();\n        end()\n    )\n\nrounded_student_matrix (The student's answer, with each cell rounded to studentPrecision): \n    map(\n        switch(\n            settings[\"precisionType\"]=\"dp\",\n            precround(c, studentPrecision),\n            settings[\"precisionType\"]=\"sigfig\",\n            siground(c, studentPrecision),\n            c\n        ),\n        c,\n        studentMatrix\n    )\n\nrounded_correct_matrix:\n    map(\n        map(\n            switch(\n                settings[\"precisionType\"]=\"dp\",\n                precround(c, studentPrecision),\n                settings[\"precisionType\"]=\"sigfig\",\n                siground(c, studentPrecision),\n                c\n            ),\n            c,\n            row\n        ),\n        row,\n        settings[\"correctAnswer\"]\n    )\n\ncorrect_cells (The indexes of the cells which are correct):\n    filter(\n        if(p[0]<correct_rows and p[1]<correct_cols,\n            withinTolerance(rounded_student_matrix[p[0]][p[1]], rounded_correct_matrix[p[0]][p[1]], settings['tolerance']),\n            false\n        ),\n        p, \n        cell_indexes\n    )\n\nmark:\n    apply(any_empty);\n    apply(any_invalid);\n    assert(settings[\"precisionType\"]=\"none\" and not settings[\"allowFractions\"], apply(all_same_precision));\n    apply(wrong_size);\n    if(len(correct_cells)=len(cell_indexes),\n        correct()\n    ,\n        if(settings['markPerCell'],\n            set_credit(len(correct_cells)/num_cells,translate('part.matrix.some incorrect',[\"count\":num_cells-len(correct_cells)]))\n        ,\n            incorrect();\n            end()\n        )\n    );\n    apply(wrong_precision)\n\ninterpreted_answer (The student's answer, to be reused by other parts):\n  studentMatrix\n", "patternmatch": "regex_match (Match the student's answer with the correct answer, interpreted as a regular expression):\n  match_regex(settings[\"correctAnswer\"],studentAnswer)\n\nregex_match_case_insensitive (Match the student's answer with the correct answer, interpreted as a case-insensitive regular expression):\n  match_regex(settings[\"correctAnswer\"],studentAnswer,\"i\")\n\nexact_match (Is the student's answer exactly the correct answer?):\n  studentAnswer=settings[\"correctAnswer\"]\n\nexact_match_case_insensitive (Is the student's answer exactly the correct answer?):\n  lower(studentAnswer)=lower(settings[\"correctAnswer\"])\n\nmatches (Does the student's answer match the correct answer?):\n  switch(\n    settings[\"matchMode\"]=\"regex\", len(regex_match)>0,\n    settings[\"matchMode\"]=\"exact\", exact_match,\n    false\n  )\n      \nmatches_case_insensitive (Does the student's answer match the correct answer, ignoring case?):\n  switch(\n    settings[\"matchMode\"]=\"regex\", len(regex_match_case_insensitive)>0,\n    settings[\"matchMode\"]=\"exact\", exact_match_case_insensitive,\n    false\n  )\n     \n\nmark:\n  assert(len(studentAnswer)>0,fail(translate(\"part.marking.nothing entered\")));\n  if(settings[\"caseSensitive\"],\n    if(matches,\n      correct(),\n      if(matches_case_insensitive,\n        set_credit(settings[\"partialCredit\"],translate(\"part.patternmatch.correct except case\")),\n        incorrect()\n      )\n    ,\n      incorrect()\n    )\n  ,\n    if(matches_case_insensitive,\n      correct()\n    ,\n      incorrect()\n    )\n  )\n\ninterpreted_answer (The student's answer, to be reused by other parts):\n  studentAnswer\n"};
            Numbas.marking_scripts = {};
            for(var x in Numbas.raw_marking_scripts) {
                Numbas.marking_scripts[x] = new Numbas.marking.MarkingScript(Numbas.raw_marking_scripts[x]);
            }
        });
        
Numbas.queueScript("bootstrap",["jquery"],function() {/*!
 * Bootstrap v3.3.4 (http://getbootstrap.com)
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */
if (typeof jQuery === 'undefined') {
  throw new Error('Bootstrap\'s JavaScript requires jQuery')
}
+function ($) {
  'use strict';
  var version = $.fn.jquery.split(' ')[0].split('.')
  if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1)) {
    throw new Error('Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher')
  }
}(jQuery);
Numbas.queueScript("bootstrap",["jquery"],function() {/*!
 * Bootstrap v3.3.4 (http://getbootstrap.com)
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */
if (typeof jQuery === 'undefined') {
  throw new Error('Bootstrap\'s JavaScript requires jQuery')
}
+function ($) {
  'use strict';
  var version = $.fn.jquery.split(' ')[0].split('.')
  if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1)) {
    throw new Error('Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher')
  }
}(jQuery);
/* ========================================================================
 * Bootstrap: transition.js v3.3.4
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================
  function transitionEnd() {
    var el = document.createElement('bootstrap')
    var transEndEventNames = {
      WebkitTransition : 'webkitTransitionEnd',
      MozTransition    : 'transitionend',
      OTransition      : 'oTransitionEnd otransitionend',
      transition       : 'transitionend'
    }
    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return { end: transEndEventNames[name] }
      }
    }
    return false // explicit for ie8 (  ._.)
  }
  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
    var called = false
    var $el = this
    $(this).one('bsTransitionEnd', function () { called = true })
    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
    setTimeout(callback, duration)
    return this
  }
  $(function () {
    $.support.transition = transitionEnd()
    if (!$.support.transition) return
    $.event.special.bsTransitionEnd = {
      bindType: $.support.transition.end,
      delegateType: $.support.transition.end,
      handle: function (e) {
        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
      }
    }
  })
}(jQuery);
/* ========================================================================
 * Bootstrap: alert.js v3.3.4
 * http://getbootstrap.com/javascript/#alerts
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // ALERT CLASS DEFINITION
  // ======================
  var dismiss = '[data-dismiss="alert"]'
  var Alert   = function (el) {
    $(el).on('click', dismiss, this.close)
  }
  Alert.VERSION = '3.3.4'
  Alert.TRANSITION_DURATION = 150
  Alert.prototype.close = function (e) {
    var $this    = $(this)
    var selector = $this.attr('data-target')
    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }
    var $parent = $(selector)
    if (e) e.preventDefault()
    if (!$parent.length) {
      $parent = $this.closest('.alert')
    }
    $parent.trigger(e = $.Event('close.bs.alert'))
    if (e.isDefaultPrevented()) return
    $parent.removeClass('in')
    function removeElement() {
      // detach from parent, fire event then clean up data
      $parent.detach().trigger('closed.bs.alert').remove()
    }
    $.support.transition && $parent.hasClass('fade') ?
      $parent
        .one('bsTransitionEnd', removeElement)
        .emulateTransitionEnd(Alert.TRANSITION_DURATION) :
      removeElement()
  }
  // ALERT PLUGIN DEFINITION
  // =======================
  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.alert')
      if (!data) $this.data('bs.alert', (data = new Alert(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }
  var old = $.fn.alert
  $.fn.alert             = Plugin
  $.fn.alert.Constructor = Alert
  // ALERT NO CONFLICT
  // =================
  $.fn.alert.noConflict = function () {
    $.fn.alert = old
    return this
  }
  // ALERT DATA-API
  // ==============
  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)
}(jQuery);
/* ========================================================================
 * Bootstrap: button.js v3.3.4
 * http://getbootstrap.com/javascript/#buttons
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // BUTTON PUBLIC CLASS DEFINITION
  // ==============================
  var Button = function (element, options) {
    this.$element  = $(element)
    this.options   = $.extend({}, Button.DEFAULTS, options)
    this.isLoading = false
  }
  Button.VERSION  = '3.3.4'
  Button.DEFAULTS = {
    loadingText: 'loading...'
  }
  Button.prototype.setState = function (state) {
    var d    = 'disabled'
    var $el  = this.$element
    var val  = $el.is('input') ? 'val' : 'html'
    var data = $el.data()
    state = state + 'Text'
    if (data.resetText == null) $el.data('resetText', $el[val]())
    // push to event loop to allow forms to submit
    setTimeout($.proxy(function () {
      $el[val](data[state] == null ? this.options[state] : data[state])
      if (state == 'loadingText') {
        this.isLoading = true
        $el.addClass(d).attr(d, d)
      } else if (this.isLoading) {
        this.isLoading = false
        $el.removeClass(d).removeAttr(d)
      }
    }, this), 0)
  }
  Button.prototype.toggle = function () {
    var changed = true
    var $parent = this.$element.closest('[data-toggle="buttons"]')
    if ($parent.length) {
      var $input = this.$element.find('input')
      if ($input.prop('type') == 'radio') {
        if ($input.prop('checked') && this.$element.hasClass('active')) changed = false
        else $parent.find('.active').removeClass('active')
      }
      if (changed) $input.prop('checked', !this.$element.hasClass('active')).trigger('change')
    } else {
      this.$element.attr('aria-pressed', !this.$element.hasClass('active'))
    }
    if (changed) this.$element.toggleClass('active')
  }
  // BUTTON PLUGIN DEFINITION
  // ========================
  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.button')
      var options = typeof option == 'object' && option
      if (!data) $this.data('bs.button', (data = new Button(this, options)))
      if (option == 'toggle') data.toggle()
      else if (option) data.setState(option)
    })
  }
  var old = $.fn.button
  $.fn.button             = Plugin
  $.fn.button.Constructor = Button
  // BUTTON NO CONFLICT
  // ==================
  $.fn.button.noConflict = function () {
    $.fn.button = old
    return this
  }
  // BUTTON DATA-API
  // ===============
  $(document)
    .on('click.bs.button.data-api', '[data-toggle^="button"]', function (e) {
      var $btn = $(e.target)
      if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')
      Plugin.call($btn, 'toggle')
      e.preventDefault()
    })
    .on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function (e) {
      $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type))
    })
}(jQuery);
/* ========================================================================
 * Bootstrap: carousel.js v3.3.4
 * http://getbootstrap.com/javascript/#carousel
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // CAROUSEL CLASS DEFINITION
  // =========================
  var Carousel = function (element, options) {
    this.$element    = $(element)
    this.$indicators = this.$element.find('.carousel-indicators')
    this.options     = options
    this.paused      = null
    this.sliding     = null
    this.interval    = null
    this.$active     = null
    this.$items      = null
    this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))
    this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element
      .on('mouseenter.bs.carousel', $.proxy(this.pause, this))
      .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))
  }
  Carousel.VERSION  = '3.3.4'
  Carousel.TRANSITION_DURATION = 600
  Carousel.DEFAULTS = {
    interval: 5000,
    pause: 'hover',
    wrap: true,
    keyboard: true
  }
  Carousel.prototype.keydown = function (e) {
    if (/input|textarea/i.test(e.target.tagName)) return
    switch (e.which) {
      case 37: this.prev(); break
      case 39: this.next(); break
      default: return
    }
    e.preventDefault()
  }
  Carousel.prototype.cycle = function (e) {
    e || (this.paused = false)
    this.interval && clearInterval(this.interval)
    this.options.interval
      && !this.paused
      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))
    return this
  }
  Carousel.prototype.getItemIndex = function (item) {
    this.$items = item.parent().children('.item')
    return this.$items.index(item || this.$active)
  }
  Carousel.prototype.getItemForDirection = function (direction, active) {
    var activeIndex = this.getItemIndex(active)
    var willWrap = (direction == 'prev' && activeIndex === 0)
                || (direction == 'next' && activeIndex == (this.$items.length - 1))
    if (willWrap && !this.options.wrap) return active
    var delta = direction == 'prev' ? -1 : 1
    var itemIndex = (activeIndex + delta) % this.$items.length
    return this.$items.eq(itemIndex)
  }
  Carousel.prototype.to = function (pos) {
    var that        = this
    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))
    if (pos > (this.$items.length - 1) || pos < 0) return
    if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) }) // yes, "slid"
    if (activeIndex == pos) return this.pause().cycle()
    return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))
  }
  Carousel.prototype.pause = function (e) {
    e || (this.paused = true)
    if (this.$element.find('.next, .prev').length && $.support.transition) {
      this.$element.trigger($.support.transition.end)
      this.cycle(true)
    }
    this.interval = clearInterval(this.interval)
    return this
  }
  Carousel.prototype.next = function () {
    if (this.sliding) return
    return this.slide('next')
  }
  Carousel.prototype.prev = function () {
    if (this.sliding) return
    return this.slide('prev')
  }
  Carousel.prototype.slide = function (type, next) {
    var $active   = this.$element.find('.item.active')
    var $next     = next || this.getItemForDirection(type, $active)
    var isCycling = this.interval
    var direction = type == 'next' ? 'left' : 'right'
    var that      = this
    if ($next.hasClass('active')) return (this.sliding = false)
    var relatedTarget = $next[0]
    var slideEvent = $.Event('slide.bs.carousel', {
      relatedTarget: relatedTarget,
      direction: direction
    })
    this.$element.trigger(slideEvent)
    if (slideEvent.isDefaultPrevented()) return
    this.sliding = true
    isCycling && this.pause()
    if (this.$indicators.length) {
      this.$indicators.find('.active').removeClass('active')
      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])
      $nextIndicator && $nextIndicator.addClass('active')
    }
    var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, "slid"
    if ($.support.transition && this.$element.hasClass('slide')) {
      $next.addClass(type)
      $next[0].offsetWidth // force reflow
      $active.addClass(direction)
      $next.addClass(direction)
      $active
        .one('bsTransitionEnd', function () {
          $next.removeClass([type, direction].join(' ')).addClass('active')
          $active.removeClass(['active', direction].join(' '))
          that.sliding = false
          setTimeout(function () {
            that.$element.trigger(slidEvent)
          }, 0)
        })
        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)
    } else {
      $active.removeClass('active')
      $next.addClass('active')
      this.sliding = false
      this.$element.trigger(slidEvent)
    }
    isCycling && this.cycle()
    return this
  }
  // CAROUSEL PLUGIN DEFINITION
  // ==========================
  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.carousel')
      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
      var action  = typeof option == 'string' ? option : options.slide
      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
      if (typeof option == 'number') data.to(option)
      else if (action) data[action]()
      else if (options.interval) data.pause().cycle()
    })
  }
  var old = $.fn.carousel
  $.fn.carousel             = Plugin
  $.fn.carousel.Constructor = Carousel
  // CAROUSEL NO CONFLICT
  // ====================
  $.fn.carousel.noConflict = function () {
    $.fn.carousel = old
    return this
  }
  // CAROUSEL DATA-API
  // =================
  var clickHandler = function (e) {
    var href
    var $this   = $(this)
    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) // strip for ie7
    if (!$target.hasClass('carousel')) return
    var options = $.extend({}, $target.data(), $this.data())
    var slideIndex = $this.attr('data-slide-to')
    if (slideIndex) options.interval = false
    Plugin.call($target, options)
    if (slideIndex) {
      $target.data('bs.carousel').to(slideIndex)
    }
    e.preventDefault()
  }
  $(document)
    .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)
    .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)
  $(window).on('load', function () {
    $('[data-ride="carousel"]').each(function () {
      var $carousel = $(this)
      Plugin.call($carousel, $carousel.data())
    })
  })
}(jQuery);
/* ========================================================================
 * Bootstrap: collapse.js v3.3.4
 * http://getbootstrap.com/javascript/#collapse
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // COLLAPSE PUBLIC CLASS DEFINITION
  // ================================
  var Collapse = function (element, options) {
    this.$element      = $(element)
    this.options       = $.extend({}, Collapse.DEFAULTS, options)
    this.$trigger      = $('[data-toggle="collapse"][href="#' + element.id + '"],' +
                           '[data-toggle="collapse"][data-target="#' + element.id + '"]')
    this.transitioning = null
    if (this.options.parent) {
      this.$parent = this.getParent()
    } else {
      this.addAriaAndCollapsedClass(this.$element, this.$trigger)
    }
    if (this.options.toggle) this.toggle()
  }
  Collapse.VERSION  = '3.3.4'
  Collapse.TRANSITION_DURATION = 350
  Collapse.DEFAULTS = {
    toggle: true
  }
  Collapse.prototype.dimension = function () {
    var hasWidth = this.$element.hasClass('width')
    return hasWidth ? 'width' : 'height'
  }
  Collapse.prototype.show = function () {
    if (this.transitioning || this.$element.hasClass('in')) return
    var activesData
    var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing')
    if (actives && actives.length) {
      activesData = actives.data('bs.collapse')
      if (activesData && activesData.transitioning) return
    }
    var startEvent = $.Event('show.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return
    if (actives && actives.length) {
      Plugin.call(actives, 'hide')
      activesData || actives.data('bs.collapse', null)
    }
    var dimension = this.dimension()
    this.$element
      .removeClass('collapse')
      .addClass('collapsing')[dimension](0)
      .attr('aria-expanded', true)
    this.$trigger
      .removeClass('collapsed')
      .attr('aria-expanded', true)
    this.transitioning = 1
    var complete = function () {
      this.$element
        .removeClass('collapsing')
        .addClass('collapse in')[dimension]('')
      this.transitioning = 0
      this.$element
        .trigger('shown.bs.collapse')
    }
    if (!$.support.transition) return complete.call(this)
    var scrollSize = $.camelCase(['scroll', dimension].join('-'))
    this.$element
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
  }
  Collapse.prototype.hide = function () {
    if (this.transitioning || !this.$element.hasClass('in')) return
    var startEvent = $.Event('hide.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return
    var dimension = this.dimension()
    this.$element[dimension](this.$element[dimension]())[0].offsetHeight
    this.$element
      .addClass('collapsing')
      .removeClass('collapse in')
      .attr('aria-expanded', false)
    this.$trigger
      .addClass('collapsed')
      .attr('aria-expanded', false)
    this.transitioning = 1
    var complete = function () {
      this.transitioning = 0
      this.$element
        .removeClass('collapsing')
        .addClass('collapse')
        .trigger('hidden.bs.collapse')
    }
    if (!$.support.transition) return complete.call(this)
    this.$element
      [dimension](0)
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
  }
  Collapse.prototype.toggle = function () {
    this[this.$element.hasClass('in') ? 'hide' : 'show']()
  }
  Collapse.prototype.getParent = function () {
    return $(this.options.parent)
      .find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]')
      .each($.proxy(function (i, element) {
        var $element = $(element)
        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
      }, this))
      .end()
  }
  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
    var isOpen = $element.hasClass('in')
    $element.attr('aria-expanded', isOpen)
    $trigger
      .toggleClass('collapsed', !isOpen)
      .attr('aria-expanded', isOpen)
  }
  function getTargetFromTrigger($trigger) {
    var href
    var target = $trigger.attr('data-target')
      || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') // strip for ie7
    return $(target)
  }
  // COLLAPSE PLUGIN DEFINITION
  // ==========================
  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.collapse')
      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)
      if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false
      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }
  var old = $.fn.collapse
  $.fn.collapse             = Plugin
  $.fn.collapse.Constructor = Collapse
  // COLLAPSE NO CONFLICT
  // ====================
  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old
    return this
  }
  // COLLAPSE DATA-API
  // =================
  $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
    var $this   = $(this)
    if (!$this.attr('data-target')) e.preventDefault()
    var $target = getTargetFromTrigger($this)
    var data    = $target.data('bs.collapse')
    var option  = data ? 'toggle' : $this.data()
    Plugin.call($target, option)
  })
}(jQuery);
/* ========================================================================
 * Bootstrap: dropdown.js v3.3.4
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // DROPDOWN CLASS DEFINITION
  // =========================
  var backdrop = '.dropdown-backdrop'
  var toggle   = '[data-toggle="dropdown"]'
  var Dropdown = function (element) {
    $(element).on('click.bs.dropdown', this.toggle)
  }
  Dropdown.VERSION = '3.3.4'
  Dropdown.prototype.toggle = function (e) {
    var $this = $(this)
    if ($this.is('.disabled, :disabled')) return
    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')
    clearMenus()
    if (!isActive) {
      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
        // if mobile we use a backdrop because click events don't delegate
        $('<div class="dropdown-backdrop"/>').insertAfter($(this)).on('click', clearMenus)
      }
      var relatedTarget = { relatedTarget: this }
      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))
      if (e.isDefaultPrevented()) return
      $this
        .trigger('focus')
        .attr('aria-expanded', 'true')
      $parent
        .toggleClass('open')
        .trigger('shown.bs.dropdown', relatedTarget)
    }
    return false
  }
  Dropdown.prototype.keydown = function (e) {
    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return
    var $this = $(this)
    e.preventDefault()
    e.stopPropagation()
    if ($this.is('.disabled, :disabled')) return
    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')
    if ((!isActive && e.which != 27) || (isActive && e.which == 27)) {
      if (e.which == 27) $parent.find(toggle).trigger('focus')
      return $this.trigger('click')
    }
    var desc = ' li:not(.disabled):visible a'
    var $items = $parent.find('[role="menu"]' + desc + ', [role="listbox"]' + desc)
    if (!$items.length) return
    var index = $items.index(e.target)
    if (e.which == 38 && index > 0)                 index--                        // up
    if (e.which == 40 && index < $items.length - 1) index++                        // down
    if (!~index)                                      index = 0
    $items.eq(index).trigger('focus')
  }
  function clearMenus(e) {
    if (e && e.which === 3) return
    $(backdrop).remove()
    $(toggle).each(function () {
      var $this         = $(this)
      var $parent       = getParent($this)
      var relatedTarget = { relatedTarget: this }
      if (!$parent.hasClass('open')) return
      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))
      if (e.isDefaultPrevented()) return
      $this.attr('aria-expanded', 'false')
      $parent.removeClass('open').trigger('hidden.bs.dropdown', relatedTarget)
    })
  }
  function getParent($this) {
    var selector = $this.attr('data-target')
    if (!selector) {
      selector = $this.attr('href')
      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }
    var $parent = selector && $(selector)
    return $parent && $parent.length ? $parent : $this.parent()
  }
  // DROPDOWN PLUGIN DEFINITION
  // ==========================
  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.dropdown')
      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }
  var old = $.fn.dropdown
  $.fn.dropdown             = Plugin
  $.fn.dropdown.Constructor = Dropdown
  // DROPDOWN NO CONFLICT
  // ====================
  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old
    return this
  }
  // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================
  $(document)
    .on('click.bs.dropdown.data-api', clearMenus)
    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)
    .on('keydown.bs.dropdown.data-api', '[role="menu"]', Dropdown.prototype.keydown)
    .on('keydown.bs.dropdown.data-api', '[role="listbox"]', Dropdown.prototype.keydown)
}(jQuery);
/* ========================================================================
 * Bootstrap: modal.js v3.3.4
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // MODAL CLASS DEFINITION
  // ======================
  var Modal = function (element, options) {
    this.options             = options
    this.$body               = $(document.body)
    this.$element            = $(element)
    this.$dialog             = this.$element.find('.modal-dialog')
    this.$backdrop           = null
    this.isShown             = null
    this.originalBodyPad     = null
    this.scrollbarWidth      = 0
    this.ignoreBackdropClick = false
    if (this.options.remote) {
      this.$element
        .find('.modal-content')
        .load(this.options.remote, $.proxy(function () {
          this.$element.trigger('loaded.bs.modal')
        }, this))
    }
  }
  Modal.VERSION  = '3.3.4'
  Modal.TRANSITION_DURATION = 300
  Modal.BACKDROP_TRANSITION_DURATION = 150
  Modal.DEFAULTS = {
    backdrop: true,
    keyboard: true,
    show: true
  }
  Modal.prototype.toggle = function (_relatedTarget) {
    return this.isShown ? this.hide() : this.show(_relatedTarget)
  }
  Modal.prototype.show = function (_relatedTarget) {
    var that = this
    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })
    this.$element.trigger(e)
    if (this.isShown || e.isDefaultPrevented()) return
    this.isShown = true
    this.checkScrollbar()
    this.setScrollbar()
    this.$body.addClass('modal-open')
    this.escape()
    this.resize()
    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))
    this.$dialog.on('mousedown.dismiss.bs.modal', function () {
      that.$element.one('mouseup.dismiss.bs.modal', function (e) {
        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true
      })
    })
    this.backdrop(function () {
      var transition = $.support.transition && that.$element.hasClass('fade')
      if (!that.$element.parent().length) {
        that.$element.appendTo(that.$body) // don't move modals dom position
      }
      that.$element
        .show()
        .scrollTop(0)
      that.adjustDialog()
      if (transition) {
        that.$element[0].offsetWidth // force reflow
      }
      that.$element
        .addClass('in')
        .attr('aria-hidden', false)
      that.enforceFocus()
      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })
      transition ?
        that.$dialog // wait for modal to slide in
          .one('bsTransitionEnd', function () {
            that.$element.trigger('focus').trigger(e)
          })
          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
        that.$element.trigger('focus').trigger(e)
    })
  }
  Modal.prototype.hide = function (e) {
    if (e) e.preventDefault()
    e = $.Event('hide.bs.modal')
    this.$element.trigger(e)
    if (!this.isShown || e.isDefaultPrevented()) return
    this.isShown = false
    this.escape()
    this.resize()
    $(document).off('focusin.bs.modal')
    this.$element
      .removeClass('in')
      .attr('aria-hidden', true)
      .off('click.dismiss.bs.modal')
      .off('mouseup.dismiss.bs.modal')
    this.$dialog.off('mousedown.dismiss.bs.modal')
    $.support.transition && this.$element.hasClass('fade') ?
      this.$element
        .one('bsTransitionEnd', $.proxy(this.hideModal, this))
        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
      this.hideModal()
  }
  Modal.prototype.enforceFocus = function () {
    $(document)
      .off('focusin.bs.modal') // guard against infinite focus loop
      .on('focusin.bs.modal', $.proxy(function (e) {
        if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
          this.$element.trigger('focus')
        }
      }, this))
  }
  Modal.prototype.escape = function () {
    if (this.isShown && this.options.keyboard) {
      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
        e.which == 27 && this.hide()
      }, this))
    } else if (!this.isShown) {
      this.$element.off('keydown.dismiss.bs.modal')
    }
  }
  Modal.prototype.resize = function () {
    if (this.isShown) {
      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))
    } else {
      $(window).off('resize.bs.modal')
    }
  }
  Modal.prototype.hideModal = function () {
    var that = this
    this.$element.hide()
    this.backdrop(function () {
      that.$body.removeClass('modal-open')
      that.resetAdjustments()
      that.resetScrollbar()
      that.$element.trigger('hidden.bs.modal')
    })
  }
  Modal.prototype.removeBackdrop = function () {
    this.$backdrop && this.$backdrop.remove()
    this.$backdrop = null
  }
  Modal.prototype.backdrop = function (callback) {
    var that = this
    var animate = this.$element.hasClass('fade') ? 'fade' : ''
    if (this.isShown && this.options.backdrop) {
      var doAnimate = $.support.transition && animate
      this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />')
        .appendTo(this.$body)
      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
        if (this.ignoreBackdropClick) {
          this.ignoreBackdropClick = false
          return
        }
        if (e.target !== e.currentTarget) return
        this.options.backdrop == 'static'
          ? this.$element[0].focus()
          : this.hide()
      }, this))
      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow
      this.$backdrop.addClass('in')
      if (!callback) return
      doAnimate ?
        this.$backdrop
          .one('bsTransitionEnd', callback)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callback()
    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass('in')
      var callbackRemove = function () {
        that.removeBackdrop()
        callback && callback()
      }
      $.support.transition && this.$element.hasClass('fade') ?
        this.$backdrop
          .one('bsTransitionEnd', callbackRemove)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callbackRemove()
    } else if (callback) {
      callback()
    }
  }
  // these following methods are used to handle overflowing modals
  Modal.prototype.handleUpdate = function () {
    this.adjustDialog()
  }
  Modal.prototype.adjustDialog = function () {
    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight
    this.$element.css({
      paddingLeft:  !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
    })
  }
  Modal.prototype.resetAdjustments = function () {
    this.$element.css({
      paddingLeft: '',
      paddingRight: ''
    })
  }
  Modal.prototype.checkScrollbar = function () {
    var fullWindowWidth = window.innerWidth
    if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8
      var documentElementRect = document.documentElement.getBoundingClientRect()
      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)
    }
    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth
    this.scrollbarWidth = this.measureScrollbar()
  }
  Modal.prototype.setScrollbar = function () {
    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
    this.originalBodyPad = document.body.style.paddingRight || ''
    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
  }
  Modal.prototype.resetScrollbar = function () {
    this.$body.css('padding-right', this.originalBodyPad)
  }
  Modal.prototype.measureScrollbar = function () { // thx walsh
    var scrollDiv = document.createElement('div')
    scrollDiv.className = 'modal-scrollbar-measure'
    this.$body.append(scrollDiv)
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
    this.$body[0].removeChild(scrollDiv)
    return scrollbarWidth
  }
  // MODAL PLUGIN DEFINITION
  // =======================
  function Plugin(option, _relatedTarget) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.modal')
      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)
      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
      if (typeof option == 'string') data[option](_relatedTarget)
      else if (options.show) data.show(_relatedTarget)
    })
  }
  var old = $.fn.modal
  $.fn.modal             = Plugin
  $.fn.modal.Constructor = Modal
  // MODAL NO CONFLICT
  // =================
  $.fn.modal.noConflict = function () {
    $.fn.modal = old
    return this
  }
  // MODAL DATA-API
  // ==============
  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this   = $(this)
    var href    = $this.attr('href')
    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) // strip for ie7
    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())
    if ($this.is('a')) e.preventDefault()
    $target.one('show.bs.modal', function (showEvent) {
      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown
      $target.one('hidden.bs.modal', function () {
        $this.is(':visible') && $this.trigger('focus')
      })
    })
    Plugin.call($target, option, this)
  })
}(jQuery);
/* ========================================================================
 * Bootstrap: tooltip.js v3.3.4
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // TOOLTIP PUBLIC CLASS DEFINITION
  // ===============================
  var Tooltip = function (element, options) {
    this.type       = null
    this.options    = null
    this.enabled    = null
    this.timeout    = null
    this.hoverState = null
    this.$element   = null
    this.init('tooltip', element, options)
  }
  Tooltip.VERSION  = '3.3.4'
  Tooltip.TRANSITION_DURATION = 150
  Tooltip.DEFAULTS = {
    animation: true,
    placement: 'top',
    selector: false,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    container: false,
    viewport: {
      selector: 'body',
      padding: 0
    }
  }
  Tooltip.prototype.init = function (type, element, options) {
    this.enabled   = true
    this.type      = type
    this.$element  = $(element)
    this.options   = this.getOptions(options)
    this.$viewport = this.options.viewport && $(this.options.viewport.selector || this.options.viewport)
    if (this.$element[0] instanceof document.constructor && !this.options.selector) {
      throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!')
    }
    var triggers = this.options.trigger.split(' ')
    for (var i = triggers.length; i--;) {
      var trigger = triggers[i]
      if (trigger == 'click') {
        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
      } else if (trigger != 'manual') {
        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'
        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'
        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
      }
    }
    this.options.selector ?
      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
      this.fixTitle()
  }
  Tooltip.prototype.getDefaults = function () {
    return Tooltip.DEFAULTS
  }
  Tooltip.prototype.getOptions = function (options) {
    options = $.extend({}, this.getDefaults(), this.$element.data(), options)
    if (options.delay && typeof options.delay == 'number') {
      options.delay = {
        show: options.delay,
        hide: options.delay
      }
    }
    return options
  }
  Tooltip.prototype.getDelegateOptions = function () {
    var options  = {}
    var defaults = this.getDefaults()
    this._options && $.each(this._options, function (key, value) {
      if (defaults[key] != value) options[key] = value
    })
    return options
  }
  Tooltip.prototype.enter = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)
    if (self && self.$tip && self.$tip.is(':visible')) {
      self.hoverState = 'in'
      return
    }
    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }
    clearTimeout(self.timeout)
    self.hoverState = 'in'
    if (!self.options.delay || !self.options.delay.show) return self.show()
    self.timeout = setTimeout(function () {
      if (self.hoverState == 'in') self.show()
    }, self.options.delay.show)
  }
  Tooltip.prototype.leave = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)
    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }
    clearTimeout(self.timeout)
    self.hoverState = 'out'
    if (!self.options.delay || !self.options.delay.hide) return self.hide()
    self.timeout = setTimeout(function () {
      if (self.hoverState == 'out') self.hide()
    }, self.options.delay.hide)
  }
  Tooltip.prototype.show = function () {
    var e = $.Event('show.bs.' + this.type)
    if (this.hasContent() && this.enabled) {
      this.$element.trigger(e)
      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
      if (e.isDefaultPrevented() || !inDom) return
      var that = this
      var $tip = this.tip()
      var tipId = this.getUID(this.type)
      this.setContent()
      $tip.attr('id', tipId)
      this.$element.attr('aria-describedby', tipId)
      if (this.options.animation) $tip.addClass('fade')
      var placement = typeof this.options.placement == 'function' ?
        this.options.placement.call(this, $tip[0], this.$element[0]) :
        this.options.placement
      var autoToken = /\s?auto?\s?/i
      var autoPlace = autoToken.test(placement)
      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'
      $tip
        .detach()
        .css({ top: 0, left: 0, display: 'block' })
        .addClass(placement)
        .data('bs.' + this.type, this)
      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)
      var pos          = this.getPosition()
      var actualWidth  = $tip[0].offsetWidth
      var actualHeight = $tip[0].offsetHeight
      if (autoPlace) {
        var orgPlacement = placement
        var $container   = this.options.container ? $(this.options.container) : this.$element.parent()
        var containerDim = this.getPosition($container)
        placement = placement == 'bottom' && pos.bottom + actualHeight > containerDim.bottom ? 'top'    :
                    placement == 'top'    && pos.top    - actualHeight < containerDim.top    ? 'bottom' :
                    placement == 'right'  && pos.right  + actualWidth  > containerDim.width  ? 'left'   :
                    placement == 'left'   && pos.left   - actualWidth  < containerDim.left   ? 'right'  :
                    placement
        $tip
          .removeClass(orgPlacement)
          .addClass(placement)
      }
      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)
      this.applyPlacement(calculatedOffset, placement)
      var complete = function () {
        var prevHoverState = that.hoverState
        that.$element.trigger('shown.bs.' + that.type)
        that.hoverState = null
        if (prevHoverState == 'out') that.leave(that)
      }
      $.support.transition && this.$tip.hasClass('fade') ?
        $tip
          .one('bsTransitionEnd', complete)
          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
        complete()
    }
  }
  Tooltip.prototype.applyPlacement = function (offset, placement) {
    var $tip   = this.tip()
    var width  = $tip[0].offsetWidth
    var height = $tip[0].offsetHeight
    // manually read margins because getBoundingClientRect includes difference
    var marginTop = parseInt($tip.css('margin-top'), 10)
    var marginLeft = parseInt($tip.css('margin-left'), 10)
    // we must check for NaN for ie 8/9
    if (isNaN(marginTop))  marginTop  = 0
    if (isNaN(marginLeft)) marginLeft = 0
    offset.top  = offset.top  + marginTop
    offset.left = offset.left + marginLeft
    // $.fn.offset doesn't round pixel values
    // so we use setOffset directly with our own function B-0
    $.offset.setOffset($tip[0], $.extend({
      using: function (props) {
        $tip.css({
          top: Math.round(props.top),
          left: Math.round(props.left)
        })
      }
    }, offset), 0)
    $tip.addClass('in')
    // check to see if placing tip in new offset caused the tip to resize itself
    var actualWidth  = $tip[0].offsetWidth
    var actualHeight = $tip[0].offsetHeight
    if (placement == 'top' && actualHeight != height) {
      offset.top = offset.top + height - actualHeight
    }
    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)
    if (delta.left) offset.left += delta.left
    else offset.top += delta.top
    var isVertical          = /top|bottom/.test(placement)
    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'
    $tip.offset(offset)
    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
  }
  Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {
    this.arrow()
      .css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')
      .css(isVertical ? 'top' : 'left', '')
  }
  Tooltip.prototype.setContent = function () {
    var $tip  = this.tip()
    var title = this.getTitle()
    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
    $tip.removeClass('fade in top bottom left right')
  }
  Tooltip.prototype.hide = function (callback) {
    var that = this
    var $tip = $(this.$tip)
    var e    = $.Event('hide.bs.' + this.type)
    function complete() {
      if (that.hoverState != 'in') $tip.detach()
      that.$element
        .removeAttr('aria-describedby')
        .trigger('hidden.bs.' + that.type)
      callback && callback()
    }
    this.$element.trigger(e)
    if (e.isDefaultPrevented()) return
    $tip.removeClass('in')
    $.support.transition && $tip.hasClass('fade') ?
      $tip
        .one('bsTransitionEnd', complete)
        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
      complete()
    this.hoverState = null
    return this
  }
  Tooltip.prototype.fixTitle = function () {
    var $e = this.$element
    if ($e.attr('title') || typeof ($e.attr('data-original-title')) != 'string') {
      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
    }
  }
  Tooltip.prototype.hasContent = function () {
    return this.getTitle()
  }
  Tooltip.prototype.getPosition = function ($element) {
    $element   = $element || this.$element
    var el     = $element[0]
    var isBody = el.tagName == 'BODY'
    var elRect    = el.getBoundingClientRect()
    if (elRect.width == null) {
      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })
    }
    var elOffset  = isBody ? { top: 0, left: 0 } : $element.offset()
    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }
    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null
    return $.extend({}, elRect, scroll, outerDims, elOffset)
  }
  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2 } :
           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } :
           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width }
  }
  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
    var delta = { top: 0, left: 0 }
    if (!this.$viewport) return delta
    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0
    var viewportDimensions = this.getPosition(this.$viewport)
    if (/right|left/.test(placement)) {
      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll
      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
      if (topEdgeOffset < viewportDimensions.top) { // top overflow
        delta.top = viewportDimensions.top - topEdgeOffset
      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow
        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
      }
    } else {
      var leftEdgeOffset  = pos.left - viewportPadding
      var rightEdgeOffset = pos.left + viewportPadding + actualWidth
      if (leftEdgeOffset < viewportDimensions.left) { // left overflow
        delta.left = viewportDimensions.left - leftEdgeOffset
      } else if (rightEdgeOffset > viewportDimensions.width) { // right overflow
        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
      }
    }
    return delta
  }
  Tooltip.prototype.getTitle = function () {
    var title
    var $e = this.$element
    var o  = this.options
    title = $e.attr('data-original-title')
      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)
    return title
  }
  Tooltip.prototype.getUID = function (prefix) {
    do prefix += ~~(Math.random() * 1000000)
    while (document.getElementById(prefix))
    return prefix
  }
  Tooltip.prototype.tip = function () {
    return (this.$tip = this.$tip || $(this.options.template))
  }
  Tooltip.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
  }
  Tooltip.prototype.enable = function () {
    this.enabled = true
  }
  Tooltip.prototype.disable = function () {
    this.enabled = false
  }
  Tooltip.prototype.toggleEnabled = function () {
    this.enabled = !this.enabled
  }
  Tooltip.prototype.toggle = function (e) {
    var self = this
    if (e) {
      self = $(e.currentTarget).data('bs.' + this.type)
      if (!self) {
        self = new this.constructor(e.currentTarget, this.getDelegateOptions())
        $(e.currentTarget).data('bs.' + this.type, self)
      }
    }
    self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
  }
  Tooltip.prototype.destroy = function () {
    var that = this
    clearTimeout(this.timeout)
    this.hide(function () {
      that.$element.off('.' + that.type).removeData('bs.' + that.type)
    })
  }
  // TOOLTIP PLUGIN DEFINITION
  // =========================
  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.tooltip')
      var options = typeof option == 'object' && option
      if (!data && /destroy|hide/.test(option)) return
      if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }
  var old = $.fn.tooltip
  $.fn.tooltip             = Plugin
  $.fn.tooltip.Constructor = Tooltip
  // TOOLTIP NO CONFLICT
  // ===================
  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old
    return this
  }
}(jQuery);
/* ========================================================================
 * Bootstrap: popover.js v3.3.4
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // POPOVER PUBLIC CLASS DEFINITION
  // ===============================
  var Popover = function (element, options) {
    this.init('popover', element, options)
  }
  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')
  Popover.VERSION  = '3.3.4'
  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
  })
  // NOTE: POPOVER EXTENDS tooltip.js
  // ================================
  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)
  Popover.prototype.constructor = Popover
  Popover.prototype.getDefaults = function () {
    return Popover.DEFAULTS
  }
  Popover.prototype.setContent = function () {
    var $tip    = this.tip()
    var title   = this.getTitle()
    var content = this.getContent()
    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
    $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events
      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
    ](content)
    $tip.removeClass('fade top bottom left right in')
    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
    // this manually by checking the contents.
    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
  }
  Popover.prototype.hasContent = function () {
    return this.getTitle() || this.getContent()
  }
  Popover.prototype.getContent = function () {
    var $e = this.$element
    var o  = this.options
    return $e.attr('data-content')
      || (typeof o.content == 'function' ?
            o.content.call($e[0]) :
            o.content)
  }
  Popover.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
  }
  // POPOVER PLUGIN DEFINITION
  // =========================
  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.popover')
      var options = typeof option == 'object' && option
      if (!data && /destroy|hide/.test(option)) return
      if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }
  var old = $.fn.popover
  $.fn.popover             = Plugin
  $.fn.popover.Constructor = Popover
  // POPOVER NO CONFLICT
  // ===================
  $.fn.popover.noConflict = function () {
    $.fn.popover = old
    return this
  }
}(jQuery);
/* ========================================================================
 * Bootstrap: scrollspy.js v3.3.4
 * http://getbootstrap.com/javascript/#scrollspy
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // SCROLLSPY CLASS DEFINITION
  // ==========================
  function ScrollSpy(element, options) {
    this.$body          = $(document.body)
    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)
    this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)
    this.selector       = (this.options.target || '') + ' .nav li > a'
    this.offsets        = []
    this.targets        = []
    this.activeTarget   = null
    this.scrollHeight   = 0
    this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this))
    this.refresh()
    this.process()
  }
  ScrollSpy.VERSION  = '3.3.4'
  ScrollSpy.DEFAULTS = {
    offset: 10
  }
  ScrollSpy.prototype.getScrollHeight = function () {
    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
  }
  ScrollSpy.prototype.refresh = function () {
    var that          = this
    var offsetMethod  = 'offset'
    var offsetBase    = 0
    this.offsets      = []
    this.targets      = []
    this.scrollHeight = this.getScrollHeight()
    if (!$.isWindow(this.$scrollElement[0])) {
      offsetMethod = 'position'
      offsetBase   = this.$scrollElement.scrollTop()
    }
    this.$body
      .find(this.selector)
      .map(function () {
        var $el   = $(this)
        var href  = $el.data('target') || $el.attr('href')
        var $href = /^#./.test(href) && $(href)
        return ($href
          && $href.length
          && $href.is(':visible')
          && [[$href[offsetMethod]().top + offsetBase, href]]) || null
      })
      .sort(function (a, b) { return a[0] - b[0] })
      .each(function () {
        that.offsets.push(this[0])
        that.targets.push(this[1])
      })
  }
  ScrollSpy.prototype.process = function () {
    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset
    var scrollHeight = this.getScrollHeight()
    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()
    var offsets      = this.offsets
    var targets      = this.targets
    var activeTarget = this.activeTarget
    var i
    if (this.scrollHeight != scrollHeight) {
      this.refresh()
    }
    if (scrollTop >= maxScroll) {
      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)
    }
    if (activeTarget && scrollTop < offsets[0]) {
      this.activeTarget = null
      return this.clear()
    }
    for (i = offsets.length; i--;) {
      activeTarget != targets[i]
        && scrollTop >= offsets[i]
        && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1])
        && this.activate(targets[i])
    }
  }
  ScrollSpy.prototype.activate = function (target) {
    this.activeTarget = target
    this.clear()
    var selector = this.selector +
      '[data-target="' + target + '"],' +
      this.selector + '[href="' + target + '"]'
    var active = $(selector)
      .parents('li')
      .addClass('active')
    if (active.parent('.dropdown-menu').length) {
      active = active
        .closest('li.dropdown')
        .addClass('active')
    }
    active.trigger('activate.bs.scrollspy')
  }
  ScrollSpy.prototype.clear = function () {
    $(this.selector)
      .parentsUntil(this.options.target, '.active')
      .removeClass('active')
  }
  // SCROLLSPY PLUGIN DEFINITION
  // ===========================
  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.scrollspy')
      var options = typeof option == 'object' && option
      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }
  var old = $.fn.scrollspy
  $.fn.scrollspy             = Plugin
  $.fn.scrollspy.Constructor = ScrollSpy
  // SCROLLSPY NO CONFLICT
  // =====================
  $.fn.scrollspy.noConflict = function () {
    $.fn.scrollspy = old
    return this
  }
  // SCROLLSPY DATA-API
  // ==================
  $(window).on('load.bs.scrollspy.data-api', function () {
    $('[data-spy="scroll"]').each(function () {
      var $spy = $(this)
      Plugin.call($spy, $spy.data())
    })
  })
}(jQuery);
/* ========================================================================
 * Bootstrap: tab.js v3.3.4
 * http://getbootstrap.com/javascript/#tabs
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // TAB CLASS DEFINITION
  // ====================
  var Tab = function (element) {
    this.element = $(element)
  }
  Tab.VERSION = '3.3.4'
  Tab.TRANSITION_DURATION = 150
  Tab.prototype.show = function () {
    var $this    = this.element
    var $ul      = $this.closest('ul:not(.dropdown-menu)')
    var selector = $this.data('target')
    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }
    if ($this.parent('li').hasClass('active')) return
    var $previous = $ul.find('.active:last a')
    var hideEvent = $.Event('hide.bs.tab', {
      relatedTarget: $this[0]
    })
    var showEvent = $.Event('show.bs.tab', {
      relatedTarget: $previous[0]
    })
    $previous.trigger(hideEvent)
    $this.trigger(showEvent)
    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return
    var $target = $(selector)
    this.activate($this.closest('li'), $ul)
    this.activate($target, $target.parent(), function () {
      $previous.trigger({
        type: 'hidden.bs.tab',
        relatedTarget: $this[0]
      })
      $this.trigger({
        type: 'shown.bs.tab',
        relatedTarget: $previous[0]
      })
    })
  }
  Tab.prototype.activate = function (element, container, callback) {
    var $active    = container.find('> .active')
    var transition = callback
      && $.support.transition
      && (($active.length && $active.hasClass('fade')) || !!container.find('> .fade').length)
    function next() {
      $active
        .removeClass('active')
        .find('> .dropdown-menu > .active')
          .removeClass('active')
        .end()
        .find('[data-toggle="tab"]')
          .attr('aria-expanded', false)
      element
        .addClass('active')
        .find('[data-toggle="tab"]')
          .attr('aria-expanded', true)
      if (transition) {
        element[0].offsetWidth // reflow for transition
        element.addClass('in')
      } else {
        element.removeClass('fade')
      }
      if (element.parent('.dropdown-menu').length) {
        element
          .closest('li.dropdown')
            .addClass('active')
          .end()
          .find('[data-toggle="tab"]')
            .attr('aria-expanded', true)
      }
      callback && callback()
    }
    $active.length && transition ?
      $active
        .one('bsTransitionEnd', next)
        .emulateTransitionEnd(Tab.TRANSITION_DURATION) :
      next()
    $active.removeClass('in')
  }
  // TAB PLUGIN DEFINITION
  // =====================
  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.tab')
      if (!data) $this.data('bs.tab', (data = new Tab(this)))
      if (typeof option == 'string') data[option]()
    })
  }
  var old = $.fn.tab
  $.fn.tab             = Plugin
  $.fn.tab.Constructor = Tab
  // TAB NO CONFLICT
  // ===============
  $.fn.tab.noConflict = function () {
    $.fn.tab = old
    return this
  }
  // TAB DATA-API
  // ============
  var clickHandler = function (e) {
    e.preventDefault()
    Plugin.call($(this), 'show')
  }
  $(document)
    .on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler)
    .on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler)
}(jQuery);
/* ========================================================================
 * Bootstrap: affix.js v3.3.4
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // AFFIX CLASS DEFINITION
  // ======================
  var Affix = function (element, options) {
    this.options = $.extend({}, Affix.DEFAULTS, options)
    this.$target = $(this.options.target)
      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))
    this.$element     = $(element)
    this.affixed      = null
    this.unpin        = null
    this.pinnedOffset = null
    this.checkPosition()
  }
  Affix.VERSION  = '3.3.4'
  Affix.RESET    = 'affix affix-top affix-bottom'
  Affix.DEFAULTS = {
    offset: 0,
    target: window
  }
  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
    var scrollTop    = this.$target.scrollTop()
    var position     = this.$element.offset()
    var targetHeight = this.$target.height()
    if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false
    if (this.affixed == 'bottom') {
      if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'
      return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'
    }
    var initializing   = this.affixed == null
    var colliderTop    = initializing ? scrollTop : position.top
    var colliderHeight = initializing ? targetHeight : height
    if (offsetTop != null && scrollTop <= offsetTop) return 'top'
    if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'
    return false
  }
  Affix.prototype.getPinnedOffset = function () {
    if (this.pinnedOffset) return this.pinnedOffset
    this.$element.removeClass(Affix.RESET).addClass('affix')
    var scrollTop = this.$target.scrollTop()
    var position  = this.$element.offset()
    return (this.pinnedOffset = position.top - scrollTop)
  }
  Affix.prototype.checkPositionWithEventLoop = function () {
    setTimeout($.proxy(this.checkPosition, this), 1)
  }
  Affix.prototype.checkPosition = function () {
    if (!this.$element.is(':visible')) return
    var height       = this.$element.height()
    var offset       = this.options.offset
    var offsetTop    = offset.top
    var offsetBottom = offset.bottom
    var scrollHeight = $(document.body).height()
    if (typeof offset != 'object')         offsetBottom = offsetTop = offset
    if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)
    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)
    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)
    if (this.affixed != affix) {
      if (this.unpin != null) this.$element.css('top', '')
      var affixType = 'affix' + (affix ? '-' + affix : '')
      var e         = $.Event(affixType + '.bs.affix')
      this.$element.trigger(e)
      if (e.isDefaultPrevented()) return
      this.affixed = affix
      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null
      this.$element
        .removeClass(Affix.RESET)
        .addClass(affixType)
        .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')
    }
    if (affix == 'bottom') {
      this.$element.offset({
        top: scrollHeight - height - offsetBottom
      })
    }
  }
  // AFFIX PLUGIN DEFINITION
  // =======================
  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.affix')
      var options = typeof option == 'object' && option
      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }
  var old = $.fn.affix
  $.fn.affix             = Plugin
  $.fn.affix.Constructor = Affix
  // AFFIX NO CONFLICT
  // =================
  $.fn.affix.noConflict = function () {
    $.fn.affix = old
    return this
  }
  // AFFIX DATA-API
  // ==============
  $(window).on('load', function () {
    $('[data-spy="affix"]').each(function () {
      var $spy = $(this)
      var data = $spy.data()
      data.offset = data.offset || {}
      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom
      if (data.offsetTop    != null) data.offset.top    = data.offsetTop
      Plugin.call($spy, data)
    })
  })
}(jQuery);
})})
Numbas.queueScript('jasny-bootstrap',['bootstrap','jquery'],function() {
/*!
 * Jasny Bootstrap v3.1.3 (http://jasny.github.io/bootstrap)
 * Copyright 2012-2014 Arnold Daniels
 * Licensed under Apache-2.0 (https://github.com/jasny/bootstrap/blob/master/LICENSE)
 */
if (typeof jQuery === 'undefined') { throw new Error('Jasny Bootstrap\'s JavaScript requires jQuery') }
/* ========================================================================
 * Bootstrap: transition.js v3.1.3
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================
  function transitionEnd() {
    var el = document.createElement('bootstrap')
    var transEndEventNames = {
      WebkitTransition : 'webkitTransitionEnd',
      MozTransition    : 'transitionend',
      OTransition      : 'oTransitionEnd otransitionend',
      transition       : 'transitionend'
    }
    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return { end: transEndEventNames[name] }
      }
    }
    return false // explicit for ie8 (  ._.)
  }
  if ($.support.transition !== undefined) return  // Prevent conflict with Twitter Bootstrap
  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
    var called = false, $el = this
    $(this).one($.support.transition.end, function () { called = true })
    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
    setTimeout(callback, duration)
    return this
  }
  $(function () {
    $.support.transition = transitionEnd()
  })
}(window.jQuery);
/* ========================================================================
 * Bootstrap: offcanvas.js v3.1.3
 * http://jasny.github.io/bootstrap/javascript/#offcanvas
 * ========================================================================
 * Copyright 2013-2014 Arnold Daniels
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */
+function ($) { "use strict";
  // OFFCANVAS PUBLIC CLASS DEFINITION
  // =================================
  var OffCanvas = function (element, options) {
    this.$element = $(element)
    this.options  = $.extend({}, OffCanvas.DEFAULTS, options)
    this.state    = null
    this.placement = null
    if (this.options.recalc) {
      this.calcClone()
      $(window).on('resize', $.proxy(this.recalc, this))
    }
    if (this.options.autohide)
      $(document).on('click', $.proxy(this.autohide, this))
    if (this.options.toggle) this.toggle()
    if (this.options.disablescrolling) {
        this.options.disableScrolling = this.options.disablescrolling
        delete this.options.disablescrolling
    }
  }
  OffCanvas.DEFAULTS = {
    toggle: true,
    placement: 'auto',
    autohide: true,
    recalc: true,
    disableScrolling: true,
    exclude: '.modal'
  }
  OffCanvas.prototype.offset = function () {
    switch (this.placement) {
      case 'left':
      case 'right':  return this.$element.outerWidth()
      case 'top':
      case 'bottom': return this.$element.outerHeight()
    }
  }
  OffCanvas.prototype.calcPlacement = function () {
    if (this.options.placement !== 'auto') {
        this.placement = this.options.placement
        return
    }
    if (!this.$element.hasClass('in')) {
      this.$element.css('visiblity', 'hidden !important').addClass('in')
    }
    var horizontal = $(window).width() / this.$element.width()
    var vertical = $(window).height() / this.$element.height()
    var element = this.$element
    function ab(a, b) {
      if (element.css(b) === 'auto') return a
      if (element.css(a) === 'auto') return b
      var size_a = parseInt(element.css(a), 10)
      var size_b = parseInt(element.css(b), 10)
      return size_a > size_b ? b : a
    }
    this.placement = horizontal >= vertical ? ab('left', 'right') : ab('top', 'bottom')
    if (this.$element.css('visibility') === 'hidden !important') {
      this.$element.removeClass('in').css('visiblity', '')
    }
  }
  OffCanvas.prototype.opposite = function (placement) {
    switch (placement) {
      case 'top':    return 'bottom'
      case 'left':   return 'right'
      case 'bottom': return 'top'
      case 'right':  return 'left'
    }
  }
  OffCanvas.prototype.getCanvasElements = function() {
    // Return a set containing the canvas plus all fixed elements
    var canvas = this.options.canvas ? $(this.options.canvas) : this.$element
    var fixed_elements = canvas.find('*').filter(function() {
      return $(this).css('position') === 'fixed'
    }).not(this.options.exclude)
    return canvas.add(fixed_elements)
  }
  OffCanvas.prototype.slide = function (elements, offset, callback) {
    // Use jQuery animation if CSS transitions aren't supported
    if (!$.support.transition) {
      var anim = {}
      anim[this.placement] = "+=" + offset
      return elements.animate(anim, 350, callback)
    }
    var placement = this.placement
    var opposite = this.opposite(placement)
    elements.each(function() {
      if ($(this).css(placement) !== 'auto')
        $(this).css(placement, (parseInt($(this).css(placement), 10) || 0) + offset)
      if ($(this).css(opposite) !== 'auto')
        $(this).css(opposite, (parseInt($(this).css(opposite), 10) || 0) - offset)
    })
    this.$element
      .one($.support.transition.end, callback)
      .emulateTransitionEnd(350)
  }
  OffCanvas.prototype.disableScrolling = function() {
    var bodyWidth = $('body').width()
    var prop = 'padding-' + this.opposite(this.placement)
    if ($('body').data('offcanvas-style') === undefined) {
      $('body').data('offcanvas-style', $('body').attr('style') || '')
    }
    $('body').css('overflow', 'hidden')
    if ($('body').width() > bodyWidth) {
      var padding = parseInt($('body').css(prop), 10) + $('body').width() - bodyWidth
      setTimeout(function() {
        $('body').css(prop, padding)
      }, 1)
    }
  }
  OffCanvas.prototype.show = function () {
    if (this.state) return
    var startEvent = $.Event('show.bs.offcanvas')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return
    this.state = 'slide-in'
    this.calcPlacement();
    var elements = this.getCanvasElements()
    var placement = this.placement
    var opposite = this.opposite(placement)
    var offset = this.offset()
    if (elements.index(this.$element) !== -1) {
      $(this.$element).data('offcanvas-style', $(this.$element).attr('style') || '')
      this.$element.css(placement, -1 * offset)
      this.$element.css(placement); // Workaround: Need to get the CSS property for it to be applied before the next line of code
    }
    elements.addClass('canvas-sliding').each(function() {
      if ($(this).data('offcanvas-style') === undefined) $(this).data('offcanvas-style', $(this).attr('style') || '')
      if ($(this).css('position') === 'static') $(this).css('position', 'relative')
      if (($(this).css(placement) === 'auto' || $(this).css(placement) === '0px') &&
          ($(this).css(opposite) === 'auto' || $(this).css(opposite) === '0px')) {
        $(this).css(placement, 0)
      }
    })
    if (this.options.disableScrolling) this.disableScrolling()
    var complete = function () {
      if (this.state != 'slide-in') return
      this.state = 'slid'
      elements.removeClass('canvas-sliding').addClass('canvas-slid')
      this.$element.trigger('shown.bs.offcanvas')
    }
    setTimeout($.proxy(function() {
      this.$element.addClass('in')
      this.slide(elements, offset, $.proxy(complete, this))
    }, this), 1)
  }
  OffCanvas.prototype.hide = function (fast) {
    if (this.state !== 'slid') return
    var startEvent = $.Event('hide.bs.offcanvas')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return
    this.state = 'slide-out'
    var elements = $('.canvas-slid')
    var placement = this.placement
    var offset = -1 * this.offset()
    var complete = function () {
      if (this.state != 'slide-out') return
      this.state = null
      this.placement = null
      this.$element.removeClass('in')
      elements.removeClass('canvas-sliding')
      elements.add(this.$element).add('body').each(function() {
        $(this).attr('style', $(this).data('offcanvas-style')).removeData('offcanvas-style')
      })
      this.$element.trigger('hidden.bs.offcanvas')
    }
    elements.removeClass('canvas-slid').addClass('canvas-sliding')
    setTimeout($.proxy(function() {
      this.slide(elements, offset, $.proxy(complete, this))
    }, this), 1)
  }
  OffCanvas.prototype.toggle = function () {
    if (this.state === 'slide-in' || this.state === 'slide-out') return
    this[this.state === 'slid' ? 'hide' : 'show']()
  }
  OffCanvas.prototype.calcClone = function() {
    this.$calcClone = this.$element.clone()
      .html('')
      .addClass('offcanvas-clone').removeClass('in')
      .appendTo($('body'))
  }
  OffCanvas.prototype.recalc = function () {
    if (this.$calcClone.css('display') === 'none' || (this.state !== 'slid' && this.state !== 'slide-in')) return
    this.state = null
    this.placement = null
    var elements = this.getCanvasElements()
    this.$element.removeClass('in')
    elements.removeClass('canvas-slid')
    elements.add(this.$element).add('body').each(function() {
      $(this).attr('style', $(this).data('offcanvas-style')).removeData('offcanvas-style')
    })
  }
  OffCanvas.prototype.autohide = function (e) {
    if ($(e.target).closest(this.$element).length === 0) this.hide()
  }
  // OFFCANVAS PLUGIN DEFINITION
  // ==========================
  var old = $.fn.offcanvas
  $.fn.offcanvas = function (option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.offcanvas')
      var options = $.extend({}, OffCanvas.DEFAULTS, $this.data(), typeof option === 'object' && option)
      if (!data) $this.data('bs.offcanvas', (data = new OffCanvas(this, options)))
      if (typeof option === 'string') data[option]()
    })
  }
  $.fn.offcanvas.Constructor = OffCanvas
  // OFFCANVAS NO CONFLICT
  // ====================
  $.fn.offcanvas.noConflict = function () {
    $.fn.offcanvas = old
    return this
  }
  // OFFCANVAS DATA-API
  // =================
  $(document).on('click.bs.offcanvas.data-api', '[data-toggle=offcanvas]', function (e) {
    var $this   = $(this), href
    var target  = $this.attr('data-target')
        || e.preventDefault()
        || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') //strip for ie7
    var $canvas = $(target)
    var data    = $canvas.data('bs.offcanvas')
    var option  = data ? 'toggle' : $this.data()
    e.stopPropagation()
    if (data) data.toggle()
      else $canvas.offcanvas(option)
  })
}(window.jQuery);
/* ============================================================
 * Bootstrap: rowlink.js v3.1.3
 * http://jasny.github.io/bootstrap/javascript/#rowlink
 * ============================================================
 * Copyright 2012-2014 Arnold Daniels
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================ */
+function ($) { "use strict";
  var Rowlink = function (element, options) {
    this.$element = $(element)
    this.options = $.extend({}, Rowlink.DEFAULTS, options)
    this.$element.on('click.bs.rowlink', 'td:not(.rowlink-skip)', $.proxy(this.click, this))
  }
  Rowlink.DEFAULTS = {
    target: "a"
  }
  Rowlink.prototype.click = function(e) {
    var target = $(e.currentTarget).closest('tr').find(this.options.target)[0]
    if ($(e.target)[0] === target) return
    e.preventDefault();
    if (target.click) {
      target.click()
    } else if (document.createEvent) {
      var evt = document.createEvent("MouseEvents");
      evt.initMouseEvent("click", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
      target.dispatchEvent(evt);
    }
  }
  // ROWLINK PLUGIN DEFINITION
  // ===========================
  var old = $.fn.rowlink
  $.fn.rowlink = function (options) {
    return this.each(function () {
      var $this = $(this)
      var data = $this.data('bs.rowlink')
      if (!data) $this.data('bs.rowlink', (data = new Rowlink(this, options)))
    })
  }
  $.fn.rowlink.Constructor = Rowlink
  // ROWLINK NO CONFLICT
  // ====================
  $.fn.rowlink.noConflict = function () {
    $.fn.rowlink = old
    return this
  }
  // ROWLINK DATA-API
  // ==================
  $(document).on('click.bs.rowlink.data-api', '[data-link="row"]', function (e) {
    if ($(e.target).closest('.rowlink-skip').length !== 0) return
    var $this = $(this)
    if ($this.data('bs.rowlink')) return
    $this.rowlink($this.data())
    $(e.target).trigger('click.bs.rowlink')
  })
}(window.jQuery);
/* ===========================================================
 * Bootstrap: inputmask.js v3.1.0
 * http://jasny.github.io/bootstrap/javascript/#inputmask
 *
 * Based on Masked Input plugin by Josh Bush (digitalbush.com)
 * ===========================================================
 * Copyright 2012-2014 Arnold Daniels
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */
+function ($) { "use strict";
  var isIphone = (window.orientation !== undefined)
  var isAndroid = navigator.userAgent.toLowerCase().indexOf("android") > -1
  var isIE = window.navigator.appName == 'Microsoft Internet Explorer'
  // INPUTMASK PUBLIC CLASS DEFINITION
  // =================================
  var Inputmask = function (element, options) {
    if (isAndroid) return // No support because caret positioning doesn't work on Android
    this.$element = $(element)
    this.options = $.extend({}, Inputmask.DEFAULTS, options)
    this.mask = String(this.options.mask)
    this.init()
    this.listen()
    this.checkVal() //Perform initial check for existing values
  }
  Inputmask.DEFAULTS = {
    mask: "",
    placeholder: "_",
    definitions: {
      '9': "[0-9]",
      'a': "[A-Za-z]",
      'w': "[A-Za-z0-9]",
      '*': "."
    }
  }
  Inputmask.prototype.init = function() {
    var defs = this.options.definitions
    var len = this.mask.length
    this.tests = []
    this.partialPosition = this.mask.length
    this.firstNonMaskPos = null
    $.each(this.mask.split(""), $.proxy(function(i, c) {
      if (c == '?') {
        len--
        this.partialPosition = i
      } else if (defs[c]) {
        this.tests.push(new RegExp(defs[c]))
        if (this.firstNonMaskPos === null)
          this.firstNonMaskPos =  this.tests.length - 1
      } else {
        this.tests.push(null)
      }
    }, this))
    this.buffer = $.map(this.mask.split(""), $.proxy(function(c, i) {
      if (c != '?') return defs[c] ? this.options.placeholder : c
    }, this))
    this.focusText = this.$element.val()
    this.$element.data("rawMaskFn", $.proxy(function() {
      return $.map(this.buffer, function(c, i) {
        return this.tests[i] && c != this.options.placeholder ? c : null
      }).join('')
    }, this))
  }
  Inputmask.prototype.listen = function() {
    if (this.$element.attr("readonly")) return
    var pasteEventName = (isIE ? 'paste' : 'input') + ".mask"
    this.$element
      .on("unmask.bs.inputmask", $.proxy(this.unmask, this))
      .on("focus.bs.inputmask", $.proxy(this.focusEvent, this))
      .on("blur.bs.inputmask", $.proxy(this.blurEvent, this))
      .on("keydown.bs.inputmask", $.proxy(this.keydownEvent, this))
      .on("keypress.bs.inputmask", $.proxy(this.keypressEvent, this))
      .on(pasteEventName, $.proxy(this.pasteEvent, this))
  }
  //Helper Function for Caret positioning
  Inputmask.prototype.caret = function(begin, end) {
    if (this.$element.length === 0) return
    if (typeof begin == 'number') {
      end = (typeof end == 'number') ? end : begin
      return this.$element.each(function() {
        if (this.setSelectionRange) {
          this.setSelectionRange(begin, end)
        } else if (this.createTextRange) {
          var range = this.createTextRange()
          range.collapse(true)
          range.moveEnd('character', end)
          range.moveStart('character', begin)
          range.select()
        }
      })
    } else {
      if (this.$element[0].setSelectionRange) {
        begin = this.$element[0].selectionStart
        end = this.$element[0].selectionEnd
      } else if (document.selection && document.selection.createRange) {
        var range = document.selection.createRange()
        begin = 0 - range.duplicate().moveStart('character', -100000)
        end = begin + range.text.length
      }
      return {
        begin: begin,
        end: end
      }
    }
  }
  Inputmask.prototype.seekNext = function(pos) {
    var len = this.mask.length
    while (++pos <= len && !this.tests[pos]);
    return pos
  }
  Inputmask.prototype.seekPrev = function(pos) {
    while (--pos >= 0 && !this.tests[pos]);
    return pos
  }
  Inputmask.prototype.shiftL = function(begin,end) {
    var len = this.mask.length
    if (begin < 0) return
    for (var i = begin, j = this.seekNext(end); i < len; i++) {
      if (this.tests[i]) {
        if (j < len && this.tests[i].test(this.buffer[j])) {
          this.buffer[i] = this.buffer[j]
          this.buffer[j] = this.options.placeholder
        } else
          break
        j = this.seekNext(j)
      }
    }
    this.writeBuffer()
    this.caret(Math.max(this.firstNonMaskPos, begin))
  }
  Inputmask.prototype.shiftR = function(pos) {
    var len = this.mask.length
    for (var i = pos, c = this.options.placeholder; i < len; i++) {
      if (this.tests[i]) {
        var j = this.seekNext(i)
        var t = this.buffer[i]
        this.buffer[i] = c
        if (j < len && this.tests[j].test(t))
          c = t
        else
          break
      }
    }
  },
  Inputmask.prototype.unmask = function() {
    this.$element
      .unbind(".mask")
      .removeData("inputmask")
  }
  Inputmask.prototype.focusEvent = function() {
    this.focusText = this.$element.val()
    var len = this.mask.length
    var pos = this.checkVal()
    this.writeBuffer()
    var that = this
    var moveCaret = function() {
      if (pos == len)
        that.caret(0, pos)
      else
        that.caret(pos)
    }
    moveCaret()
    setTimeout(moveCaret, 50)
  }
  Inputmask.prototype.blurEvent = function() {
    this.checkVal()
    if (this.$element.val() !== this.focusText)
      this.$element.trigger('change')
  }
  Inputmask.prototype.keydownEvent = function(e) {
    var k = e.which
    //backspace, delete, and escape get special treatment
    if (k == 8 || k == 46 || (isIphone && k == 127)) {
      var pos = this.caret(),
      begin = pos.begin,
      end = pos.end
      if (end - begin === 0) {
        begin = k != 46 ? this.seekPrev(begin) : (end = this.seekNext(begin - 1))
        end = k == 46 ? this.seekNext(end) : end
      }
      this.clearBuffer(begin, end)
      this.shiftL(begin, end - 1)
      return false
    } else if (k == 27) {//escape
      this.$element.val(this.focusText)
      this.caret(0, this.checkVal())
      return false
    }
  }
  Inputmask.prototype.keypressEvent = function(e) {
    var len = this.mask.length
    var k = e.which,
    pos = this.caret()
    if (e.ctrlKey || e.altKey || e.metaKey || k < 32)  {//Ignore
      return true
    } else if (k) {
      if (pos.end - pos.begin !== 0) {
        this.clearBuffer(pos.begin, pos.end)
        this.shiftL(pos.begin, pos.end - 1)
      }
      var p = this.seekNext(pos.begin - 1)
      if (p < len) {
        var c = String.fromCharCode(k)
        if (this.tests[p].test(c)) {
          this.shiftR(p)
          this.buffer[p] = c
          this.writeBuffer()
          var next = this.seekNext(p)
          this.caret(next)
        }
      }
      return false
    }
  }
  Inputmask.prototype.pasteEvent = function() {
    var that = this
    setTimeout(function() {
      that.caret(that.checkVal(true))
    }, 0)
  }
  Inputmask.prototype.clearBuffer = function(start, end) {
    var len = this.mask.length
    for (var i = start; i < end && i < len; i++) {
      if (this.tests[i])
        this.buffer[i] = this.options.placeholder
    }
  }
  Inputmask.prototype.writeBuffer = function() {
    return this.$element.val(this.buffer.join('')).val()
  }
  Inputmask.prototype.checkVal = function(allow) {
    var len = this.mask.length
    //try to place characters where they belong
    var test = this.$element.val()
    var lastMatch = -1
    for (var i = 0, pos = 0; i < len; i++) {
      if (this.tests[i]) {
        this.buffer[i] = this.options.placeholder
        while (pos++ < test.length) {
          var c = test.charAt(pos - 1)
          if (this.tests[i].test(c)) {
            this.buffer[i] = c
            lastMatch = i
            break
          }
        }
        if (pos > test.length)
          break
      } else if (this.buffer[i] == test.charAt(pos) && i != this.partialPosition) {
        pos++
        lastMatch = i
      }
    }
    if (!allow && lastMatch + 1 < this.partialPosition) {
      this.$element.val("")
      this.clearBuffer(0, len)
    } else if (allow || lastMatch + 1 >= this.partialPosition) {
      this.writeBuffer()
      if (!allow) this.$element.val(this.$element.val().substring(0, lastMatch + 1))
    }
    return (this.partialPosition ? i : this.firstNonMaskPos)
  }
  // INPUTMASK PLUGIN DEFINITION
  // ===========================
  var old = $.fn.inputmask
  $.fn.inputmask = function (options) {
    return this.each(function () {
      var $this = $(this)
      var data = $this.data('bs.inputmask')
      if (!data) $this.data('bs.inputmask', (data = new Inputmask(this, options)))
    })
  }
  $.fn.inputmask.Constructor = Inputmask
  // INPUTMASK NO CONFLICT
  // ====================
  $.fn.inputmask.noConflict = function () {
    $.fn.inputmask = old
    return this
  }
  // INPUTMASK DATA-API
  // ==================
  $(document).on('focus.bs.inputmask.data-api', '[data-mask]', function (e) {
    var $this = $(this)
    if ($this.data('bs.inputmask')) return
    $this.inputmask($this.data())
  })
}(window.jQuery);
/* ===========================================================
 * Bootstrap: fileinput.js v3.1.3
 * http://jasny.github.com/bootstrap/javascript/#fileinput
 * ===========================================================
 * Copyright 2012-2014 Arnold Daniels
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */
+function ($) { "use strict";
  var isIE = window.navigator.appName == 'Microsoft Internet Explorer'
  // FILEUPLOAD PUBLIC CLASS DEFINITION
  // =================================
  var Fileinput = function (element, options) {
    this.$element = $(element)
    this.$input = this.$element.find(':file')
    if (this.$input.length === 0) return
    this.name = this.$input.attr('name') || options.name
    this.$hidden = this.$element.find('input[type=hidden][name="' + this.name + '"]')
    if (this.$hidden.length === 0) {
      this.$hidden = $('<input type="hidden">').insertBefore(this.$input)
    }
    this.$preview = this.$element.find('.fileinput-preview')
    var height = this.$preview.css('height')
    if (this.$preview.css('display') !== 'inline' && height !== '0px' && height !== 'none') {
      this.$preview.css('line-height', height)
    }
    this.original = {
      exists: this.$element.hasClass('fileinput-exists'),
      preview: this.$preview.html(),
      hiddenVal: this.$hidden.val()
    }
    this.listen()
  }
  Fileinput.prototype.listen = function() {
    this.$input.on('change.bs.fileinput', $.proxy(this.change, this))
    $(this.$input[0].form).on('reset.bs.fileinput', $.proxy(this.reset, this))
    this.$element.find('[data-trigger="fileinput"]').on('click.bs.fileinput', $.proxy(this.trigger, this))
    this.$element.find('[data-dismiss="fileinput"]').on('click.bs.fileinput', $.proxy(this.clear, this))
  },
  Fileinput.prototype.change = function(e) {
    var files = e.target.files === undefined ? (e.target && e.target.value ? [{ name: e.target.value.replace(/^.+\\/, '')}] : []) : e.target.files
    e.stopPropagation()
    if (files.length === 0) {
      this.clear()
      return
    }
    this.$hidden.val('')
    this.$hidden.attr('name', '')
    this.$input.attr('name', this.name)
    var file = files[0]
    if (this.$preview.length > 0 && (typeof file.type !== "undefined" ? file.type.match(/^image\/(gif|png|jpeg)$/) : file.name.match(/\.(gif|png|jpe?g)$/i)) && typeof FileReader !== "undefined") {
      var reader = new FileReader()
      var preview = this.$preview
      var element = this.$element
      reader.onload = function(re) {
        var $img = $('<img>')
        $img[0].src = re.target.result
        files[0].result = re.target.result
        element.find('.fileinput-filename').text(file.name)
        // if parent has max-height, using `(max-)height: 100%` on child doesn't take padding and border into account
        if (preview.css('max-height') != 'none') $img.css('max-height', parseInt(preview.css('max-height'), 10) - parseInt(preview.css('padding-top'), 10) - parseInt(preview.css('padding-bottom'), 10)  - parseInt(preview.css('border-top'), 10) - parseInt(preview.css('border-bottom'), 10))
        preview.html($img)
        element.addClass('fileinput-exists').removeClass('fileinput-new')
        element.trigger('change.bs.fileinput', files)
      }
      reader.readAsDataURL(file)
    } else {
      this.$element.find('.fileinput-filename').text(file.name)
      this.$preview.text(file.name)
      this.$element.addClass('fileinput-exists').removeClass('fileinput-new')
      this.$element.trigger('change.bs.fileinput')
    }
  },
  Fileinput.prototype.clear = function(e) {
    if (e) e.preventDefault()
    this.$hidden.val('')
    this.$hidden.attr('name', this.name)
    this.$input.attr('name', '')
    //ie8+ doesn't support changing the value of input with type=file so clone instead
    if (isIE) {
      var inputClone = this.$input.clone(true);
      this.$input.after(inputClone);
      this.$input.remove();
      this.$input = inputClone;
    } else {
      this.$input.val('')
    }
    this.$preview.html('')
    this.$element.find('.fileinput-filename').text('')
    this.$element.addClass('fileinput-new').removeClass('fileinput-exists')
    if (e !== undefined) {
      this.$input.trigger('change')
      this.$element.trigger('clear.bs.fileinput')
    }
  },
  Fileinput.prototype.reset = function() {
    this.clear()
    this.$hidden.val(this.original.hiddenVal)
    this.$preview.html(this.original.preview)
    this.$element.find('.fileinput-filename').text('')
    if (this.original.exists) this.$element.addClass('fileinput-exists').removeClass('fileinput-new')
     else this.$element.addClass('fileinput-new').removeClass('fileinput-exists')
    this.$element.trigger('reset.bs.fileinput')
  },
  Fileinput.prototype.trigger = function(e) {
    this.$input.trigger('click')
    e.preventDefault()
  }
  // FILEUPLOAD PLUGIN DEFINITION
  // ===========================
  var old = $.fn.fileinput
  $.fn.fileinput = function (options) {
    return this.each(function () {
      var $this = $(this),
          data = $this.data('bs.fileinput')
      if (!data) $this.data('bs.fileinput', (data = new Fileinput(this, options)))
      if (typeof options == 'string') data[options]()
    })
  }
  $.fn.fileinput.Constructor = Fileinput
  // FILEINPUT NO CONFLICT
  // ====================
  $.fn.fileinput.noConflict = function () {
    $.fn.fileinput = old
    return this
  }
  // FILEUPLOAD DATA-API
  // ==================
  $(document).on('click.fileinput.data-api', '[data-provides="fileinput"]', function (e) {
    var $this = $(this)
    if ($this.data('bs.fileinput')) return
    $this.fileinput($this.data())
    var $target = $(e.target).closest('[data-dismiss="fileinput"],[data-trigger="fileinput"]');
    if ($target.length > 0) {
      e.preventDefault()
      $target.trigger('click.bs.fileinput')
    }
  })
}(window.jQuery);
});
Numbas.queueScript('SCORM_API_wrapper',[],function(module) {
/* ===========================================================
pipwerks SCORM Wrapper for JavaScript
v1.1.20121005
Created by Philip Hutchison, January 2008
https://github.com/pipwerks/scorm-api-wrapper
Copyright (c) Philip Hutchison
MIT-style license: http://pipwerks.mit-license.org/
This wrapper works with both SCORM 1.2 and SCORM 2004.
Inspired by APIWrapper.js, created by the ADL and
Concurrent Technologies Corporation, distributed by
the ADL (http://www.adlnet.gov/scorm).
SCORM.API.find() and SCORM.API.get() functions based
on ADL code, modified by Mike Rustici
(http://www.scorm.com/resources/apifinder/SCORMAPIFinder.htm),
further modified by Philip Hutchison
=============================================================== */
var pipwerks = {};                                  //pipwerks 'namespace' helps ensure no conflicts with possible other "SCORM" variables
pipwerks.UTILS = {};                                //For holding UTILS functions
pipwerks.debug = { isActive: false };                //Enable (true) or disable (false) for debug mode
pipwerks.SCORM = {                                  //Define the SCORM object
    version:    null,                               //Store SCORM version.
    handleCompletionStatus: true,                   //Whether or not the wrapper should automatically handle the initial completion status
    handleExitMode: true,                           //Whether or not the wrapper should automatically handle the exit mode
    API:        { handle: null,
                  isFound: false },                 //Create API child object
    connection: { isActive: false },                //Create connection child object
    data:       { completionStatus: null,
                  exitStatus: null },               //Create data child object
    debug:      {}                                  //Create debug child object
};
/* --------------------------------------------------------------------------------
   pipwerks.SCORM.isAvailable
   A simple function to allow Flash ExternalInterface to confirm
   presence of JS wrapper before attempting any LMS communication.
   Parameters: none
   Returns:    Boolean (true)
----------------------------------------------------------------------------------- */
pipwerks.SCORM.isAvailable = function(){
    return true;
};
// ------------------------------------------------------------------------- //
// --- SCORM.API functions ------------------------------------------------- //
// ------------------------------------------------------------------------- //
/* -------------------------------------------------------------------------
   pipwerks.SCORM.API.find(window)
   Looks for an object named API in parent and opener windows
   Parameters: window (the browser window object).
   Returns:    Object if API is found, null if no API found
---------------------------------------------------------------------------- */
pipwerks.SCORM.API.find = function(win){
    var API = null,
        findAttempts = 0,
        findAttemptLimit = 500,
        errorGettingAPI = false;
        traceMsgPrefix = "SCORM.API.find",
        trace = pipwerks.UTILS.trace,
        scorm = pipwerks.SCORM;
    try {
        while (!errorGettingAPI &&
               (!win.API && !win.API_1484_11) &&
               (win.parent) &&
               (win.parent != win) &&
               (findAttempts <= findAttemptLimit)){
                    findAttempts++;
                    win = win.parent;
        }
    }
    catch(e) {
        errorGettingAPI = e;
    }
    try {
        if(scorm.version){                                            //If SCORM version is specified by user, look for specific API
            switch(scorm.version){
                case "2004" :
                    if(win.API_1484_11){
                        API = win.API_1484_11;
                    } else {
                        trace(traceMsgPrefix +": SCORM version 2004 was specified by user, but API_1484_11 cannot be found.");
                    }
                    break;
                case "1.2" :
                    if(win.API){
                        API = win.API;
                    } else {
                        trace(traceMsgPrefix +": SCORM version 1.2 was specified by user, but API cannot be found.");
                    }
                    break;
            }
        } else {                                                    //If SCORM version not specified by user, look for APIs
            if(win.API_1484_11) {                                    //SCORM 2004-specific API.
                scorm.version = "2004";                                //Set version
                API = win.API_1484_11;
            } else if(win.API){                                        //SCORM 1.2-specific API
                scorm.version = "1.2";                                //Set version
                API = win.API;
            }
        }
    }
    catch(e) {
        errorGettingAPI = e;
    }
    if(API){
        trace(traceMsgPrefix +": API found. Version: " +scorm.version);
        trace("API: " +API);
    } else {
        trace(traceMsgPrefix +": Error finding API. \nFind attempts: " +findAttempts +". \nFind attempt limit: " +findAttemptLimit+". \nError getting window parent: "+errorGettingAPI);
    }
    return API;
};
/* -------------------------------------------------------------------------
   pipwerks.SCORM.API.get()
   Looks for an object named API, first in the current window's frame
   hierarchy and then, if necessary, in the current window's opener window
   hierarchy (if there is an opener window).
   Parameters:  None.
   Returns:     Object if API found, null if no API found
---------------------------------------------------------------------------- */
pipwerks.SCORM.API.get = function(){
    var API = null,
        win = window,
        scorm = pipwerks.SCORM,
        find = scorm.API.find,
        trace = pipwerks.UTILS.trace;
    try {
        if(win.parent && win.parent != win){
            API = find(win.parent);
        }
        if(!API && win.top.opener){
            API = find(win.top.opener);
        }
        //Special handling for Plateau
        //Thanks to Joseph Venditti for the patch
        if(!API && win.top.opener && win.top.opener.document) {
            API = find(win.top.opener.document);
        }
    }
    catch(e) {}
    if(API){
        scorm.API.isFound = true;
    } else {
        trace("API.get failed: Can't find the API!");
    }
    return API;
};
/* -------------------------------------------------------------------------
   pipwerks.SCORM.API.getHandle()
   Returns the handle to API object if it was previously set
   Parameters:  None.
   Returns:     Object (the pipwerks.SCORM.API.handle variable).
---------------------------------------------------------------------------- */
pipwerks.SCORM.API.getHandle = function() {
    var API = pipwerks.SCORM.API;
    if(!API.handle && !API.isFound){
        API.handle = API.get();
    }
    return API.handle;
};
// ------------------------------------------------------------------------- //
// --- pipwerks.SCORM.connection functions --------------------------------- //
// ------------------------------------------------------------------------- //
/* -------------------------------------------------------------------------
   pipwerks.SCORM.connection.initialize()
   Tells the LMS to initiate the communication session.
   Parameters:  None
   Returns:     Boolean
---------------------------------------------------------------------------- */
pipwerks.SCORM.connection.initialize = function(){
    var success = false,
        scorm = pipwerks.SCORM,
        completionStatus = scorm.data.completionStatus,
        trace = pipwerks.UTILS.trace,
        makeBoolean = pipwerks.UTILS.StringToBoolean,
        debug = scorm.debug,
        traceMsgPrefix = "SCORM.connection.initialize ";
    trace("connection.initialize called.");
    if(!scorm.connection.isActive){
        var API = scorm.API.getHandle(),
            errorCode = 0;
        if(API){
            switch(scorm.version){
                case "1.2" : success = makeBoolean(API.LMSInitialize("")); break;
                case "2004": success = makeBoolean(API.Initialize("")); break;
            }
            if(success){
                //Double-check that connection is active and working before returning 'true' boolean
                errorCode = debug.getCode();
                if(errorCode !== null && errorCode === 0){
                    scorm.connection.isActive = true;
                    if(scorm.handleCompletionStatus){
                        //Automatically set new launches to incomplete
                        completionStatus = scorm.status("get");
                        if(completionStatus){
                            switch(completionStatus){
                                //Both SCORM 1.2 and 2004
                                case "not attempted": scorm.status("set", "incomplete"); break;
                                //SCORM 2004 only
                                case "unknown" : scorm.status("set", "incomplete"); break;
                                //Additional options, presented here in case you'd like to use them
                                //case "completed"  : break;
                                //case "incomplete" : break;
                                //case "passed"     : break;    //SCORM 1.2 only
                                //case "failed"     : break;    //SCORM 1.2 only
                                //case "browsed"    : break;    //SCORM 1.2 only
                            }
                        }
                    }
                } else {
                    success = false;
                    trace(traceMsgPrefix +"failed. \nError code: " +errorCode +" \nError info: " +debug.getInfo(errorCode));
                }
            } else {
                errorCode = debug.getCode();
                if(errorCode !== null && errorCode !== 0){
                    trace(traceMsgPrefix +"failed. \nError code: " +errorCode +" \nError info: " +debug.getInfo(errorCode));
                } else {
                    trace(traceMsgPrefix +"failed: No response from server.");
                }
            }
        } else {
            trace(traceMsgPrefix +"failed: API is null.");
        }
    } else {
          trace(traceMsgPrefix +"aborted: Connection already active.");
     }
     return success;
};
/* -------------------------------------------------------------------------
   pipwerks.SCORM.connection.terminate()
   Tells the LMS to terminate the communication session
   Parameters:  None
   Returns:     Boolean
---------------------------------------------------------------------------- */
pipwerks.SCORM.connection.terminate = function(){
    var success = false,
        scorm = pipwerks.SCORM,
        exitStatus = scorm.data.exitStatus,
        completionStatus = scorm.data.completionStatus,
        trace = pipwerks.UTILS.trace,
        makeBoolean = pipwerks.UTILS.StringToBoolean,
        debug = scorm.debug,
        traceMsgPrefix = "SCORM.connection.terminate ";
    if(scorm.connection.isActive){
        var API = scorm.API.getHandle(),
            errorCode = 0;
        if(API){
             if(scorm.handleExitMode && !exitStatus){
                if(completionStatus !== "completed" && completionStatus !== "passed"){
                    switch(scorm.version){
                        case "1.2" : success = scorm.set("cmi.core.exit", "suspend"); break;
                        case "2004": success = scorm.set("cmi.exit", "suspend"); break;
                    }
                } else {
                    switch(scorm.version){
                        case "1.2" : success = scorm.set("cmi.core.exit", "logout"); break;
                        case "2004": success = scorm.set("cmi.exit", "normal"); break;
                    }
                }
            }
            switch(scorm.version){
                case "1.2" : success = makeBoolean(API.LMSFinish("")); break;
                case "2004": success = makeBoolean(API.Terminate("")); break;
            }
            if(success){
                scorm.connection.isActive = false;
            } else {
                errorCode = debug.getCode();
                trace(traceMsgPrefix +"failed. \nError code: " +errorCode +" \nError info: " +debug.getInfo(errorCode));
            }
        } else {
            trace(traceMsgPrefix +"failed: API is null.");
        }
    } else {
        trace(traceMsgPrefix +"aborted: Connection already terminated.");
    }
    return success;
};
// ------------------------------------------------------------------------- //
// --- pipwerks.SCORM.data functions --------------------------------------- //
// ------------------------------------------------------------------------- //
/* -------------------------------------------------------------------------
   pipwerks.SCORM.data.get(parameter)
   Requests information from the LMS.
   Parameter: parameter (string, name of the SCORM data model element)
   Returns:   string (the value of the specified data model element)
---------------------------------------------------------------------------- */
pipwerks.SCORM.data.get = function(parameter){
    var value = null,
        scorm = pipwerks.SCORM,
        trace = pipwerks.UTILS.trace,
        debug = scorm.debug,
        traceMsgPrefix = "SCORM.data.get(" +parameter +") ";
    if(scorm.connection.isActive){
        var API = scorm.API.getHandle(),
            errorCode = 0;
          if(API){
            switch(scorm.version){
                case "1.2" : value = API.LMSGetValue(parameter); break;
                case "2004": value = API.GetValue(parameter); break;
            }
            errorCode = debug.getCode();
            //GetValue returns an empty string on errors
            //If value is an empty string, check errorCode to make sure there are no errors
            if(value !== "" || errorCode === 0){
                //GetValue is successful.
                //If parameter is lesson_status/completion_status or exit status, let's
                //grab the value and cache it so we can check it during connection.terminate()
                switch(parameter){
                    case "cmi.core.lesson_status":
                    case "cmi.completion_status" : scorm.data.completionStatus = value; break;
                    case "cmi.core.exit":
                    case "cmi.exit"     : scorm.data.exitStatus = value; break;
                }
            } else {
                trace(traceMsgPrefix +"failed. \nError code: " +errorCode +"\nError info: " +debug.getInfo(errorCode));
            }
        } else {
            trace(traceMsgPrefix +"failed: API is null.");
        }
    } else {
        trace(traceMsgPrefix +"failed: API connection is inactive.");
    }
    trace(traceMsgPrefix +" value: " +value);
    return String(value);
};
/* -------------------------------------------------------------------------
   pipwerks.SCORM.data.set()
   Tells the LMS to assign the value to the named data model element.
   Also stores the SCO's completion status in a variable named
   pipwerks.SCORM.data.completionStatus. This variable is checked whenever
   pipwerks.SCORM.connection.terminate() is invoked.
   Parameters: parameter (string). The data model element
               value (string). The value for the data model element
   Returns:    Boolean
---------------------------------------------------------------------------- */
pipwerks.SCORM.data.set = function(parameter, value){
    var success = false,
        scorm = pipwerks.SCORM,
        trace = pipwerks.UTILS.trace,
        makeBoolean = pipwerks.UTILS.StringToBoolean,
        debug = scorm.debug,
        traceMsgPrefix = "SCORM.data.set(" +parameter +") ";
    if(scorm.connection.isActive){
        var API = scorm.API.getHandle(),
            errorCode = 0;
        if(API){
            switch(scorm.version){
                case "1.2" : success = makeBoolean(API.LMSSetValue(parameter, value)); break;
                case "2004": success = makeBoolean(API.SetValue(parameter, value)); break;
            }
            if(success){
                if(parameter === "cmi.core.lesson_status" || parameter === "cmi.completion_status"){
                    scorm.data.completionStatus = value;
                }
            } else {
                trace(traceMsgPrefix +"failed. \nError code: " +errorCode +". \nError info: " +debug.getInfo(errorCode));
            }
        } else {
            trace(traceMsgPrefix +"failed: API is null.");
        }
    } else {
        trace(traceMsgPrefix +"failed: API connection is inactive.");
    }
    return success;
};
/* -------------------------------------------------------------------------
   pipwerks.SCORM.data.save()
   Instructs the LMS to persist all data to this point in the session
   Parameters: None
   Returns:    Boolean
---------------------------------------------------------------------------- */
pipwerks.SCORM.data.save = function(){
    var success = false,
        scorm = pipwerks.SCORM,
        trace = pipwerks.UTILS.trace,
        makeBoolean = pipwerks.UTILS.StringToBoolean,
        traceMsgPrefix = "SCORM.data.save failed";
    if(scorm.connection.isActive){
        var API = scorm.API.getHandle();
        if(API){
            switch(scorm.version){
                case "1.2" : success = makeBoolean(API.LMSCommit("")); break;
                case "2004": success = makeBoolean(API.Commit("")); break;
            }
        } else {
            trace(traceMsgPrefix +": API is null.");
        }
    } else {
        trace(traceMsgPrefix +": API connection is inactive.");
    }
    return success;
};
pipwerks.SCORM.status = function (action, status){
    var success = false,
        scorm = pipwerks.SCORM,
        trace = pipwerks.UTILS.trace,
        traceMsgPrefix = "SCORM.getStatus failed",
        cmi = "";
    if(action !== null){
        switch(scorm.version){
            case "1.2" : cmi = "cmi.core.lesson_status"; break;
            case "2004": cmi = "cmi.completion_status"; break;
        }
        switch(action){
            case "get": success = scorm.data.get(cmi); break;
            case "set": if(status !== null){
                            success = scorm.data.set(cmi, status);
                        } else {
                            success = false;
                            trace(traceMsgPrefix +": status was not specified.");
                        }
                        break;
            default      : success = false;
                        trace(traceMsgPrefix +": no valid action was specified.");
        }
    } else {
        trace(traceMsgPrefix +": action was not specified.");
    }
    return success;
};
// ------------------------------------------------------------------------- //
// --- pipwerks.SCORM.debug functions -------------------------------------- //
// ------------------------------------------------------------------------- //
/* -------------------------------------------------------------------------
   pipwerks.SCORM.debug.getCode
   Requests the error code for the current error state from the LMS
   Parameters: None
   Returns:    Integer (the last error code).
---------------------------------------------------------------------------- */
pipwerks.SCORM.debug.getCode = function(){
    var scorm = pipwerks.SCORM,
        API = scorm.API.getHandle(),
        trace = pipwerks.UTILS.trace,
        code = 0;
    if(API){
        switch(scorm.version){
            case "1.2" : code = parseInt(API.LMSGetLastError(), 10); break;
            case "2004": code = parseInt(API.GetLastError(), 10); break;
        }
    } else {
        trace("SCORM.debug.getCode failed: API is null.");
    }
    return code;
};
/* -------------------------------------------------------------------------
   pipwerks.SCORM.debug.getInfo()
   "Used by a SCO to request the textual description for the error code
   specified by the value of [errorCode]."
   Parameters: errorCode (integer).
   Returns:    String.
----------------------------------------------------------------------------- */
pipwerks.SCORM.debug.getInfo = function(errorCode){
    var scorm = pipwerks.SCORM,
        API = scorm.API.getHandle(),
        trace = pipwerks.UTILS.trace,
        result = "";
    if(API){
        switch(scorm.version){
            case "1.2" : result = API.LMSGetErrorString(errorCode.toString()); break;
            case "2004": result = API.GetErrorString(errorCode.toString()); break;
        }
    } else {
        trace("SCORM.debug.getInfo failed: API is null.");
    }
    return String(result);
};
/* -------------------------------------------------------------------------
   pipwerks.SCORM.debug.getDiagnosticInfo
   "Exists for LMS specific use. It allows the LMS to define additional
   diagnostic information through the API Instance."
   Parameters: errorCode (integer).
   Returns:    String (Additional diagnostic information about the given error code).
---------------------------------------------------------------------------- */
pipwerks.SCORM.debug.getDiagnosticInfo = function(errorCode){
    var scorm = pipwerks.SCORM,
        API = scorm.API.getHandle(),
        trace = pipwerks.UTILS.trace,
        result = "";
    if(API){
        switch(scorm.version){
            case "1.2" : result = API.LMSGetDiagnostic(errorCode); break;
            case "2004": result = API.GetDiagnostic(errorCode); break;
        }
    } else {
        trace("SCORM.debug.getDiagnosticInfo failed: API is null.");
    }
    return String(result);
};
// ------------------------------------------------------------------------- //
// --- Shortcuts! ---------------------------------------------------------- //
// ------------------------------------------------------------------------- //
// Because nobody likes typing verbose code.
pipwerks.SCORM.init = pipwerks.SCORM.connection.initialize;
pipwerks.SCORM.get  = pipwerks.SCORM.data.get;
pipwerks.SCORM.set  = pipwerks.SCORM.data.set;
pipwerks.SCORM.save = pipwerks.SCORM.data.save;
pipwerks.SCORM.quit = pipwerks.SCORM.connection.terminate;
// ------------------------------------------------------------------------- //
// --- pipwerks.UTILS functions -------------------------------------------- //
// ------------------------------------------------------------------------- //
/* -------------------------------------------------------------------------
   pipwerks.UTILS.StringToBoolean()
   Converts 'boolean strings' into actual valid booleans.
   (Most values returned from the API are the strings "true" and "false".)
   Parameters: String
   Returns:    Boolean
---------------------------------------------------------------------------- */
pipwerks.UTILS.StringToBoolean = function(value){
    var t = typeof value;
    switch(t){
       //typeof new String("true") === "object", so handle objects as string via fall-through.
       //See https://github.com/pipwerks/scorm-api-wrapper/issues/3
       case "object":
       case "string": return (/(true|1)/i).test(value);
       case "number": return !!value;
       case "boolean": return value;
       case "undefined": return null;
       default: return false;
    }
};
/* -------------------------------------------------------------------------
   pipwerks.UTILS.trace()
   Displays error messages when in debug mode.
   Parameters: msg (string)
   Return:     None
---------------------------------------------------------------------------- */
pipwerks.UTILS.trace = function(msg){
     if(pipwerks.debug.isActive){
        if(window.console && window.console.log){
            console.log(msg);
        } else {
            //alert(msg);
        }
     }
};
module.exports.pipwerks = pipwerks
});
Numbas.queueScript('answer-widgets',['knockout','util','jme','jme-display'],function() {
    var util = Numbas.util;
    ko.components.register('answer-widget', {
        viewModel: function(params) {
            this.answerJSON = params.answer;
            this.part = ko.unwrap(params.part);
            this.disable = params.disable;
            this.widget = params.widget || this.part.input_widget();
            this.widget_options = params.widget_options || this.part.input_options();
            this.classes = {'answer-widget':true};
            this.classes['answer-widget-'+this.widget] = true;
        },
        template: '\
        <span data-bind="if: widget"><span data-bind="css: classes, component: {name: \'answer-widget-\'+widget, params: {answerJSON: answerJSON, part: part, disable: disable, options: widget_options}}"></span></span>\
        '
    });
    ko.components.register('answer-widget-string', {
        viewModel: function(params) {
            this.answerJSON = params.answerJSON;
            var init = ko.unwrap(this.answerJSON);
            this.input = ko.observable(init.valid ? init.value || '' : '');
            this.part = params.part;
            this.disable = params.disable;
            this.options = params.options;
            this.allowEmpty = this.options.allowEmpty;
            var lastValue = this.input();
            this.subscriptions = [
                this.answerJSON.subscribe(function(v) {
                    if(v.value!=this.input()) {
                        this.input(v.value);
                    }
                },this),
                this.input.subscribe(function(value) {
                    var empty = value=='';
                    var valid = !empty || this.allowEmpty;
                    if(value != lastValue) {
                        this.answerJSON({valid: valid, value: value, empty: empty});
                    }
                    lastValue = value;
                },this)
            ];
            this.dispose = function() {
                this.subscriptions.forEach(function(sub) { sub.dispose(); });
            }
        },
        template: '\
            <input type="text" data-bind="event: part.inputEvents, textInput: input, autosize: true, disable: ko.unwrap(disable) || ko.unwrap(part.revealed)">\
        '
    });
    ko.components.register('answer-widget-number', {
        viewModel: function(params) {
            var vm = this;
            this.answerJSON = params.answerJSON;
            this.part = params.part;
            this.options = params.options;
            this.allowFractions = this.options.allowFractions || false;
            this.allowedNotationStyles = this.options.allowedNotationStyles || ['plain','en','si-en'];
            this.disable = params.disable;
            var init = ko.unwrap(this.answerJSON);
            function cleanNumber(n) {
                if(n===undefined) {
                    return '';
                }
                return Numbas.math.niceNumber(n,{style: vm.allowedNotationStyles[0]}) || '';
            }
            this.input = ko.observable(init.valid ? cleanNumber(init.value) : '');
            var lastValue = init.value;
            this.result = ko.computed(function() {
                var input = this.input().trim();
                if(input=='') {
                    return {valid:false, empty: true};
                }
                if(!util.isNumber(input,this.allowFractions,this.allowedNotationStyles)) {
                    if(util.isNumber(input, true, this.allowedNotationStyles)) {
                        return {valid: false, warnings: [R('answer.number.fractions not allowed')]};
                    } else {
                        return {valid:false, warnings: [R('answer.number.not a number')]};
                    }
                } else {
                    var n = Numbas.util.parseNumber(input,this.allowFractions,this.allowedNotationStyles);
                    return {valid:true, value: n};
                }
            },this);
            this.subscriptions = [
                this.answerJSON.subscribe(function(v) {
                    if(v.value==this.result().value) {
                        return;
                    }
                    var s = cleanNumber(v.value);
                    if(s!=this.input() && v.valid) {
                        this.input(s);
                    }
                },this)
            ];
            this.setAnswerJSON = ko.computed(function() {
                this.answerJSON(this.result())
            },this);
            this.dispose = function() {
                this.subscriptions.forEach(function(sub) { sub.dispose(); });
                this.result.dispose();
                this.setAnswerJSON.dispose();
            }
        },
        template: '\
            <input type="text" data-bind="event: part.inputEvents, textInput: input, autosize: true, disable: ko.unwrap(disable) || ko.unwrap(part.revealed)">\
        '
    });
    ko.components.register('answer-widget-jme', {
        viewModel: function(params) {
            this.answerJSON = params.answerJSON;
            var p = this.part = params.part;
            this.options = params.options;
            this.showPreview = this.options.showPreview || false;
            this.returnString = this.options.returnString || false;
            this.disable = params.disable;
            var init = ko.unwrap(this.answerJSON);
            function cleanExpression(expr) {
                if(typeof(expr)=='string') {
                    return expr;
                }
                try {
                    return Numbas.jme.display.treeToJME(expr) || '';
                } catch(e) {
                    throw(e);
                }
            }
            this.input = ko.observable(init.valid ? cleanExpression(init.value) : '');
            this.latex = ko.computed(function() {
                var input = this.input();
                if(input==='') {
                    return '';
                }
                try {
                    var tex = Numbas.jme.display.exprToLaTeX(input,'',p.question.scope);
                    if(tex===undefined) {
                        throw(new Numbas.Error('display.part.jme.error making maths'));
                    }
                }
                catch(e) {
                    return '';
                }
                return tex;
            },this).extend({throttle:100});
            this.result = ko.computed(function() {
                var input = this.input().trim();
                if(input=='') {
                    return {valid:false,empty:true};
                }
                if(this.options.returnString) {
                    return {valid: true, value: input};
                } else {
                    try {
                        var expr = Numbas.jme.compile(input);
                        var scope = p.getScope();
                        var ruleset = new Numbas.jme.rules.Ruleset([],{});
                        expr = Numbas.jme.display.simplifyTree(expr, ruleset, scope);
                        return {valid: true, value: expr}
                    } catch(e) {
                        return {valid: false, warnings: [R('answer.jme.invalid expression',{message:e.message})]};
                    }
                }
            },this);
            this.subscriptions = [
                this.answerJSON.subscribe(function(v) {
                    if(v.value==this.result().value) {
                        return;
                    }
                    var s = cleanExpression(v.value);
                    if(s!=this.input() && v.valid) {
                        this.input(s);
                    }
                },this)
            ];
            var lastValue = this.input();
            this.setAnswerJSON = ko.computed(function() {
                if(this.input()!=lastValue) {
                    this.answerJSON(this.result());
                    lastValue = this.input();
                }
            },this);
            this.dispose = function() {
                this.subscriptions.forEach(function(sub) { sub.dispose(); });
                this.latex.dispose();
                this.result.dispose();
                this.setAnswerJSON.dispose();
            }
        },
        template: '\
            <input type="text" data-bind="event: part.inputEvents, textInput: input, autosize: true, disable: ko.unwrap(disable) || ko.unwrap(part.revealed)">\
            <span class="jme-preview" data-bind="visible: showPreview && latex(), maths: \'\\\\displaystyle{{\'+latex()+\'}}\'"></span>\
        '
    });
    ko.components.register('answer-widget-gapfill', {
        viewModel: function(params) {
            this.answerJSON = params.answerJSON;
            var part = params.part;
            this.disable = params.disable;
            this.gaps = ko.computed(function() {
                return Knockout.unwrap(part.gaps).map(function(gap) {
                    return {answerJSON: ko.observable(), part: gap};
                });
            },this)
            this.setAnswerJSON = ko.computed(function() {
                this.answerJSON(this.gaps().map(function(g){return g.answerJSON()}));
            },this);
            this.dispose = function() {
                this.gaps.dispose();
                this.setAnswerJSON.dispose();
            }
        },
        template: '\
            <table class="table">\
                <tbody data-bind="foreach: gaps">\
                    <tr>\
                        <th><span data-bind="text: part.header"></span></th>\
                        <td><div data-bind="component: {name: \'answer-widget\', params: {answer: answerJSON, widget: Knockout.unwrap(part.type).widget, part: part, disable: disable}}"></div></td>\
                    </tr>\
                </tbody>\
            </table>\
        '
    });
    ko.components.register('answer-widget-matrix', {
        viewModel: function(params) {
            var vm = this;
            this.answerJSON = params.answerJSON;
            this.options = params.options;
            this.disable = params.disable;
            this.allowFractions = this.options.allowFractions || false;
            this.allowedNotationStyles = this.options.allowedNotationStyles || ['plain','en','si-en'];
            this.allowResize = this.options.allowResize===undefined ? true : this.options.allowResize;
            this.numRows = this.options.numRows || 1;
            this.numColumns = this.options.numColumns || 1;
            this.parseCells = this.options.parseCells===undefined ? true : this.options.parseCells;
            var init = ko.unwrap(this.answerJSON);
            var value = init.value;
            if(value!==undefined) {
                value = value.map(function(r){ return r.map(function(c){ return vm.parseCells ? Numbas.math.niceNumber(c,{style: vm.allowedNotationStyles[0]}) || '' : c }) });
            }
            if(!value) {
                value = [];
                for(var i=0;i<this.numRows;i++) {
                    var row = [];
                    for(var j=0;j<this.numColumns;j++) {
                        row.push('');
                    }
                    value.push(row);
                }
            }
            this.input = ko.observable(value);
            this.result = ko.computed(function() {
                var value = this.input().slice().map(function(r){return r.slice()});
                var cells = Array.prototype.concat.apply([],value);
                var empty = cells.every(function(cell){return !cell.trim()});
                if(empty) {
                    return {valid: false, empty: true};
                }
                if(this.parseCells) {
                    var valid = cells.every(function(cell){ return cell.trim() && util.isNumber(cell,vm.allowFractions,vm.allowedNotationStyles) });
                    if(!valid) {
                        var validFractions = cells.every(function(cell){ return util.isNumber(cell,true,vm.allowedNotationStyles) });
                        if(validFractions) {
                            return {valid: false, warnings: [R('answer.matrix.fractions not allowed')]};
                        } else {
                            return {valid:false, warnings: [R('answer.matrix.some cell not a number')]};
                        }
                    } else {
                        var matrix = value.map(function(row){ return row.map(function(cell){ return Numbas.util.parseNumber(cell,this.allowFractions,this.allowedNotationStyles) }) });
                        matrix.rows = value.length;
                        matrix.columns = matrix.rows>0 ? value[0].length : 0;
                        return {valid:true, value: matrix};
                    }
                } else {
                    return {valid: true, value: value};
                }
            },this);
            this.subscriptions = [
                this.answerJSON.subscribe(function(v) {
                    if(util.objects_equal(v.value,this.result().value)) {
                        return;
                    }
                    if(v.valid) {
                        this.input(v.value);
                    }
                },this)
            ];
            var lastValue = this.result();
            this.setAnswerJSON = ko.computed(function() {
                var result = this.result();
                var valuesSame = (!result.valid && !lastValue.valid) || ((result.value!==undefined && lastValue.value!==undefined) && result.value.length == lastValue.value.length && result.value.every(function(row,i) { return row.length== lastValue.value[i].length && row.every(function(cell,j){ return cell == lastValue.value[i][j] || isNaN(cell) && isNaN(lastValue.value[i][j]); }) }));
                if(!valuesSame || result.valid!=lastValue.valid) {
                    this.answerJSON(result);
                }
                lastValue = result;
            },this);
            this.dispose = function() {
                this.subscriptions.forEach(function(sub) { sub.dispose(); });
                this.result.dispose();
                this.setAnswerJSON.dispose();
            }
        },
        template: '\
            <matrix-input params="value: input, allowResize: true, disable: disable, allowResize: allowResize, rows: numRows, columns: numColumns"></matrix-input>\
        '
    });
    ko.components.register('matrix-input',{
        viewModel: function(params) {
            var vm = this;
            this.allowResize = params.allowResize ? params.allowResize : ko.observable(false);
            if(typeof params.rows=='function') {
                this.numRows = params.rows;
            } else {
                this.numRows = ko.observable(params.rows || 2);
            }
            if(typeof params.columns=='function') {
                this.numColumns = params.columns;
            } else {
                this.numColumns = ko.observable(params.columns || 2);
            }
            this.value = ko.observableArray([]);
            var v = params.value();
            function make_result() {
                var v = vm.value().map(function(row,i){
                    return row().map(function(cell,j){return cell.cell()})
                })
                vm.result(v);
            };
            function make_cell(c) {
                var cell = {cell: ko.observable(c)};
                cell.cell.subscribe(make_result);
                return cell;
            }
            function setMatrix(v) {
                vm.numRows(v.length || 1);
                vm.numColumns(v.length ? v[0].length : 1);
                vm.value(v.map(function(r){return ko.observableArray(r.map(function(c){return make_cell(c)}))}));
            }
            setMatrix(ko.unwrap(params.value));
            this.disable = params.disable || false;
            this.keydown = function(obj,e) {
                this.oldPos = e.target.selectionStart;
                return true;
            }
            this.moveArrow = function(obj,e) {
                var cell = $(e.target).parent('td');
                var selectionStart = e.target.selectionStart;
                switch(e.which) {
                case 39:
                    if(e.target.selectionStart == this.oldPos && e.target.selectionStart==e.target.selectionEnd && e.target.selectionEnd==e.target.value.length) {
                        cell.next().find('input').focus();
                    }
                    break;
                case 37:
                    if(e.target.selectionStart == this.oldPos && e.target.selectionStart==e.target.selectionEnd && e.target.selectionEnd==0) {
                        cell.prev().find('input').focus();
                    }
                    break;
                case 38:
                    var e = cell.parents('tr').prev().children().eq(cell.index()).find('input');
                    if(e.length) {
                        e.focus();
                        e[0].setSelectionRange(this.oldPos,this.oldPos);
                    }
                    break;
                case 40:
                    var e = cell.parents('tr').next().children().eq(cell.index()).find('input');
                    if(e.length) {
                        e.focus();
                        e[0].setSelectionRange(this.oldPos,this.oldPos);
                    }
                    break;
                }
                return false;
            }
            this.result = ko.observableArray([]);
            make_result();
            this.update = function() {
                // update value when number of rows or columns changes
                var numRows = parseInt(this.numRows());
                var numColumns = parseInt(this.numColumns());
                var value = this.value();
                if(numRows==value.length && (numRows==0 || numColumns==value[0]().length)) {
                    return;
                }
                value.splice(numRows,value.length-numRows);
                for(var i=0;i<numRows;i++) {
                    var row;
                    if(value.length<=i) {
                        row = [];
                        value.push(ko.observableArray(row));
                    } else {
                        row = value[i]();
                    }
                    row.splice(numColumns,row.length-numColumns);
                    for(var j=0;j<numColumns;j++) {
                        var cell;
                        if(row.length<=j) {
                            row.push(make_cell(''));
                        } else {
                            cell = row[j];
                        }
                    }
                    value[i](row);
                }
                this.value(value.slice());
                make_result();
            }
            this.updateComputed = ko.computed(this.update,this);
            this.subscriptions = [
                params.value.subscribe(function(v) {
                    if(v==this.result()) {
                        return;
                    }
                    setMatrix(v);
                },this)
            ];
            var firstGo = true;
            //update value with model
            this.setValue = ko.computed(function() {
                var v = this.result();
                if(firstGo) {
                    firstGo = false;
                    return;
                }
                params.value(v);
            },this)
            this.dispose = function() {
                this.subscriptions.forEach(function(sub) { sub.dispose(); });
                this.updateComputed.dispose();
                this.setValue.dispose();
            }
        },
        template:
         '<div class="matrix-input">'
        +'    <!-- ko if: allowResize --><div class="matrix-size">'
        +'        <label class="num-rows">Rows: <input type="number" min="1" data-bind="value: numRows, autosize: true, disable: disable"/></label>'
        +'        <label class="num-columns">Columns: <input type="number" min="1" data-bind="value: numColumns, autosize: true, disable: disable"/></label>'
        +'    </div><!-- /ko -->'
        +'    <div class="matrix-wrapper">'
        +'        <span class="left-bracket"></span>'
        +'        <table class="matrix">'
        +'            <tbody data-bind="foreach: value">'
        +'                <tr data-bind="foreach: $data">'
        +'                    <td class="cell"><input type="text" data-bind="textInput: cell, autosize: true, disable: $parents[1].disable, event: {keydown: $parents[1].keydown, keyup: $parents[1].moveArrow}"></td>'
        +'                </tr>'
        +'            </tbody>'
        +'        </table>'
        +'        <span class="right-bracket"></span>'
        +'    </div>'
        +'</div>'
        }
    )
    ko.components.register('answer-widget-radios', {
        viewModel: function(params) {
            this.part = params.part;
            this.disable = params.disable;
            this.options = params.options;
            this.choices = ko.observableArray(this.options.choices);
            this.answerAsArray = this.options.answerAsArray;
            this.choice = ko.observable(null);
            this.answerJSON = params.answerJSON;
            var init = ko.unwrap(this.answerJSON);
            if(init.valid) {
                if(this.answerAsArray) {
                    var choice = init.value.findIndex(function(c){ return c[0]; });
                    if(choice>=0) {
                        this.choice(choice);
                    }
                } else {
                    this.choice(init.value);
                }
            }
            this.choiceArray = ko.pureComputed(function() {
                var choice = this.choice();
                if(choice===null || choice===undefined) {
                    return null;
                }
                return this.choices().map(function(c,i){ return [i==choice]; })
            },this);
            this.subscriptions = [
                this.answerJSON.subscribe(function(v) {
                    if(!v.valid) {
                        this.choice(null);
                        return;
                    }
                    var choice = this.answerAsArray ? v.value.findIndex(function(c){ return c[0]; }) : v.value;
                    if(choice!=this.choice()) {
                        this.choice(choice);
                    }
                },this)
            ];
            this.setAnswerJSON = ko.computed(function() {
                var value = this.answerAsArray ? this.choiceArray() : this.choice();
                this.answerJSON({valid: value!==null, value: value, empty: value===null});
            },this);
            this.dispose = function() {
                this.subscriptions.forEach(function(sub) { sub.dispose(); });
                this.setAnswerJSON.dispose();
            }
        },
        template: '\
            <form>\
            <ul class="list-unstyled" data-bind="foreach: choices">\
                <li><label><input type="radio" name="choice" data-bind="checkedValue: $index, checked: $parent.choice, disable: $parent.disable"> <span data-bind="html: $data"></span></label></li>\
            </ul>\
            </form>\
        '
    });
    ko.components.register('answer-widget-dropdown', {
        viewModel: function(params) {
            this.part = params.part;
            this.disable = params.disable;
            this.options = params.options;
            this.choices = this.options.choices.map(function(c,i){return {label: c, index: i}});
            this.choices.splice(0,0,{label: '', index: null});
            this.answerAsArray = this.options.answerAsArray;
            this.choice = ko.observable(null);
            this.answerJSON = params.answerJSON;
            var init = ko.unwrap(this.answerJSON);
            if(init.valid) {
                if(this.answerAsArray) {
                    var choice = init.value.findIndex(function(c){ return c[0]; });
                    if(choice>=0) {
                        this.choice(this.choices[choice+1]);
                    }
                } else {
                    this.choice(this.choices[init.value+1]);
                }
            }
            this.subscriptions = [
                this.answerJSON.subscribe(function(v) {
                    if(!v.valid) {
                        this.choice(null);
                        return;
                    }
                    var current = this.choice()
                    var choice = this.answerAsArray ? v.value.findIndex(function(c){ return c[0]; }) : v.value;
                    if(!current || choice!=current.index) {
                        this.choice(this.choices[choice+1]);
                    }
                },this)
            ];
            this.setAnswerJSON = ko.computed(function() {
                var choice = this.choice();
                if(choice && choice.index!==null) {
                    var value;
                    if(this.answerAsArray) {
                        value = this.choices.slice(1).map(function(c,i){ return [i==choice.index]; });
                    } else {
                        value = choice.index;
                    }
                    this.answerJSON({valid: true, value: value});
                } else {
                    if(this.answerJSON().valid) {
                        this.answerJSON({valid: false, empty: true});
                    }
                }
            },this);
            this.dispose = function() {
                this.subscriptions.forEach(function(sub) { sub.dispose(); });
                this.setAnswerJSON.dispose();
            }
        },
        template: '\
            <select data-bind="options: choices, optionsText: \'label\', value: choice, disable: disable"></select>\
        '
    });
    ko.components.register('answer-widget-checkboxes', {
        viewModel: function(params) {
            var vm = this;
            this.part = params.part;
            this.disable = params.disable;
            this.options = params.options;
            this.answerJSON = params.answerJSON;
            var init = ko.unwrap(this.answerJSON);
            this.answerAsArray = this.options.answerAsArray;
            this.choices = ko.computed(function() {
                return ko.unwrap(this.options.choices).map(function(choice,i) {
                    return {
                        content: choice,
                        ticked: ko.observable(init.valid ? vm.answerAsArray ? init.value[i][0] : init.value[i] : false)
                    }
                });
            },this);
            this.subscriptions = [
                this.answerJSON.subscribe(function(v) {
                    var current = this.choices().map(function(c){ return c.ticked(); });
                    var value = v.value;
                    if(this.answerAsArray) {
                        value = value.map(function(row){ return row[0]; });
                    }
                    if(current.length==value.length && current.every(function(t,i){ return t==value[i]; })) {
                        return;
                    }
                    this.choices().map(function(c,i) { c.ticked(v.value[i]); });
                }, this)
            ];
            this.make_result = function() {
                var v = this.choices().map(function(c){ return c.ticked() });
                if(this.answerAsArray) {
                    return v.map(function(c){ return [c]; });
                } else {
                    return v;
                }
            }
            var lastValue = this.make_result();
            this.setAnswerJSON = ko.computed(function() {
                var value = this.make_result();
                var same = util.objects_equal(value,lastValue);
                if(!same) {
                    this.answerJSON({valid: true, value: value});
                }
                lastValue = value;
            },this);
            this.dispose = function() {
                this.subscriptions.forEach(function(sub) { sub.dispose(); });
                this.setAnswerJSON.dispose();
            }
        },
        template: '\
            <form>\
            <ul class="list-unstyled" data-bind="foreach: choices">\
                <li><label><input type="checkbox" name="choice" data-bind="checked: ticked, disable: $parent.disable"> <span data-bind="html: content"></span></label></li>\
            </ul>\
            </form>\
        '
    });
    ko.components.register('answer-widget-m_n_x', {
        viewModel: function(params) {
            this.part = params.part;
            this.answerJSON = params.answerJSON;
            this.disable = params.disable;
            this.options = params.options;
            this.choices = ko.observableArray(this.options.choices);
            this.answers = ko.observableArray(this.options.answers);
            this.ticks = ko.computed(function() {
                var choices = this.choices();
                var answers = this.answers();
                var ticks = [];
                for(var i=0;i<choices.length;i++) {
                    var row = [];
                    for(var j=0;j<answers.length;j++) {
                        row.push({ticked: ko.observable(false)});
                    }
                    ticks.push(row);
                }
                return ticks;
            },this);
            var init = ko.unwrap(this.answerJSON);
            if(init.valid) {
                var ticks = this.ticks();
                for(var i=0;i<ticks.length;i++) {
                    for(var j=0;j<ticks[i].length;j++) {
                        ticks[i][j].ticked(init.value[i][j]);
                    }
                }
            }
            this.setAnswerJSON = ko.computed(function() {
                var ticks = this.ticks().map(function(r){return r.map(function(d){return d.ticked()})});
                // because of the never-ending madness to do with the order of matrices in multiple choice parts,
                // this matrix needs to be transposed
                // It makes more sense for the array to go [choice][answer], because that's how they're displayed, but
                // changing that would mean breaking old questions.
                var numAnswers = this.answers().length;
                var numChoices = this.choices().length;
                var oticks = [];
                for(var i=0;i<numAnswers;i++) {
                    var row = [];
                    oticks.push(row);
                    for(var j=0;j<numChoices;j++) {
                        row.push(ticks[j][i]);
                    }
                }
                this.answerJSON({valid: true, value: oticks});
            },this);
            this.dispose = function() {
                this.ticks.dispose();
                this.setAnswerJSON.dispose();
            }
        },
        template: '\
            <form>\
                <table>\
                <thead>\
                <tr>\
                    <td></td>\
                    <!-- ko foreach: answers -->\
                    <th><span data-bind="html: $data"></span></th>\
                    <!-- /ko -->\
                </tr>\
                <tbody data-bind="foreach: ticks">\
                    <tr>\
                        <th><span data-bind="html: $parent.choices()[$index()]"></span></th>\
                        <!-- ko foreach: $data -->\
                        <td><input type="checkbox" data-bind="checked: ticked, disable: $parents[1].disable"></td>\
                        <!-- /ko -->\
                    </tr>\
                </tbody>\
                </table>\
            </form>\
        '
    });
});

/*
Copyright 2011-14 Newcastle University
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/** @file Wrappers for the various navigation actions the user can do.
 *
 * The assumption is that these should only be called in response to some event the user triggers, by clicking or whatever.
 *
 * Provides {@link Numbas.controls}
 */
Numbas.queueScript('controls',['base','schedule'],function() {
var job = Numbas.schedule.add;
/** @namespace Numbas.controls */
Numbas.controls = /** @lends Numbas.controls */ {
    /** Start the exam - triggered when user clicks "Start" button on frontpage
     * @see Numbas.Exam#begin
     */
    beginExam: function()
    {
        job(Numbas.exam.begin,Numbas.exam);
    },
    /** Pause the exam
     * @see Numbas.Exam#pause
     */
    pauseExam: function()
    {
        job(Numbas.exam.pause,Numbas.exam);
    },
    /** Resume the paused exam
     * @see Numbas.Exam#resume
     */
    resumeExam: function()
    {
        job(Numbas.exam.resume,Numbas.exam);
    },
    /** (Try to) end the exam
     * @see Numbas.Exam#tryEnd
     */
    endExam: function()
    {
        job(function() {
            Numbas.exam.tryEnd();
        });
    },
    /** In an ended exam, go back from reviewing a question the results page */
    backToResults: function()
    {
        job(function() {
            Numbas.exam.showInfoPage('result');
        });
    },
    /** "Exit" the exam - really this just shows the "You can close the browser" page
     * @see Numbas.Exam#exit
     */
    exitExam: function()
    {
        job(Numbas.exam.exit,Numbas.exam);
    },
    /** Try to move to the next question
     * @see Numbas.Exam#tryChangeQuestion
     */
    nextQuestion: function( )
    {
        job(function() {
            Numbas.exam.tryChangeQuestion( Numbas.exam.currentQuestion.number+1 );
        });
    },
    /** Try to move to the previous question
     * @see Numbas.Exam#tryChangeQuestion
     */
    previousQuestion: function()
    {
        job(function() {
            Numbas.exam.tryChangeQuestion( Numbas.exam.currentQuestion.number-1 );
        });
    },
    /** Make a function which tries to jump to question N
     * @param {Number} n - number of the question to jump to
     * @returns {function}
     * @see Numbas.controls.jumpQuestion
     */
    makeQuestionJumper: function(n) {
        return function() {
            Numbas.controls.jumpQuestion(n);
        }
    },
    /** Try to move directly to a particular question
     * @param {Number} jumpTo - number of the question to jump to
     * @see Numbas.Exam#tryChangeQuestion
     */
    jumpQuestion: function( jumpTo )
    {
        job(function() {
            if(jumpTo == Numbas.exam.currentQuestion.number)
                return;
            Numbas.exam.tryChangeQuestion( jumpTo );
        });
    },
    /** Regenerate the current question
     * @see Numbas.Exam#regenQuestion
     */
    regenQuestion: function()
    {
        job(function() {
            Numbas.display.showConfirm(R('control.confirm regen'+(Numbas.exam.mark == 0 ? ' no marks' : '')),
                function(){Numbas.exam.regenQuestion();}
            );
        });
    },
    /** Show the advice for the current question
     * @see Numbas.Question#getAdvice
     */
    getAdvice: function()
    {
        job(Numbas.exam.currentQuestion.getAdvice,Numbas.exam.currentQuestion);
    },
    /** Reveal the answers to the current question
     * @see Numbas.Question#revealAnswer
     */
    revealAnswer: function()
    {
        job(function() {
            Numbas.display.showConfirm(R('control.confirm reveal'+(Numbas.exam.mark == 0 ? ' no marks' : '')),
                function(){ Numbas.exam.currentQuestion.revealAnswer(); }
            );
        });
    },
    /** Submit student's answers to all parts in the current question
     * @see Numbas.Question#submit
     */
    submitQuestion: function()
    {
        job(Numbas.exam.currentQuestion.submit,Numbas.exam.currentQuestion);
    },
    /* Show steps for a question part
     * @param {Numbas.parts.partpath} partRef - id of the part
     * @see Numbas.parts.Part#showSteps
     */
    showSteps: function( partRef )
    {
        job(function() {
            Numbas.exam.currentQuestion.getPart(partRef).showSteps();
        });
    },
    /** Hide the steps for a question part
     * @param {Numbas.parts.partpath} partRef - id of the part
     * @see Numbas.parts.Part#hideSteps
     */
    hideSteps: function( partRef )
    {
        job(function() {
            Numbas.exam.currentQuestion.getPart(partRef).hideSteps();
        });
    }
};
});

Numbas.queueScript('display-base',['controls','math','xml','util','timing','jme','jme-display'],function() {
var util = Numbas.util;
var jme = Numbas.jme;
/** @namespace Numbas.display */
var display = Numbas.display = /** @lends Numbas.display */ {
    /** Localise strings in page HTML - for tags with an attribute `data-localise`, run that attribute through R.js to localise it, and replace the tag's HTML with the result
     */
    localisePage: function() {
        $('[data-localise]').each(function() {
            var localString = R($(this).data('localise'));
            $(this).html(localString);
        });
    },
    /** Get the attribute with the given name or, if it doesn't exist, look for localise-<name>.
     * If that exists, localise its value and set the desired attribute, then return it.
     * @param {Element} elem
     * @param {String} name
     * @returns {String}
     */
    getLocalisedAttribute: function(elem, name) {
        var attr_localise;
        var attr = elem.getAttribute(name);
        if(!attr && (attr_localise = elem.getAttribute('localise-'+name))) {
            attr = R(attr_localise);
            elem.setAttribute(name,attr);
        }
        return attr;
    },
    /** Update the progress bar when loading
     */
    showLoadProgress: function()
    {
        var p= 100 * Numbas.schedule.completed / Numbas.schedule.total;
        $('#loading .progress-bar').width(p+'%');
    },
    /** Initialise the display. Called as soon as the page loads.
     */
    init: function()
    {
        //hide the various content-display bits
        $('.mainDisplay > *').hide();
        //show the page;
        $('#loading').hide();
        $('#everything').show();
        Knockout.applyBindings(Numbas.exam.display);
        for(var i=0;i<Numbas.exam.questionList.length;i++) {
            Numbas.exam.display.applyQuestionBindings(Numbas.exam.questionList[i]);
        }
        $(document).keydown( function(e)
        {
            if(!Numbas.exam.inProgress) { return; }
            if($('input:focus').length || $('#jqibox').is(':visible'))
                return;
            switch(e.keyCode)
            {
            case 37:
                Numbas.controls.previousQuestion();
                break;
            case 39:
                Numbas.controls.nextQuestion();
                break;
            }
        });
        Numbas.exam.display.questions().map(function(q) {
            q.init();
        });
        // hide the side nav when you click a question selector
        $('.question-nav').on('click','#navMenu.in .questionSelector a',function() {
        });
        // bind buttons in the modals
        $('.modal button.ok').on('click',function() {
            display.modal.ok();
            display.modal.ok = display.modal.cancel = function() {};
        })
        $('#confirm-modal,#alert-modal').on('shown.bs.modal',function() {
            $(this).find('.modal-footer .ok').focus();
        });
        $('.modal button.cancel').on('click',function() {
            display.modal.cancel();
            display.modal.ok = display.modal.cancel = function() {};
        })
    },
    /** Does an input element currently have focus?
     * @type {Boolean}
     */
    inInput: false,
    //alert / confirm boxes
    //
    /** Callback functions for the modals
     * @type {Object.<function>}
     */
    modal: {
        ok: function() {},
        cancel: function() {}
    },
    /** Show an alert dialog
     * @param {String} msg - message to show the user
     * @param {function} fnOK - callback when OK is clicked
     */
    showAlert: function(msg,fnOK) {
        fnOK = fnOK || function() {};
        this.modal.ok = fnOK;
        $('#alert-modal .modal-body').html(msg);
        $('#alert-modal').modal('show');
        $('#alert-modal .modal-footer .ok').focus();
    },
    /** Show a confirmation dialog box
     * @param {String} msg - message to show the user
     * @param {function} fnOK - callback if OK is clicked
     * @param {function} fnCancel - callback if cancelled
     */
    showConfirm: function(msg,fnOK,fnCancel) {
        this.modal.ok = fnOK || function(){};
        this.modal.cancel = fnCancel || function(){};
        $('#confirm-modal .modal-body').html(msg);
        $('#confirm-modal').modal('show');
    },
    /** Make MathJax typeset any maths in the selector
     * @param {jQuery|Element} [selector] - elements to typeset. If not given, the whole page is typeset
     * @param {function} callback - function to call when typesetting is finished
     */
    typeset: function(selector,callback)
    {
        try
        {
            if(!selector)
                selector = $('body');
            $(selector).each(function(i,elem) {
                display.MathJaxQueue.Push(['Typeset',MathJax.Hub,elem]);
            });
            if(callback)
                display.MathJaxQueue.Push(callback);
        }
        catch(e)
        {
            if(MathJax===undefined && !display.failedMathJax)
            {
                display.failedMathJax = true;
                display.showAlert("Failed to load MathJax. Maths will not be typeset properly.\n\nIf you are the exam author, please check that you are connected to the internet, or modify the theme to load a local copy of MathJax. Instructions for doing this are given in the manual.");
            }
            else
            {
                Numbas.showError(e);
            }
        };
    },
    /** The Numbas exam has failed so much it can't continue - show an error message and the error
     * @param {Error} e
     */
    die: function(e) {
        var message = (e || e.message)+'';
        var stack = e.stack.replace(/\n/g,'<br>\n');
        Numbas.debug(message+' <br> '+stack);
        //hide all the non-error stuff
        $('.mainDisplay > *,#loading,#everything').hide();
        //show the error stuff
        $('#die').show();
        $('#die .error .message').html(message);
        $('#die .error .stack').html(stack);
    }
};
//get size of contents of an input
//from http://stackoverflow.com/questions/118241/calculate-text-width-with-javascript
$.textMetrics = function(el) {
    var h = 0, w = 0;
    var div = document.createElement('div');
    document.body.appendChild(div);
    $(div).css({
        position: 'absolute',
        left: -1000,
        top: -1000,
        display: 'none'
    });
    var val = $(el).val();
    val = val.replace(/ /g,'&nbsp;');
    $(div).html(val);
    var styles = ['font-size','font-style', 'font-weight', 'font-family','line-height', 'text-transform', 'letter-spacing'];
    $(styles).each(function() {
        var s = this.toString();
        $(div).css(s, $(el).css(s));
    });
    h = $(div).outerHeight();
    w = $(div).outerWidth();
    $(div).remove();
    var ret = {
     height: h,
     width: w
    };
    return ret;
}
/** An object which can produce feedback: {@link Numbas.Question} or {@link Numbas.parts.Part}.
 * @typedef {Object} Numbas.display.feedbackable
 * 	@property {observable.<Boolean>} answered - has the object been answered?
 * 	@property {observable.<Boolean>} isDirty - has the student's answer changed?
 * 	@property {observable.<Number>} score - number of marks awarded
 *  @property {observable.<Number>} marks - number of marks available
 *  @property {observable.<Number>} credit - proportion of available marks awarded
 *  @property {observable.<Boolean>} doesMarking - does the object do any marking?
 *	@property {observable.<Boolean>} revealed - have the correct answers been revealed?
 */
/** Settings for {@link Numbas.display.showScoreFeedback}
 * @typedef {Object} Numbas.display.showScoreFeedback_settings
 * @property {Boolean} showTotalMark - Show the total marks available?
 * @property {Boolean} showActualMark - Show the student's current score?
 * @property {Boolean} showAnswerState - Show the correct/incorrect state after marking?
 */
/** Feedback states for a question or part: "wrong", "correct", "partial" or "none".
 * @typedef {String} Numbas.display.feedback_state
 */
/** A model representing feedback on an item which is marked - a question or a part.
 * @typedef {Object} Numbas.display.scoreFeedback
 * @property {observable.<Boolean>} update - Call `update(true)` when the score changes. Used to trigger animations.
 * @property {observable.<Numbas.display.feedback_state>} state - The current state of the item, to be shown to the student.
 * @property {observable.<Boolean>} answered - Has the item been answered? False if the student has changed their answer since submitting.
 * @property {observable.<String>} answeredString - Translated text describing how much of the item has been answered: 'unanswered', 'partially answered' or 'answered'
 * @property {observable.<String>} message - Text summarising the state of the item.
 * @property {observable.<String>} iconClass - CSS class for the feedback icon.
 * @property {observable.<Object>} iconAttr - A dictionary of attributes for the feedback icon.
 */
/** Update a score feedback box
 * @param {Numbas.display.feedbackable} obj - object to show feedback about
 * @param {Numbas.display.showScoreFeedback_settings} settings
 * @memberof Numbas.display
 * @returns Numbas.display.scoreFeedback
 */
var showScoreFeedback = display.showScoreFeedback = function(obj,settings)
{
    var niceNumber = Numbas.math.niceNumber;
    var scoreDisplay = '';
    var newScore = Knockout.observable(false);
    var answered = Knockout.computed(function() {
        return obj.answered();
    });
    var showFeedbackIcon = settings.showFeedbackIcon === undefined ? settings.showAnswerState : settings.showFeedbackIcon;
    var anyAnswered = Knockout.computed(function() {
        if(obj.anyAnswered===undefined) {
            return answered();
        } else {
            return obj.anyAnswered();
        }
    });
    var partiallyAnswered = Knockout.computed(function() {
        return anyAnswered() && !answered();
    },this);
    var state = Knockout.computed(function() {
        var revealed = obj.revealed(), score = obj.score(), marks = obj.marks(), credit = obj.credit();
        if( obj.doesMarking() && showFeedbackIcon && (revealed || (settings.showAnswerState && anyAnswered())) ) {
            if(credit<=0) {
                return 'wrong';
            } else if(Numbas.math.precround(credit,10)==1) {
                return 'correct';
            } else {
                return 'partial';
            }
        }
        else {
            return 'none';
        }
    });
    return {
        update: Knockout.computed({
            read: function() {
                return newScore();
            },
            write: function() {
                newScore(true);
                newScore(false);
            }
        }),
        state: state,
        answered: answered,
        answeredString: Knockout.computed(function() {
            if(obj.marks()==0 || !(obj.revealed() || settings.showActualMark || settings.showTotalMark)) {
                return '';
            }
            var key = answered() ? 'answered' : partiallyAnswered() ? 'partially answered' : 'unanswered';
            return R('question.score feedback.'+key);
        },this),
        message: Knockout.computed(function() {
            var revealed = obj.revealed(), score = obj.score(), marks = obj.marks();
            var scoreobj = {
                marks: marks,
                score: score,
                marksString: niceNumber(marks)+' '+R('mark',{count:marks}),
                scoreString: niceNumber(score)+' '+R('mark',{count:score}),
            };
            if(marks==0) {
                return R('question.score feedback.not marked');
            }
            if(!revealed) {
                if(settings.showActualMark) {
                    if(settings.showTotalMark) {
                        return R('question.score feedback.score total actual',scoreobj);
                    } else {
                        return R('question.score feedback.score actual',scoreobj);
                    }
                } else if(settings.showTotalMark) {
                    return R('question.score feedback.score total',scoreobj);
                } else {
                    var key = answered () ? 'answered' : anyAnswered() ? 'partially answered' : 'unanswered';
                    return R('question.score feedback.'+key);
                }
            } else {
                return R('question.score feedback.score total actual',scoreobj);
            }
        }),
        iconClass: Knockout.computed(function() {
            if (!showFeedbackIcon) {
                return 'invisible';
            }
            switch(state()) {
            case 'wrong':
                return 'icon-remove';
            case 'correct':
                return 'icon-ok';
            case 'partial':
                return 'icon-ok partial';
            default:
                return '';
            }
        }),
        iconAttr: Knockout.computed(function() {
            return {title:R('question.score feedback.'+state())};
        })
    }
};
});

/*
Copyright 2011-16 Newcastle University
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/** @file Display code. Provides {@link Numbas.display} */
Numbas.queueScript('display',['display-base','mathjax-hooks','knockout-handlers','exam-display','question-display','part-display','display/parts/extension','display/parts/gapfill','display/parts/information','display/parts/jme','display/parts/matrix','display/parts/multipleresponse','display/parts/numberentry','display/parts/patternmatch'],function() {
});
Numbas.queueScript('es6-promise',[],function(module) {
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
 * @version   3.2.2+39aa2571
 */
(function() {
    "use strict";
    function lib$es6$promise$utils$$objectOrFunction(x) {
      return typeof x === 'function' || (typeof x === 'object' && x !== null);
    }
    function lib$es6$promise$utils$$isFunction(x) {
      return typeof x === 'function';
    }
    function lib$es6$promise$utils$$isMaybeThenable(x) {
      return typeof x === 'object' && x !== null;
    }
    var lib$es6$promise$utils$$_isArray;
    if (!Array.isArray) {
      lib$es6$promise$utils$$_isArray = function (x) {
        return Object.prototype.toString.call(x) === '[object Array]';
      };
    } else {
      lib$es6$promise$utils$$_isArray = Array.isArray;
    }
    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
    var lib$es6$promise$asap$$len = 0;
    var lib$es6$promise$asap$$vertxNext;
    var lib$es6$promise$asap$$customSchedulerFn;
    var lib$es6$promise$asap$$asap = function asap(callback, arg) {
      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
      lib$es6$promise$asap$$len += 2;
      if (lib$es6$promise$asap$$len === 2) {
        // If len is 2, that means that we need to schedule an async flush.
        // If additional callbacks are queued before the queue is flushed, they
        // will be processed by this flush that we are scheduling.
        if (lib$es6$promise$asap$$customSchedulerFn) {
          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
        } else {
          lib$es6$promise$asap$$scheduleFlush();
        }
      }
    }
    function lib$es6$promise$asap$$setScheduler(scheduleFn) {
      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
    }
    function lib$es6$promise$asap$$setAsap(asapFn) {
      lib$es6$promise$asap$$asap = asapFn;
    }
    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
    var lib$es6$promise$asap$$isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
    // test for web worker but not in IE10
    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
      typeof importScripts !== 'undefined' &&
      typeof MessageChannel !== 'undefined';
    // node
    function lib$es6$promise$asap$$useNextTick() {
      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
      // see https://github.com/cujojs/when/issues/410 for details
      return function() {
        process.nextTick(lib$es6$promise$asap$$flush);
      };
    }
    // vertx
    function lib$es6$promise$asap$$useVertxTimer() {
      return function() {
        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
      };
    }
    function lib$es6$promise$asap$$useMutationObserver() {
      var iterations = 0;
      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
      var node = document.createTextNode('');
      observer.observe(node, { characterData: true });
      return function() {
        node.data = (iterations = ++iterations % 2);
      };
    }
    // web worker
    function lib$es6$promise$asap$$useMessageChannel() {
      var channel = new MessageChannel();
      channel.port1.onmessage = lib$es6$promise$asap$$flush;
      return function () {
        channel.port2.postMessage(0);
      };
    }
    function lib$es6$promise$asap$$useSetTimeout() {
      return function() {
        setTimeout(lib$es6$promise$asap$$flush, 1);
      };
    }
    var lib$es6$promise$asap$$queue = new Array(1000);
    function lib$es6$promise$asap$$flush() {
      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {
        var callback = lib$es6$promise$asap$$queue[i];
        var arg = lib$es6$promise$asap$$queue[i+1];
        callback(arg);
        lib$es6$promise$asap$$queue[i] = undefined;
        lib$es6$promise$asap$$queue[i+1] = undefined;
      }
      lib$es6$promise$asap$$len = 0;
    }
    function lib$es6$promise$asap$$attemptVertx() {
      try {
        var r = require;
        var vertx = r('vertx');
        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
        return lib$es6$promise$asap$$useVertxTimer();
      } catch(e) {
        return lib$es6$promise$asap$$useSetTimeout();
      }
    }
    var lib$es6$promise$asap$$scheduleFlush;
    // Decide what async method to use to triggering processing of queued callbacks:
    if (lib$es6$promise$asap$$isNode) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
    } else if (lib$es6$promise$asap$$isWorker) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
    } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
    } else {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
    }
    function lib$es6$promise$then$$then(onFulfillment, onRejection) {
      var parent = this;
      var child = new this.constructor(lib$es6$promise$$internal$$noop);
      if (child[lib$es6$promise$$internal$$PROMISE_ID] === undefined) {
        lib$es6$promise$$internal$$makePromise(child);
      }
      var state = parent._state;
      if (state) {
        var callback = arguments[state - 1];
        lib$es6$promise$asap$$asap(function(){
          lib$es6$promise$$internal$$invokeCallback(state, child, callback, parent._result);
        });
      } else {
        lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
      }
      return child;
    }
    var lib$es6$promise$then$$default = lib$es6$promise$then$$then;
    function lib$es6$promise$promise$resolve$$resolve(object) {
      /*jshint validthis:true */
      var Constructor = this;
      if (object && typeof object === 'object' && object.constructor === Constructor) {
        return object;
      }
      var promise = new Constructor(lib$es6$promise$$internal$$noop);
      lib$es6$promise$$internal$$resolve(promise, object);
      return promise;
    }
    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
    var lib$es6$promise$$internal$$PROMISE_ID = Math.random().toString(36).substring(16);
    function lib$es6$promise$$internal$$noop() {}
    var lib$es6$promise$$internal$$PENDING   = void 0;
    var lib$es6$promise$$internal$$FULFILLED = 1;
    var lib$es6$promise$$internal$$REJECTED  = 2;
    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();
    function lib$es6$promise$$internal$$selfFulfillment() {
      return new TypeError("You cannot resolve a promise with itself");
    }
    function lib$es6$promise$$internal$$cannotReturnOwn() {
      return new TypeError('A promises callback cannot return that same promise.');
    }
    function lib$es6$promise$$internal$$getThen(promise) {
      try {
        return promise.then;
      } catch(error) {
        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
        return lib$es6$promise$$internal$$GET_THEN_ERROR;
      }
    }
    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
      try {
        then.call(value, fulfillmentHandler, rejectionHandler);
      } catch(e) {
        return e;
      }
    }
    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
       lib$es6$promise$asap$$asap(function(promise) {
        var sealed = false;
        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
          if (sealed) { return; }
          sealed = true;
          if (thenable !== value) {
            lib$es6$promise$$internal$$resolve(promise, value);
          } else {
            lib$es6$promise$$internal$$fulfill(promise, value);
          }
        }, function(reason) {
          if (sealed) { return; }
          sealed = true;
          lib$es6$promise$$internal$$reject(promise, reason);
        }, 'Settle: ' + (promise._label || ' unknown promise'));
        if (!sealed && error) {
          sealed = true;
          lib$es6$promise$$internal$$reject(promise, error);
        }
      }, promise);
    }
    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
        lib$es6$promise$$internal$$fulfill(promise, thenable._result);
      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
        lib$es6$promise$$internal$$reject(promise, thenable._result);
      } else {
        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {
          lib$es6$promise$$internal$$resolve(promise, value);
        }, function(reason) {
          lib$es6$promise$$internal$$reject(promise, reason);
        });
      }
    }
    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable, then) {
      if (maybeThenable.constructor === promise.constructor &&
          then === lib$es6$promise$then$$default &&
          constructor.resolve === lib$es6$promise$promise$resolve$$default) {
        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
      } else {
        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
        } else if (then === undefined) {
          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
        } else if (lib$es6$promise$utils$$isFunction(then)) {
          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
        } else {
          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
        }
      }
    }
    function lib$es6$promise$$internal$$resolve(promise, value) {
      if (promise === value) {
        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());
      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
        lib$es6$promise$$internal$$handleMaybeThenable(promise, value, lib$es6$promise$$internal$$getThen(value));
      } else {
        lib$es6$promise$$internal$$fulfill(promise, value);
      }
    }
    function lib$es6$promise$$internal$$publishRejection(promise) {
      if (promise._onerror) {
        promise._onerror(promise._result);
      }
      lib$es6$promise$$internal$$publish(promise);
    }
    function lib$es6$promise$$internal$$fulfill(promise, value) {
      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
      promise._result = value;
      promise._state = lib$es6$promise$$internal$$FULFILLED;
      if (promise._subscribers.length !== 0) {
        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
      }
    }
    function lib$es6$promise$$internal$$reject(promise, reason) {
      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
      promise._state = lib$es6$promise$$internal$$REJECTED;
      promise._result = reason;
      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
    }
    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
      var subscribers = parent._subscribers;
      var length = subscribers.length;
      parent._onerror = null;
      subscribers[length] = child;
      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;
      if (length === 0 && parent._state) {
        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
      }
    }
    function lib$es6$promise$$internal$$publish(promise) {
      var subscribers = promise._subscribers;
      var settled = promise._state;
      if (subscribers.length === 0) { return; }
      var child, callback, detail = promise._result;
      for (var i = 0; i < subscribers.length; i += 3) {
        child = subscribers[i];
        callback = subscribers[i + settled];
        if (child) {
          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
        } else {
          callback(detail);
        }
      }
      promise._subscribers.length = 0;
    }
    function lib$es6$promise$$internal$$ErrorObject() {
      this.error = null;
    }
    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();
    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
      try {
        return callback(detail);
      } catch(e) {
        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
      }
    }
    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
      var hasCallback = lib$es6$promise$utils$$isFunction(callback),
          value, error, succeeded, failed;
      if (hasCallback) {
        value = lib$es6$promise$$internal$$tryCatch(callback, detail);
        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
          failed = true;
          error = value.error;
          value = null;
        } else {
          succeeded = true;
        }
        if (promise === value) {
          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
          return;
        }
      } else {
        value = detail;
        succeeded = true;
      }
      if (promise._state !== lib$es6$promise$$internal$$PENDING) {
        // noop
      } else if (hasCallback && succeeded) {
        lib$es6$promise$$internal$$resolve(promise, value);
      } else if (failed) {
        lib$es6$promise$$internal$$reject(promise, error);
      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
        lib$es6$promise$$internal$$fulfill(promise, value);
      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
        lib$es6$promise$$internal$$reject(promise, value);
      }
    }
    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
      try {
        resolver(function resolvePromise(value){
          lib$es6$promise$$internal$$resolve(promise, value);
        }, function rejectPromise(reason) {
          lib$es6$promise$$internal$$reject(promise, reason);
        });
      } catch(e) {
        lib$es6$promise$$internal$$reject(promise, e);
      }
    }
    var lib$es6$promise$$internal$$id = 0;
    function lib$es6$promise$$internal$$nextId() {
      return lib$es6$promise$$internal$$id++;
    }
    function lib$es6$promise$$internal$$makePromise(promise) {
      promise[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$id++;
      promise._state = undefined;
      promise._result = undefined;
      promise._subscribers = [];
    }
    function lib$es6$promise$promise$all$$all(entries) {
      return new lib$es6$promise$enumerator$$default(this, entries).promise;
    }
    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
    function lib$es6$promise$promise$race$$race(entries) {
      /*jshint validthis:true */
      var Constructor = this;
      if (!lib$es6$promise$utils$$isArray(entries)) {
        return new Constructor(function(resolve, reject) {
          reject(new TypeError('You must pass an array to race.'));
        });
      } else {
        return new Constructor(function(resolve, reject) {
          var length = entries.length;
          for (var i = 0; i < length; i++) {
            Constructor.resolve(entries[i]).then(resolve, reject);
          }
        });
      }
    }
    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
    function lib$es6$promise$promise$reject$$reject(reason) {
      /*jshint validthis:true */
      var Constructor = this;
      var promise = new Constructor(lib$es6$promise$$internal$$noop);
      lib$es6$promise$$internal$$reject(promise, reason);
      return promise;
    }
    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;
    function lib$es6$promise$promise$$needsResolver() {
      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
    }
    function lib$es6$promise$promise$$needsNew() {
      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }
    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
    /**
      Promise objects represent the eventual result of an asynchronous operation. The
      primary way of interacting with a promise is through its `then` method, which
      registers callbacks to receive either a promise's eventual value or the reason
      why the promise cannot be fulfilled.
      Terminology
      -----------
      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
      - `thenable` is an object or function that defines a `then` method.
      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
      - `exception` is a value that is thrown using the throw statement.
      - `reason` is a value that indicates why a promise was rejected.
      - `settled` the final resting state of a promise, fulfilled or rejected.
      A promise can be in one of three states: pending, fulfilled, or rejected.
      Promises that are fulfilled have a fulfillment value and are in the fulfilled
      state.  Promises that are rejected have a rejection reason and are in the
      rejected state.  A fulfillment value is never a thenable.
      Promises can also be said to *resolve* a value.  If this value is also a
      promise, then the original promise's settled state will match the value's
      settled state.  So a promise that *resolves* a promise that rejects will
      itself reject, and a promise that *resolves* a promise that fulfills will
      itself fulfill.
      Basic Usage:
      ------------
      ```js
      var promise = new Promise(function(resolve, reject) {
        // on success
        resolve(value);
        // on failure
        reject(reason);
      });
      promise.then(function(value) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```
      Advanced Usage:
      ---------------
      Promises shine when abstracting away asynchronous interactions such as
      `XMLHttpRequest`s.
      ```js
      function getJSON(url) {
        return new Promise(function(resolve, reject){
          var xhr = new XMLHttpRequest();
          xhr.open('GET', url);
          xhr.onreadystatechange = handler;
          xhr.responseType = 'json';
          xhr.setRequestHeader('Accept', 'application/json');
          xhr.send();
          function handler() {
            if (this.readyState === this.DONE) {
              if (this.status === 200) {
                resolve(this.response);
              } else {
                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
              }
            }
          };
        });
      }
      getJSON('/posts.json').then(function(json) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```
      Unlike callbacks, promises are great composable primitives.
      ```js
      Promise.all([
        getJSON('/posts'),
        getJSON('/comments')
      ]).then(function(values){
        values[0] // => postsJSON
        values[1] // => commentsJSON
        return values;
      });
      ```
      @class Promise
      @param {function} resolver
      Useful for tooling.
      @constructor
    */
    function lib$es6$promise$promise$$Promise(resolver) {
      this[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$nextId();
      this._result = this._state = undefined;
      this._subscribers = [];
      if (lib$es6$promise$$internal$$noop !== resolver) {
        typeof resolver !== 'function' && lib$es6$promise$promise$$needsResolver();
        this instanceof lib$es6$promise$promise$$Promise ? lib$es6$promise$$internal$$initializePromise(this, resolver) : lib$es6$promise$promise$$needsNew();
      }
    }
    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;
    lib$es6$promise$promise$$Promise.prototype = {
      constructor: lib$es6$promise$promise$$Promise,
    /**
      The primary way of interacting with a promise is through its `then` method,
      which registers callbacks to receive either a promise's eventual value or the
      reason why the promise cannot be fulfilled.
      ```js
      findUser().then(function(user){
        // user is available
      }, function(reason){
        // user is unavailable, and you are given the reason why
      });
      ```
      Chaining
      --------
      The return value of `then` is itself a promise.  This second, 'downstream'
      promise is resolved with the return value of the first promise's fulfillment
      or rejection handler, or rejected if the handler throws an exception.
      ```js
      findUser().then(function (user) {
        return user.name;
      }, function (reason) {
        return 'default name';
      }).then(function (userName) {
        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
        // will be `'default name'`
      });
      findUser().then(function (user) {
        throw new Error('Found user, but still unhappy');
      }, function (reason) {
        throw new Error('`findUser` rejected and we're unhappy');
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
      });
      ```
      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
      ```js
      findUser().then(function (user) {
        throw new PedagogicalException('Upstream error');
      }).then(function (value) {
        // never reached
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // The `PedgagocialException` is propagated all the way down to here
      });
      ```
      Assimilation
      ------------
      Sometimes the value you want to propagate to a downstream promise can only be
      retrieved asynchronously. This can be achieved by returning a promise in the
      fulfillment or rejection handler. The downstream promise will then be pending
      until the returned promise is settled. This is called *assimilation*.
      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // The user's comments are now available
      });
      ```
      If the assimliated promise rejects, then the downstream promise will also reject.
      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // If `findCommentsByAuthor` fulfills, we'll have the value here
      }, function (reason) {
        // If `findCommentsByAuthor` rejects, we'll have the reason here
      });
      ```
      Simple Example
      --------------
      Synchronous Example
      ```javascript
      var result;
      try {
        result = findResult();
        // success
      } catch(reason) {
        // failure
      }
      ```
      Errback Example
      ```js
      findResult(function(result, err){
        if (err) {
          // failure
        } else {
          // success
        }
      });
      ```
      Promise Example;
      ```javascript
      findResult().then(function(result){
        // success
      }, function(reason){
        // failure
      });
      ```
      Advanced Example
      --------------
      Synchronous Example
      ```javascript
      var author, books;
      try {
        author = findAuthor();
        books  = findBooksByAuthor(author);
        // success
      } catch(reason) {
        // failure
      }
      ```
      Errback Example
      ```js
      function foundBooks(books) {
      }
      function failure(reason) {
      }
      findAuthor(function(author, err){
        if (err) {
          failure(err);
          // failure
        } else {
          try {
            findBoooksByAuthor(author, function(books, err) {
              if (err) {
                failure(err);
              } else {
                try {
                  foundBooks(books);
                } catch(reason) {
                  failure(reason);
                }
              }
            });
          } catch(error) {
            failure(err);
          }
          // success
        }
      });
      ```
      Promise Example;
      ```javascript
      findAuthor().
        then(findBooksByAuthor).
        then(function(books){
          // found books
      }).catch(function(reason){
        // something went wrong
      });
      ```
      @method then
      @param {Function} onFulfilled
      @param {Function} onRejected
      Useful for tooling.
      @return {Promise}
    */
      then: lib$es6$promise$then$$default,
    /**
      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
      as the catch block of a try/catch statement.
      ```js
      function findAuthor(){
        throw new Error('couldn't find that author');
      }
      // synchronous
      try {
        findAuthor();
      } catch(reason) {
        // something went wrong
      }
      // async with promises
      findAuthor().catch(function(reason){
        // something went wrong
      });
      ```
      @method catch
      @param {Function} onRejection
      Useful for tooling.
      @return {Promise}
    */
      'catch': function(onRejection) {
        return this.then(null, onRejection);
      }
    };
    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;
    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
      this._instanceConstructor = Constructor;
      this.promise = new Constructor(lib$es6$promise$$internal$$noop);
      if (!this.promise[lib$es6$promise$$internal$$PROMISE_ID]) {
        lib$es6$promise$$internal$$makePromise(this.promise);
      }
      if (lib$es6$promise$utils$$isArray(input)) {
        this._input     = input;
        this.length     = input.length;
        this._remaining = input.length;
        this._result = new Array(this.length);
        if (this.length === 0) {
          lib$es6$promise$$internal$$fulfill(this.promise, this._result);
        } else {
          this.length = this.length || 0;
          this._enumerate();
          if (this._remaining === 0) {
            lib$es6$promise$$internal$$fulfill(this.promise, this._result);
          }
        }
      } else {
        lib$es6$promise$$internal$$reject(this.promise, lib$es6$promise$enumerator$$validationError());
      }
    }
    function lib$es6$promise$enumerator$$validationError() {
      return new Error('Array Methods must be provided an Array');
    }
    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
      var length  = this.length;
      var input   = this._input;
      for (var i = 0; this._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
        this._eachEntry(input[i], i);
      }
    };
    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
      var c = this._instanceConstructor;
      var resolve = c.resolve;
      if (resolve === lib$es6$promise$promise$resolve$$default) {
        var then = lib$es6$promise$$internal$$getThen(entry);
        if (then === lib$es6$promise$then$$default &&
            entry._state !== lib$es6$promise$$internal$$PENDING) {
          this._settledAt(entry._state, i, entry._result);
        } else if (typeof then !== 'function') {
          this._remaining--;
          this._result[i] = entry;
        } else if (c === lib$es6$promise$promise$$default) {
          var promise = new c(lib$es6$promise$$internal$$noop);
          lib$es6$promise$$internal$$handleMaybeThenable(promise, entry, then);
          this._willSettleAt(promise, i);
        } else {
          this._willSettleAt(new c(function(resolve) { resolve(entry); }), i);
        }
      } else {
        this._willSettleAt(resolve(entry), i);
      }
    };
    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
      var promise = this.promise;
      if (promise._state === lib$es6$promise$$internal$$PENDING) {
        this._remaining--;
        if (state === lib$es6$promise$$internal$$REJECTED) {
          lib$es6$promise$$internal$$reject(promise, value);
        } else {
          this._result[i] = value;
        }
      }
      if (this._remaining === 0) {
        lib$es6$promise$$internal$$fulfill(promise, this._result);
      }
    };
    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
      var enumerator = this;
      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {
        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
      }, function(reason) {
        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
      });
    };
    function lib$es6$promise$polyfill$$polyfill() {
      var local;
      if (typeof global !== 'undefined') {
          local = global;
      } else if (typeof self !== 'undefined') {
          local = self;
      } else {
          try {
              local = Function('return this')();
          } catch (e) {
              throw new Error('polyfill failed because global object is unavailable in this environment');
          }
      }
      var P = local.Promise;
      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
        return;
      }
      local.Promise = lib$es6$promise$promise$$default;
    }
    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;
    lib$es6$promise$promise$$default.Promise = lib$es6$promise$promise$$default;
    lib$es6$promise$promise$$default.polyfill = lib$es6$promise$polyfill$$default;
    /* global define:true module:true window: true */
    if (typeof define === 'function' && define['amd']) {
      define(function() { return lib$es6$promise$promise$$default; });
    } else if (typeof module !== 'undefined' && module['exports']) {
      module['exports'] = lib$es6$promise$promise$$default;
    } else if (typeof this !== 'undefined') {
      this['Promise'] = lib$es6$promise$promise$$default;
    }
    lib$es6$promise$polyfill$$default();
}).call(this);
});
Numbas.queueScript('exam-display',['display-base','math','util','timing'],function() {
    var display = Numbas.display;
    var util = Numbas.util;
    /** Display properties of the {@link Numbas.Exam} object.
     * @name ExamDisplay
     * @memberof Numbas.display
     * @constructor
     * @param {Numbas.Exam} e - associated exam
     *
     */
    display.ExamDisplay = function(e)
    {
        this.exam=e;
        /** The exam's mode ({@link Numbas.Exam#mode})
         * @member {observable|String} mode
         * @memberof Numbas.display.ExamDisplay
         */
        this.mode = Knockout.observable(e.mode);
        /** Is {@link Numbas.store} currently saving?
         * @member {observable|Boolean} saving
         * @memberof Numbas.display.ExamDisplay
         */
        this.saving = Knockout.observable(false);
        /** The name of the currently displayed info page
         * @member {observable|String} infoPage
         * @memberof Numbas.display.ExamDisplay
         */
        this.infoPage = Knockout.observable(null);
        /** The current question ({@link Numbas.Exam#currentQuestion})
         * @member {observable|Numbas.Question} currentQuestion
         * @memberof Numbas.display.ExamDisplay
         */
        this.currentQuestion = Knockout.observable(null);
        /** What kind of view are we in at the moment? 'infopage' or 'question'
         * @member {observable|String} viewType
         * @memberof Numbas.display.ExamDisplay
         */
        this.viewType = Knockout.computed(function() {
            if(this.infoPage()) {
                return 'infopage';
            } else if(this.currentQuestion()) {
                return 'question';
            }
        },this);
        /** The number of the current question
         * @member {observable|Number} currentQuestionNumber
         * @memberof Numbas.display.ExamDisplay
         */
        this.currentQuestionNumber = Knockout.computed(function() {
            var q = this.currentQuestion();
            if(q)
                return q.question.number;
            else
                return null;
        },this);
        /** All the exam's question display objects
         * @member {observable|Numbas.display.QuestionDisplay[]} questions
         * @memberof Numbas.display.ExamDisplay
         */
        this.questions = Knockout.observableArray([]);
        /** Can the student go back to the previous question? (False if the current question is the first one
         * @member {observable|Boolean} canReverse
         * @memberof Numbas.display.ExamDisplay
         */
        this.canReverse = Knockout.computed(function() {
            return this.exam.settings.navigateReverse && this.currentQuestionNumber()>0;
        },this);
        /** Can the student go forward to the next question? (False if the current question is the last one)
         * @member {observable|Boolean} canAdvance
         * @memberof Numbas.display.ExamDisplay
         */
        this.canAdvance = Knockout.computed(function() {
            return this.currentQuestionNumber()<this.exam.settings.numQuestions-1;
        },this);
        /** The student's total score ({@link Numbas.Exam#score})
         * @member {observable|Number} score
         * @memberof Numbas.display.ExamDisplay
         */
        this.score = Knockout.observable(e.score);
        /** The total marks available for the exam ({@link Numbas.Exam#mark})
         * @member {observable|Number} marks
         * @memberof Numbas.display.ExamDisplay
         */
        this.marks = Knockout.observable(e.mark);
        /** The percentage score the student needs to achieve to pass ({@link Numbas.Exam#percentPass}), formatted as a string.
         * @member {observable|String} percentPass
         * @memberof Numbas.display.ExamDisplay
         */
        this.percentPass = Knockout.observable(e.settings.percentPass*100+'%');
        /** String displaying the student's current score, and the total marks available, if allowed
         * @member {observable|String} examScoreDisplay
         * @memberof Numbas.display.ExamDisplay
         */
        this.examScoreDisplay = Knockout.computed(function() {
            var niceNumber = Numbas.math.niceNumber;
            var exam = this.exam;
            var score = this.score();
            var marks = this.marks();
            var totalExamScoreDisplay = '';
            if(exam.settings.showTotalMark)
                totalExamScoreDisplay = niceNumber(score)+'/'+niceNumber(marks);
            else
                totalExamScoreDisplay = niceNumber(score);
            return totalExamScoreDisplay;
        },this);
        /** The student's total score as a percentage of the total marks available
         * @member {observable|Number} percentScore
         * @memberof Numbas.display.ExamDisplay
         */
        this.percentScore = Knockout.observable(0);
        /** The time left in the exam
         * @member {observable|String} displayTime
         * @memberof Numbas.display.ExamDisplay
         */
        this.displayTime = Knockout.observable('');
        /** Show the names of question groups in the menu?
         * @member {observable|String} showQuestionGroupNames
         * @memberof Numbas.display.ExamDisplay
         */
        this.showQuestionGroupNames = Knockout.observable(e.settings.showQuestionGroupNames);
        /** Time the exam started, formatted for display
         * @mamber {observable|String} startTime
         * @memberof Numbas.display.ExamDisplay
         */
        var _startTime = Knockout.observable();
        this.startTime = Knockout.computed({
            read: function() {
                var t = _startTime();
                if(t) {
                    return util.formatTime(new Date(t));
                } else {
                    return '';
                }
            },
            write: function(v) {
                return _startTime(v);
            }
        });
        /** Time the exam ended, formatted for display
         * @mamber {observable|String} endTime
         * @memberof Numbas.display.ExamDisplay
         */
        var _endTime = Knockout.observable();
        this.endTime = Knockout.computed({
            read: function() {
                var t = _endTime();
                if(t) {
                    return util.formatTime(new Date(t));
                } else {
                    return '';
                }
            },
            write: function(v) {
                return _endTime(v);
            }
        });
        /** The total time the student has spent in the exam
         * @member {observable|String} timeSpent
         * @memberof Numbas.display.ExamDisplay
         */
        this.timeSpent = Knockout.observable('');
        /** Is the student allowed to pause the exam?
         * @member {Boolean} allowPause
         * @memberof Numbas.display.ExamDisplay
         */
        this.allowPause = e.settings.allowPause;
        /** Total number of questions the student attempted
         * @member {observable|Number} questionsAttempted
         * @memberof Numbas.display.ExamDisplay
         */
        this.questionsAttempted = Knockout.computed(function() {
            return this.questions().reduce(function(s,q) {
                return s + (q.answered() ? 1 : 0);
            },0);
        },this);
        /** Total number of questions the student attempted, formatted as a fraction of the total number of questions
         * @member {observable|String} questionsAttemptedDisplay
         * @memberof Numbas.display.ExamDisplay
         */
        this.questionsAttemptedDisplay = Knockout.computed(function() {
            return this.questionsAttempted()+' / '+this.exam.settings.numQuestions;
        },this);
        /** The result of the exam - passed or failed?
         * @member {observable|String} result
         * @memberof Numbas.display.ExamDisplay
         */
        this.result = Knockout.observable('');
        /** Did the student pass the exam?
         * @member {observable|Boolean} passed
         * @memberof Numbas.display.ExamDisplay
         */
        this.passed = Knockout.observable(false);
        /** Message shown to the student based on their total score
         * @member {observable|String} feedbackMessage
         * @memberof Numbas.display.ExamDisplay
         */
        this.feedbackMessage = Knockout.observable(null);
        document.title = e.settings.name;
    }
    display.ExamDisplay.prototype = /** @lends Numbas.display.ExamDisplay.prototype */
    {
        /** Reference to the associated exam object
         * @type {Numbas.Exam}
         * @memberof Numbas.display.ExamDisplay
         */
        exam: undefined,
        /** Update the timer
         * @memberof Numbas.display.ExamDisplay
         */
        showTiming: function()
        {
            this.displayTime(Numbas.timing.secsToDisplayTime(this.exam.timeRemaining));
            this.timeSpent(Numbas.timing.secsToDisplayTime(this.exam.timeSpent));
        },
        /** Initialise the question list display
         * @memberof Numbas.display.ExamDisplay
         */
        initQuestionList: function() {
            this.question_groups = this.exam.question_groups.map(function(g) {
                return {
                    name: g.settings.name,
                    group: g,
                    questions: Knockout.observable(g.questionList.map(function(q){return q.display}))
                }
            });
            for(var i=0; i<this.exam.questionList.length; i++) {
                this.questions.push(this.exam.questionList[i].display);
            }
        },
        /** Hide the timer
         * @memberof Numbas.display.ExamDisplay
         */
        hideTiming: function()
        {
            this.displayTime('');
        },
        /** Show/update the student's total score
         * @memberof Numbas.display.ExamDisplay
         */
        showScore: function()
        {
            var exam = this.exam;
            this.marks(Numbas.math.niceNumber(exam.mark));
            this.score(Numbas.math.niceNumber(exam.score));
            this.percentScore(exam.percentScore);
        },
        /** Update the question list display - typically, scroll so the current question is visible
         * @memberof Numbas.display.ExamDisplay
         */
        updateQuestionMenu: function()
        {
            var exam = this.exam;
            //scroll question list to centre on current question
            if(display.carouselGo)
                display.carouselGo(exam.currentQuestion.number-1,300);
        },
        /** Show an info page (one of the front page, pause , results, or exit)
         * @param {String} page - name of the page to show
         * @memberof Numbas.display.ExamDisplay
         */
        showInfoPage: function(page)
        {
            window.onbeforeunload = null;
            this.infoPage(page);
            this.currentQuestion(null);
            var exam = this.exam;
            //scroll back to top of screen
            scroll(0,0);
            switch(page)
            {
            case "frontpage":
                this.marks(exam.mark);
                break;
            case "result":
                this.result(exam.result);
                this.passed(exam.passed);
                this.feedbackMessage(exam.feedbackMessage);
                this.startTime(exam.start);
                this.endTime(exam.stop);
                break;
            case "suspend":
                this.showScore();
                break;
            case "exit":
                break;
            }
            this.hideNavMenu();
        },
        /** Show the current question
         * @memberof Numbas.display.ExamDisplay
         */
        showQuestion: function()
        {
            var exam = this.exam;
            this.infoPage(null);
            this.currentQuestion(exam.currentQuestion.display);
            if(exam.settings.preventLeave && this.mode() != 'review')
                window.onbeforeunload = function() { return R('control.confirm leave') };
            else
                window.onbeforeunload = null;
            exam.currentQuestion.display.show();
            this.hideNavMenu();
        },
        /** Hide the sliding side menu
         * @memberof Numbas.display.ExamDisplay
         */
        hideNavMenu: function() {
            if($('#navMenu').data('bs.offcanvas')) {
                $('#navMenu').offcanvas('hide');
            }
        },
        /** Called just before the current question is regenerated
         * @memberof Numbas.display.ExamDisplay
         */
        startRegen: function() {
            $('#questionDisplay').hide();
            this.exam.currentQuestion.display.html.remove();
            this.oldQuestion = this.exam.currentQuestion.display;
        },
        /** Called after the current question has been regenerated
         * @memberof Numbas.display.ExamDisplay
         */
        endRegen: function() {
            var currentQuestion = this.exam.currentQuestion;
            this.questions.splice(currentQuestion.number,1,currentQuestion.display);
            var group = this.question_groups.filter(function(g){return g.group == currentQuestion.group})[0];
            var n_in_group = currentQuestion.group.questionList.indexOf(currentQuestion);
            var group_questions = group.questions();
            group_questions.splice(n_in_group,1,currentQuestion.display);
            group.questions(group_questions);
            this.applyQuestionBindings(currentQuestion);
            $('#questionDisplay').fadeIn(200);
        },
        /** Apply knockout bindings to the given question
         * @param {Numbas.Question}
         * @memberof Numbas.display.ExamDisplay
         */
        applyQuestionBindings: function(question) {
            Knockout.applyBindings({exam: this, question: question.display},question.display.html[0]);
        },
        /** Called when the exam ends
         * @memberof Numbas.display.ExamDisplay
         */
        end: function() {
            this.timeSpent(Numbas.timing.secsToDisplayTime(this.exam.timeSpent));
            this.mode(this.exam.mode);
            this.questions().map(function(q) {
                q.end();
            });
        }
    };
});
/*
Copyright 2011-14 Newcastle University
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/** @file Defines the {@link Numbas.Exam} object. */
Numbas.queueScript('exam',['base','timing','util','xml','display','schedule','storage','scorm-storage','math','question','jme-variables','jme-display','jme-rules','jme'],function() {
    var job = Numbas.schedule.add;
    var util = Numbas.util;
/** Keeps track of all info we need to know while exam is running.
 *
 * Loads XML from {@link Numbas.xml.examXML}
 * @param {Numbas.storage.BlankStorage} [store] - the storage engine to use
 * @constructor
 * @memberof Numbas
 */
function Exam(store)
{
    var tryGetAttribute = Numbas.xml.tryGetAttribute;
    this.store = store;
    //get the exam info out of the XML and into the exam object
    var xml = this.xml = Numbas.xml.examXML.selectSingleNode('/exam');
    if(!xml)
    {
        throw(new Numbas.Error('exam.xml.bad root'));
    }
    var settings = this.settings;
    this.signals = new Numbas.schedule.SignalBox();
    //load settings from XML
    tryGetAttribute(settings,xml,'.',['name','percentPass']);
    tryGetAttribute(settings,xml,'questions',['shuffle','all','pick'],['shuffleQuestions','allQuestions','pickQuestions']);
    tryGetAttribute(settings,xml,'settings/navigation',['allowregen','reverse','browse','showfrontpage','showresultspage','preventleave'],['allowRegen','navigateReverse','navigateBrowse','showFrontPage','showResultsPage','preventLeave']);
    //get navigation events and actions
    settings.navigationEvents = {};
    var navigationEventNodes = xml.selectNodes('settings/navigation/event');
    for( var i=0; i<navigationEventNodes.length; i++ )
    {
        var e = new ExamEvent(navigationEventNodes[i]);
        settings.navigationEvents[e.type] = e;
    }
    tryGetAttribute(settings,xml,'settings/timing',['duration','allowPause']);
    //get text representation of exam duration
    this.displayDuration = settings.duration>0 ? Numbas.timing.secsToDisplayTime( settings.duration ) : '';
    //get timing events
    settings.timerEvents = {};
    var timerEventNodes = this.xml.selectNodes('settings/timing/event');
    for( i=0; i<timerEventNodes.length; i++ )
    {
        var e = new ExamEvent(timerEventNodes[i]);
        settings.timerEvents[e.type] = e;
    }
    //feedback
    var feedbackPath = 'settings/feedback';
    tryGetAttribute(settings,xml,feedbackPath,['showactualmark','showtotalmark','showanswerstate','allowrevealanswer','showStudentName'],['showActualMark','showTotalMark','showAnswerState','allowRevealAnswer','showStudentName']);
    var serializer = new XMLSerializer();
    var isEmpty = Numbas.xml.isEmpty;
    var introNode = this.xml.selectSingleNode(feedbackPath+'/intro/content/span');
    this.hasIntro = !isEmpty(introNode);
    this.introMessage = this.hasIntro ? serializer.serializeToString(introNode) : '';
    var feedbackMessageNodes = this.xml.selectNodes(feedbackPath+'/feedbackmessages/feedbackmessage');
    this.feedbackMessages = [];
    for(var i=0;i<feedbackMessageNodes.length;i++) {
        var feedbackMessageNode = feedbackMessageNodes[i];
        var feedbackMessage = {threshold: 0, message: ''};
        feedbackMessage.message = serializer.serializeToString(feedbackMessageNode.selectSingleNode('content/span'));
        tryGetAttribute(feedbackMessage,null,feedbackMessageNode,['threshold']);
        this.feedbackMessages.push(feedbackMessage);
    }
    this.feedbackMessages.sort(function(a,b){ var ta = a.threshold, tb = b.threshold; return ta>tb ? 1 : ta<tb ? -1 : 0});
    var scope = new Numbas.jme.Scope(Numbas.jme.builtinScope);
    for(var extension in Numbas.extensions) {
        if('scope' in Numbas.extensions[extension]) {
            scope = new Numbas.jme.Scope([scope,Numbas.extensions[extension].scope]);
        }
    }
    scope = new Numbas.jme.Scope([scope,{functions: Numbas.jme.variables.makeFunctions(this.xml,this.scope)}]);
    this.scope = scope;
    //rulesets
    var rulesetNodes = xml.selectNodes('settings/rulesets/set');
    var sets = {};
    for( i=0; i<rulesetNodes.length; i++)
    {
        var name = rulesetNodes[i].getAttribute('name');
        var set = [];
        //get new rule definitions
        defNodes = rulesetNodes[i].selectNodes('ruledef');
        for( var j=0; j<defNodes.length; j++ )
        {
            var pattern = defNodes[j].getAttribute('pattern');
            var result = defNodes[j].getAttribute('result');
            var conditions = [];
            var conditionNodes = defNodes[j].selectNodes('conditions/condition');
            for(var k=0; k<conditionNodes.length; k++)
            {
                conditions.push(Numbas.xml.getTextContent(conditionNodes[k]));
            }
            var rule = new Numbas.jme.display.Rule(pattern,conditions,result);
            set.push(rule);
        }
        //get included sets
        var includeNodes = rulesetNodes[i].selectNodes('include');
        for(var j=0; j<includeNodes.length; j++ )
        {
            set.push(includeNodes[j].getAttribute('name'));
        }
        sets[name] = this.scope.rulesets[name] = set;
    }
    for(var name in sets)
    {
        this.scope.rulesets[name] = Numbas.jme.collectRuleset(sets[name],this.scope.allRulesets());
    }
    // question groups
    tryGetAttribute(settings,xml,'question_groups',['showQuestionGroupNames']);
    var groupNodes = this.xml.selectNodes('question_groups/question_group');
    this.question_groups = [];
    for(var i=0;i<groupNodes.length;i++) {
        this.question_groups.push(new QuestionGroup(this,groupNodes[i]));
    }
    //initialise display
    this.display = new Numbas.display.ExamDisplay(this);
}
Numbas.Exam = Exam;

/** The question list has been initialised - every question is loaded and ready to use.
 * @event Numbas.Exam#question list initialised
 */

Exam.prototype = /** @lends Numbas.Exam.prototype */ {
    /** Signals produced while loading this exam.
     * @type {Numbas.schedule.SignalBox} 
     * */
    signals: undefined,

    /** Storage engine
     * @type {Numbas.storage.BlankStorage}
     */
    store: undefined,
    /** Settings
     * @property {String} name - Title of exam
     * @property {Number} percentPass - Percentage of max. score student must achieve to pass
     * @property {Boolean} shuffleQuestions - should the questions be shuffled?
     * @property {Number} numQuestions - number of questions in this sitting
     * @property {Boolean} preventLeave - prevent the browser from leaving the page while the exam is running?
     * @property {Boolean} allowRegen -can student re-randomise a question?
     * @property {Boolean} navigateReverse - can student navigate to previous question?
     * @property {Boolean} navigateBrowse - can student jump to any question they like?
     * @property {Boolean} showFrontPage - show the frontpage before starting the exam?
     * @property {Boolean} showResultsPage - show the results page after finishing the exam?
     * @property {Array.<Object.<Numbas.ExamEvent>>} navigationEvents - checks to perform when doing certain navigation action
     * @property {Array.<Object.<Numbas.ExamEvent>>} timerEvents - events based on timing
     * @property {Number} duration - how long is exam? (seconds)
     * @property {Boolean} allowPause - can the student suspend the timer with the pause button or by leaving?
     * @property {Boolean} showActualMark - show current score?
     * @property {Boolean} showTotalMark - show total marks in exam?
     * @property {Boolean} showAnswerState - tell student if answer is correct/wrong/partial?
     * @property {Boolean} allowRevealAnswer - allow 'reveal answer' button?
     * @property {Boolean} showQuestionGroupNames - show the names of question groups?
     * @memberof Numbas.Exam.prototype
     * @instance
     */
    settings: {
        name: '',
        percentPass: 0,
        shuffleQuestions: false,
        numQuestions: 0,
        preventLeave: true,
        allowRegen: false,
        navigateReverse: false,
        navigateBrowse: false,
        showFrontPage: true,
        showResultsPage: true,
        navigationEvents: {},
        timerEvents: {},
        duration: 0,
        allowPause: false,
        showActualMark: false,
        showTotalMark: false,
        showAnswerState: false,
        allowRevealAnswer: false,
        showQuestionGroupNames: false,
        showStudentName: true
    },
    /** Base node of exam XML
     * @type Element
     */
    xml: undefined,
    /**
     * Can be
     *  * `"normal"` - Student is currently sitting the exam
     *  * `"review"` - Student is reviewing a completed exam
     *  @type String
     */
    mode: 'normal',
    /** Total marks available in the exam
     * @type Number
     */
    mark: 0,
    /** Student's current score
     * @type Number
     */
    score: 0,                    //student's current score
    /** Student's score as a percentage
     * @type Number
     */
    percentScore: 0,
    /** Did the student pass the exam?
     * @type Boolean
     */
    passed: false,                //did student pass the exam?
    /** Student's name
     * @type String
     */
    student_name: undefined,
    /** Student's ID
     * @type String
     */
    student_id: undefined,
    /** JME evaluation environment
     *
     * Contains variables, rulesets and functions defined by the exam and by extensions.
     *
     * Inherited by each {@link Numbas.Question}'s scope.
     * @type Numbas.jme.Scope
     */
    scope: undefined,
    /** Number of the current question
     * @type Number
     */
    currentQuestionNumber: 0,
    /**
     * Object representing the current question.
     * @type Numbas.Question
     */
    currentQuestion: undefined,
    /** Groups of questions in the exam
     * @type Array.<Numbas.QuestionGroup>
     */
    question_groups: [],
    /**
     * Which questions are used?
     * @type Number[]
     */
    questionSubset: [],
    /**
     * Question objects, in the order the student will see them
     * @type Array.<Numbas.Question>
     */
    questionList: [],
    /** Exam duration in `h:m:s` format
     * @type String
     */
    displayDuration: '',
    /** Stopwatch object - updates the timer every second.
     * @property {Date} start
     * @property {Date} end
     * @property {Number} oldTimeSpent - `timeSpent` when the stopwatch was last updated
     * @property {Number} id - id of the `Interval` which calls {@link Numbas.Exam#countDown}
     */
    stopwatch: undefined,
    /** Time that the exam should stop
     * @type Date
     */
    endTime: undefined,
    /** Seconds until the end of the exam
     * @type Number
     */
    timeRemaining: 0,
    /** Seconds the exam has been in progress
     * @type Number
     */
    timeSpent: 0,
    /** Is the exam in progress?
     *
     * `false` before starting, when paused, and after ending.
     * @type Boolean
     */
    inProgress: false,
    /** Time the exam started
     * @type Date
     */
    start: Date(),
    /** Time the exam finished
     * @type null|Date
     */
    stop: null,
    /* Display object for this exam
     * @type Numbas.display.ExamDisplay
     */
    display: undefined,
    /** Stuff to do when starting exam afresh, before showing the front page.
     * @fires Numbas.Exam#event:ready
     */
    init: function()
    {
        var exam = this;
        var variablesTodo = Numbas.xml.loadVariables(exam.xml,exam.scope);
        var result = Numbas.jme.variables.makeVariables(variablesTodo,exam.scope);
        exam.scope.variables = result.variables;
        job(exam.chooseQuestionSubset,exam);            //choose questions to use
        job(exam.makeQuestionList,exam);                //create question objects
        exam.signals.on('question list initialised', function() {
            if(exam.store) {
                job(exam.store.init,exam.store,exam);        //initialise storage
                job(exam.store.save,exam.store);            //make sure data get saved to LMS
            }
            exam.signals.trigger('ready');
        });
    },
    /** Restore previously started exam from storage 
     * @fires Numbas.Exam#event:ready
     * @listens Numbas.Exam#event:question list initialised
     */
    load: function() {
        var exam = this;
        if(!this.store) {
            return;
        }
        this.loading = true;
        var suspendData = this.store.load(this);    //get saved info from storage
        job(function() {
            var e = this;
            var numQuestions = 0;
            suspendData.questionSubsets.forEach(function(subset,i) {
                e.question_groups[i].questionSubset = subset;
                numQuestions += subset.length;
            });
            this.settings.numQuestions = numQuestions;
            this.start = new Date(suspendData.start);
            if(suspendData.stop) {
                this.stop = suspendData.stop
            }
            if(this.settings.allowPause) {
                this.timeSpent = suspendData.timeSpent;
                this.timeRemaining = this.settings.duration - (suspendData.duration-suspendData.timeRemaining);
            }
            else {
                this.endTime = new Date(this.start.getTime()+this.settings.duration*1000);
                this.timeRemaining = (this.endTime - new Date())/1000;
            }
            this.score = suspendData.score;
        },this);
        job(this.makeQuestionList,this,true);
        exam.signals.on('question list initialised', function() {
            if(suspendData.currentQuestion!==undefined)
                exam.changeQuestion(suspendData.currentQuestion);
            exam.loading = false;
            exam.calculateScore();
            exam.signals.trigger('ready');
        });
    },
    /** Decide which questions to use and in what order
     * @see Numbas.QuestionGroup#chooseQuestionSubset
     */
    chooseQuestionSubset: function()
    {
        var numQuestions = 0;
        this.question_groups.forEach(function(group) {
            group.chooseQuestionSubset();
            numQuestions += group.questionSubset.length;
        });
        this.settings.numQuestions = numQuestions;
        if(numQuestions==0) {
            throw(new Numbas.Error('exam.changeQuestion.no questions'));
        }
    },
    /**
     * Having chosen which questions to use, make question list and create question objects
     *
     * If loading, need to restore randomised variables instead of generating anew
     *
     * @param {Boolean} lo
     * @fires Numbas.Exam#event:question list initialised
     * @listens Numbas.Question#event:ready
     * @listens Numbas.Question#event:HTMLAttached
     */
    makeQuestionList: function(loading)
    {
        var exam = this;
        this.questionList = [];
        var questionAcc = 0;
        this.question_groups.forEach(function(group) {
            group.questionList = [];
            var questionNodes = group.xml.selectNodes("questions/question");
            group.questionSubset.forEach(function(n) {
                job(function(n) {
                var question = Numbas.createQuestionFromXML( questionNodes[n], questionAcc++, exam, group, exam.scope, exam.store);
                    if(loading) {
                        question.resume();
                    } else {
                        question.generateVariables();
                    }
                    exam.questionList.push(question);
                    group.questionList.push(question);
                },group,n);
            });
        });
        job(function() {
            Promise.all(exam.questionList.map(function(q){ return q.signals.on(['ready','HTMLAttached']) })).then(function() {
                exam.settings.numQuestions = exam.questionList.length;
                //register questions with exam display
                exam.display.initQuestionList();
                //calculate max marks available in exam
                exam.mark = 0;
                //go through the questions and recalculate the part scores, then the question scores, then the exam score
                for( i=0; i<exam.settings.numQuestions; i++ )
                {
                    exam.mark += exam.questionList[i].marks;
                }
                exam.signals.trigger('question list initialised');
            }).catch(function(e) {
                Numbas.schedule.halt(e);
            });
        });
        if(loading) {
            job(function() {
                this.updateScore();
            },this);
        }
    },
    /**
     * Show the given info page
     * @param {String} page - Name of the page to show
     */
    showInfoPage: function(page) {
        if(this.currentQuestion)
            this.currentQuestion.leave();
        this.display.showInfoPage(page);
    },
    /**
     * Begin the exam - start timing, go to the first question
     */
    begin: function()
    {
        this.start = new Date();        //make a note of when the exam was started
        this.endTime = new Date(this.start.getTime()+this.settings.duration*1000);    //work out when the exam should end
        this.timeRemaining = this.settings.duration;
        this.changeQuestion(0);            //start at the first question!
        this.updateScore();                //initialise score
        //set countdown going
        if(this.mode!='review')
            this.startTiming();
        this.display.showQuestion();    //display the current question
    },
    /**
     * Pause the exam, and show the `suspend` page
     */
    pause: function()
    {
        this.endTiming();
        this.display.showInfoPage('suspend');
        this.store && this.store.pause();
    },
    /**
     * Resume the exam
     */
    resume: function()
    {
        this.startTiming();
        this.display.showQuestion();
    },
    /**
     * Set the stopwatch going
     */
    startTiming: function()
    {
        this.inProgress = true;
        this.stopwatch = {
            start: new Date(),
            end: new Date((new Date()).getTime() + this.timeRemaining*1000),
            oldTimeSpent: this.timeSpent,
            id: setInterval(function(){exam.countDown();}, 1000)
        };
        if( this.settings.duration > 0 )
            this.display.showTiming();
        else
            this.display.hideTiming();
        var exam = this;
        this.countDown();
    },
    /**
     * Calculate time remaining and end the exam when timer reaches zero
     */
    countDown: function()
    {
        var t = new Date();
        this.timeSpent = this.stopwatch.oldTimeSpent + (t - this.stopwatch.start)/1000;
        if(this.settings.duration > 0)
        {
            this.timeRemaining = Math.ceil((this.stopwatch.end - t)/1000);
            this.display.showTiming();
            if(this.settings.duration > 300 && this.timeRemaining<300 && !this.showedTimeWarning)
            {
                this.showedTimeWarning = true;
                var e = this.settings.timerEvents['timedwarning'];
                if(e && e.action=='warn')
                {
                    Numbas.display.showAlert(e.message);
                }
            }
            else if(this.timeRemaining<=0)
            {
                var e = this.settings.timerEvents['timeout'];
                if(e && e.action=='warn')
                {
                    Numbas.display.showAlert(e.message);
                }
                this.end(true);
            }
        }
    },
    /** Stop the stopwatch */
    endTiming: function()
    {
        this.inProgress = false;
        clearInterval( this.stopwatch.id );
    },
    /** Recalculate and display the student's total score.
     * @see Numbas.Exam#calculateScore
     */
    updateScore: function()
    {
        this.calculateScore();
        this.display.showScore();
        this.store && this.store.saveExam(this);
    },
    /** Calculate the student's score */
    calculateScore: function()
    {
        this.score=0;
        for(var i=0; i<this.questionList.length; i++)
            this.score += this.questionList[i].score;
        this.percentScore = this.mark>0 ? Math.round(100*this.score/this.mark) : 0;
    },
    /**
     * Call this when student wants to move between questions.
     *
     * Will check move is allowed and if so change question and update display
     *
     * @param {Number} i - Number of the question to move to
     * @see Numbas.Exam#changeQuestion
     */
    tryChangeQuestion: function(i)
    {
        if(i<0 || i>=this.settings.numQuestions)
            return;
        if( ! (this.settings.navigateBrowse     // is browse navigation enabled?
            || (this.questionList[i].visited && this.settings.navigateReverse)    // if not, we can still move backwards to questions already seen if reverse navigation is enabled
            || (i>this.currentQuestion.number && this.questionList[i-1].visited)    // or you can always move to the next question
        ))
        {
            return;
        }
        var currentQuestion = this.currentQuestion;
        if(!currentQuestion)
            return;
        if(i==currentQuestion.number)
            return;
        var exam = this;
        function go()
        {
            exam.changeQuestion(i);
            exam.display.showQuestion();
        }
        if(currentQuestion.leavingDirtyQuestion()) {
        }
        else if(currentQuestion.answered || currentQuestion.revealed || currentQuestion.marks==0)
        {
            go();
        }
        else
        {
            var eventObj = this.settings.navigationEvents.onleave;
            switch( eventObj.action )
            {
            case 'none':
                go();
                break;
            case 'warnifunattempted':
                Numbas.display.showConfirm(eventObj.message+'<p>'+R('control.proceed anyway')+'</p>',go);
                break;
            case 'preventifunattempted':
                Numbas.display.showAlert(eventObj.message);
                break;
            }
        }
    },
    /**
     * Change the current question. Student's can't trigger this without going through {@link Numbas.Exam#tryChangeQuestion}
     *
     * @param {Number} i - Number of the question to move to
     */
    changeQuestion: function(i)
    {
        if(this.currentQuestion) {
            this.currentQuestion.leave();
        }
        this.currentQuestion = this.questionList[i];
        if(!this.currentQuestion)
        {
            throw(new Numbas.Error('exam.changeQuestion.no questions'));
        }
        this.currentQuestion.visited = true;
        this.store && this.store.changeQuestion(this.currentQuestion);
    },
    /**
     * Show a question in review mode
     *
     * @param {Number} i - Number of the question to show
     */
    reviewQuestion: function(i) {
        this.changeQuestion(i);
        this.display.showQuestion();
    },
    /**
     * Regenerate the current question
     * @listens Numbas.Question#event:ready
     * @listens Numbas.Question#event:HTMLAttached
     */
    regenQuestion: function()
    {
        var e = this;
        var oq = e.currentQuestion;
        var n = oq.number;
        var group = oq.group
        var n_in_group = group.questionList.indexOf(oq);
        e.display.startRegen();
        var q = Numbas.createQuestionFromXML(oq.originalXML, oq.number, e, oq.group, e.scope);
        q.generateVariables();
        q.signals.on('ready',function() {
            e.questionList[n] = group.questionList[n_in_group] = q;
            e.changeQuestion(n);
        });
        q.signals.on(['ready','HTMLAttached'], function() {
            e.currentQuestion.display.init();
            e.display.showQuestion();
            e.display.endRegen();
        });
    },
    /**
     * Try to end the exam - shows confirmation dialog, and checks that all answers have been submitted.
     * @see Numbas.Exam#end
     */
    tryEnd: function() {
        var message = R('control.confirm end');
        var answeredAll = true;
        var submittedAll = true;
        for(var i=0;i<this.questionList.length;i++) {
            if(!this.questionList[i].answered) {
                answeredAll = false;
                break;
            }
            if(this.questionList[i].isDirty()) {
                submittedAll = false;
            }
        }
        if(this.currentQuestion.leavingDirtyQuestion())
            return;
        if(!answeredAll) {
            message = R('control.not all questions answered') + '<br/>' + message;
        }
        else if(!submittedAll) {
            message = R('control.not all questions submitted') + '<br/>' + message;
        }
        Numbas.display.showConfirm(
            message,
            function() {
                job(Numbas.exam.end,Numbas.exam,true);
            }
        );
    },
    /**
     * End the exam. The student can't directly trigger this without going through {@link Numbas.Exam#tryEnd}
     */
    end: function(save)
    {
        this.mode = 'review';
        //work out summary info
        this.passed = (this.percentScore >= this.settings.percentPass*100);
        this.result = R(this.passed ? 'exam.passed' :'exam.failed')
        var percentScore = this.percentScore;
        this.feedbackMessage = null;
        for(var i=0;i<this.feedbackMessages.length;i++) {
            if(percentScore>=this.feedbackMessages[i].threshold) {
                this.feedbackMessage = this.feedbackMessages[i].message;
            } else {
                break;
            }
        }
        if(save) {
            //get time of finish
            this.stop = new Date();
            //stop the stopwatch
            this.endTiming();
            //send result to LMS, and tell it we're finished
            this.store && this.store.end();
        }
        this.display.end();
        for(var i=0;i<this.questionList.length;i++) {
            this.questionList[i].revealAnswer(true);
        }
        //display the results
        if(this.settings.showResultsPage) {
            this.display.showInfoPage( 'result' );
        } else {
            this.exit();
        }
    },
    /**
     * Exit the exam - show the `exit` page
     */
    exit: function()
    {
        this.display.showInfoPage('exit');
    }
};
/** Represents what should happen when a particular timing or navigation event happens
 * @param Element eventNode - XML to load settings from
 * @constructor
 * @memberof Numbas
 */
function ExamEvent(eventNode)
{
    var tryGetAttribute = Numbas.xml.tryGetAttribute;
    tryGetAttribute(this,null,eventNode,['type','action']);
    this.message = Numbas.xml.serializeMessage(eventNode);
}
ExamEvent.prototype = /** @lends Numbas.ExamEvent.prototype */ {
    /** Name of the event this corresponds to
     *
     * Navigation events:
     * * `onleave` - the student tries to move to another question without answering the current one.
     *
     * (there used to be more, but now they're all the same one)
     *
     * Timer events:
     * * `timedwarning` - Five minutes until the exam ends.
     * * `timeout` - There's no time left; the exam is over.
     * @memberof Numbas.ExamEvent
     * @instance
     * @type String
     */
    type: '',
    /** Action to take when the event happens.
     *
     * Choices for timer events:
     * * `none` - don't do anything
     * * `warn` - show a message
     *
     * Choices for navigation events:
     * * `none` - just allow the navigation
     * * `warnifunattempted` - Show a warning but allow the student to continue.
     * * `preventifunattempted` - Show a warning but allow the student to continue.
     * @memberof Numbas.ExamEvent
     * @instance
     * @type String
     */
    action: 'none',
    /** Message to show the student when the event happens.
     * @memberof Numbas.ExamEvent
     * @instance
     * @type String
     */
    message: ''
};
/** Represents a group of questions
 *
 * @constructor
 * @property {Numbas.Exam} exam - the exam this group belongs to
 * @property {Element} xml
 * @property {Array.<Number>} questionSubset - the indices of the picked questions, in the order they should appear to the student
 * @property {Array.<Numbas.Question>} questionList
 * @memberof Numbas
 */
function QuestionGroup(exam, groupNode) {
    this.exam = exam;
    this.xml = groupNode;
    this.settings = util.copyobj(this.settings);
    Numbas.xml.tryGetAttribute(this.settings,this.xml,'.',['name','pickingStrategy','pickQuestions']);
}
QuestionGroup.prototype = {
    /** Settings for this group
     * @property {String} name
     * @property {String} pickingStrategy - how to pick the list of questions: 'all-ordered', 'all-shuffled' or 'random-subset'
     * @property {Number} pickQuestions - if `pickingStrategy` is 'random-subset', how many questions to pick
     */
    settings: {
        name: '',
        pickingStrategy: 'all-ordered',
        pickQuestions: 1
    },
    /** Decide which questions to use and in what order */
    chooseQuestionSubset: function() {
        var questionNodes = this.xml.selectNodes('questions/question');
        var numQuestions = questionNodes.length;
        switch(this.settings.pickingStrategy) {
            case 'all-ordered':
                this.questionSubset = Numbas.math.range(numQuestions);
                break;
            case 'all-shuffled':
                this.questionSubset = Numbas.math.deal(numQuestions);
                break;
            case 'random-subset':
                this.questionSubset = Numbas.math.deal(numQuestions).slice(0,this.settings.pickQuestions);
                break;
        }
    }
}
});

Numbas.queueScript('i18next',[],function(module) {
        var exports = {};
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.i18next=e()}(this,function(){"use strict";function t(t){return null==t?"":""+t}function e(t,e,n){t.forEach(function(t){e[t]&&(n[t]=e[t])})}function n(t,e,n){function o(t){return t&&t.indexOf("###")>-1?t.replace(/###/g,"."):t}function r(){return!t||"string"==typeof t}for(var i="string"!=typeof e?[].concat(e):e.split(".");i.length>1;){if(r())return{};var a=o(i.shift());!t[a]&&n&&(t[a]=new n),t=t[a]}return r()?{}:{obj:t,k:o(i.shift())}}function o(t,e,o){var r=n(t,e,Object),i=r.obj,a=r.k;i[a]=o}function r(t,e,o,r){var i=n(t,e,Object),a=i.obj,s=i.k;a[s]=a[s]||[],r&&(a[s]=a[s].concat(o)),r||a[s].push(o)}function i(t,e){var o=n(t,e),r=o.obj,i=o.k;if(r)return r[i]}function a(t,e,n){for(var o in e)o in t?"string"==typeof t[o]||t[o]instanceof String||"string"==typeof e[o]||e[o]instanceof String?n&&(t[o]=e[o]):a(t[o],e[o],n):t[o]=e[o];return t}function s(t){return t.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&")}function l(t){return"string"==typeof t?t.replace(/[&<>"'\/]/g,function(t){return E[t]}):t}function u(t){return t.interpolation={unescapeSuffix:"HTML"},t.interpolation.prefix=t.interpolationPrefix||"__",t.interpolation.suffix=t.interpolationSuffix||"__",t.interpolation.escapeValue=t.escapeInterpolation||!1,t.interpolation.nestingPrefix=t.reusePrefix||"$t(",t.interpolation.nestingSuffix=t.reuseSuffix||")",t}function c(t){return t.resStore&&(t.resources=t.resStore),t.ns&&t.ns.defaultNs?(t.defaultNS=t.ns.defaultNs,t.ns=t.ns.namespaces):t.defaultNS=t.ns||"translation",t.fallbackToDefaultNS&&t.defaultNS&&(t.fallbackNS=t.defaultNS),t.saveMissing=t.sendMissing,t.saveMissingTo=t.sendMissingTo||"current",t.returnNull=!t.fallbackOnNull,t.returnEmptyString=!t.fallbackOnEmpty,t.returnObjects=t.returnObjectTrees,t.joinArrays="\n",t.returnedObjectHandler=t.objectTreeKeyHandler,t.parseMissingKeyHandler=t.parseMissingKey,t.appendNamespaceToMissingKey=!0,t.nsSeparator=t.nsseparator||":",t.keySeparator=t.keyseparator||".","sprintf"===t.shortcutFunction&&(t.overloadTranslationOptionHandler=function(t){for(var e=[],n=1;n<t.length;n++)e.push(t[n]);return{postProcess:"sprintf",sprintf:e}}),t.whitelist=t.lngWhitelist,t.preload=t.preload,"current"===t.load&&(t.load="currentOnly"),"unspecific"===t.load&&(t.load="languageOnly"),t.backend=t.backend||{},t.backend.loadPath=t.resGetPath||"locales/__lng__/__ns__.json",t.backend.addPath=t.resPostPath||"locales/add/__lng__/__ns__",t.backend.allowMultiLoading=t.dynamicLoad,t.cache=t.cache||{},t.cache.prefix="res_",t.cache.expirationTime=6048e5,t.cache.enabled=t.useLocalStorage,t=u(t),t.defaultVariables&&(t.interpolation.defaultVariables=t.defaultVariables),t}function p(t){return t=u(t),t.joinArrays="\n",t}function f(t){return(t.interpolationPrefix||t.interpolationSuffix||void 0!==t.escapeInterpolation)&&(t=u(t)),t.nsSeparator=t.nsseparator,t.keySeparator=t.keyseparator,t.returnObjects=t.returnObjectTrees,t}function g(t){t.lng=function(){return C.deprecate("i18next.lng() can be replaced by i18next.language for detected language or i18next.languages for languages ordered by translation lookup."),t.services.languageUtils.toResolveHierarchy(t.language)[0]},t.preload=function(e,n){C.deprecate("i18next.preload() can be replaced with i18next.loadLanguages()"),t.loadLanguages(e,n)},t.setLng=function(e,n,o){return C.deprecate("i18next.setLng() can be replaced with i18next.changeLanguage() or i18next.getFixedT() to get a translation function with fixed language or namespace."),"function"==typeof n&&(o=n,n={}),n||(n={}),n.fixLng===!0&&o?o(null,t.getFixedT(e)):t.changeLanguage(e,o)},t.addPostProcessor=function(e,n){C.deprecate("i18next.addPostProcessor() can be replaced by i18next.use({ type: 'postProcessor', name: 'name', process: fc })"),t.use({type:"postProcessor",name:e,process:n})}}function h(t){return t.charAt(0).toUpperCase()+t.slice(1)}function d(){var t={};return H.forEach(function(e){e.lngs.forEach(function(n){t[n]={numbers:e.nr,plurals:U[e.fc]}})}),t}function y(t,e){for(var n=t.indexOf(e);n!==-1;)t.splice(n,1),n=t.indexOf(e)}function v(){return{debug:!1,initImmediate:!0,ns:["translation"],defaultNS:["translation"],fallbackLng:["dev"],fallbackNS:!1,whitelist:!1,nonExplicitWhitelist:!1,load:"all",preload:!1,simplifyPluralSuffix:!0,keySeparator:".",nsSeparator:":",pluralSeparator:"_",contextSeparator:"_",saveMissing:!1,saveMissingTo:"fallback",missingKeyHandler:!1,postProcess:!1,returnNull:!0,returnEmptyString:!0,returnObjects:!1,joinArrays:!1,returnedObjectHandler:function(){},parseMissingKeyHandler:!1,appendNamespaceToMissingKey:!1,appendNamespaceToCIMode:!1,overloadTranslationOptionHandler:function(t){return{defaultValue:t[1]}},interpolation:{escapeValue:!0,format:function(t,e,n){return t},prefix:"{{",suffix:"}}",formatSeparator:",",unescapePrefix:"-",nestingPrefix:"$t(",nestingSuffix:")",defaultVariables:void 0}}}function b(t){return"string"==typeof t.ns&&(t.ns=[t.ns]),"string"==typeof t.fallbackLng&&(t.fallbackLng=[t.fallbackLng]),"string"==typeof t.fallbackNS&&(t.fallbackNS=[t.fallbackNS]),t.whitelist&&t.whitelist.indexOf("cimode")<0&&t.whitelist.push("cimode"),t}function m(){}var x="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},S=function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")},k=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(t[o]=n[o])}return t},w=function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)},O=function(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e},L=function(){function t(t,e){var n=[],o=!0,r=!1,i=void 0;try{for(var a,s=t[Symbol.iterator]();!(o=(a=s.next()).done)&&(n.push(a.value),!e||n.length!==e);o=!0);}catch(t){r=!0,i=t}finally{try{!o&&s.return&&s.return()}finally{if(r)throw i}}return n}return function(e,n){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return t(e,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),j=function(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++)n[e]=t[e];return n}return Array.from(t)},N={type:"logger",log:function(t){this.output("log",t)},warn:function(t){this.output("warn",t)},error:function(t){this.output("error",t)},output:function(t,e){var n;console&&console[t]&&(n=console)[t].apply(n,j(e))}},P=function(){function t(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};S(this,t),this.init(e,n)}return t.prototype.init=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.prefix=e.prefix||"i18next:",this.logger=t||N,this.options=e,this.debug=e.debug},t.prototype.setDebug=function(t){this.debug=t},t.prototype.log=function(){for(var t=arguments.length,e=Array(t),n=0;n<t;n++)e[n]=arguments[n];return this.forward(e,"log","",!0)},t.prototype.warn=function(){for(var t=arguments.length,e=Array(t),n=0;n<t;n++)e[n]=arguments[n];return this.forward(e,"warn","",!0)},t.prototype.error=function(){for(var t=arguments.length,e=Array(t),n=0;n<t;n++)e[n]=arguments[n];return this.forward(e,"error","")},t.prototype.deprecate=function(){for(var t=arguments.length,e=Array(t),n=0;n<t;n++)e[n]=arguments[n];return this.forward(e,"warn","WARNING DEPRECATED: ",!0)},t.prototype.forward=function(t,e,n,o){return o&&!this.debug?null:("string"==typeof t[0]&&(t[0]=""+n+this.prefix+" "+t[0]),this.logger[e](t))},t.prototype.create=function(e){return new t(this.logger,k({prefix:this.prefix+":"+e+":"},this.options))},t}(),C=new P,R=function(){function t(){S(this,t),this.observers={}}return t.prototype.on=function(t,e){var n=this;t.split(" ").forEach(function(t){n.observers[t]=n.observers[t]||[],n.observers[t].push(e)})},t.prototype.off=function(t,e){var n=this;this.observers[t]&&this.observers[t].forEach(function(){if(e){var o=n.observers[t].indexOf(e);o>-1&&n.observers[t].splice(o,1)}else delete n.observers[t]})},t.prototype.emit=function(t){for(var e=arguments.length,n=Array(e>1?e-1:0),o=1;o<e;o++)n[o-1]=arguments[o];if(this.observers[t]){var r=[].concat(this.observers[t]);r.forEach(function(t){t.apply(void 0,n)})}if(this.observers["*"]){var i=[].concat(this.observers["*"]);i.forEach(function(e){var o;e.apply(e,(o=[t]).concat.apply(o,n))})}},t}(),E={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","/":"&#x2F;"},A=function(t){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{ns:["translation"],defaultNS:"translation"};S(this,e);var r=O(this,t.call(this));return r.data=n,r.options=o,r}return w(e,t),e.prototype.addNamespaces=function(t){this.options.ns.indexOf(t)<0&&this.options.ns.push(t)},e.prototype.removeNamespaces=function(t){var e=this.options.ns.indexOf(t);e>-1&&this.options.ns.splice(e,1)},e.prototype.getResource=function(t,e,n){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},r=o.keySeparator||this.options.keySeparator;void 0===r&&(r=".");var a=[t,e];return n&&"string"!=typeof n&&(a=a.concat(n)),n&&"string"==typeof n&&(a=a.concat(r?n.split(r):n)),t.indexOf(".")>-1&&(a=t.split(".")),i(this.data,a)},e.prototype.addResource=function(t,e,n,r){var i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{silent:!1},a=this.options.keySeparator;void 0===a&&(a=".");var s=[t,e];n&&(s=s.concat(a?n.split(a):n)),t.indexOf(".")>-1&&(s=t.split("."),r=e,e=s[1]),this.addNamespaces(e),o(this.data,s,r),i.silent||this.emit("added",t,e,n,r)},e.prototype.addResources=function(t,e,n){for(var o in n)"string"==typeof n[o]&&this.addResource(t,e,o,n[o],{silent:!0});this.emit("added",t,e,n)},e.prototype.addResourceBundle=function(t,e,n,r,s){var l=[t,e];t.indexOf(".")>-1&&(l=t.split("."),r=n,n=e,e=l[1]),this.addNamespaces(e);var u=i(this.data,l)||{};r?a(u,n,s):u=k({},u,n),o(this.data,l,u),this.emit("added",t,e,n)},e.prototype.removeResourceBundle=function(t,e){this.hasResourceBundle(t,e)&&delete this.data[t][e],this.removeNamespaces(e),this.emit("removed",t,e)},e.prototype.hasResourceBundle=function(t,e){return void 0!==this.getResource(t,e)},e.prototype.getResourceBundle=function(t,e){return e||(e=this.options.defaultNS),"v1"===this.options.compatibilityAPI?k({},this.getResource(t,e)):this.getResource(t,e)},e.prototype.toJSON=function(){return this.data},e}(R),T={processors:{},addPostProcessor:function(t){this.processors[t.name]=t},handle:function(t,e,n,o,r){var i=this;return t.forEach(function(t){i.processors[t]&&(e=i.processors[t].process(e,n,o,r))}),e}},M=function(t){function n(o){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};S(this,n);var i=O(this,t.call(this));return e(["resourceStore","languageUtils","pluralResolver","interpolator","backendConnector"],o,i),i.options=r,i.logger=C.create("translator"),i}return w(n,t),n.prototype.changeLanguage=function(t){t&&(this.language=t)},n.prototype.exists=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{interpolation:{}};return"v1"===this.options.compatibilityAPI&&(e=f(e)),void 0!==this.resolve(t,e)},n.prototype.extractFromKey=function(t,e){var n=e.nsSeparator||this.options.nsSeparator;void 0===n&&(n=":");var o=e.keySeparator||this.options.keySeparator||".",r=e.ns||this.options.defaultNS;if(n&&t.indexOf(n)>-1){var i=t.split(n);(n!==o||n===o&&this.options.ns.indexOf(i[0])>-1)&&(r=i.shift()),t=i.join(o)}return"string"==typeof r&&(r=[r]),{key:t,namespaces:r}},n.prototype.translate=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("object"!==("undefined"==typeof e?"undefined":x(e))?e=this.options.overloadTranslationOptionHandler(arguments):"v1"===this.options.compatibilityAPI&&(e=f(e)),void 0===t||null===t||""===t)return"";"number"==typeof t&&(t=String(t)),"string"==typeof t&&(t=[t]);var n=e.keySeparator||this.options.keySeparator||".",o=this.extractFromKey(t[t.length-1],e),r=o.key,i=o.namespaces,a=i[i.length-1],s=e.lng||this.language,l=e.appendNamespaceToCIMode||this.options.appendNamespaceToCIMode;if(s&&"cimode"===s.toLowerCase()){if(l){var u=e.nsSeparator||this.options.nsSeparator;return a+u+r}return r}var c=this.resolve(t,e),p=Object.prototype.toString.apply(c),g=["[object Number]","[object Function]","[object RegExp]"],h=void 0!==e.joinArrays?e.joinArrays:this.options.joinArrays;if(c&&"string"!=typeof c&&g.indexOf(p)<0&&(!h||"[object Array]"!==p)){if(!e.returnObjects&&!this.options.returnObjects)return this.logger.warn("accessing an object - but returnObjects options is not enabled!"),this.options.returnedObjectHandler?this.options.returnedObjectHandler(r,c,e):"key '"+r+" ("+this.language+")' returned an object instead of string.";if(e.keySeparator||this.options.keySeparator){var d="[object Array]"===p?[]:{};for(var y in c)Object.prototype.hasOwnProperty.call(c,y)&&(d[y]=this.translate(""+r+n+y,k({},e,{joinArrays:!1,ns:i})));c=d}}else if(h&&"[object Array]"===p)c=c.join(h),c&&(c=this.extendTranslation(c,r,e));else{var v=!1,b=!1;if(this.isValidLookup(c)||void 0===e.defaultValue||(v=!0,c=e.defaultValue),this.isValidLookup(c)||(b=!0,c=r),b||v){this.logger.log("missingKey",s,a,r,c);var m=[],S=this.languageUtils.getFallbackCodes(this.options.fallbackLng,e.lng||this.language);if("fallback"===this.options.saveMissingTo&&S&&S[0])for(var w=0;w<S.length;w++)m.push(S[w]);else"all"===this.options.saveMissingTo?m=this.languageUtils.toResolveHierarchy(e.lng||this.language):m.push(e.lng||this.language);this.options.saveMissing&&(this.options.missingKeyHandler?this.options.missingKeyHandler(m,a,r,c):this.backendConnector&&this.backendConnector.saveMissing&&this.backendConnector.saveMissing(m,a,r,c)),this.emit("missingKey",m,a,r,c)}c=this.extendTranslation(c,r,e),b&&c===r&&this.options.appendNamespaceToMissingKey&&(c=a+":"+r),b&&this.options.parseMissingKeyHandler&&(c=this.options.parseMissingKeyHandler(c))}return c},n.prototype.extendTranslation=function(t,e,n){var o=this;n.interpolation&&this.interpolator.init(k({},n,{interpolation:k({},this.options.interpolation,n.interpolation)}));var r=n.replace&&"string"!=typeof n.replace?n.replace:n;this.options.interpolation.defaultVariables&&(r=k({},this.options.interpolation.defaultVariables,r)),t=this.interpolator.interpolate(t,r,n.lng||this.language),n.nest!==!1&&(t=this.interpolator.nest(t,function(){return o.translate.apply(o,arguments)},n)),n.interpolation&&this.interpolator.reset();var i=n.postProcess||this.options.postProcess,a="string"==typeof i?[i]:i;return void 0!==t&&a&&a.length&&n.applyPostProcessor!==!1&&(t=T.handle(a,t,e,n,this)),t},n.prototype.resolve=function(t){var e=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},o=void 0;return"string"==typeof t&&(t=[t]),t.forEach(function(t){if(!e.isValidLookup(o)){var r=e.extractFromKey(t,n),i=r.key,a=r.namespaces;e.options.fallbackNS&&(a=a.concat(e.options.fallbackNS));var s=void 0!==n.count&&"string"!=typeof n.count,l=void 0!==n.context&&"string"==typeof n.context&&""!==n.context,u=n.lngs?n.lngs:e.languageUtils.toResolveHierarchy(n.lng||e.language);a.forEach(function(t){e.isValidLookup(o)||u.forEach(function(r){if(!e.isValidLookup(o)){var a=i,u=[a],c=void 0;s&&(c=e.pluralResolver.getSuffix(r,n.count)),s&&l&&u.push(a+c),l&&u.push(a+=""+e.options.contextSeparator+n.context),s&&u.push(a+=c);for(var p=void 0;p=u.pop();)e.isValidLookup(o)||(o=e.getResource(r,t,p,n))}})})}}),o},n.prototype.isValidLookup=function(t){return!(void 0===t||!this.options.returnNull&&null===t||!this.options.returnEmptyString&&""===t)},n.prototype.getResource=function(t,e,n){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return this.resourceStore.getResource(t,e,n,o)},n}(R),_=function(){function t(e){S(this,t),this.options=e,this.whitelist=this.options.whitelist||!1,this.logger=C.create("languageUtils")}return t.prototype.getScriptPartFromCode=function(t){if(!t||t.indexOf("-")<0)return null;var e=t.split("-");return 2===e.length?null:(e.pop(),this.formatLanguageCode(e.join("-")))},t.prototype.getLanguagePartFromCode=function(t){if(!t||t.indexOf("-")<0)return t;var e=t.split("-");return this.formatLanguageCode(e[0])},t.prototype.formatLanguageCode=function(t){if("string"==typeof t&&t.indexOf("-")>-1){var e=["hans","hant","latn","cyrl","cans","mong","arab"],n=t.split("-");return this.options.lowerCaseLng?n=n.map(function(t){return t.toLowerCase()}):2===n.length?(n[0]=n[0].toLowerCase(),n[1]=n[1].toUpperCase(),e.indexOf(n[1].toLowerCase())>-1&&(n[1]=h(n[1].toLowerCase()))):3===n.length&&(n[0]=n[0].toLowerCase(),2===n[1].length&&(n[1]=n[1].toUpperCase()),"sgn"!==n[0]&&2===n[2].length&&(n[2]=n[2].toUpperCase()),e.indexOf(n[1].toLowerCase())>-1&&(n[1]=h(n[1].toLowerCase())),e.indexOf(n[2].toLowerCase())>-1&&(n[2]=h(n[2].toLowerCase()))),n.join("-")}return this.options.cleanCode||this.options.lowerCaseLng?t.toLowerCase():t},t.prototype.isWhitelisted=function(t){return("languageOnly"===this.options.load||this.options.nonExplicitWhitelist)&&(t=this.getLanguagePartFromCode(t)),!this.whitelist||!this.whitelist.length||this.whitelist.indexOf(t)>-1},t.prototype.getFallbackCodes=function(t,e){if(!t)return[];if("string"==typeof t&&(t=[t]),"[object Array]"===Object.prototype.toString.apply(t))return t;if(!e)return t.default||[];var n=t[e];return n||(n=t[this.getScriptPartFromCode(e)]),n||(n=t[this.formatLanguageCode(e)]),n||(n=t.default),n||[]},t.prototype.toResolveHierarchy=function(t,e){var n=this,o=this.getFallbackCodes(e||this.options.fallbackLng||[],t),r=[],i=function(t){t&&(n.isWhitelisted(t)?r.push(t):n.logger.warn("rejecting non-whitelisted language code: "+t))};return"string"==typeof t&&t.indexOf("-")>-1?("languageOnly"!==this.options.load&&i(this.formatLanguageCode(t)),"languageOnly"!==this.options.load&&"currentOnly"!==this.options.load&&i(this.getScriptPartFromCode(t)),"currentOnly"!==this.options.load&&i(this.getLanguagePartFromCode(t))):"string"==typeof t&&i(this.formatLanguageCode(t)),o.forEach(function(t){r.indexOf(t)<0&&i(n.formatLanguageCode(t))}),r},t}(),H=[{lngs:["ach","ak","am","arn","br","fil","gun","ln","mfe","mg","mi","oc","tg","ti","tr","uz","wa"],nr:[1,2],fc:1},{lngs:["af","an","ast","az","bg","bn","ca","da","de","dev","el","en","eo","es","es_ar","et","eu","fi","fo","fur","fy","gl","gu","ha","he","hi","hu","hy","ia","it","kn","ku","lb","mai","ml","mn","mr","nah","nap","nb","ne","nl","nn","no","nso","pa","pap","pms","ps","pt","pt_br","rm","sco","se","si","so","son","sq","sv","sw","ta","te","tk","ur","yo"],nr:[1,2],fc:2},{lngs:["ay","bo","cgg","fa","id","ja","jbo","ka","kk","km","ko","ky","lo","ms","sah","su","th","tt","ug","vi","wo","zh"],nr:[1],fc:3},{lngs:["be","bs","dz","hr","ru","sr","uk"],nr:[1,2,5],fc:4},{lngs:["ar"],nr:[0,1,2,3,11,100],fc:5},{lngs:["cs","sk"],nr:[1,2,5],fc:6},{lngs:["csb","pl"],nr:[1,2,5],fc:7},{lngs:["cy"],nr:[1,2,3,8],fc:8},{lngs:["fr"],nr:[1,2],fc:9},{lngs:["ga"],nr:[1,2,3,7,11],fc:10},{lngs:["gd"],nr:[1,2,3,20],fc:11},{lngs:["is"],nr:[1,2],fc:12},{lngs:["jv"],nr:[0,1],fc:13},{lngs:["kw"],nr:[1,2,3,4],fc:14},{lngs:["lt"],nr:[1,2,10],fc:15},{lngs:["lv"],nr:[1,2,0],fc:16},{lngs:["mk"],nr:[1,2],fc:17},{lngs:["mnk"],nr:[0,1,2],fc:18},{lngs:["mt"],nr:[1,2,11,20],fc:19},{lngs:["or"],nr:[2,1],fc:2},{lngs:["ro"],nr:[1,2,20],fc:20},{lngs:["sl"],nr:[5,1,2,3],fc:21}],U={1:function(t){return Number(t>1)},2:function(t){return Number(1!=t)},3:function(t){return 0},4:function(t){return Number(t%10==1&&t%100!=11?0:t%10>=2&&t%10<=4&&(t%100<10||t%100>=20)?1:2)},5:function(t){return Number(0===t?0:1==t?1:2==t?2:t%100>=3&&t%100<=10?3:t%100>=11?4:5)},6:function(t){return Number(1==t?0:t>=2&&t<=4?1:2)},7:function(t){return Number(1==t?0:t%10>=2&&t%10<=4&&(t%100<10||t%100>=20)?1:2)},8:function(t){return Number(1==t?0:2==t?1:8!=t&&11!=t?2:3)},9:function(t){return Number(t>=2)},10:function(t){return Number(1==t?0:2==t?1:t<7?2:t<11?3:4)},11:function(t){return Number(1==t||11==t?0:2==t||12==t?1:t>2&&t<20?2:3)},12:function(t){return Number(t%10!=1||t%100==11)},13:function(t){return Number(0!==t)},14:function(t){return Number(1==t?0:2==t?1:3==t?2:3)},15:function(t){return Number(t%10==1&&t%100!=11?0:t%10>=2&&(t%100<10||t%100>=20)?1:2)},16:function(t){return Number(t%10==1&&t%100!=11?0:0!==t?1:2)},17:function(t){return Number(1==t||t%10==1?0:1)},18:function(t){return Number(0==t?0:1==t?1:2)},19:function(t){return Number(1==t?0:0===t||t%100>1&&t%100<11?1:t%100>10&&t%100<20?2:3)},20:function(t){return Number(1==t?0:0===t||t%100>0&&t%100<20?1:2)},21:function(t){return Number(t%100==1?1:t%100==2?2:t%100==3||t%100==4?3:0)}},V=function(){function t(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};S(this,t),this.languageUtils=e,this.options=n,this.logger=C.create("pluralResolver"),this.rules=d()}return t.prototype.addRule=function(t,e){this.rules[t]=e},t.prototype.getRule=function(t){return this.rules[this.languageUtils.getLanguagePartFromCode(t)]},t.prototype.needsPlural=function(t){var e=this.getRule(t);return e&&e.numbers.length>1},t.prototype.getSuffix=function(t,e){var n=this,o=this.getRule(t);if(o){if(1===o.numbers.length)return"";var r=o.noAbs?o.plurals(e):o.plurals(Math.abs(e)),i=o.numbers[r];this.options.simplifyPluralSuffix&&2===o.numbers.length&&1===o.numbers[0]&&(2===i?i="plural":1===i&&(i=""));var a=function(){return n.options.prepend&&i.toString()?n.options.prepend+i.toString():i.toString()};return"v1"===this.options.compatibilityJSON?1===i?"":"number"==typeof i?"_plural_"+i.toString():a():"v2"===this.options.compatibilityJSON||2===o.numbers.length&&1===o.numbers[0]?a():2===o.numbers.length&&1===o.numbers[0]?a():this.options.prepend&&r.toString()?this.options.prepend+r.toString():r.toString()}return this.logger.warn("no plural rule found for: "+t),""},t}(),I=function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};S(this,e),this.logger=C.create("interpolator"),this.init(t,!0)}return e.prototype.init=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=arguments[1];e&&(this.options=t,this.format=t.interpolation&&t.interpolation.format||function(t){return t},this.escape=t.interpolation&&t.interpolation.escape||l),t.interpolation||(t.interpolation={escapeValue:!0});var n=t.interpolation;this.escapeValue=void 0===n.escapeValue||n.escapeValue,this.prefix=n.prefix?s(n.prefix):n.prefixEscaped||"{{",this.suffix=n.suffix?s(n.suffix):n.suffixEscaped||"}}",this.formatSeparator=n.formatSeparator?n.formatSeparator:n.formatSeparator||",",this.unescapePrefix=n.unescapeSuffix?"":n.unescapePrefix||"-",this.unescapeSuffix=this.unescapePrefix?"":n.unescapeSuffix||"",this.nestingPrefix=n.nestingPrefix?s(n.nestingPrefix):n.nestingPrefixEscaped||s("$t("),this.nestingSuffix=n.nestingSuffix?s(n.nestingSuffix):n.nestingSuffixEscaped||s(")"),this.resetRegExp()},e.prototype.reset=function(){this.options&&this.init(this.options)},e.prototype.resetRegExp=function(){var t=this.prefix+"(.+?)"+this.suffix;this.regexp=new RegExp(t,"g");var e=""+this.prefix+this.unescapePrefix+"(.+?)"+this.unescapeSuffix+this.suffix;this.regexpUnescape=new RegExp(e,"g");var n=this.nestingPrefix+"(.+?)"+this.nestingSuffix;this.nestingRegexp=new RegExp(n,"g")},e.prototype.interpolate=function(e,n,o){function r(t){return t.replace(/\$/g,"$$$$")}var a=this,s=void 0,l=void 0,u=function(t){if(t.indexOf(a.formatSeparator)<0)return i(n,t);var e=t.split(a.formatSeparator),r=e.shift().trim(),s=e.join(a.formatSeparator).trim();return a.format(i(n,r),s,o)};for(this.resetRegExp();s=this.regexpUnescape.exec(e);)l=u(s[1].trim()),e=e.replace(s[0],l),this.regexpUnescape.lastIndex=0;for(;s=this.regexp.exec(e);)l=u(s[1].trim()),"string"!=typeof l&&(l=t(l)),l||(this.logger.warn("missed to pass in variable "+s[1]+" for interpolating "+e),l=""),l=r(this.escapeValue?this.escape(l):l),e=e.replace(s[0],l),this.regexp.lastIndex=0;return e},e.prototype.nest=function(e,n){function o(t){if(t.indexOf(",")<0)return t;var e=t.split(",");t=e.shift();var n=e.join(",");n=this.interpolate(n,s),n=n.replace(/'/g,'"');try{s=JSON.parse(n)}catch(e){this.logger.error("failed parsing options string in nesting for key "+t,e)}return t}var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},i=void 0,a=void 0,s=k({},r);for(s.applyPostProcessor=!1;i=this.nestingRegexp.exec(e);){if(a=n(o.call(this,i[1].trim()),s),a&&i[0]===e&&"string"!=typeof a)return a;"string"!=typeof a&&(a=t(a)),a||(this.logger.warn("missed to resolve "+i[1]+" for nesting "+e),a=""),e=e.replace(i[0],a),this.regexp.lastIndex=0}return e},e}(),F=function(t){function e(n,o,r){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};S(this,e);var a=O(this,t.call(this));return a.backend=n,a.store=o,a.services=r,a.options=i,a.logger=C.create("backendConnector"),a.state={},a.queue=[],a.backend&&a.backend.init&&a.backend.init(r,i.backend,i),a}return w(e,t),e.prototype.queueLoad=function(t,e,n){var o=this,r=[],i=[],a=[],s=[];return t.forEach(function(t){var n=!0;e.forEach(function(e){var a=t+"|"+e;o.store.hasResourceBundle(t,e)?o.state[a]=2:o.state[a]<0||(1===o.state[a]?i.indexOf(a)<0&&i.push(a):(o.state[a]=1,n=!1,i.indexOf(a)<0&&i.push(a),r.indexOf(a)<0&&r.push(a),s.indexOf(e)<0&&s.push(e)))}),n||a.push(t)}),(r.length||i.length)&&this.queue.push({pending:i,loaded:{},errors:[],callback:n}),{toLoad:r,pending:i,toLoadLanguages:a,toLoadNamespaces:s}},e.prototype.loaded=function(t,e,n){var o=this,i=t.split("|"),a=L(i,2),s=a[0],l=a[1];e&&this.emit("failedLoading",s,l,e),n&&this.store.addResourceBundle(s,l,n),this.state[t]=e?-1:2,this.queue.forEach(function(n){r(n.loaded,[s],l),y(n.pending,t),e&&n.errors.push(e),0!==n.pending.length||n.done||(o.emit("loaded",n.loaded),n.done=!0,n.errors.length?n.callback(n.errors):n.callback())}),this.queue=this.queue.filter(function(t){return!t.done})},e.prototype.read=function(t,e,n){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=this,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:250,a=arguments[5];return t.length?this.backend[n](t,e,function(s,l){return s&&l&&o<5?void setTimeout(function(){r.read.call(r,t,e,n,o+1,2*i,a)},i):void a(s,l)}):a(null,{})},e.prototype.load=function(t,e,n){var o=this;if(!this.backend)return this.logger.warn("No backend was added via i18next.use. Will not load resources."),n&&n();var r=k({},this.backend.options,this.options.backend);"string"==typeof t&&(t=this.services.languageUtils.toResolveHierarchy(t)),"string"==typeof e&&(e=[e]);var a=this.queueLoad(t,e,n);return a.toLoad.length?void(r.allowMultiLoading&&this.backend.readMulti?this.read(a.toLoadLanguages,a.toLoadNamespaces,"readMulti",null,null,function(t,e){t&&o.logger.warn("loading namespaces "+a.toLoadNamespaces.join(", ")+" for languages "+a.toLoadLanguages.join(", ")+" via multiloading failed",t),!t&&e&&o.logger.log("successfully loaded namespaces "+a.toLoadNamespaces.join(", ")+" for languages "+a.toLoadLanguages.join(", ")+" via multiloading",e),a.toLoad.forEach(function(n){var r=n.split("|"),a=L(r,2),s=a[0],l=a[1],u=i(e,[s,l]);if(u)o.loaded(n,t,u);else{var c="loading namespace "+l+" for language "+s+" via multiloading failed";o.loaded(n,c),o.logger.error(c)}})}):a.toLoad.forEach(function(t){o.loadOne(t)})):(a.pending.length||n(),null)},e.prototype.reload=function(t,e){var n=this;this.backend||this.logger.warn("No backend was added via i18next.use. Will not load resources.");var o=k({},this.backend.options,this.options.backend);"string"==typeof t&&(t=this.services.languageUtils.toResolveHierarchy(t)),"string"==typeof e&&(e=[e]),o.allowMultiLoading&&this.backend.readMulti?this.read(t,e,"readMulti",null,null,function(o,r){o&&n.logger.warn("reloading namespaces "+e.join(", ")+" for languages "+t.join(", ")+" via multiloading failed",o),!o&&r&&n.logger.log("successfully reloaded namespaces "+e.join(", ")+" for languages "+t.join(", ")+" via multiloading",r),t.forEach(function(t){e.forEach(function(e){var a=i(r,[t,e]);if(a)n.loaded(t+"|"+e,o,a);else{var s="reloading namespace "+e+" for language "+t+" via multiloading failed";n.loaded(t+"|"+e,s),n.logger.error(s)}})})}):t.forEach(function(t){e.forEach(function(e){n.loadOne(t+"|"+e,"re")})})},e.prototype.loadOne=function(t){var e=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",o=t.split("|"),r=L(o,2),i=r[0],a=r[1];this.read(i,a,"read",null,null,function(o,r){o&&e.logger.warn(n+"loading namespace "+a+" for language "+i+" failed",o),!o&&r&&e.logger.log(n+"loaded namespace "+a+" for language "+i,r),e.loaded(t,o,r)})},e.prototype.saveMissing=function(t,e,n,o){this.backend&&this.backend.create&&this.backend.create(t,e,n,o),t&&t[0]&&this.store.addResource(t[0],e,n,o)},e}(R),D=function(t){function e(n,o,r){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};S(this,e);var a=O(this,t.call(this));return a.cache=n,a.store=o,a.services=r,a.options=i,a.logger=C.create("cacheConnector"),a.cache&&a.cache.init&&a.cache.init(r,i.cache,i),a}return w(e,t),e.prototype.load=function(t,e,n){var o=this;if(!this.cache)return n&&n();var r=k({},this.cache.options,this.options.cache),i="string"==typeof t?this.services.languageUtils.toResolveHierarchy(t):t;r.enabled?this.cache.load(i,function(t,e){if(t&&o.logger.error("loading languages "+i.join(", ")+" from cache failed",t),e)for(var r in e)if(Object.prototype.hasOwnProperty.call(e,r))for(var a in e[r])if(Object.prototype.hasOwnProperty.call(e[r],a)&&"i18nStamp"!==a){var s=e[r][a];s&&o.store.addResourceBundle(r,a,s)}n&&n()}):n&&n()},e.prototype.save=function(){this.cache&&this.options.cache&&this.options.cache.enabled&&this.cache.save(this.store.data)},e}(R),K=function(t){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},o=arguments[1];S(this,e);var r=O(this,t.call(this));if(r.options=b(n),r.services={},r.logger=C,r.modules={external:[]},o&&!r.isInitialized&&!n.isClone){var i;if(!r.options.initImmediate)return i=r.init(n,o),O(r,i);setTimeout(function(){r.init(n,o)},0)}return r}return w(e,t),e.prototype.init=function(t,e){function n(t){return t?"function"==typeof t?new t:t:null}var o=this;if("function"==typeof t&&(e=t,t={}),t||(t={}),"v1"===t.compatibilityAPI?this.options=k({},v(),b(c(t)),{}):"v1"===t.compatibilityJSON?this.options=k({},v(),b(p(t)),{}):this.options=k({},v(),this.options,b(t)),this.format=this.options.interpolation.format,e||(e=m),!this.options.isClone){this.modules.logger?C.init(n(this.modules.logger),this.options):C.init(null,this.options);var r=new _(this.options);this.store=new A(this.options.resources,this.options);var i=this.services;i.logger=C,i.resourceStore=this.store,i.resourceStore.on("added removed",function(t,e){i.cacheConnector.save()}),i.languageUtils=r,i.pluralResolver=new V(r,{prepend:this.options.pluralSeparator,compatibilityJSON:this.options.compatibilityJSON,simplifyPluralSuffix:this.options.simplifyPluralSuffix}),i.interpolator=new I(this.options),i.backendConnector=new F(n(this.modules.backend),i.resourceStore,i,this.options),i.backendConnector.on("*",function(t){for(var e=arguments.length,n=Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];o.emit.apply(o,[t].concat(n))}),i.backendConnector.on("loaded",function(t){i.cacheConnector.save()}),i.cacheConnector=new D(n(this.modules.cache),i.resourceStore,i,this.options),i.cacheConnector.on("*",function(t){for(var e=arguments.length,n=Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];o.emit.apply(o,[t].concat(n))}),this.modules.languageDetector&&(i.languageDetector=n(this.modules.languageDetector),i.languageDetector.init(i,this.options.detection,this.options)),this.translator=new M(this.services,this.options),
this.translator.on("*",function(t){for(var e=arguments.length,n=Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];o.emit.apply(o,[t].concat(n))}),this.modules.external.forEach(function(t){t.init&&t.init(o)})}var a=["getResource","addResource","addResources","addResourceBundle","removeResourceBundle","hasResourceBundle","getResourceBundle"];a.forEach(function(t){o[t]=function(){var e;return(e=o.store)[t].apply(e,arguments)}}),"v1"===this.options.compatibilityAPI&&g(this);var s=function(){o.changeLanguage(o.options.lng,function(t,n){o.isInitialized=!0,o.logger.log("initialized",o.options),o.emit("initialized",o.options),e(t,n)})};return this.options.resources||!this.options.initImmediate?s():setTimeout(s,0),this},e.prototype.loadResources=function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:m;if(this.options.resources)e(null);else{if(this.language&&"cimode"===this.language.toLowerCase())return e();var n=[],o=function(e){if(e){var o=t.services.languageUtils.toResolveHierarchy(e);o.forEach(function(t){n.indexOf(t)<0&&n.push(t)})}};if(this.language)o(this.language);else{var r=this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);r.forEach(function(t){return o(t)})}this.options.preload&&this.options.preload.forEach(function(t){return o(t)}),this.services.cacheConnector.load(n,this.options.ns,function(){t.services.backendConnector.load(n,t.options.ns,e)})}},e.prototype.reloadResources=function(t,e){t||(t=this.languages),e||(e=this.options.ns),this.services.backendConnector.reload(t,e)},e.prototype.use=function(t){return"backend"===t.type&&(this.modules.backend=t),"cache"===t.type&&(this.modules.cache=t),("logger"===t.type||t.log&&t.warn&&t.error)&&(this.modules.logger=t),"languageDetector"===t.type&&(this.modules.languageDetector=t),"postProcessor"===t.type&&T.addPostProcessor(t),"3rdParty"===t.type&&this.modules.external.push(t),this},e.prototype.changeLanguage=function(t,e){var n=this,o=function(t,o){o&&(n.emit("languageChanged",o),n.logger.log("languageChanged",o)),e&&e(t,function(){return n.t.apply(n,arguments)})},r=function(t){t&&(n.language=t,n.languages=n.services.languageUtils.toResolveHierarchy(t),n.translator.changeLanguage(t),n.services.languageDetector&&n.services.languageDetector.cacheUserLanguage(t)),n.loadResources(function(e){o(e,t)})};t||!this.services.languageDetector||this.services.languageDetector.async?!t&&this.services.languageDetector&&this.services.languageDetector.async?this.services.languageDetector.detect(r):r(t):r(this.services.languageDetector.detect())},e.prototype.getFixedT=function(t,e){var n=this,o=function t(e){var o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=k({},o);return r.lng=r.lng||t.lng,r.lngs=r.lngs||t.lngs,r.ns=r.ns||t.ns,n.t(e,r)};return"string"==typeof t?o.lng=t:o.lngs=t,o.ns=e,o},e.prototype.t=function(){var t;return this.translator&&(t=this.translator).translate.apply(t,arguments)},e.prototype.exists=function(){var t;return this.translator&&(t=this.translator).exists.apply(t,arguments)},e.prototype.setDefaultNamespace=function(t){this.options.defaultNS=t},e.prototype.loadNamespaces=function(t,e){var n=this;return this.options.ns?("string"==typeof t&&(t=[t]),t.forEach(function(t){n.options.ns.indexOf(t)<0&&n.options.ns.push(t)}),void this.loadResources(e)):e&&e()},e.prototype.loadLanguages=function(t,e){"string"==typeof t&&(t=[t]);var n=this.options.preload||[],o=t.filter(function(t){return n.indexOf(t)<0});return o.length?(this.options.preload=n.concat(o),void this.loadResources(e)):e()},e.prototype.dir=function(t){if(t||(t=this.languages&&this.languages.length>0?this.languages[0]:this.language),!t)return"rtl";var e=["ar","shu","sqr","ssh","xaa","yhd","yud","aao","abh","abv","acm","acq","acw","acx","acy","adf","ads","aeb","aec","afb","ajp","apc","apd","arb","arq","ars","ary","arz","auz","avl","ayh","ayl","ayn","ayp","bbz","pga","he","iw","ps","pbt","pbu","pst","prp","prd","ur","ydd","yds","yih","ji","yi","hbo","men","xmn","fa","jpr","peo","pes","prs","dv","sam"];return e.indexOf(this.services.languageUtils.getLanguagePartFromCode(t))>=0?"rtl":"ltr"},e.prototype.createInstance=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=arguments[1];return new e(t,n)},e.prototype.cloneInstance=function(){var t=this,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:m,r=k({},this.options,n,{isClone:!0}),i=new e(r,o),a=["store","services","language"];return a.forEach(function(e){i[e]=t[e]}),i.translator=new M(i.services,i.options),i.translator.on("*",function(t){for(var e=arguments.length,n=Array(e>1?e-1:0),o=1;o<e;o++)n[o-1]=arguments[o];i.emit.apply(i,[t].concat(n))}),i.init(r,o),i},e}(R),q=new K;return q})
    window['i18next'] = module.exports;
});
/*
Copyright 2011-15 Newcastle University
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/** @file Sets up JME built-in functions.
 *
 * Provides {@link Numbas.jme}
 */
Numbas.queueScript('jme-builtins',['jme-base','jme-rules'],function(){
var util = Numbas.util;
var math = Numbas.math;
var vectormath = Numbas.vectormath;
var matrixmath = Numbas.matrixmath;
var setmath = Numbas.setmath;
var jme = Numbas.jme;
var types = Numbas.jme.types;
var Scope = jme.Scope;
var funcObj = jme.funcObj;
var TNum = types.TNum;
var TString = types.TString;
var TBool = types.TBool;
var THTML = types.THTML;
var TList = types.TList;
var TKeyPair = types.TKeyPair;
var TDict = types.TDict;
var TMatrix = types.TMatrix;
var TName = types.TName;
var TRange = types.TRange;
var TSet = types.TSet;
var TVector = types.TVector;
var TExpression = types.TExpression;
var TOp = Numbas.jme.types.TOp;
/** The built-in JME evaluation scope
 * @type {Numbas.jme.Scope}
 * @memberof Numbas.jme
 */
var builtinScope = jme.builtinScope = new Scope({rulesets:jme.rules.simplificationRules});
builtinScope.setVariable('nothing',new types.TNothing);
var funcs = {};
function newBuiltin(name,intype,outcons,fn,options) {
    return builtinScope.addFunction(new funcObj(name,intype,outcons,fn,options));
}
newBuiltin('+u', [TNum], TNum, function(a){return a;});
newBuiltin('+u', [TVector], TVector, function(a){return a;});
newBuiltin('+u', [TMatrix], TMatrix, function(a){return a;});
newBuiltin('-u', [TNum], TNum, math.negate);
newBuiltin('-u', [TVector], TVector, vectormath.negate);
newBuiltin('-u', [TMatrix], TMatrix, matrixmath.negate);
newBuiltin('+', [TNum,TNum], TNum, math.add);
newBuiltin('+', [TList,TList], TList, null, {
    evaluate: function(args,scope)
    {
        var value = args[0].value.concat(args[1].value);
        return new TList(value);
    }
});
newBuiltin('+',[TList,'?'],TList, null, {
    evaluate: function(args,scope)
    {
        var value = args[0].value.slice();
        value.push(args[1]);
        return new TList(value);
    }
});
newBuiltin('+',[TDict,TDict],TDict, null,{
    evaluate: function(args,scope) {
        var nvalue = {};
        Object.keys(args[0].value).forEach(function(x) {
            nvalue[x] = args[0].value[x];
        })
        Object.keys(args[1].value).forEach(function(x) {
            nvalue[x] = args[1].value[x];
        })
        return new TDict(nvalue);
    }
});
var fconc = function(a,b) { return a+b; }
newBuiltin('+', [TString,'?'], TString, fconc);
newBuiltin('+', ['?',TString], TString, fconc);
newBuiltin('+', [TVector,TVector], TVector, vectormath.add);
newBuiltin('+', [TMatrix,TMatrix], TMatrix, matrixmath.add);
newBuiltin('-', [TNum,TNum], TNum, math.sub);
newBuiltin('-', [TVector,TVector], TVector, vectormath.sub);
newBuiltin('-', [TMatrix,TMatrix], TMatrix, matrixmath.sub);
newBuiltin('*', [TNum,TNum], TNum, math.mul );
newBuiltin('*', [TNum,TVector], TVector, vectormath.mul);
newBuiltin('*', [TVector,TNum], TVector, function(a,b){return vectormath.mul(b,a)});
newBuiltin('*', [TMatrix,TVector], TVector, vectormath.matrixmul);
newBuiltin('*', [TNum,TMatrix], TMatrix, matrixmath.scalarmul );
newBuiltin('*', [TMatrix,TNum], TMatrix, function(a,b){ return matrixmath.scalarmul(b,a); } );
newBuiltin('*', [TMatrix,TMatrix], TMatrix, matrixmath.mul);
newBuiltin('*', [TVector,TMatrix], TVector, vectormath.vectormatrixmul);
newBuiltin('/', [TNum,TNum], TNum, math.div );
newBuiltin('/', [TMatrix,TNum], TMatrix, function(a,b){ return matrixmath.scalardiv(a,b); } );
newBuiltin('/', [TVector,TNum], TVector, function(a,b){return vectormath.div(a,b)});
newBuiltin('^', [TNum,TNum], TNum, math.pow );
newBuiltin('dot',[TVector,TVector],TNum,vectormath.dot);
newBuiltin('dot',[TMatrix,TVector],TNum,vectormath.dot);
newBuiltin('dot',[TVector,TMatrix],TNum,vectormath.dot);
newBuiltin('dot',[TMatrix,TMatrix],TNum,vectormath.dot);
newBuiltin('cross',[TVector,TVector],TVector,vectormath.cross);
newBuiltin('cross',[TMatrix,TVector],TVector,vectormath.cross);
newBuiltin('cross',[TVector,TMatrix],TVector,vectormath.cross);
newBuiltin('cross',[TMatrix,TMatrix],TVector,vectormath.cross);
newBuiltin('det', [TMatrix], TNum, matrixmath.abs);
newBuiltin('numrows',[TMatrix], TNum, function(m){ return m.rows });
newBuiltin('numcolumns',[TMatrix], TNum, function(m){ return m.columns });
newBuiltin('angle',[TVector,TVector],TNum,vectormath.angle);
newBuiltin('transpose',[TVector],TMatrix, vectormath.transpose);
newBuiltin('transpose',[TMatrix],TMatrix, matrixmath.transpose);
newBuiltin('is_zero',[TVector],TBool, vectormath.is_zero);
newBuiltin('id',[TNum],TMatrix, matrixmath.id);
newBuiltin('sum_cells',[TMatrix],TNum,matrixmath.sum_cells);
newBuiltin('..', [TNum,TNum], TRange, math.defineRange);
newBuiltin('#', [TRange,TNum], TRange, math.rangeSteps);
newBuiltin('in',[TNum,TRange],TBool,function(x,r) {
    var start = r[0];
    var end = r[1];
    var step_size = r[2];
    if(x>end || x<start) {
        return false;
    }
    if(step_size===0) {
        return true;
    } else {
        var max_steps = Math.floor(end-start)/step_size;
        var steps = Math.floor((x-start)/step_size);
        return step_size*steps + start == x && steps <= max_steps;
    }
});
newBuiltin('list',[TRange],TList,function(range) {
    return math.rangeToList(range).map(function(n){return new TNum(n)});
});
newBuiltin('dict',['*keypair'],TDict,null,{
    evaluate: function(args,scope) {
        if(args.length==0) {
            return new TDict({});
        }
        var value = {};
        if(args[0].tok.type=='keypair') {
            args.forEach(function(kp) {
                value[kp.tok.key] = jme.evaluate(kp.args[0],scope);
            });
        } else if(args.length==1) {
            var list = scope.evaluate(args[0]);
            var items = list.value;
            if(list.type!='list' || !items.every(function(item) {return item.type=='list' && item.value.length==2 && item.value[0].type=='string';})) {
                throw(new Numbas.Error('jme.typecheck.no right type definition',{op:'dict'}));
            }
            items.forEach(function(item) {
                value[item.value[0].value] = item.value[1];
            });
        } else {
            throw(new Numbas.Error('jme.typecheck.no right type definition',{op:'dict'}));
        }
        return new TDict(value);
    }
});
Numbas.jme.lazyOps.push('dict');
newBuiltin('keys',[TDict],TList,function(d) {
    var o = [];
    Object.keys(d).forEach(function(key) {
        o.push(new TString(key));
    })
    return o;
});
newBuiltin('values',[TDict],TList,function(d) {
    var o = [];
    Object.values(d).forEach(function(v) {
        o.push(v);
    })
    return o;
});
newBuiltin('values',[TDict,TList],TList,function(d,keys) {
    return keys.map(function(key) {
        if(!d.hasOwnProperty(key.value)) {
            throw(new Numbas.Error('jme.func.listval.key not in dict',{key:key}));
        } else {
            return d[key.value];
        }
    });
})
newBuiltin('items',[TDict],TList,null, {
    evaluate: function(args,scope) {
        var o = [];
        Object.entries(args[0].value).forEach(function(x) {
            o.push(new TList([new TString(x[0]), x[1]]))
        });
        return new TList(o);
    }
});
newBuiltin('listval',[TDict,TString],'?', null, {
    evaluate: function(args,scope) {
        var d = args[0].value;
        var key = args[1].value;
        if(!d.hasOwnProperty(key)) {
            throw(new Numbas.Error('jme.func.listval.key not in dict',{key:key}));
        }
        return d[key];
    }
});
newBuiltin('get',[TDict,TString,'?'],'?',null,{
    evaluate: function(args,scope) {
        var d = args[0].value;
        var key = args[1].value;
        if(!d.hasOwnProperty(key)) {
            return args[2]
        }
        return d[key];
    }
});
newBuiltin('in', [TString,TDict], TBool, function(s,d) {
    return d.hasOwnProperty(s);
});
newBuiltin('in',[TString, TString], TBool, function(sub,str) {
    return str.indexOf(sub)>=0;
});
newBuiltin('json_decode', [TString], '?', null, {
    evaluate: function(args,scope) {
        var data = JSON.parse(args[0].value);
        return jme.wrapValue(data);
    }
});
newBuiltin('json_encode', ['?'], TString, null, {
    evaluate: function(args,scope) {
        var s = new TString(JSON.stringify(jme.unwrapValue(args[0])));
        s.safe = true;
        return s;
    }
});
newBuiltin('lpad',[TString,TNum,TString],TString,util.lpad);
newBuiltin('formatstring',[TString,TList],TString,function(str,extra) {
    return util.formatString.apply(util,[str].concat(extra));
},{unwrapValues:true});
newBuiltin('unpercent',[TString],TNum,util.unPercent);
newBuiltin('letterordinal',[TNum],TString,util.letterOrdinal);
newBuiltin('html',[TString],THTML,function(html) { return $(html) });
newBuiltin('nonemptyhtml',[TString],TBool,function(html) {
    return util.isNonemptyHTML(html);
});
newBuiltin('image',[TString],THTML,function(url){ return $('<img/>').attr('src',url); });
newBuiltin('latex',[TString],TString,null,{
    evaluate: function(args,scope) {
        var s = new TString(args[0].value);
        s.latex = true;
        return s;
    }
});
newBuiltin('safe',[TString],TString,null, {
    evaluate: function(args,scope) {
        var t = new TString(args[0].tok.value);
        t.safe = true;
        return t;
    },
    typecheck: function(variables) {
        return variables.length==1 && variables[0].type=='string';
    }
});
Numbas.jme.lazyOps.push('safe');
jme.findvarsOps.safe = function(tree,boundvars,scope) {
    return [];
}
newBuiltin('capitalise',[TString],TString,function(s) { return util.capitalise(s); });
newBuiltin('upper',[TString],TString,function(s) { return s.toUpperCase(); });
newBuiltin('lower',[TString],TString,function(s) { return s.toLowerCase(); });
newBuiltin('pluralise',[TNum,TString,TString],TString,function(n,singular,plural) { return util.pluralise(n,singular,plural); });
newBuiltin('join',[TList,TString],TString,function(list,delimiter) {
    return list.map(jme.tokenToDisplayString).join(delimiter);
});
newBuiltin('split',[TString,TString],TList, function(str,delimiter) {
    return str.split(delimiter).map(function(s){return new TString(s)});
});
newBuiltin('trim',[TString],TString, function(str) { return str.trim(); });
newBuiltin('currency',[TNum,TString,TString],TString,util.currency);
newBuiltin('separateThousands',[TNum,TString],TString,util.separateThousands);
newBuiltin('listval',[TString,TNum],TString,function(s,i) {return s[i]});
newBuiltin('listval',[TString,TRange],TString,function(s,range) {return s.slice(range[0],range[1])});
newBuiltin('in',[TString,TString],TBool,function(sub,str) { return str.indexOf(sub)>=0 });
newBuiltin('lpad',[TString,TNum,TString], TString, util.lpad);
newBuiltin('rpad',[TString,TNum,TString], TString, util.rpad);
newBuiltin('match_regex',[TString,TString],TList,function(pattern,str) {
    var re = new RegExp(pattern);
    var m = re.exec(str);
    return m || [];
},{unwrapValues: true});
newBuiltin('match_regex',[TString,TString,TString],TList,function(pattern,str,flags) {
    var re = new RegExp(pattern,flags);
    var m = re.exec(str);
    return m || [];
},{unwrapValues: true});
//the next three versions of the `except` operator
//exclude numbers from a range, given either as a range, a list or a single value
newBuiltin('except', [TRange,TRange], TList,
    function(range,except) {
        if(range[2]==0) {
            throw(new Numbas.Error("jme.func.except.continuous range"));
        }
        range = math.rangeToList(range);
        if(except[2]==0) {
            return range.filter(function(i){return i<except[0] || i>except[1]}).map(function(i){return new TNum(i)});
        } else {
            except = math.rangeToList(except);
            return math.except(range,except).map(function(i){return new TNum(i)});
        }
    }
);
newBuiltin('except', [TRange,TList], TList,
    function(range,except) {
        if(range[2]==0) {
            throw(new Numbas.Error("jme.func.except.continuous range"));
        }
        range = math.rangeToList(range)
        except = except.map(function(i){ return i.value; });
        return math.except(range,except).map(function(i){return new TNum(i)});
    }
);
newBuiltin('except', [TRange,TNum], TList,
    function(range,except) {
        if(range[2]==0) {
            throw(new Numbas.Error("jme.func.except.continuous range"));
        }
        range = math.rangeToList(range);
        return math.except(range,[except]).map(function(i){return new TNum(i)});
    }
);
//exclude numbers from a list, so use the math.except function
newBuiltin('except', [TList,TRange], TList,
    function(range,except) {
        range = range.map(function(i){ return i.value; });
        except = math.rangeToList(except);
        return math.except(range,except).map(function(i){return new TNum(i)});
    }
);
//exclude values of any type from a list containing values of any type, so use the util.except function
newBuiltin('except', [TList,TList], TList,
    function(list,except) {
        return util.except(list,except);
    }
);
newBuiltin('except',[TList,'?'], TList, null, {
    evaluate: function(args,scope) {
        return new TList(util.except(args[0].value,[args[1]]));
    }
});
newBuiltin('distinct',[TList],TList, util.distinct,{unwrapValues: false});
newBuiltin('in',['?',TList],TBool,null,{
    evaluate: function(args,scope) {
        return new TBool(util.contains(args[1].value,args[0]));
    }
});
newBuiltin('<', [TNum,TNum], TBool, math.lt);
newBuiltin('>', [TNum,TNum], TBool, math.gt );
newBuiltin('<=', [TNum,TNum], TBool, math.leq );
newBuiltin('>=', [TNum,TNum], TBool, math.geq );
newBuiltin('<>', ['?','?'], TBool, null, {
    evaluate: function(args,scope) {
        return new TBool(util.neq(args[0],args[1]));
    }
});
newBuiltin('=', ['?','?'], TBool, null, {
    evaluate: function(args,scope) {
        return new TBool(util.eq(args[0],args[1]));
    }
});
newBuiltin('and', [TBool,TBool], TBool, function(a,b){return a&&b;} );
newBuiltin('not', [TBool], TBool, function(a){return !a;} );
newBuiltin('or', [TBool,TBool], TBool, function(a,b){return a||b;} );
newBuiltin('xor', [TBool,TBool], TBool, function(a,b){return (a || b) && !(a && b);} );
newBuiltin('implies', [TBool,TBool], TBool, function(a,b){return !a || b;} );
newBuiltin('abs', [TNum], TNum, math.abs );
newBuiltin('abs', [TString], TNum, function(s){return s.length} );
newBuiltin('abs', [TList], TNum, function(l) { return l.length; });
newBuiltin('abs', [TRange], TNum, function(r) { return r[2]==0 ? Math.abs(r[0]-r[1]) : math.rangeSize(r); });
newBuiltin('abs', [TVector], TNum, vectormath.abs);
newBuiltin('abs', [TDict], TNum, function(d) {
    var n = 0;
    for(var x in d) {
        n += 1;
    }
    return n;
});
newBuiltin('arg', [TNum], TNum, math.arg );
newBuiltin('re', [TNum], TNum, math.re );
newBuiltin('im', [TNum], TNum, math.im );
newBuiltin('conj', [TNum], TNum, math.conjugate );
newBuiltin('isint',[TNum],TBool, function(a){ return util.isInt(a); });
newBuiltin('sqrt', [TNum], TNum, math.sqrt );
newBuiltin('ln', [TNum], TNum, math.log );
newBuiltin('log', [TNum], TNum, math.log10 );
newBuiltin('log', [TNum,TNum], TNum, math.log_base );
newBuiltin('exp', [TNum], TNum, math.exp );
newBuiltin('fact', [TNum], TNum, math.factorial );
newBuiltin('gamma', [TNum], TNum, math.gamma );
newBuiltin('sin', [TNum], TNum, math.sin );
newBuiltin('cos', [TNum], TNum, math.cos );
newBuiltin('tan', [TNum], TNum, math.tan );
newBuiltin('cosec', [TNum], TNum, math.cosec );
newBuiltin('sec', [TNum], TNum, math.sec );
newBuiltin('cot', [TNum], TNum, math.cot );
newBuiltin('arcsin', [TNum], TNum, math.arcsin );
newBuiltin('arccos', [TNum], TNum, math.arccos );
newBuiltin('arctan', [TNum], TNum, math.arctan );
newBuiltin('sinh', [TNum], TNum, math.sinh );
newBuiltin('cosh', [TNum], TNum, math.cosh );
newBuiltin('tanh', [TNum], TNum, math.tanh );
newBuiltin('cosech', [TNum], TNum, math.cosech );
newBuiltin('sech', [TNum], TNum, math.sech );
newBuiltin('coth', [TNum], TNum, math.coth );
newBuiltin('arcsinh', [TNum], TNum, math.arcsinh );
newBuiltin('arccosh', [TNum], TNum, math.arccosh );
newBuiltin('arctanh', [TNum], TNum, math.arctanh );
newBuiltin('ceil', [TNum], TNum, math.ceil );
newBuiltin('floor', [TNum], TNum, math.floor );
newBuiltin('round', [TNum], TNum, math.round );
newBuiltin('trunc', [TNum], TNum, math.trunc );
newBuiltin('fract', [TNum], TNum, math.fract );
newBuiltin('degrees', [TNum], TNum, math.degrees );
newBuiltin('radians', [TNum], TNum, math.radians );
newBuiltin('sign', [TNum], TNum, math.sign );
newBuiltin('rational_approximation',[TNum],TList,function(n) {
    return math.rationalApproximation(n);
},{unwrapValues:true});
newBuiltin('rational_approximation',[TNum,TNum],TList,function(n,accuracy) {
    return math.rationalApproximation(n,accuracy);
},{unwrapValues:true});
newBuiltin('factorise',[TNum],TList,function(n) {
        return math.factorise(n).map(function(n){return new TNum(n)});
    }
);
newBuiltin('random', [TRange], TNum, math.random, {random:true} );
newBuiltin('random',[TList],'?',null, {
    random:true,
    evaluate: function(args,scope)
    {
        return math.choose(args[0].value);
    }
});
newBuiltin( 'random',[],'?', null, {
    random:true,
    typecheck: function() { return true; },
    evaluate: function(args,scope) { return math.choose(args);}
});
newBuiltin('mod', [TNum,TNum], TNum, math.mod );
newBuiltin('max', [TNum,TNum], TNum, math.max );
newBuiltin('min', [TNum,TNum], TNum, math.min );
newBuiltin('max', [TList], TNum, math.listmax, {unwrapValues: true});
newBuiltin('min', [TList], TNum, math.listmin, {unwrapValues: true});
newBuiltin('precround', [TNum,TNum], TNum, math.precround );
newBuiltin('precround', [TMatrix,TNum], TMatrix, matrixmath.precround );
newBuiltin('precround', [TVector,TNum], TVector, vectormath.precround );
newBuiltin('siground', [TNum,TNum], TNum, math.siground );
newBuiltin('siground', [TMatrix,TNum], TMatrix, matrixmath.siground );
newBuiltin('siground', [TVector,TNum], TVector, vectormath.siground );
newBuiltin('dpformat', [TNum,TNum], TString, function(n,p) {return math.niceNumber(n,{precisionType: 'dp', precision:p});}, {latex: true} );
newBuiltin('dpformat', [TNum,TNum,TString], TString, function(n,p,style) {return math.niceNumber(n,{precisionType: 'dp', precision:p, style: style});}, {latex: true} );
newBuiltin('sigformat', [TNum,TNum], TString, function(n,p) {return math.niceNumber(n,{precisionType: 'sigfig', precision:p});}, {latex: true} );
newBuiltin('sigformat', [TNum,TNum,TString], TString, function(n,p,style) {return math.niceNumber(n,{precisionType: 'sigfig', precision:p, style:style});}, {latex: true} );
newBuiltin('formatnumber', [TNum,TString], TString, function(n,style) {return math.niceNumber(n,{style:style});});
newBuiltin('string', [TNum], TString, math.niceNumber);
newBuiltin('parsenumber', [TString,TString], TNum, function(s,style) {return util.parseNumber(s,false,style,true);});
newBuiltin('parsenumber', [TString,TList], TNum, function(s,styles) {return util.parseNumber(s,false,styles,true);}, {unwrapValues: true});
newBuiltin('parsenumber_or_fraction', [TString,TString], TNum, function(s,style) {return util.parseNumber(s,true,style,true);});
newBuiltin('parsenumber_or_fraction', [TString,TList], TNum, function(s,styles) {return util.parseNumber(s,true,styles,true);}, {unwrapValues: true});
newBuiltin('togivenprecision', [TString,TString,TNum,TBool], TBool, math.toGivenPrecision);
newBuiltin('withintolerance',[TNum,TNum,TNum],TBool, math.withinTolerance);
newBuiltin('countdp',[TString],TNum, function(s) { return math.countDP(util.cleanNumber(s)); });
newBuiltin('countsigfigs',[TString],TNum, function(s) { return math.countSigFigs(util.cleanNumber(s)); });
newBuiltin('isnan',[TNum],TBool,function(n) {
    return isNaN(n);
});
newBuiltin('matchnumber',[TString,TList],TList,function(s,styles) {
    var result = util.matchNotationStyle(s,styles,true);
    return [new TString(result.matched), new TNum(util.parseNumber(result.cleaned,false,['plain'],true))];
},{unwrapValues:true});
newBuiltin('cleannumber',[TString,TList],TString,util.cleanNumber,{unwrapValues:true});
newBuiltin('isbool',[TString],TBool,util.isBool);
newBuiltin('perm', [TNum,TNum], TNum, math.permutations );
newBuiltin('comb', [TNum,TNum], TNum, math.combinations );
newBuiltin('root', [TNum,TNum], TNum, math.root );
newBuiltin('award', [TNum,TBool], TNum, function(a,b){return (b?a:0);} );
newBuiltin('gcd', [TNum,TNum], TNum, math.gcf );
newBuiltin('gcd_without_pi_or_i', [TNum,TNum], TNum, function(a,b) {    // take out factors of pi or i before working out gcd. Used by the fraction simplification rules
        if(a.complex && a.re==0) {
            a = a.im;
        }
        if(b.complex && b.re==0) {
            b = b.im;
        }
        a = a/math.pow(Math.PI,math.piDegree(a));
        b = b/math.pow(Math.PI,math.piDegree(b));
        return math.gcf(a,b);
} );
newBuiltin('coprime',[TNum,TNum], TBool, math.coprime);
newBuiltin('lcm', [TNum,TNum], TNum, math.lcm );
newBuiltin('lcm', [TList], TNum, function(l){
        if(l.length==0) {
            return 1;
        } else if(l.length==1) {
            return l[0];
        } else {
            return math.lcm.apply(math,l);
        }
    },
    {unwrapValues: true}
);
newBuiltin('|', [TNum,TNum], TBool, math.divides );
newBuiltin('sum',[TList],TNum,math.sum,{unwrapValues: true});
newBuiltin('sum',[TVector],TNum,math.sum);
newBuiltin('deal',[TNum],TList,
    function(n) {
        return math.deal(n).map(function(i) {
            return new TNum(i);
        });
    },
    {
        random:true
    }
);
newBuiltin('shuffle',[TList],TList,
    function(list) {
        return math.shuffle(list);
    },
    {
        random:true
    }
);
newBuiltin('shuffle',[TRange],TList,
    function(range) {
        var list = math.rangeToList(range).map(function(n){return new TNum(n)})
        return math.shuffle(list);
    },
    {
        random:true
    }
);
//if needs to be a bit different because it can return any type
newBuiltin('if', [TBool,'?','?'], '?',null, {
    evaluate: function(args,scope)
    {
        var test = jme.evaluate(args[0],scope).value;
        if(test)
            return jme.evaluate(args[1],scope);
        else
            return jme.evaluate(args[2],scope);
    }
});
Numbas.jme.lazyOps.push('if');
newBuiltin('switch',[],'?', null, {
    typecheck: function(variables)
    {
        //should take alternating booleans and [any value]
        //final odd-numbered argument is the 'otherwise' option
        if(variables.length <2)
            return false;
        var check=0;
        if(variables.length % 2 == 0)
            check = variables.length;
        else
            check = variables.length-1;
        for( var i=0; i<check; i+=2 )
        {
            switch(variables[i].tok.type)
            {
            case '?':
            case 'boolean':
                break;
            default:
                return false;
            }
        }
        return true;
    },
    evaluate: function(args,scope)
    {
        for(var i=0; i<args.length-1; i+=2 )
        {
            var result = jme.evaluate(args[i],scope).value;
            if(result)
                return jme.evaluate(args[i+1],scope);
        }
        if(args.length % 2 == 1)
            return jme.evaluate(args[args.length-1],scope);
        else
            throw(new Numbas.Error('jme.func.switch.no default case'));
    }
});
Numbas.jme.lazyOps.push('switch');
newBuiltin('isa',['?',TString],TBool, null, {
    evaluate: function(args,scope)
    {
        var kind = jme.evaluate(args[1],scope).value;
        if(args[0].tok.type=='name' && scope.getVariable(args[0].tok.name.toLowerCase())==undefined )
            return new TBool(kind=='name');
        var match = false;
        if(kind=='complex')
        {
            match = args[0].tok.type=='number' && args[0].tok.value.complex || false;
        }
        else
        {
            match = args[0].tok.type == kind;
        }
        return new TBool(match);
    }
});
Numbas.jme.lazyOps.push('isa');
// repeat(expr,n) evaluates expr n times and returns a list of the results
newBuiltin('repeat',['?',TNum],TList, null, {
    evaluate: function(args,scope)
    {
        var size = jme.evaluate(args[1],scope).value;
        var value = [];
        for(var i=0;i<size;i++)
        {
            value[i] = jme.evaluate(args[0],scope);
        }
        return new TList(value);
    }
});
Numbas.jme.lazyOps.push('repeat');
function satisfy(names,definitions,conditions,scope,maxRuns) {
        maxRuns = maxRuns===undefined ? 100 : maxRuns;
        if(definitions.length!=names.length) {
            throw(new Numbas.Error('jme.func.satisfy.wrong number of definitions'));
        }
        var satisfied = false;
        var runs = 0;
        while(runs<maxRuns && !satisfied) {
            runs += 1;
            var variables = {};
            for(var i=0; i<names.length; i++) {
                variables[names[i]] = jme.evaluate(definitions[i],scope);
            }
            var nscope = new jme.Scope([scope,{variables:variables}]);
            satisfied = true;
            for(var i=0; i<conditions.length; i++) {
                var ok = jme.evaluate(conditions[i],nscope);
                if(ok.type!='boolean') {
                    throw(new Numbas.Error('jme.func.satisfy.condition not a boolean'));
                }
                if(!ok.value) {
                    satisfied = false;
                    break;
                }
            }
        }
        if(!satisfied) {
            throw(new Numbas.Error('jme.func.satisfy.took too many runs'));
        }
        return variables;
}
newBuiltin('satisfy', [TList,TList,TList,TNum], TList, null, {
    evaluate: function(args,scope)
    {
        var names = args[0].args.map(function(t){ return t.tok.name; });
        var definitions = args[1].args;
        var conditions = args[2].args;
        var maxRuns = args.length>3 ? jme.evaluate(args[3]).value : 100;
        var variables = satisfy(names,definitions,conditions,scope,maxRuns);
        return new TList(names.map(function(name){ return variables[name]; }));
    }
});
Numbas.jme.lazyOps.push('satisfy');
jme.findvarsOps.satisfy = function(tree,boundvars,scope) {
    var names = tree.args[0].args.map(function(t){return t.tok.name});
    boundvars = boundvars.concat(0,0,names);
    var vars = [];
    for(var i=1;i<tree.args.length;i++)
        vars = vars.merge(jme.findvars(tree.args[i],boundvars));
    return vars;
}
newBuiltin('listval',[TList,TNum],'?', null, {
    evaluate: function(args,scope)
    {
        var list = args[0];
        var index = util.wrapListIndex(args[1].value,list.vars);
        if(list.type!='list') {
            if(list.type=='name')
                throw(new Numbas.Error('jme.variables.variable not defined',{name:list.name}));
            else
                throw(new Numbas.Error('jme.func.listval.not a list'));
        }
        if(index in list.value)
            return list.value[index];
        else
            throw(new Numbas.Error('jme.func.listval.invalid index',{index:index,size:list.value.length}));
    }
});
newBuiltin('listval',[TList,TRange],TList, null, {
    evaluate: function(args,scope)
    {
        var range = args[1].value;
        var list = args[0];
        var size = list.vars;
        var start = util.wrapListIndex(range[0],size);
        var end = util.wrapListIndex(range[1],size);
        var step = range[2];
        var value;
        if(step!=1) {
            value = [];
            for(var i=start;i<end;i += step) {
                if(i%1==0) {
                    value.push(list.value[i]);
                }
            }
        } else {
            value = list.value.slice(start,end);
        }
        return new TList(value);
    }
});
newBuiltin('listval',[TVector,TNum],TNum, null, {
    evaluate: function(args,scope)
    {
        var vector = args[0].value;
        var index = util.wrapListIndex(args[1].value,vector.length);
        return new TNum(vector[index] || 0);
    }
});
newBuiltin('listval',[TVector,TRange],TVector,null, {
    evaluate: function(args,scope)
    {
        var range = args[1].value;
        var vector = args[0].value;
        var start = util.wrapListIndex(range[0],vector.length);
        var end = util.wrapListIndex(range[1],vector.length);
        var v = [];
        for(var i=start;i<end;i++) {
            v.push(vector[i] || 0);
        }
        return new TVector(v);
    }
});
newBuiltin('listval',[TMatrix,TNum],TVector, null, {
    evaluate: function(args,scope)
    {
        var matrix = args[0].value;
        var index = util.wrapListIndex(args[1].value,matrix.length);
        return new TVector(matrix[index] || []);
    }
});
newBuiltin('listval',[TMatrix,TRange],TMatrix,null, {
    evaluate: function(args,scope)
    {
        var range = args[1].value;
        var matrix = args[0].value;
        var start = util.wrapListIndex(range[0],matrix.length);
        var end = util.wrapListIndex(range[1],matrix.length);
        var v = [];
        return new TMatrix(matrix.slice(start,end));
    }
});
newBuiltin('isset',[TName],TBool,null, {
    evaluate: function(args,scope) {
        var name = args[0].tok.name;
        return new TBool(name in scope.variables);
    }
});
Numbas.jme.lazyOps.push('isset');
jme.findvarsOps.isset = function(tree,boundvars,scope) {
    boundvars = boundvars.slice();
    boundvars.push(tree.args[1].tok.name.toLowerCase());
    var vars = jme.findvars(tree.args[0],boundvars,scope);
    vars = vars.merge(jme.findvars(tree.args[2],boundvars));
    return vars;
}
jme.substituteTreeOps.isset = function(tree,scope,allowUnbound) {
    return tree;
}
function mapOverList(lambda,names,list,scope) {
    var olist = list.map(function(v) {
        if(typeof(names)=='string') {
            scope.setVariable(names,v);
        } else {
            names.forEach(function(name,i) {
                scope.setVariable(name,v.value[i]);
            });
        }
        return scope.evaluate(lambda);
    });
    return new TList(olist);
}
/** Functions for 'map', by the type of the thing being mapped over.
 * Functions take a JME expression lambda, a name or list of names to map, a value to map over, and a scope to evaluate against.
 * @memberof Numbas.jme
 * @enum {function}
 */
jme.mapFunctions = {
    'list': mapOverList,
    'set': mapOverList,
    'range': function(lambda,name,range,scope) {
        var list = math.rangeToList(range).map(function(n){return new TNum(n)});
        return mapOverList(lambda,name,list,scope);
    },
    'matrix': function(lambda,name,matrix,scope) {
        return new TMatrix(matrixmath.map(matrix,function(n) {
            scope.setVariable(name,new TNum(n));
            var o = scope.evaluate(lambda);
            if(o.type!='number') {
                throw(new Numbas.Error("jme.map.matrix map returned non number"))
            }
            return o.value;
        }));
    },
    'vector': function(lambda,name,vector,scope) {
        return new TVector(vectormath.map(vector,function(n) {
            scope.setVariable(name,new TNum(n));
            var o = scope.evaluate(lambda);
            if(o.type!='number') {
                throw(new Numbas.Error("jme.map.vector map returned non number"))
            }
            return o.value;
        }));
    }
}
newBuiltin('map',['?',TName,'?'],TList, null, {
    evaluate: function(args,scope)
    {
        var lambda = args[0];
        var value = jme.evaluate(args[2],scope);
        if(!(value.type in jme.mapFunctions)) {
            throw(new Numbas.Error('jme.typecheck.map not on enumerable',{type:value.type}));
        }
        scope = new Scope(scope);
        var names_tok = args[1].tok;
        var names;
        if(names_tok.type=='name') {
            names = names_tok.name;
        } else {
            names = args[1].args.map(function(t){return t.tok.name;});
        }
        return jme.mapFunctions[value.type](lambda,names,value.value,scope);
    }
});
Numbas.jme.lazyOps.push('map');
jme.findvarsOps.map = function(tree,boundvars,scope) {
    var mapped_boundvars = boundvars.slice();
    if(tree.args[1].tok.type=='list') {
        var names = tree.args[1].args;
        for(var i=0;i<names.length;i++) {
            mapped_boundvars.push(names[i].tok.name.toLowerCase());
        }
    } else {
        mapped_boundvars.push(tree.args[1].tok.name.toLowerCase());
    }
    var vars = jme.findvars(tree.args[0],mapped_boundvars,scope);
    vars = vars.merge(jme.findvars(tree.args[2],boundvars,scope));
    return vars;
}
jme.substituteTreeOps.map = function(tree,scope,allowUnbound) {
    tree.args[2] = jme.substituteTree(tree.args[2],scope,allowUnbound);
    return tree;
}
newBuiltin('filter',['?',TName,'?'],TList,null, {
    evaluate: function(args,scope) {
        var lambda = args[0];
        var list = jme.evaluate(args[2],scope);
        switch(list.type) {
        case 'list':
            list = list.value;
            break;
        case 'range':
            list = math.rangeToList(list.value);
            for(var i=0;i<list.length;i++) {
                list[i] = new TNum(list[i]);
            }
            break;
        default:
            throw(new Numbas.Error('jme.typecheck.map not on enumerable',list.type));
        }
        scope = new Scope(scope);
        var name = args[1].tok.name;
        var value = list.filter(function(v) {
            scope.setVariable(name,v);
            return jme.evaluate(lambda,scope).value;
        });
        return new TList(value);
    }
});
Numbas.jme.lazyOps.push('filter');
jme.findvarsOps.filter = function(tree,boundvars,scope) {
    var mapped_boundvars = boundvars.slice();
    if(tree.args[1].tok.type=='list') {
        var names = tree.args[1].args;
        for(var i=0;i<names.length;i++) {
            mapped_boundvars.push(names[i].tok.name.toLowerCase());
        }
    } else {
        mapped_boundvars.push(tree.args[1].tok.name.toLowerCase());
    }
    var vars = jme.findvars(tree.args[0],mapped_boundvars,scope);
    vars = vars.merge(jme.findvars(tree.args[2],boundvars,scope));
    return vars;
}
jme.substituteTreeOps.filter = function(tree,scope,allowUnbound) {
    tree.args[2] = jme.substituteTree(tree.args[2],scope,allowUnbound);
    return tree;
}


newBuiltin('take',[TNum,'?',TName,'?'],TList,null, {
    evaluate: function(args,scope) {
        var n = scope.evaluate(args[0]).value;
        var lambda = args[1];
        var list = scope.evaluate(args[3]);
        switch(list.type) {
        case 'list':
            list = list.value;
            break;
        case 'range':
            list = math.rangeToList(list.value);
            for(var i=0;i<list.length;i++) {
                list[i] = new TNum(list[i]);
            }
            break;
        default:
            throw(new Numbas.Error('jme.typecheck.map not on enumerable',list.type));
        }
        scope = new Scope(scope);
        var name = args[2].tok.name;
        var value = [];
        for(var i=0;i<list.length && value.length<n;i++) {
            var v = list[i];
            scope.setVariable(name,v);
            var ok = scope.evaluate(lambda).value;
            if(ok) {
                value.push(v);
            }
        };
        return new TList(value);
    }
});
Numbas.jme.lazyOps.push('take');
jme.findvarsOps.take = function(tree,boundvars,scope) {
    var mapped_boundvars = boundvars.slice();
    if(tree.args[2].tok.type=='list') {
        var names = tree.args[2].args;
        for(var i=0;i<names.length;i++) {
            mapped_boundvars.push(names[i].tok.name.toLowerCase());
        }
    } else {
        mapped_boundvars.push(tree.args[2].tok.name.toLowerCase());
    }
    var vars = jme.findvars(tree.args[1],mapped_boundvars,scope);
    vars = vars.merge(jme.findvars(tree.args[0],boundvars,scope));
    vars = vars.merge(jme.findvars(tree.args[3],boundvars,scope));
    return vars;
}
jme.substituteTreeOps.take = function(tree,scope,allowUnbound) {
    var args = tree.args.slice();
    args[0] = jme.substituteTree(args[0],scope,allowUnbound);
    args[3] = jme.substituteTree(args[3],scope,allowUnbound);
    return {tok:tree.tok, args: args};
}



function tok_is_true(item){return item.type=='boolean' && item.value}
newBuiltin('all',[TList],TBool,function(list) {
    return list.every(tok_is_true);
});
newBuiltin('some',[TList],TBool,function(list) {
    return list.some(tok_is_true);
});
newBuiltin('let',['?'],TList, null, {
    evaluate: function(args,scope)
    {
        var lambda = args[args.length-1];
        var variables = {};
        if(args[0].tok.type=='dict') {
            var d = scope.evaluate(args[0]);
            variables = d.value;
            var nscope = new Scope([scope,{variables:variables}]);
        } else {
            var nscope = new Scope([scope]);
            for(var i=0;i<args.length-1;i+=2) {
                var value = nscope.evaluate(args[i+1]);
                if(args[i].tok.type=='name') {
                    var name = args[i].tok.name;
                    nscope.setVariable(name,value);
                } else if(args[i].tok.type=='list') {
                    var names = args[i].args.map(function(t){return t.tok.name});
                    if(value.type!='list') {
                        throw(new Numbas.Error("jme.let.list assignment not a list"));
                    }
                    var values = value.value;
                    if(values.length<names.length) {
                        throw(new Numbas.Error("jme.let.list not long enough"));
                    }
                    for(var j=0;j<names.length;j++) {
                        nscope.setVariable(names[j],values[j]);
                    }
                }
            }
        }
        return nscope.evaluate(lambda);
    },
    typecheck: function(variables) {
        if(variables.length==2 && variables[0].tok.type=='dict') {
            return true;
        }
        if(variables.length<3 || (variables.length%2)!=1) {
            return false;
        }
        for(var i=0;i<variables.length-1;i+=2) {
            if(variables[i].tok.type!='name' && variables[i].tok.type!='list') {
                return false;
            }
        }
    }
});
Numbas.jme.lazyOps.push('let');
jme.findvarsOps.let = function(tree,boundvars,scope) {
    // find vars used in variable assignments
    var vars = [];
    for(var i=0;i<tree.args.length-1;i+=2) {
        vars = vars.merge(jme.findvars(tree.args[i+1],boundvars,scope));
    }
    // find variable names assigned by let
    boundvars = boundvars.slice();
    for(var i=0;i<tree.args.length-1;i+=2) {
        boundvars.push(tree.args[i].tok.name.toLowerCase());
    }
    // find variables used in the lambda expression, excluding the ones assigned by let
    vars = vars.merge(jme.findvars(tree.args[tree.args.length-1],boundvars,scope));
    return vars;
}
jme.substituteTreeOps.let = function(tree,scope,allowUnbound) {
    for(var i=1;i<tree.args.length-1;i+=2) {
        tree.args[i] = jme.substituteTree(tree.args[i],scope,allowUnbound);
    }
}

newBuiltin('unset',[TDict,'?'],'?',null,{
    evaluate: function(args,scope) {
        var defs = jme.unwrapValue(scope.evaluate(args[0]));
        var nscope = scope.unset(defs);
        return nscope.evaluate(args[1]);
    }
});
Numbas.jme.lazyOps.push('unset');

newBuiltin('sort',[TList],TList, null, {
    evaluate: function(args,scope)
    {
        var list = args[0];
        var newlist = new TList(list.vars);
        newlist.value = list.value.slice().sort(jme.compareTokens);
        return newlist;
    }
});
newBuiltin('sort_destinations',[TList],TList,null, {
    evaluate: function(args,scope) {
        var list = args[0];
        var newlist = new TList(list.vars);
        var sorted = list.value.map(function(v,i){ return {tok:v,i:i} }).sort(function(a,b){
            return jme.compareTokens(a.tok,b.tok);
        });
        var inverse = [];
        for(var i=0;i<sorted.length;i++) {
            inverse[sorted[i].i] = i;
        }
        newlist.value = inverse.map(function(n) {
            return new TNum(n);
        });
        return newlist;
    }
});
newBuiltin('reverse',[TList],TList,null, {
    evaluate: function(args,scope) {
        var list = args[0];
        return new TList(list.value.slice().reverse());
    }
});
// indices of given value in given list
newBuiltin('indices',[TList,'?'],TList,null, {
    evaluate: function(args,scope) {
        var list = args[0];
        var target = args[1];
        var out = [];
        list.value.map(function(v,i) {
            if(util.eq(v,target)) {
                out.push(new TNum(i));
            }
        });
        return new TList(out);
    }
});
newBuiltin('set',[TList],TSet,function(l) {
    return util.distinct(l);
});
newBuiltin('set',[TRange],TSet,function(r) {
    return math.rangeToList(r).map(function(n){return new TNum(n)});
});
newBuiltin('set', ['?'], TSet, null, {
    evaluate: function(args,scope) {
        return new TSet(util.distinct(args));
    },
    typecheck: function() {
        return true;
    }
});
newBuiltin('list',[TSet],TList,function(set) {
    var l = [];
    for(var i=0;i<set.length;i++) {
        l.push(set[i]);
    }
    return l;
});
newBuiltin('union',[TSet,TSet],TSet,setmath.union);
newBuiltin('intersection',[TSet,TSet],TSet,setmath.intersection);
newBuiltin('or',[TSet,TSet],TSet,setmath.union);
newBuiltin('and',[TSet,TSet],TSet,setmath.intersection);
newBuiltin('-',[TSet,TSet],TSet,setmath.minus);
newBuiltin('abs',[TSet],TNum,setmath.size);
newBuiltin('in',['?',TSet],TBool,null,{
    evaluate: function(args,scope) {
        return new TBool(util.contains(args[1].value,args[0]));
    }
});
newBuiltin('product',['?'],TList,function() {
    var lists = Array.prototype.slice.call(arguments);
    var prod = util.product(lists);
    return prod.map(function(l){ return new TList(l); });
}, {
    typecheck: function(variables) {
        for(var i=0;i<variables.length;i++) {
            var t = variables[i].type;
            if(!(t=='list' || t=='set')) {
                return false;
            }
        }
        return true;
    }
});

newBuiltin('product',[TList,TNum],TList,function(l,n) {
    return util.cartesian_power(l,n).map(function(sl){ return new TList(sl); });
});

newBuiltin('zip',['?'],TList,function() {
    var lists = Array.prototype.slice.call(arguments);
    var zipped = util.zip(lists);
    return zipped.map(function(l){ return new TList(l); });
}, {
    typecheck: function(variables) {
        for(var i=0;i<variables.length;i++) {
            var t = variables[i].type;
            if(!(t=='list' || t=='set')) {
                return false;
            }
        }
        return true;
    }
});
newBuiltin('combinations',['?',TNum],TList,function(list,r) {
    var prod = util.combinations(list,r);
    return prod.map(function(l){ return new TList(l); });
}, {
    typecheck: function(variables) {
        return (variables[0].type=='set' || variables[0].type=='list') && variables[1].type=='number';
    }
});
newBuiltin('combinations_with_replacement',['?',TNum],TList,function(list,r) {
    var prod = util.combinations_with_replacement(list,r);
    return prod.map(function(l){ return new TList(l); });
}, {
    typecheck: function(variables) {
        return (variables[0].type=='set' || variables[0].type=='list') && variables[1].type=='number';
    }
});
newBuiltin('permutations',['?',TNum],TList,function(list,r) {
    var prod = util.permutations(list,r);
    return prod.map(function(l){ return new TList(l); });
}, {
    typecheck: function(variables) {
        return (variables[0].type=='set' || variables[0].type=='list') && variables[1].type=='number';
    }
});
newBuiltin('vector',['*TNum'],TVector, null, {
    evaluate: function(args,scope)
    {
        var value = [];
        for(var i=0;i<args.length;i++)
        {
            value.push(args[i].value);
        }
        return new TVector(value);
    }
});
newBuiltin('vector',[TList],TVector, null, {
    evaluate: function(args,scope)
    {
        var list = args[0];
        var value = list.value.map(function(x){return x.value});
        return new TVector(value);
    }
});
newBuiltin('matrix',[TList],TMatrix,null, {
    evaluate: function(args,scope)
    {
        var list = args[0];
        var rows = list.vars;
        var columns = 0;
        var value = [];
        if(!list.value.length) {
            rows = 0;
            columns = 0;
        } else {
            switch(list.value[0].type)
            {
            case 'number':
                value = [list.value.map(function(e){return e.value})];
                rows = 1;
                columns = list.vars;
                break;
            case 'vector':
                value = list.value.map(function(v){return v.value});
                columns = list.value[0].value.length;
                break;
            case 'list':
                for(var i=0;i<rows;i++)
                {
                    var row = list.value[i].value;
                    value.push(row.map(function(x){return x.value}));
                    columns = Math.max(columns,row.length);
                }
                break;
            default:
                throw(new Numbas.Error('jme.func.matrix.invalid row type',{type:list.value[0].type}));
            }
        }
        value.rows = rows;
        value.columns = columns;
        return new TMatrix(value);
    }
});
newBuiltin('matrix',['*list'],TMatrix, null, {
    evaluate: function(args,scope)
    {
        var rows = args.length;
        var columns = 0;
        var value = [];
        for(var i=0;i<args.length;i++)
        {
            var row = args[i].value;
            value.push(row.map(function(x){return x.value}));
            columns = Math.max(columns,row.length);
        }
        value.rows = rows;
        value.columns = columns;
        return new TMatrix(value);
    }
});
newBuiltin('rowvector',['*number'],TMatrix, null, {
    evaluate: function(args,scope)
    {
        var row = [];
        for(var i=0;i<args.length;i++)
        {
            row.push(args[i].value);
        }
        var matrix = [row];
        matrix.rows = 1;
        matrix.columns = row.length;
        return new TMatrix(matrix);
    }
});
newBuiltin('rowvector',[TList],TMatrix, null, {
    evaluate: function(args,scope)
    {
        var list = args[0];
        var row = list.value.map(function(x){return x.value});
        var matrix = [row];
        matrix.rows = 1;
        matrix.columns = row.length;
        return new TMatrix(matrix);
    }
});
//cast vector to list
newBuiltin('list',[TVector],TList,null, {
    evaluate: function(args,scope)
    {
        var vector = args[0];
        var value = vector.value.map(function(n){ return new TNum(n)});
        return new TList(value);
    }
});
//cast matrix to list of lists
newBuiltin('list',[TMatrix],TList,null, {
    evaluate: function(args,scope)
    {
        var matrix = args[0];
        var value = [];
        for(var i=0;i<matrix.value.rows;i++)
        {
            var row = new TList(matrix.value[i].map(function(n){return new TNum(n)}));
            value.push(row);
        }
        return new TList(value);
    }
});
newBuiltin('table',[TList,TList],THTML,
    function(data,headers) {
        var table = $('<table/>');
        var thead = $('<thead/>');
        table.append(thead);
        for(var i=0;i<headers.length;i++) {
            var cell = headers[i];
            if(typeof cell=='number')
                cell = Numbas.math.niceNumber(cell);
            thead.append($('<th/>').html(cell));
        }
        var tbody=$('<tbody/>');
        table.append(tbody);
        for(var i=0;i<data.length;i++) {
            var row = $('<tr/>');
            tbody.append(row);
            for(var j=0;j<data[i].length;j++) {
                var cell = data[i][j];
                if(typeof cell=='number')
                    cell = Numbas.math.niceNumber(cell);
                row.append($('<td/>').html(cell));
            }
        }
        return new THTML(table);
    },
    {
        unwrapValues: true
    }
);
newBuiltin('table',[TList],THTML,
    function(data) {
        var table = $('<table/>');
        var tbody=$('<tbody/>');
        table.append(tbody);
        for(var i=0;i<data.length;i++) {
            var row = $('<tr/>');
            tbody.append(row);
            for(var j=0;j<data[i].length;j++) {
                var cell = data[i][j];
                if(typeof cell=='number')
                    cell = Numbas.math.niceNumber(cell);
                row.append($('<td/>').html(cell));
            }
        }
        return new THTML(table);
    },
    {
        unwrapValues: true
    }
);
newBuiltin('parse',[TString],TExpression,function(str) {
    return jme.compile(str);
});
newBuiltin('expression',[TString],TExpression,function(str) {
    return jme.compile(str);
});
newBuiltin('args',[TExpression],TList,null, {
    evaluate: function(args, scope) {
        return new TList(args[0].tree.args.map(function(tree){ return new TExpression(tree); }));
    }
});
newBuiltin('type',[TExpression],TString,null, {
    evaluate: function(args,scope) {
        return args[0].tree.tok.type;
    }
});
newBuiltin('name',[TString],TName,function(name){ return name });
newBuiltin('string',[TName],TString,function(name){ return name });
newBuiltin('op',[TString],TOp,function(name){ return name });
newBuiltin('assert',[TBool,'?'],'?',null,{
    evaluate: function(args, scope) {
        var result = scope.evaluate(args[0]).value;
        if(!result) {
            return scope.evaluate(args[1]);
        } else {
            return new TBool(false);
        }
    }
});
Numbas.jme.lazyOps.push('assert');
newBuiltin('try',['?',TName,'?'],'?',null, {
    evaluate: function(args, scope) {
        try {
            var res = scope.evaluate(args[0]);
            return res;
        } catch(e) {
            var variables = {};
            variables[args[1].tok.name] = e.message;
            return scope.evaluate(args[2],variables);
        }
    }
});
Numbas.jme.lazyOps.push('try');
jme.findvarsOps.try = function(tree,boundvars,scope) {
    var try_boundvars = boundvars.slice();
    try_boundvars.push(tree.args[1].tok.name.toLowerCase());
    vars = jme.findvars(tree.args[0],boundvars,scope);
    vars = vars.merge(jme.findvars(tree.args[2],try_boundvars,scope));
    return vars;
}
newBuiltin('exec',[TOp,TList],TExpression,null, {
    evaluate: function(args, scope) {
        var tok = args[0];
        var eargs = args[1].value.map(function(a) {
            if(a.type!='expression') {
                return {tok:a};
            } else {
                return a.tree;
            }
        });
        return new TExpression({tok: tok, args: eargs});
    }
});
newBuiltin('simplify',[TExpression,TString],TExpression,null, {
    evaluate: function(args, scope) {
        var tree = args[0].tree;
        var ruleset = jme.rules.collectRuleset(args[1].value,scope.allRulesets());
        return new TExpression(jme.display.simplifyTree(tree, ruleset, scope));
    }
});
newBuiltin('simplify',[TExpression,TList],TExpression,null, {
    evaluate: function(args, scope) {
        var tree = args[0].tree;
        var ruleset = jme.rules.collectRuleset(args[1].value.map(function(x){ return x.value}),scope.allRulesets());
        return new TExpression(jme.display.simplifyTree(tree, ruleset, scope));
    }
});
newBuiltin('simplify',[TString,TString],TExpression,null, {
    evaluate: function(args,scope) {
        return new TExpression(jme.display.simplify(args[0].value,args[1].value,scope));
    }
});
newBuiltin('string',[TExpression],TString,null, {
    evaluate: function(args,scope) {
        return new TString(jme.display.treeToJME(args[0].tree));
    }
});
newBuiltin('eval',[TExpression],'?',null,{
    evaluate: function(args,scope) {
        return scope.evaluate(args[0].tree);
    }
});
newBuiltin('eval',[TExpression, TDict],'?',null,{
    evaluate: function(args,scope) {
        return (new Numbas.jme.Scope([scope,{variables:args[1].value}])).evaluate(args[0].tree);
    }
});
newBuiltin('findvars',[TExpression],TList,null, {
    evaluate: function(args, scope) {
        var vars = jme.findvars(args[0].tree,[],scope);
        return new TList(vars.map(function(v){ return new TString(v) }));
    }
});
newBuiltin('definedvariables',[],TList,null, {
    evaluate: function(args, scope) {
        var vars = Object.keys(scope.allVariables());
        return new TList(vars.map(function(x){ return new TString(x) }));
    }
});
newBuiltin('resultsequal',['?','?',TString,TNum],TBool,null, {
    evaluate: function(args, scope) {
        var a = args[0];
        var b = args[1];
        var accuracy = args[3].value;
        var checkingFunction = jme.checkingFunctions[args[2].value.toLowerCase()];
        return new TBool(jme.resultsEqual(a,b,checkingFunction,accuracy));
    }
});
newBuiltin('match',[TExpression,TString],TDict,null, {
    evaluate: function(args, scope) {
        var expr = args[0].tree;
        var pattern = Numbas.jme.compile(args[1].value);
        var match = Numbas.jme.display.matchTree(pattern,expr,false);
        if(!match) {
            return jme.wrapValue({match: false, groups: {}});
        } else {
            var groups = {}
            for(var x in match) {
                groups[x] = new TExpression(match[x]);
            }
            return jme.wrapValue({
                match: true,
                groups: groups
            });
        }
    }
});
newBuiltin('matches',[TExpression,TString],TBool,null, {
    evaluate: function(args, scope) {
        var expr = args[0].tree;
        var pattern = Numbas.jme.compile(args[1].value);
        var match = Numbas.jme.display.matchTree(pattern,expr,false);
        return new TBool(match && true);
    }
});
newBuiltin('replace',[TString,TString,TExpression],TExpression,null,{
    evaluate: function(args, scope) {
        var pattern = args[0].value;
        var repl = args[1].value;
        var expr = args[2].tree;
        var rule = new jme.rules.Rule(pattern,[],repl);
        var set = new jme.rules.Ruleset([rule]);
        return new TExpression(jme.display.simplifyTree(expr,set,scope,true));
    }
});
newBuiltin('canonical_compare',['?','?'],TNum,null, {
    evaluate: function(args,scope) {
        var cmp = jme.compareTrees(args[0],args[1]);
        return new TNum(cmp);
    }
});
jme.lazyOps.push('canonical_compare');
newBuiltin('translate',[TString],TString,function(s) {
    return R(s);
});
newBuiltin('translate',[TString,TDict],TString,function(s,params) {
    return R(s,params);
},{unwrapValues:true});
///end of builtins
});

/*
Copyright 2011-14 Newcastle University
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/** @file Stuff to do with displaying JME expressions - convert to TeX, simplify, or convert syntax trees back to JME
 *
 * Provides {@link Numbas.jme.display}
 */
Numbas.queueScript('jme-display',['base','math','jme','util','jme-rules'],function() {
var math = Numbas.math;
var jme = Numbas.jme;
var util = Numbas.util;

/** A LaTeX string
 * @typedef TeX
 * @type {String}
 */

/** @namespace Numbas.jme.display */
jme.display = /** @lends Numbas.jme.display */ {
    /** Convert a JME expression to LaTeX.
     *
     * @param {JME} expr
     * @param {Array.<String>|Numbas.jme.rules.Ruleset} ruleset - can be anything accepted by {@link Numbas.jme.display.collectRuleset}
     * @param {Numbas.jme.Scope} scope
     * @returns {TeX}
     */
    exprToLaTeX: function(expr,ruleset,scope)
    {
        if(!ruleset)
            ruleset = jme.rules.simplificationRules.basic;
        ruleset = jme.collectRuleset(ruleset,scope.allRulesets());
        expr+='';    //make sure expr is a string
        if(!expr.trim().length)    //if expr is the empty string, don't bother going through the whole compilation proces
            return '';
        var tree = jme.display.simplify(expr,ruleset,scope); //compile the expression to a tree and simplify it
        var tex = texify(tree,ruleset.flags); //render the tree as TeX
        return tex;
    },
    /** Simplify a JME expression string according to the given ruleset and return it as a JME string
     *
     * @param {JME} expr
     * @param {Array.<String>|Numbas.jme.rules.Ruleset} ruleset - can be anything accepted by {@link Numbas.jme.display.collectRuleset}
     * @param {Numbas.jme.Scope} scope
     * @returns {JME}
     *
     * @see Numbas.jme.display.simplify
     */
    simplifyExpression: function(expr,ruleset,scope)
    {
        if(expr.trim()=='')
            return '';
        return treeToJME(jme.display.simplify(expr,ruleset,scope),ruleset.flags);
    },
    /** Simplify a JME expression string according to given ruleset and return it as a syntax tree
     *
     * @param {JME} expr
     * @param {Array.<String>|Numbas.jme.rules.Ruleset} ruleset
     * @param {Numbas.jme.Scope} scope
     * @returns {Numbas.jme.tree}
     *
     * @see Numbas.jme.display.simplifyExpression
     * @see Numbas.jme.display.simplifyTree
     */
    simplify: function(expr,ruleset,scope)
    {
        if(expr.trim()=='')
            return;
        if(!ruleset)
            ruleset = jme.rules.simplificationRules.basic;
        ruleset = jme.collectRuleset(ruleset,scope.allRulesets());        //collect the ruleset - replace set names with the appropriate Rule objects
        try
        {
            var exprTree = jme.compile(expr,{},true);    //compile the expression to a tree. notypecheck is true, so undefined function names can be used.
            return jme.display.simplifyTree(exprTree,ruleset,scope);    // simplify the tree
        }
        catch(e)
        {
            //e.message += '\nSimplifying expression failed. Expression was: '+expr;
            throw(e);
        }
    },
    /** Simplify a syntax tree according to the given ruleset
     *
     * @param {Numbas.jme.tree} exprTree
     * @param {Array.<String>|Numbas.jme.rules.Ruleset} ruleset
     * @param {Numbas.jme.Scope} scope
     * @param {Boolean} allowUnbound
     * @returns {Numbas.jme.tree}
     *
     * @see Numbas.jme.display.simplify
     */
    simplifyTree: function(exprTree,ruleset,scope,allowUnbound)
    {
        if(!exprTree) {
            throw(new Numbas.Error('jme.display.simplifyTree.empty expression'));
        }
        if(!scope)
            throw(new Numbas.Error('jme.display.simplifyTree.no scope given'));
        scope = Numbas.util.copyobj(scope);
        scope.variables = {};    //remove variables from the scope so they don't accidentally get substituted in
        var applied = true;
        var rules = ruleset.rules;
        var depth = 0;
        var seen = [];
        // apply rules until nothing can be done
        while( applied )
        {
            //the eval() function is a meta-function which, when used in the result of a rule, allows you to replace an expression with a single data value
            if(exprTree.tok.type=='function' && exprTree.tok.name=='eval')
            {
                exprTree = {tok: Numbas.jme.evaluate(exprTree.args[0],scope)};
            }
            else
            {
                if(exprTree.args)    //if this token is an operation with arguments, try to simplify the arguments first
                {
                    for(var i=0;i<exprTree.args.length;i++)
                    {
                        exprTree.args[i] = jme.display.simplifyTree(exprTree.args[i],ruleset,scope,allowUnbound);
                    }
                }
                applied = false;
                for( var i=0; i<rules.length;i++)    //check each rule
                {
                    var match;
                    if(match = rules[i].match(exprTree,scope))    //if rule can be applied, apply it!
                    {
                        exprTree = jme.substituteTree(Numbas.util.copyobj(rules[i].result,true),new jme.Scope([{variables:match}]),allowUnbound);
                        applied = true;
                        depth += 1;
                        if(depth > 100) {
                            var str = Numbas.jme.display.treeToJME(exprTree);
                            if(seen.contains(str)) {
                                throw(new Numbas.Error("jme.display.simplifyTree.stuck in a loop",{expr:str}));
                            }
                            seen.push(str);
                        }
                        break;
                    }
                }
            }
        }
        return exprTree
    }
};
/// all private methods below here
function texifyWouldBracketOpArg(thing,i, settings) {
    settings = settings || {};
    var tok = thing.args[i].tok;
    var precedence = jme.precedence;
    if(tok.type=='op') {    //if this is an op applied to an op, might need to bracket
        var op1 = thing.args[i].tok.name;    //child op
        var op2 = thing.tok.name;            //parent op
        var p1 = precedence[op1];    //precedence of child op
        var p2 = precedence[op2];    //precedence of parent op
        //if leaving out brackets would cause child op to be evaluated after parent op, or precedences the same and parent op not commutative, or child op is negation and parent is exponentiation
        return ( p1 > p2 || (p1==p2 && i>0 && !jme.commutative[op2]) || (op1=='-u' && precedence[op2]<=precedence['*']) )
    }
    //complex numbers might need brackets round them when multiplied with something else or unary minusing
    else if(tok.type=='number' && tok.value.complex && thing.tok.type=='op' && (thing.tok.name=='*' || thing.tok.name=='-u' || i==0 && thing.tok.name=='^') ) {
        var v = thing.args[i].tok.value;
        return !(v.re==0 || v.im==0);
    } else if(jme.isOp(thing.tok, '^') && settings.fractionnumbers && tok.type=='number' && texSpecialNumber(tok.value)===undefined && math.rationalApproximation(Math.abs(tok.value))[1] != 1) {
        return true;
    }
    return false;
}
/** Apply brackets to an op argument if appropriate
 * @memberof Numbas.jme.display
 * @private
 *
 * @param {Numbas.jme.tree} thing
 * @param {Array.<String>} texArgs - the arguments of `thing`, as TeX
 * @param {Number} i - the index of the argument to bracket
 * @returns {TeX}
 */
function texifyOpArg(thing,texArgs,i)
{
    var tex = texArgs[i];
    if(texifyWouldBracketOpArg(thing,i)) {
        tex = '\\left ( '+tex+' \\right )';
    }
    return tex;
}
/** Helper function for texing infix operators
 * @memberof Numbas.jme.display
 * @private
 *
 * @param {TeX} code - the TeX command for the operator
 * @returns {function} - a function which will convert a syntax tree with the operator at the top to TeX, by putting `code` in between the TeX of the two arguments.
 */
function infixTex(code)
{
    return function(thing,texArgs)
    {
        var arity = thing.args.length;
        if( arity == 1 )    //if operation is unary, prepend argument with code
        {
            return code+texArgs[0];
        }
        else if ( arity == 2 )    //if operation is binary, put code in between arguments
        {
            return texArgs[0]+' '+code+' '+texArgs[1];
        }
    }
}
/** Helper for texing nullary functions
 * @memberof Numbas.jme.display
 * @private
 *
 * @param {TeX} code - the TeX command for the function
 * @returns {function} - a function which returns the appropriate (constant) TeX code
 */
function nullaryTex(code)
{
    return function(thing,texArgs){ return '\\textrm{'+code+'}'; };
}
/** Helper function for texing functions
 * @memberof Numbas.jme.display
 * @private
 *
 * @param {TeX} code - the TeX command for the function
 * @returns {function} - a function which converts a syntax tree to the appropriate TeX
 */
function funcTex(code)
{
    var f = function(thing,texArgs){
        return code+' \\left ( '+texArgs.join(', ')+' \\right )';
    }
    f.code = code;
    return f;
}
/** Define how to texify each operation and function
 * @enum {function}
 * @memberof Numbas.jme.display
 */
var texOps = jme.display.texOps = {
    /** range definition. Should never really be seen */
    '#': (function(thing,texArgs) { return texArgs[0]+' \\, \\# \\, '+texArgs[1]; }),
    /** logical negation */
    'not': infixTex('\\neg '),
    /** unary addition */
    '+u': function(thing,texArgs,settings) {
        var tex = texArgs[0];
        if( thing.args[0].tok.type=='op' ) {
            var op = thing.args[0].tok.name;
            if( op=='-u' || op=='+u' ) {
                tex='\\left ( '+tex+' \\right )';
            }
        }
        return '+'+tex;
    },
    /** unary minus */
    '-u': (function(thing,texArgs,settings) {
        var tex = texArgs[0];
        if( thing.args[0].tok.type=='op' )
        {
            var op = thing.args[0].tok.name;
            if(
                op=='-u' || op=='+u' ||
                (!(op=='/' || op=='*') && jme.precedence[op]>jme.precedence['-u'])    //brackets are needed if argument is an operation which would be evaluated after negation
            ) {
                tex='\\left ( '+tex+' \\right )';
            }
        }
        else if(thing.args[0].tok.type=='number' && thing.args[0].tok.value.complex) {
            var value = thing.args[0].tok.value;
            return settings.texNumber({complex:true,re:-value.re,im:-value.im}, settings);
        }
        return '-'+tex;
    }),
    /** exponentiation */
    '^': (function(thing,texArgs,settings) {
        var tex0 = texArgs[0];
        //if left operand is an operation, it needs brackets round it. Exponentiation is right-associative, so 2^3^4 won't get any brackets, but (2^3)^4 will.
        if(thing.args[0].tok.type=='op' || (thing.args[0].tok.type=='function' && thing.args[0].tok.name=='exp') || texifyWouldBracketOpArg(thing, 0, settings)) {
            tex0 = '\\left ( ' +tex0+' \\right )';
        }
        var trigFunctions = ['cos','sin','tan','sec','cosec','cot','arcsin','arccos','arctan','cosh','sinh','tanh','cosech','sech','coth','arccosh','arcsinh','arctanh'];
        if(thing.args[0].tok.type=='function' && trigFunctions.contains(thing.args[0].tok.name) && thing.args[1].tok.type=='number' && util.isInt(thing.args[1].tok.value) && thing.args[1].tok.value>0) {
            return texOps[thing.args[0].tok.name].code + '^{'+texArgs[1]+'}' + '\\left( '+texify(thing.args[0].args[0],settings)+' \\right)';
        }
        return (tex0+'^{ '+texArgs[1]+' }');
    }),
    '*': (function(thing, texArgs, settings) {
        var s = texifyOpArg(thing,texArgs,0);
        for(var i=1; i<thing.args.length; i++ )
        {
            var left = thing.args[i-1];
            var right = thing.args[i];
            var use_symbol = false;
            if(settings.alwaystimes) {
                use_symbol = true;
            } else {
                // if we'd end up with two digits next to each other, but from different arguments, we need a times symbol
                if(util.isInt(texArgs[i-1].charAt(texArgs[i-1].length-1)) && util.isInt(texArgs[i].charAt(0)) && !texifyWouldBracketOpArg(thing,i)) {
                    use_symbol = true;
                //anything times e^(something) or (not number)^(something)
                } else if (jme.isOp(right.tok,'^') && (right.args[0].value==Math.E || right.args[0].tok.type!='number')) {
                    use_symbol = false;
                //real number times Pi or E
                } else if (right.tok.type=='number' && (right.tok.value==Math.PI || right.tok.value==Math.E || right.tok.value.complex) && left.tok.type=='number' && !(left.tok.value.complex)) {
                    use_symbol = false
                //number times a power of i
                } else if (jme.isOp(right.tok,'^') && right.args[0].tok.type=='number' && math.eq(right.args[0].tok.value,math.complex(0,1)) && left.tok.type=='number') {
                    use_symbol = false;
                // times sign when LHS or RHS is a factorial
                } else if((left.tok.type=='function' && left.tok.name=='fact') || (right.tok.type=='function' && right.tok.name=='fact')) {
                    use_symbol = true;
                //(anything except i) times i
                } else if ( !(left.tok.type=='number' && math.eq(left.tok.value,math.complex(0,1))) && right.tok.type=='number' && math.eq(right.tok.value,math.complex(0,1))) {
                    use_symbol = false;
                // anything times number, or (-anything), or an op with lower precedence than times, with leftmost arg a number
                } else if ( right.tok.type=='number'
                        ||
                            jme.isOp(right.tok,'-u')
                        ||
                        (
                            !jme.isOp(right.tok,'-u')
                            && (right.tok.type=='op' && jme.precedence[right.tok.name]<=jme.precedence['*']
                                && (right.args[0].tok.type=='number'
                                && right.args[0].tok.value!=Math.E)
                            )
                        )
                ) {
                    use_symbol = true;
                }
            }
            s += use_symbol ? ' \\times ' : ' ';
            s += texifyOpArg(thing,texArgs,i);
        }
        return s;
    }),
    '/': (function(thing,texArgs) { return ('\\frac{ '+texArgs[0]+' }{ '+texArgs[1]+' }'); }),
    '+': (function(thing,texArgs,settings) {
        var a = thing.args[0];
        var b = thing.args[1];
        if(jme.isOp(b.tok,'+u') || jme.isOp(b.tok,'-u')) {
            return texArgs[0]+' + \\left ( '+texArgs[1]+' \\right )';
        } else {
            return texArgs[0]+' + '+texArgs[1];
        }
    }),
    '-': (function(thing,texArgs,settings) {
        var a = thing.args[0];
        var b = thing.args[1];
        if(b.tok.type=='number' && b.tok.value.complex && b.tok.value.re!=0) {
            var texb = settings.texNumber(math.complex(b.tok.value.re,-b.tok.value.im), settings);
            return texArgs[0]+' - '+texb;
        }
        else{
            if(jme.isOp(b.tok,'+') || jme.isOp(b.tok,'-') || jme.isOp(b.tok,'+u') || jme.isOp(b.tok,'-u'))
                return texArgs[0]+' - \\left ( '+texArgs[1]+' \\right )';
            else
                return texArgs[0]+' - '+texArgs[1];
        }
    }),
    'dot': infixTex('\\cdot'),
    'cross': infixTex('\\times'),
    'transpose': (function(thing,texArgs) {
        var tex = texArgs[0];
        if(thing.args[0].tok.type=='op')
            tex = '\\left ( ' +tex+' \\right )';
        return (tex+'^{\\mathrm{T}}');
    }),
    '..': infixTex('\\dots'),
    'except': infixTex('\\operatorname{except}'),
    '<': infixTex('\\lt'),
    '>': infixTex('\\gt'),
    '<=': infixTex('\\leq'),
    '>=': infixTex('\\geq'),
    '<>': infixTex('\neq'),
    '=': infixTex('='),
    'and': infixTex('\\wedge'),
    'or': infixTex('\\vee'),
    'xor': infixTex('\\, \\textrm{XOR} \\,'),
    'implies': infixTex('\\to'),
    'in': infixTex('\\in'),
    '|': infixTex('|'),
    'abs': (function(thing,texArgs,settings) {
        var arg;
        if(thing.args[0].tok.type=='vector')
            arg = texVector(thing.args[0].tok.value,settings);
        else if(thing.args[0].tok.type=='function' && thing.args[0].tok.name=='vector')
            arg = texVector(thing.args[0],settings);
        else if(thing.args[0].tok.type=='matrix')
            arg = texMatrix(thing.args[0].tok.value,settings);
        else if(thing.args[0].tok.type=='function' && thing.args[0].tok.name=='matrix')
            arg = texMatrix(thing.args[0],settings);
        else
            arg = texArgs[0];
        return ('\\left | '+arg+' \\right |');
    }),
    'sqrt': (function(thing,texArgs) { return ('\\sqrt{ '+texArgs[0]+' }'); }),
    'exp': (function(thing,texArgs) { return ('e^{ '+texArgs[0]+' }'); }),
    'fact': (function(thing,texArgs)
            {
                if(thing.args[0].tok.type=='number' || thing.args[0].tok.type=='name')
                {
                    return texArgs[0]+'!';
                }
                else
                {
                    return '\\left ('+texArgs[0]+' \\right )!';
                }
            }),
    'ceil': (function(thing,texArgs) { return '\\left \\lceil '+texArgs[0]+' \\right \\rceil';}),
    'floor': (function(thing,texArgs) { return '\\left \\lfloor '+texArgs[0]+' \\right \\rfloor';}),
    'int': (function(thing,texArgs) { return ('\\int \\! '+texArgs[0]+' \\, \\mathrm{d}'+texArgs[1]); }),
    'defint': (function(thing,texArgs) { return ('\\int_{'+texArgs[2]+'}^{'+texArgs[3]+'} \\! '+texArgs[0]+' \\, \\mathrm{d}'+texArgs[1]); }),
    'diff': (function(thing,texArgs)
            {
                var degree = (thing.args[2].tok.type=='number' && thing.args[2].tok.value==1) ? '' : '^{'+texArgs[2]+'}';
                if(thing.args[0].tok.type=='name')
                {
                    return ('\\frac{\\mathrm{d}'+degree+texArgs[0]+'}{\\mathrm{d}'+texArgs[1]+degree+'}');
                }
                else
                {
                    return ('\\frac{\\mathrm{d}'+degree+'}{\\mathrm{d}'+texArgs[1]+degree+'} \\left ('+texArgs[0]+' \\right )');
                }
            }),
    'partialdiff': (function(thing,texArgs)
            {
                var degree = (thing.args[2].tok.type=='number' && thing.args[2].tok.value==1) ? '' : '^{'+texArgs[2]+'}';
                if(thing.args[0].tok.type=='name')
                {
                    return ('\\frac{\\partial '+degree+texArgs[0]+'}{\\partial '+texArgs[1]+degree+'}');
                }
                else
                {
                    return ('\\frac{\\partial '+degree+'}{\\partial '+texArgs[1]+degree+'} \\left ('+texArgs[0]+' \\right )');
                }
            }),
    'sub': (function(thing,texArgs) {
        return texArgs[0]+'_{ '+texArgs[1]+' }';
    }),
    'sup': (function(thing,texArgs) {
        return texArgs[0]+'^{ '+texArgs[1]+' }';
    }),
    'limit': (function(thing,texArgs) { return ('\\lim_{'+texArgs[1]+' \\to '+texArgs[2]+'}{'+texArgs[0]+'}'); }),
    'mod': (function(thing,texArgs) {return texArgs[0]+' \\pmod{'+texArgs[1]+'}';}),
    'perm': (function(thing,texArgs) { return '^{'+texArgs[0]+'}\\kern-2pt P_{'+texArgs[1]+'}';}),
    'comb': (function(thing,texArgs) { return '^{'+texArgs[0]+'}\\kern-1pt C_{'+texArgs[1]+'}';}),
    'root': (function(thing,texArgs) { return '\\sqrt['+texArgs[1]+']{'+texArgs[0]+'}'; }),
    'if': (function(thing,texArgs)
            {
                for(var i=0;i<3;i++)
                {
                    if(thing.args[i].args!==undefined)
                        texArgs[i] = '\\left ( '+texArgs[i]+' \\right )';
                }
                return '\\textbf{If} \\; '+texArgs[0]+' \\; \\textbf{then} \\; '+texArgs[1]+' \\; \\textbf{else} \\; '+texArgs[2];
            }),
    'switch': funcTex('\\operatorname{switch}'),
    'gcd': funcTex('\\operatorname{gcd}'),
    'lcm': funcTex('\\operatorname{lcm}'),
    'trunc': funcTex('\\operatorname{trunc}'),
    'fract': funcTex('\\operatorname{fract}'),
    'degrees': funcTex('\\operatorname{degrees}'),
    'radians': funcTex('\\operatorname{radians}'),
    'round': funcTex('\\operatorname{round}'),
    'sign': funcTex('\\operatorname{sign}'),
    'random': funcTex('\\operatorname{random}'),
    'max': funcTex('\\operatorname{max}'),
    'min': funcTex('\\operatorname{min}'),
    'precround': funcTex('\\operatorname{precround}'),
    'siground': funcTex('\\operatorname{siground}'),
    'award': funcTex('\\operatorname{award}'),
    'hour24': nullaryTex('hour24'),
    'hour': nullaryTex('hour'),
    'ampm': nullaryTex('ampm'),
    'minute': nullaryTex('minute'),
    'second': nullaryTex('second'),
    'msecond': nullaryTex('msecond'),
    'dayofweek': nullaryTex('dayofweek'),
    'sin': funcTex('\\sin'),
    'cos': funcTex('\\cos'),
    'tan': funcTex('\\tan'),
    'sec': funcTex('\\sec'),
    'cot': funcTex('\\cot'),
    'cosec': funcTex('\\csc'),
    'arccos': funcTex('\\arccos'),
    'arcsin': funcTex('\\arcsin'),
    'arctan': funcTex('\\arctan'),
    'cosh': funcTex('\\cosh'),
    'sinh': funcTex('\\sinh'),
    'tanh': funcTex('\\tanh'),
    'coth': funcTex('\\coth'),
    'cosech': funcTex('\\operatorname{cosech}'),
    'sech': funcTex('\\operatorname{sech}'),
    'arcsinh': funcTex('\\operatorname{arcsinh}'),
    'arccosh': funcTex('\\operatorname{arccosh}'),
    'arctanh': funcTex('\\operatorname{arctanh}'),
    'ln': function(thing,texArgs,settings) {
        if(thing.args[0].tok.type=='function' && thing.args[0].tok.name=='abs')
            return '\\ln '+texArgs[0];
        else
            return '\\ln \\left ( '+texArgs[0]+' \\right )';
    },
    'log': function(thing,texArgs,settings) {
        var base = thing.args.length==1 ? '10' : texArgs[1];
        return '\\log_{'+base+'} \\left ( '+texArgs[0]+' \\right )';
    },
    'vector': (function(thing,texArgs,settings) {
        return '\\left ( '+texVector(thing,settings)+' \\right )';
    }),
    'rowvector': (function(thing,texArgs,settings) {
        if(thing.args[0].tok.type!='list')
            return texMatrix({args:[{args:thing.args}]},settings,true);
        else
            return texMatrix(thing,settings,true);
    }),
    'matrix': (function(thing,texArgs,settings) {
        return texMatrix(thing,settings,true);
    }),
    'listval': (function(thing,texArgs) {
        return texArgs[0]+' \\left['+texArgs[1]+'\\right]';
    }),
    'verbatim': (function(thing,texArgs) {
        return thing.args[0].tok.value;
    }),
    'set': function(thing,texArgs,settings) {
        if(thing.args.length==1 && thing.args[0].tok.type=='list') {
            return '\\left\\{ '+texify(thing.args[0],settings)+' \\right\\}';
        } else {
            return '\\left\\{ '+texArgs.join(', ')+' \\right\\}';
        }
    }
}
/** Convert a special number to TeX, or return undefined if not a special number.
 *  @memberof Numbas.jme.display
 *  @private
 *
 *  @param {Number} n
 *  @returns {TeX}
 */
var texSpecialNumber = jme.display.texSpecialNumber = function(value) {
    var specials = jme.display.specialNumbers;
    var pvalue = Math.abs(value);
    for(var i=0;i<specials.length;i++) {
        if(pvalue==specials[i].value) {
            return (value<0 ? '-' : '') + specials[i].tex;
        }
    }
}
/** Convert a number to TeX, displaying it as a fractionm using {@link Numbas.math.rationalApproximation}
 * @memberof Numbas.jme.display
 * @private
 *
 * @param {Number} n
 * @param {Numbas.jme.display.texify_settings} settings
 * @returns {TeX}
 */
var texRationalNumber = jme.display.texRationalNumber = function(n, settings)
{
    if(n.complex)
    {
        var re = texRationalNumber(n.re, settings);
        var im = texRationalNumber(n.im, settings)+' i';
        if(n.im==0)
            return re;
        else if(n.re==0)
        {
            if(n.im==1)
                return 'i';
            else if(n.im==-1)
                return '-i';
            else
                return im;
        }
        else if(n.im<0)
        {
            if(n.im==-1)
                return re+' - i';
            else
                return re+' '+im;
        }
        else
        {
            if(n.im==1)
                return re+' + '+'i';
            else
                return re+' + '+im;
        }
    }
    else
    {
        var special = texSpecialNumber(n);
        if(special !== undefined) {
            return special;
        }
        var piD;
        if((piD = math.piDegree(n)) > 0)
            n /= Math.pow(Math.PI,piD);
        var m;
        var out = math.niceNumber(n);
        if(m = out.match(math.re_scientificNumber)) {
            var mantissa = m[1];
            var exponent = m[2];
            if(exponent[0]=='+')
                exponent = exponent.slice(1);
            return mantissa+' \\times 10^{'+exponent+'}';
        }
        var f = math.rationalApproximation(Math.abs(n));
        if(f[1]==1) {
            out = Math.abs(f[0]).toString();
        } else {
            if(settings.mixedfractions && f[0] > f[1]) {
                var properNumerator = math.mod(f[0], f[1]);
                var mixedInteger = (f[0]-properNumerator)/f[1];
                out = mixedInteger+' \\frac{'+properNumerator+'}{'+f[1]+'}';
            }
            else {
                out = '\\frac{'+f[0]+'}{'+f[1]+'}';
            }
        }
        if(n<0)
            out='-'+out;
        switch(piD)
        {
        case 0:
            return out;
        case 1:
            if(n==-1)
                return '-\\pi';
            else
                return out+' \\pi';
        default:
            if(n==-1)
                return '-\\pi^{'+piD+'}';
            else
                return out+' \\pi^{'+piD+'}';
        }
    }
}
/** Convert a number to TeX, displaying it as a decimal.
 * @memberof Numbas.jme.display
 * @private
 *
 * @param {Number} n
 * @param {Numbas.jme.display.texify_settings} settings
 * @returns {TeX}
 */
function texRealNumber(n, settings)
{
    if(n.complex)
    {
        var re = texRealNumber(n.re, settings);
        var im = texRealNumber(n.im, settings)+' i';
        if(n.im==0)
            return re;
        else if(n.re==0)
        {
            if(n.im==1)
                return 'i';
            else if(n.im==-1)
                return '-i';
            else
                return im;
        }
        else if(n.im<0)
        {
            if(n.im==-1)
                return re+' - i';
            else
                return re+' '+im;
        }
        else
        {
            if(n.im==1)
                return re+' + '+'i';
            else
                return re+' + '+im;
        }
    }
    else
    {
        var special = texSpecialNumber(n);
        if(special !== undefined) {
            return special;
        }
        var piD;
        if((piD = math.piDegree(n)) > 0)
            n /= Math.pow(Math.PI,piD);
        var out = math.niceNumber(n);
        var m;
        if(m = out.match(math.re_scientificNumber)) {
            var mantissa = m[1];
            var exponent = m[2];
            if(exponent[0]=='+')
                exponent = exponent.slice(1);
            return mantissa+' \\times 10^{'+exponent+'}';
        }
        switch(piD)
        {
        case 0:
            return out;
        case 1:
            if(n==1)
                return '\\pi';
            else if(n==-1)
                return '-\\pi';
            else
                return out+' \\pi';
        default:
            if(n==1)
                return '\\pi^{'+piD+'}';
            else if(n==-1)
                return '-\\pi^{'+piD+'}';
            else
                return out+' \\pi^{'+piD+'}';
        }
    }
}
/** Convert a vector to TeX. If `settings.rowvector` is true, then it's set horizontally.
 * @memberof Numbas.jme.display
 * @private
 *
 * @param {Array.<Number>|Numbas.jme.tree} v
 * @param {Numbas.jme.display.texify_settings} settings
 * @returns {TeX}
 */
function texVector(v,settings)
{
    var out;
    var elements;
    if(v.args) {
        elements = v.args.map(function(x){return texify(x,settings)});
    } else {
        var texNumber = settings.fractionnumbers ? texRationalNumber : texRealNumber;
        elements = v.map(function(x){return texNumber(x, settings)});
    }
    if(settings.rowvector)
        out = elements.join(' , ');
    else
        out = '\\begin{matrix} '+elements.join(' \\\\ ')+' \\end{matrix}';
    return out;
}
/** Convert a matrix to TeX.
 * @memberof Numbas.jme.display
 * @private
 *
 * @param {Array.<Array.<Number>>|Numbas.jme.tree} m
 * @param {Numbas.jme.display.texify_settings} settings
 * @param {Boolean} parens - enclose the matrix in parentheses?
 * @returns {TeX}
 */
function texMatrix(m,settings,parens)
{
    var out;
    if(m.args)
    {
        var all_lists = true;
        var rows = m.args.map(function(x) {
            if(x.tok.type=='list') {
                return x.args.map(function(y){ return texify(y,settings); });
            } else {
                all_lists = false;
            }
        })
        if(!all_lists) {
            return '\\operatorname{matrix}(' + m.args.map(function(x){return texify(x,settings);}).join(',') +')';
        }
    }
    else
    {
        var texNumber = settings.fractionnumbers ? texRationalNumber : texRealNumber;
        var rows = m.map(function(x){
            return x.map(function(y){ return texNumber(y, settings) });
        });
    }
    if(rows.length==1) {
        out = rows[0].join(', & ');
    }
    else {
        rows = rows.map(function(x) {
            return x.join(' & ');
        });
        out = rows.join(' \\\\ ');
    }
    if(parens)
        return '\\begin{pmatrix} '+out+' \\end{pmatrix}';
    else
        return '\\begin{matrix} '+out+' \\end{matrix}';
}
/** Dictionary of functions to convert specific name annotations to TeX
 *
 * @enum
 * @memberof Numbas.jme.display
 */
var texNameAnnotations = jme.display.texNameAnnotations = {
    verbatim: function(name) {    //verbatim - use to get round things like i and e being interpreted as constants
        return name;
    },
    op: function(name) {
        return '\\operatorname{'+name+'}';
    },
    vector: function(name) {
        return '\\boldsymbol{'+name+'}';
    },
    unit: function(name) {    //unit vector
        return '\\hat{'+name+'}';
    },
    dot: function(name) {        //dot on top
        return '\\dot{'+name+'}';
    },
    matrix: function(name) {
        return '\\mathrm{'+name+'}';
    }
}
texNameAnnotations.verb = texNameAnnotations.verbatim;
texNameAnnotations.v = texNameAnnotations.vector;
texNameAnnotations.m = texNameAnnotations.matrix;
/** Convert a variable name to TeX
 * @memberof Numbas.jme.display
 *
 * @param {String} name
 * @param {Array.<String>} [annotations]
 * @param {function} [longNameMacro=texttt] - function which returns TeX for a long name
 * @returns {TeX}
 */
var texName = jme.display.texName = function(name,annotations,longNameMacro)
{
    longNameMacro = longNameMacro || (function(name){ return '\\texttt{'+name+'}'; });
    var oname = name;
    function applyAnnotations(name) {
        if(!annotations) {
            return name;
        }
        for(var i=0;i<annotations.length;i++)
        {
            var annotation = annotations[i];
            if(annotation in texNameAnnotations) {
                name = texNameAnnotations[annotation](name);
            } else {
                name = '\\'+annotation+'{'+name+'}';
            }
        }
        return name;
    }
    var num_subscripts = name.length - name.replace('_','').length;
    var re_math_variable = /^([^_]*[a-zA-Z])(?:(\d+)|_(\d+)|_([^']{1,2}))?('*)$/;
    var m,isgreek;
    // if the name is a single letter or greek letter name, followed by digits, subscripts or primes
    // m[1]: the "root" name - the bit before any digits, subscripts or primes
    // m[2]: digits immediately following the root
    // m[3]: digits in a subscript
    // m[4]: one or two non-prime characters in a subscript
    // m[5]: prime characters, at the end of the name
    if((m=name.match(re_math_variable)) && (m[1].length==1 || (isgreek=greek.contains(m[1])))) {
        if(isgreek) {
            m[1] = '\\'+m[1];
        }
        name = applyAnnotations(m[1]);
        var subscript = (m[2] || m[3] || m[4]);
        if(subscript) {
            name += '_{'+subscript+'}';
        }
        name += m[5];
    } else if(!name.match(/^\\/)) {
        name = applyAnnotations(longNameMacro(name));
    }
    return name;
}
var greek = ['alpha','beta','gamma','delta','epsilon','zeta','eta','theta','iota','kappa','lambda','mu','nu','xi','omicron','pi','rho','sigma','tau','upsilon','phi','chi','psi','omega']
/** Definition of a number with a special name
 * @typedef Numbas.jme.display.special_number_definition
 * @property {Number} value
 * @property {TeX} tex - The TeX code for this number
 * @property {JME} jme - The JME code for this number
 */
/** List of numbers with special names
 *
 * @memberof Numbas.jme.display
 * @type {Array.<Numbas.jme.display.special_number_definition>}
 */
jme.display.specialNumbers = [
    {value: Math.E, tex: 'e', jme: 'e'},
    {value: Math.PI, tex: '\\pi', jme: 'pi'},
    {value: Infinity, tex: '\\infty', jme: 'infinity'}
];
/** Dictionary of functions to turn {@link Numbas.jme.types} objects into TeX strings
 *
 * @enum
 * @memberof Numbas.jme.display
 */
var typeToTeX = jme.display.typeToTeX = {
    'nothing': function(thing,tok,texArgs,settings) {
        return '\\text{nothing}';
    },
    'number': function(thing,tok,texArgs,settings) {
        return settings.texNumber(tok.value, settings);
    },
    'string': function(thing,tok,texArgs,settings) {
        if(tok.latex)
            return tok.value.replace(/\\([\{\}])/g,'$1');
        else
            return '\\textrm{'+tok.value+'}';
    },
    'boolean': function(thing,tok,texArgs,settings) {
        return tok.value ? 'true' : 'false';
    },
    range: function(thing,tok,texArgs,settings) {
        return tok.value[0]+ ' \\dots '+tok.value[1];
    },
    list: function(thing,tok,texArgs,settings) {
        if(!texArgs)
        {
            texArgs = [];
            for(var i=0;i<tok.vars;i++)
            {
                texArgs[i] = texify(tok.value[i],settings);
            }
        }
        return '\\left[ '+texArgs.join(', ')+' \\right]';
    },
    keypair: function(thing,tok,texArgs,settings) {
        var key = '\\textrm{'+tok.key+'}';
        return key+' \\colon '+texArgs[0];
    },
    dict: function(thing,tok,texArgs,settings) {
        if(!texArgs)
        {
            texArgs = [];
            if(tok.value) {
                for(var key in tok.value) {
                    texArgs.push(texify({tok: new jme.types.TKeyPair(key), args:[{tok:tok.value[key]}]},settings));
                }
            }
        }
        return '\\left[ '+texArgs.join(', ')+' \\right]';
    },
    vector: function(thing,tok,texArgs,settings) {
        return ('\\left ( '
                + texVector(tok.value,settings)
                + ' \\right )' );
    },
    matrix: function(thing,tok,texArgs,settings) {
        return '\\left ( '+texMatrix(tok.value,settings)+' \\right )';
    },
    name: function(thing,tok,texArgs,settings) {
        return texName(tok.name,tok.annotation);
    },
    special: function(thing,tok,texArgs,settings) {
        return tok.value;
    },
    conc: function(thing,tok,texArgs,settings) {
        return texArgs.join(' ');
    },
    op: function(thing,tok,texArgs,settings) {
        var name = tok.name.toLowerCase();
        var fn = name in texOps ? texOps[name] : infixTex('\\, \\operatorname{'+name+'} \\,');
        return fn(thing,texArgs,settings);
    },
    'function': function(thing,tok,texArgs,settings) {
        var lowerName = tok.name.toLowerCase();
        if(texOps[lowerName]) {
            return texOps[lowerName](thing,texArgs,settings);
        }
        else {
            function texOperatorName(name) {
                return '\\operatorname{'+name.replace(/_/g,'\\_')+'}';
            }
            return texName(tok.name,tok.annotation,texOperatorName)+' \\left ( '+texArgs.join(', ')+' \\right )';
        }
    },
    set: function(thing,tok,texArgs,settings) {
        texArgs = [];
        for(var i=0;i<tok.value.length;i++) {
            texArgs.push(texify(tok.value[i],settings));
        }
        return '\\left\\{ '+texArgs.join(', ')+' \\right\\}';
    }
}
/** Take a nested application of a single op, e.g. ((1*2)*3)*4, and flatten it so that the tree has one op two or more arguments
 */
function flatten(tree,op) {
    if(!jme.isOp(tree.tok,op)) {
        return [tree];
    }
    var args = [];
    for(var i=0;i<tree.args.length;i++) {
        args = args.concat(flatten(tree.args[i],op));
    }
    return args;
}
/** A dictionary of settings for {@link Numbas.jme.display.texify}.
 * @typedef Numbas.jme.display.texify_settings
 * @property {Boolean} fractionnumbers - Show all numbers as fractions?
 * @property {Boolean} nicenumber - Run numbers through {@link Numbas.math.niceNumber}?
 * @property {Number} accuracy - Accuracy to use when finding rational approximations to numbers. See {@link Numbas.math.rationalApproximation}.
 * @property {Boolean} rowvector - Display vectors as a horizontal list of components?
 */
/** Turn a syntax tree into a TeX string. Data types can be converted to TeX straightforwardly, but operations and functions need a bit more care.
 *
 * The idea here is that each function and op has a function associated with it which takes a syntax tree with that op at the top and returns the appropriate TeX
 *
 * @memberof Numbas.jme.display
 * @method
 *
 * @param {Numbas.jme.tree} thing
 * @param {Numbas.jme.display.texify_settings} settings
 *
 * @returns {TeX}
 */
var texify = Numbas.jme.display.texify = function(thing,settings)
{
    if(!thing)
        return '';
    if(!settings)
        settings = {};
    var tok = thing.tok || thing;
    if(jme.isOp(tok,'*')) {
        // flatten nested multiplications, so a string of consecutive multiplications can be considered together
        thing = {tok: thing.tok, args: flatten(thing,'*')};
    }
    if(thing.args)
    {
        var texArgs = [];
        for(var i=0; i<thing.args.length; i++ )
        {
            texArgs[i] = texify(thing.args[i],settings);
        }
    }
    settings.texNumber = settings.fractionnumbers ? texRationalNumber : texRealNumber;
    if(tok.type in typeToTeX) {
        return typeToTeX[tok.type](thing,tok,texArgs,settings);
    } else {
        throw(new Numbas.Error(R('jme.display.unknown token type',{type:tok.type})));
    }
}
/** Convert a special number to JME, or return undefined if not a special number.
 *  @memberof Numbas.jme.display
 *  @private
 *
 *  @param {Number} n
 *  @returns {TeX}
 */
var jmeSpecialNumber = jme.display.jmeSpecialNumber = function(value) {
    var specials = jme.display.specialNumbers;
    var pvalue = Math.abs(value);
    for(var i=0;i<specials.length;i++) {
        if(pvalue==specials[i].value) {
            return (value<0 ? '-' : '') + specials[i].jme;
        }
    }
}
/** Write a number in JME syntax as a fraction, using {@link Numbas.math.rationalApproximation}
 *
 * @memberof Numbas.jme.display
 * @private
 *
 * @param {Number} n
 * @param {Numbas.jme.display.jme_display_settings} settings - if `settings.niceNumber===false`, don't round off numbers
 * @returns {JME}
 */
var jmeRationalNumber = jme.display.jmeRationalNumber = function(n,settings)
{
    settings = settings || {};
    if(n.complex)
    {
        var re = jmeRationalNumber(n.re);
        var im = jmeRationalNumber(n.im)+'i';
        if(n.im==0)
            return re;
        else if(n.re==0)
        {
            if(n.im==1)
                return 'i';
            else if(n.im==-1)
                return '-i';
            else
                return im;
        }
        else if(n.im<0)
        {
            if(n.im==-1)
                return re+' - i';
            else
                return re+' - '+jmeRationalNumber(-n.im)+'i';
        }
        else
        {
            if(n.im==1)
                return re+' + '+'i';
            else
                return re+' + '+im;
        }
    }
    else
    {
        var special = jmeSpecialNumber(n);
        if(special !== undefined) {
            return special;
        }
        var piD;
        if((piD = math.piDegree(n)) > 0)
            n /= Math.pow(Math.PI,piD);
        var m;
        var out;
        if(settings.niceNumber===false) {
            out = n+'';
        } else {
            out = math.niceNumber(n);
        }
        if(m = out.match(math.re_scientificNumber)) {
            var mantissa = m[1];
            var exponent = m[2];
            if(exponent[0]=='+')
                exponent = exponent.slice(1);
            return mantissa+'*10^('+exponent+')';
        }
        var f = math.rationalApproximation(Math.abs(n),settings.accuracy);
        if(f[1]==1)
            out = Math.abs(f[0]).toString();
        else
            out = f[0]+'/'+f[1];
        if(n<0)
            out=' - '+out;
        switch(piD)
        {
        case 0:
            return out;
        case 1:
            return out+' pi';
        default:
            return out+' pi^'+piD;
        }
    }
}
/** Write a number in JME syntax as a decimal.
 *
 * @memberof Numbas.jme.display
 * @private
 *
 * @param {Number} n
 * @param {Numbas.jme.display.jme_display_settings} settings - if `settings.niceNumber===false`, don't round off numbers
 * @returns {JME}
 */
function jmeRealNumber(n,settings)
{
    settings = settings || {};
    if(n.complex)
    {
        var re = jmeRealNumber(n.re);
        var im = jmeRealNumber(n.im);
        if(im[im.length-1].match(/[a-zA-Z]/))
            im += '*i';
        else
            im += 'i';
        if(n.im==0)
            return re;
        else if(n.re==0)
        {
            if(n.im==1)
                return 'i';
            else if(n.im==-1)
                return '-i';
            else
                return im;
        }
        else if(n.im<0)
        {
            if(n.im==-1)
                return re+' - i';
            else
                return re+' - '+jmeRealNumber(-n.im)+'i';
        }
        else
        {
            if(n.im==1)
                return re+' + i';
            else
                return re+' + '+im;
        }
    }
    else
    {
        var special = jmeSpecialNumber(n);
        if(special !== undefined) {
            return special;
        }
        var piD;
        if((piD = math.piDegree(n)) > 0)
            n /= Math.pow(Math.PI,piD);
        var out;
        if(settings.niceNumber===false) {
            out = n+'';
        } else {
            out = math.niceNumber(n);
        }
        var m;
        if(m = out.match(math.re_scientificNumber)) {
            var mantissa = m[1];
            var exponent = m[2];
            if(exponent[0]=='+')
                exponent = exponent.slice(1);
            return mantissa+'*10^('+exponent+')';
        }
        switch(piD)
        {
        case 0:
            return out;
        case 1:
            if(n==1)
                return 'pi';
            else
                return out+' pi';
        default:
            if(n==1)
                return 'pi^'+piD;
            else
                return out+' pi^'+piD;
        }
    }
}
/** Dictionary of functions to turn {@link Numbas.jme.types} objects into JME strings
 *
 * @enum
 * @memberof Numbas.jme.display
 */
var typeToJME = Numbas.jme.display.typeToJME = {
    'nothing': function(tree,tok,bits,settings) {
        return 'nothing';
    },
    'number': function(tree,tok,bits,settings) {
        switch(tok.value)
        {
        case Math.E:
            return 'e';
        case Math.PI:
            return 'pi';
        default:
            return settings.jmeNumber(tok.value,settings);
        }
    },
    name: function(tree,tok,bits,settings) {
        return tok.name;
    },
    'string': function(tree,tok,bits,settings) {
        var str = '"'+jme.escape(tok.value)+'"';
        if(tok.latex) {
            return 'latex('+str+')';
        } else if(tok.safe) {
            return 'safe('+str+')';
        } else {
            return str;
        }
    },
    html: function(tree,tok,bits,settings) {
        var html = $(tok.value).clone().wrap('<div>').parent().html();
        html = html.replace(/"/g,'\\"');
        return 'html("'+html+'")';
    },
    'boolean': function(tree,tok,bits,settings) {
        return (tok.value ? 'true' : 'false');
    },
    range: function(tree,tok,bits,settings) {
        return tok.value[0]+'..'+tok.value[1]+(tok.value[2]==1 ? '' : '#'+tok.value[2]);
    },
    list: function(tree,tok,bits,settings) {
        if(!bits)
        {
            if(tok.value) {
                bits = tok.value.map(function(b){return treeToJME({tok:b},settings);});
            }
            else {
                bits = [];
            }
        }
        return '[ '+bits.join(', ')+' ]';
    },
    keypair: function(tree,tok,bits,settings) {
        var key = typeToJME['string'](null,{value:tok.key},[],settings);
        return key+': '+bits[0];
    },
    dict: function(tree,tok,bits,settings) {
        if(!bits)
        {
            bits = [];
            if(tok.value) {
                for(var key in tok.value) {
                    bits.push(treeToJME({tok: new jme.types.TKeyPair(key), args:[{tok:tok.value[key]}]},settings));
                }
            }
        }
        if(bits.length) {
            return '[ '+bits.join(', ')+' ]';
        } else {
            return 'dict()';
        }
    },
    vector: function(tree,tok,bits,settings) {
        return 'vector('+tok.value.map(function(n){ return settings.jmeNumber(n,settings)}).join(',')+')';
    },
    matrix: function(tree,tok,bits,settings) {
        return 'matrix('+
            tok.value.map(function(row){return '['+row.map(function(n){ return settings.jmeNumber(n,settings)}).join(',')+']'}).join(',')+')';
    },
    'function': function(tree,tok,bits,settings) {
        if(tok.name in jmeFunctions) {
            return jmeFunctions[tok.name](tree,tok,bits,settings);
        }
        if(!bits) {
            return tok.name+'()';
        } else {
            return tok.name+'('+bits.join(',')+')';
        }
    },
    op: function(tree,tok,bits,settings) {
        var op = tok.name;
        var args = tree.args, l = args.length;
        for(var i=0;i<l;i++) {
            var arg_type = args[i].tok.type;
            var arg_value = args[i].tok.value;
            var pd;
            var arg_op = null;
            if(arg_type=='op') {
                arg_op = args[i].tok.name;
            } else if(arg_type=='number' && arg_value.complex && arg_value.im!=0) {
                if(arg_value.re!=0) {
                    arg_op = arg_value.im<0 ? '-' : '+';   // implied addition/subtraction because this number will be written in the form 'a+bi'
                } else if(arg_value.im!=1) {
                    arg_op = '*';   // implied multiplication because this number will be written in the form 'bi'
                }
            } else if(arg_type=='number' && (pd = math.piDegree(args[i].tok.value))>0 && arg_value/math.pow(Math.PI,pd)>1) {
                arg_op = '*';   // implied multiplication because this number will be written in the form 'a*pi'
            } else if(arg_type=='number' && bits[i].indexOf('/')>=0) {
                arg_op = '/';   // implied division because this number will be written in the form 'a/b'
            }
            var bracketArg = arg_op!=null && op in opBrackets && opBrackets[op][i][arg_op]==true;
            if(bracketArg) {
                bits[i] = '('+bits[i]+')';
                args[i].bracketed=true;
            }
        }
        //omit multiplication symbol when not necessary
        if(op=='*') {
            //number or brackets followed by name or brackets doesn't need a times symbol
            //except <anything>*(-<something>) does
            if(!settings.alwaystimes && ((args[0].tok.type=='number' && math.piDegree(args[0].tok.value)==0 && args[0].tok.value!=Math.E) || args[0].bracketed) && (args[1].tok.type == 'name' || args[1].bracketed && !jme.isOp(tree.args[1].tok,'-u')) )
            {
                op = '';
            }
        }
        switch(op) {
        case '+u':
            op='+';
            break;
        case '-u':
            op='-';
            if(args[0].tok.type=='number' && args[0].tok.value.complex)
                return settings.jmeNumber({complex:true, re: -args[0].tok.value.re, im: -args[0].tok.value.im},settings);
            break;
        case '-':
            var b = args[1].tok.value;
            if(args[1].tok.type=='number' && args[1].tok.value.complex && args[1].tok.value.re!=0) {
                return bits[0]+' - '+settings.jmeNumber(math.complex(b.re,-b.im),settings);
            }
            op = ' - ';
            break;
        case 'and':
        case 'or':
        case 'isa':
        case 'except':
        case '+':
        case 'in':
            op=' '+op+' ';
            break;
        case 'not':
            op = 'not ';
            break;
        case 'fact':
            op = '!';
            if(!(tree.args[0].tok.type=='number' || tree.args[0].tok.type=='name')) {
                bits[0] = '('+bits[0]+')';
            }
            break;
        }
        if(l==1) {
            return tok.postfix ? bits[0]+op : op+bits[0];
        } else {
            return bits[0]+op+bits[1];
        }
    },
    set: function(tree,tok,bits,settings) {
        return 'set('+tok.value.map(function(thing){return treeToJME({tok:thing},settings);}).join(',')+')';
    },
    expression: function(tree,tok,bits,settings) {
        var expr = treeToJME(tok.tree);
        if(settings.wrapexpressions) {
            expr = 'expression("'+jme.escape(expr)+'")';
        }
        return expr;
    }
}
/** Define how to render function in JME, for special cases when the normal rendering `f(...)` isn't right.
 * @enum {function}
 * @memberof Numbas.jme.display
 */
var jmeFunctions = jme.display.jmeFunctions = {
    'dict': typeToJME.dict,
    'fact': function(tree,tok,bits,settings) {
        if(tree.args[0].tok.type=='number' || tree.args[0].tok.type=='name') {
            return bits[0]+'!';
        } else {
            return '( '+bits[0]+' )!';
        }
    }
}
/** A dictionary of settings for {@link Numbas.jme.display.treeToJME}.
 * @typedef Numbas.jme.display.jme_display_settings
 * @property {Boolean} fractionnumbers - Show all numbers as fractions?
 * @property {Boolean} niceNumber - Run numbers through {@link Numbas.math.niceNumber}?
 * @property {Boolean} wrapexpressions - Wrap TExpression tokens in `expression("")`?
 * @property {Number} accuracy - Accuracy to use when finding rational approximations to numbers. See {@link Numbas.math.rationalApproximation}.
 */
/** Turn a syntax tree back into a JME expression (used when an expression is simplified)
 * @memberof Numbas.jme.display
 * @method
 *
 * @param {Numbas.jme.tree} tree
 * @param {Numbas.jme.display.jme_display_settings} settings
 * @returns {JME}
 */
var treeToJME = jme.display.treeToJME = function(tree,settings)
{
    if(!tree)
        return '';
    settings = util.copyobj(settings || {}, true);
    var args=tree.args, l;
    if(args!==undefined && ((l=args.length)>0))
    {
        var bits = args.map(function(i){return treeToJME(i,settings)});
    }
    settings.jmeNumber = settings.fractionnumbers ? jmeRationalNumber : jmeRealNumber;
    var tok = tree.tok;
    if(tok.type in typeToJME) {
        return typeToJME[tok.type](tree,tok,bits,settings);
    } else {
        throw(new Numbas.Error(R('jme.display.unknown token type',{type:tok.type})));
    }
}
/** Does each argument (of an operation) need brackets around it?
 *
 * Arrays consisting of one object for each argument of the operation
 * @enum
 * @memberof Numbas.jme.display
 * @private
 */
var opBrackets = Numbas.jme.display.opBrackets = {
    '+u':[{}],
    '-u':[{'+':true,'-':true}],
    '+': [{},{}],
    '-': [{},{'+':true,'-':true}],
    '*': [{'+u':true,'-u':true,'+':true, '-':true, '/':true},{'+u':true,'-u':true,'+':true, '-':true, '/':true}],
    '/': [{'+u':true,'-u':true,'+':true, '-':true, '*':false},{'+u':true,'-u':true,'+':true, '-':true, '*':true}],
    '^': [{'+u':true,'-u':true,'+':true, '-':true, '*':true, '/':true, '^': true},{'+u':true,'-u':true,'+':true, '-':true, '*':true, '/':true}],
    'and': [{'or':true, 'xor':true},{'or':true, 'xor':true}],
    'or': [{'xor':true},{'xor':true}],
    'xor':[{},{}],
    '=': [{},{}]
};

function align(name,items) {
    function centre(line,n) {
        if(line.length>=n) {
            return line;
        }
        var npad = (n-line.length)/2;
        var nlpad = Math.floor(npad);
        var nrpad = Math.ceil(npad);
        for(var i=0;i<nlpad;i++) {
            line = ' '+line;
        }
        for(var i=0;i<nrpad;i++) {
            line = line+' ';
        }
        return line;
    }
    
    var item_lines = items.map(function(item){return item.split('\n')});
    var item_widths = item_lines.map(function(lines) {return lines.reduce(function(m,l){return Math.max(l.length,m)},0)});
    console.log(item_widths);
    var num_lines = item_lines.reduce(function(t,ls){return Math.max(ls.length,t)},0);
    item_lines = item_lines.map(function(lines,i) {
        var w = item_widths[i];
        var o = [];
        for(var j=0;j<num_lines;j++) {
            var l = lines[j] || '';
            for(var i=l.length;i<w;i++) {
                l += ' ';
            }
            o.push(l);
        }
        return o;
    });
    var bottom_lines = [];
    for(var i=0;i<num_lines;i++) {
        bottom_lines.push(item_lines.map(function(lines){return lines[i]}).join('  '));
    }
    var bottom_line = bottom_lines.join('\n');
    var width = item_widths.reduce(function(t,w){return t+w},0)+2*(items.length-1);
    var ci = Math.floor(width/2-0.5);
    var top_line = '';
    top_line = centre(name,width);
    var middle_line;
    if(items.length==1) {
        middle_line = '';
        for(var i=0;i<width;i++) {
            middle_line += i==ci ? '│' : ' ';
        }
    } else {
        middle_line = items.map(function(rarg,i) {
            var s = '';
            var mid = Math.floor(item_widths[i]/2-0.5);
            for(var j=0;j<item_widths[i];j++) {
                if(i==0) {
                    s += j<mid ? ' ' : j==mid ? '┌' : '─';
                } else if(i==items.length-1) {
                    s += j<mid ? '─' : j==mid ? '┐' : ' ';
                } else {
                    s += j==mid ? '┬' : '─';
                }
            }
            return s;
        }).join('──');
    }
    var top_joins = {
        '│': '│',
        '┌': '├',
        '┐': '┤',
        '─': '┴',
        '┬': '┼'
    }
    var mid = top_joins[middle_line[ci]];
    middle_line = middle_line.slice(0,ci)+mid+middle_line.slice(ci+1);
    if(top_line.length>bottom_line.length) {
        middle_line = centre(middle_line,name.length);
        bottom_line = centre(bottom_line,name.length);
    }
    return [top_line,middle_line,bottom_line].join('\n');
}

/** Display a tree as a diagram using
 * @param {Numbas.jme.tree} tree
 * @returns {String}
 */
var tree_diagram = Numbas.jme.display.tree_diagram = function(tree) {
    switch(tree.tok.type) {
        case 'op':
        case 'function':
            var args = tree.args.map(function(arg){ return tree_diagram(arg); });
            console.log(treeToJME(tree));
            return align(tree.tok.name, args);
        default:
            return treeToJME(tree);
    }
};

/** For backwards compatibility, copy references from some Numbas.jme.rules members to Numbas.jme.display.
 *  These used to belong to Numbas.jme.display, but were moved into a separate file.
 */
['Rule','getCommutingTerms','matchTree','matchExpression','simplificationRules','compileRules'].forEach(function(name) {
    jme.display[name] = jme.rules[name];
});
});

Numbas.queueScript('jme-rules',['base','math','jme-base','util'],function() {
/** @file Code to do with JME pattern-matching rules.
 *
 * Provides {@link Numbas.jme.rules}
 */
/** @namespace Numbas.jme.rules */
var math = Numbas.math;
var jme = Numbas.jme;
var util = Numbas.util;
jme.rules = {};
/** Simplification rule
 * @memberof Numbas.jme.rules
 * @constructor
 *
 * @param {JME} pattern - expression pattern to match. Variables will match any sub-expression.
 * @param {JME[]} conditions - conditions as JME expressions on the matched variables, which must all evaluate to true for the rule to match.
 * @param {JME} result - expression pattern to rewrite to.
 *
 * @property {JME} patternString - the JME string defining the pattern to match
 * @property {JME} resultString - the JME string defining the result of the rule
 * @property {JME} conditionStrings - JME strings defining the conditions
 * @property {Numbas.jme.tree} tree - `patternString` compiled to a syntax tree
 * @property {Numbas.jme.tree} result - `result` compiled to a syntax tree
 * @property {Numbas.jme.tree[]} conditions `conditions` compiled to syntax trees
 */
var Rule = jme.rules.Rule = function(pattern,conditions,result,name)
{
    this.name = name;
    this.patternString = pattern;
    this.tree = jme.compile(pattern,{},true);
    this.resultString = result;
    this.result = jme.compile(result,{},true);
    this.conditionStrings = conditions.slice();
    this.conditions = [];
    for(var i=0;i<conditions.length;i++)
    {
        this.conditions.push(jme.compile(conditions[i],{},true));
    }
}
Rule.prototype = /** @lends Numbas.jme.rules.Rule.prototype */ {
    /** Match a rule on given syntax tree.
     * @memberof Numbas.jme.rules.Rule.prototype
     * @param {Numbas.jme.tree} exprTree - the syntax tree to test
     * @param {Numbas.jme.Scope} scope - used when checking conditions
     * @returns {Boolean|Numbas.jme.rules.jme_pattern_match} - `false` if no match, or a dictionary of matched subtrees
     */
    match: function(exprTree,scope)
    {
        //see if expression matches rule
        var match = matchTree(this.tree,exprTree);
        if(match==false)
            return false;
        //if expression matches rule, then match is a dictionary of matched variables
        //check matched variables against conditions
        if(this.matchConditions(match,scope))
            return match;
        else
            return false;
    },
    matchAll: function(exprTree,scope) {
        var r = this;
        var matches = matchAllTree(this.tree,exprTree);
        return matches.filter(function(match) {
            return r.matchConditions(match,scope);
        });
    },
    /** Check that a matched pattern satisfies all the rule's conditions
     * @memberof Numbas.jme.rules.Rule.prototype
     * @param {Numbas.jme.rules.jme_pattern_match} match
     * @param {Numbas.jme.Scope} scope
     * @returns {Boolean}
     */
    matchConditions: function(match,scope)
    {
        scope = new Numbas.jme.Scope(scope);
        for(var i=0;i<this.conditions.length;i++)
        {
            var condition_tree = Numbas.util.copyobj(this.conditions[i],true);
            condition_tree = jme.substituteTree(condition_tree,new jme.Scope([{variables:match}]));
            try {
                var result = scope.evaluate(condition_tree, null, true);
                if(result.value==false)
                    return false;
            } catch(e) {
                return false;
            }
        }
        return true;
    }
}
var endTermNames = {
    '??':true,
    'm_nothing':true,
    'm_number': true
}
function isEndTerm(term) {
    while(term.tok.type=='function' && /^m_(?:all|pm|not|commute)$/.test(term.tok.name) || jme.isOp(term.tok,';')) {
        term = term.args[0];
    }
    if(term.tok.type=='function' && term.tok.name=='m_any') {
        for(var i=0;i<term.args.length;i++) {
            if(isEndTerm(term.args[i])) {
                return true;
            }
        }
        return false;
    }
    return term.tok.type=='name' && endTermNames[term.tok.name];
}
/** Given a tree representing a series of terms t1 <op> t2 <op> t3 <op> ..., return the terms as a list.
 * @param {Numbas.jme.tree} tree
 * @param {String} op
 * @param {String[]} names
 * @returns {Object} - {terms: a list of subtrees, termnames: the match names set in each term}
 */
var getCommutingTerms = Numbas.jme.rules.getCommutingTerms = function(tree,op,names) {
    if(names===undefined) {
        names = [];
    }
    if(op=='+' && jme.isOp(tree.tok,'-')) {
        tree = {tok: new jme.types.TOp('+'), args: [tree.args[0],{tok: new jme.types.TOp('-u'), args: [tree.args[1]]}]};
    }
    if(!tree.args || tree.tok.name!=op) {
        return {terms: [tree], termnames: names.slice()};
    }
    var terms = [];
    var termnames = [];
    var rest = [];
    var restnames = [];
    for(var i=0; i<tree.args.length;i++) {
        var arg = tree.args[i];
        var oarg = arg;
        var argnames = names.slice();
        while(jme.isOp(arg.tok,';')) {
            argnames.push(arg.args[1].tok.name);
            arg = arg.args[0];
        }
        if(jme.isOp(arg.tok,op) || (op=='+' && jme.isOp(arg.tok,'-'))) {
            var sub = getCommutingTerms(arg,op,argnames);
            terms = terms.concat(sub.terms);
            termnames = termnames.concat(sub.termnames);
        } else if(jme.isName(arg.tok,'?') || isEndTerm(arg)) {
            rest.push(arg);
            restnames.push(argnames);
        } else {
            terms.push(arg);
            termnames.push(argnames);
        }
    }
    if(rest.length) {
        terms = terms.concat(rest);
        termnames = termnames.concat(restnames);
    }
    return {terms: terms, termnames: termnames};
}
/** A dictionary representing the results of a JME pattern match.
 * Maps variable names to trees.
 * @typedef Numbas.jme.rules.jme_pattern_match
 * @type Object.<Numbas.jme.tree>
 * @see {Numbas.jme.rules#matchTree}
 */
/** Recursively check whether `exprTree` matches `ruleTree`. Variables in `ruleTree` match any subtree.
 * @memberof Numbas.jme.rules
 *
 * @param {Numbas.jme.tree} ruleTree
 * @param {Numbas.jme.tree} exprTree
 * @param {Boolean} doCommute - take commutativity of operations into account, e.g. terms of a sum can be in any order.
 * @returns {Boolean|Numbas.jme.rules.jme_pattern_match} - `false` if no match, otherwise a dictionary of subtrees matched to variable names
 */
var matchTree = jme.rules.matchTree = function(ruleTree,exprTree,doCommute) {
    if(doCommute===undefined) {
        doCommute = false;
    }
    if(!exprTree)
        return false;
    var ruleTok = ruleTree.tok;
    var exprTok = exprTree.tok;
    if(jme.isOp(ruleTok,';')) {
        if(ruleTree.args[1].tok.type!='name') {
            throw(new Numbas.Error('jme.matchTree.group name not a name'));
        }
        var name = ruleTree.args[1].tok.name;
        var m = matchTree(ruleTree.args[0],exprTree,doCommute);
        if(m) {
            m[name] = exprTree;
            return m;
        } else {
            return false;
        }
    }
    if(ruleTok.type=='name')
    {
        switch(ruleTok.name) {
            case '?':
            case '??':
                return {};
            case 'm_number':
                return exprTok.type=='number' ? {} : false;
        }
    }
    if(ruleTok.type=='function') {
        switch(ruleTok.name) {
            case 'm_any':
                for(var i=0;i<ruleTree.args.length;i++) {
                    var m;
                    if(m=matchTree(ruleTree.args[i],exprTree,doCommute)) {
                        return m;
                    }
                }
                return false;
            case 'm_all':
                return matchTree(ruleTree.args[0],exprTree,doCommute);
            case 'm_pm':
                if(jme.isOp(exprTok,'-u')) {
                    return matchTree({tok: new jme.types.TOp('-u'),args: [ruleTree.args[0]]},exprTree,doCommute);
                } else {
                    return matchTree(ruleTree.args[0],exprTree,doCommute);
                }
            case 'm_not':
                if(!matchTree(ruleTree.args[0],exprTree,doCommute)) {
                    return {};
                } else {
                    return false;
                }
            case 'm_and':
                var d = {};
                for(var i=0;i<ruleTree.args.length;i++) {
                    var m = matchTree(ruleTree.args[i],exprTree,doCommute);
                    if(m) {
                        for(var name in m) {
                            d[name] = m[name];
                        }
                    } else {
                        return false;
                    }
                }
                return d;
            case 'm_uses':
                var vars = jme.findvars(exprTree);
                for(var i=0;i<ruleTree.args.length;i++) {
                    var name = ruleTree.args[i].tok.name;
                    if(!vars.contains(name)) {
                        return false;
                    }
                }
                return {};
            case 'm_commute':
                return matchTree(ruleTree.args[0],exprTree,true);
            case 'm_type':
                var wantedType = ruleTree.args[0].tok.name || ruleTree.args[0].tok.value;
                if(exprTok.type==wantedType) {
                    return {};
                } else {
                    return false;
                }
        }
    }
    if(jme.isName(ruleTok,'m_nothing')) {
        return false;
    } else if(jme.isName(ruleTok,'m_number')) {
        if(exprTok.type=='number') {
            return {};
        } else {
            return false;
        }
    }
    if(ruleTok.type!='op' && ruleTok.type != exprTok.type)
    {
        return false;
    }
    switch(ruleTok.type)
    {
    case 'number':
        if( !math.eq(ruleTok.value,exprTok.value) ) {
            return false;
        } else {
            return {};
        }
    case 'string':
    case 'boolean':
    case 'special':
    case 'range':
        if(ruleTok.value != exprTok.value) {
            return false;
        } else {
            return {};
        }
    case 'function':
    case 'op':
        var d = {};
        if(doCommute && jme.commutative[ruleTok.name]) {
            var commutingOp = ruleTok.name;
            var ruleTerms = getCommutingTerms(ruleTree,commutingOp);
            var exprTerms = getCommutingTerms(exprTree,commutingOp);
            var rest = [];
            var namedTerms = {};
            var matchedRules = [];
            var termMatches = [];
            for(var i=0; i<exprTerms.terms.length; i++) {
                var m = null;
                var matched = false;
                for(var j=0; j<ruleTerms.terms.length; j++) {
                    var ruleTerm = ruleTerms.terms[j];
                    m = matchTree(ruleTerm,exprTerms.terms[i],doCommute);
                    if((!matchedRules[j] || ruleTerm.tok.name=='m_all') && m) {
                        matched = true;
                        matchedRules[j] = true;
                        for(var name in m) {
                            if(!namedTerms[name]) {
                                namedTerms[name] = [];
                            }
                            namedTerms[name].push(m[name]);
                        }
                        var names = ruleTerms.termnames[j];
                        if(names) {
                            for(var k=0;k<names.length;k++) {
                                var name = names[k];
                                if(!namedTerms[name]) {
                                    namedTerms[name] = [];
                                }
                                namedTerms[name].push(exprTerms.terms[i]);
                            }
                        }
                        break;
                    }
                }
                if(!matched) {
                    return false;
                }
            }
            for(var i=0;i<ruleTerms.terms.length;i++) {
                var term = ruleTerms.terms[i];
                if(!isEndTerm(term) && !matchedRules[i]) {
                    return false;
                }
            }
            for(var name in namedTerms) {
                var terms = namedTerms[name];
                var sub = terms[0];
                for(var i=1;i<terms.length;i++) {
                    var op = new jme.types.TOp(commutingOp);
                    sub = {tok: op, args: [sub,terms[i]]};
                }
                d[name] = sub;
            }
            return d;
        } else {
            if(ruleTok.type!=exprTok.type || ruleTok.name!=exprTok.name) {
                return false;
            }
            var i = 0;
            var j = 0;
            for(var i=0;i<ruleTree.args.length;i++)
            {
                if(jme.isFunction(ruleTree.args[i].tok,'m_all')) {
                    while(j<exprTree.args.length) {
                        var m = matchTree(ruleTree.args[i],exprTree.args[i],doCommute);
                        if(!m) {
                            break;
                        }
                        for(var x in m) {
                            d[x]=m[x];
                        }
                        j += 1;
                    }
                } else if(jme.isName(ruleTree.args[i].tok,'m_nothing')) {
                    continue;
                } else {
                    var m = matchTree(ruleTree.args[i],exprTree.args[j],doCommute);
                    if(m===false) {
                        return false;
                    } else {
                        for(var x in m) {
                            d[x]=m[x];
                        }
                        j += 1;
                    }
                }
            }
            // if not all terms in the rule have been matched, the rule doesn't match
            if(j<i) {
                return false;
            }
            return d
        }
    case 'name':
        if(ruleTok.name.toLowerCase()==exprTok.name.toLowerCase()) {
            return {};
        } else {
            return false;
        }
    default:
        return {};
    }
}
var matchAllTree = jme.rules.matchAllTree = function(ruleTree,exprTree,doCommute) {
    var matches = [];
    var m = matchTree(ruleTree,exprTree,doCommute);
    if(m) {
        matches = [m];
    }
    if(exprTree.args) {
        exprTree.args.forEach(function(arg) {
            var submatches = matchAllTree(ruleTree,arg,doCommute);
            matches = matches.concat(submatches);
        });
    }
    return matches;
}
/** Match expression against a pattern. Wrapper for {@link Numbas.jme.rules.matchTree}
 *
 * @memberof Numbas.jme.rules
 * @method
 *
 * @param {JME} pattern
 * @param {JME} expr
 * @param {Boolean} doCommute
 *
 * @returns {Boolean|Numbas.jme.rules.jme_pattern_match} - `false` if no match, otherwise a dictionary of subtrees matched to variable names
 */
var matchExpression = jme.rules.matchExpression = function(pattern,expr,doCommute) {
    pattern = jme.compile(pattern);
    expr = jme.compile(expr);
    return matchTree(pattern,expr,doCommute);
}
/** Flags used to control the behaviour of JME display functions.
 * Values are `undefined` so they can be overridden
 * @memberof Numbas.jme.rules
 */
var displayFlags = jme.rules.displayFlags = {
    fractionnumbers: undefined,
    rowvector: undefined,
    alwaystimes: undefined,
    mixedfractions: undefined
};
/** Flags used in JME simplification rulesets
 * @type Object.<Boolean>
 * @typedef Numbas.jme.rules.ruleset_flags
 * @property {Boolean} fractionnumbers - Show all numbers as fractions?
 * @property {Boolean} rowvector - Display vectors as a horizontal list of components?
 * @property {Boolean} alwaystimes - Always show the multiplication symbol between multiplicands?
 * @see Numbas.jme.rules.Ruleset
 */
/** Set of simplification rules
 * @constructor
 * @memberof Numbas.jme.rules
 * @param {Numbas.jme.rules.Rule[]} rules
 * @param {Numbas.jme.rules.ruleset_flags} flags
 */
var Ruleset = jme.rules.Ruleset = function(rules,flags) {
    this.rules = rules;
    this.flags = util.extend_object({},displayFlags,flags);
}
Ruleset.prototype = /** @lends Numbas.jme.rules.Ruleset.prototype */ {
    /** Test whether flag is set
     * @memberof Numbas.jme.rules.Ruleset.prototype
     */
    flagSet: function(flag) {
        flag = flag.toLowerCase();
        if(this.flags.hasOwnProperty(flag))
            return this.flags[flag];
        else
            return false;
    }
}
var ruleSort = util.sortBy(['patternString','resultString','conditionStrings']);
function mergeRulesets(r1,r2) {
    var rules = r1.rules.merge(r2.rules,ruleSort);
    var flags = util.extend_object({},r1.flags,r2.flags);
    return new Ruleset(rules, flags);
}
/** Collect a ruleset together from a list of ruleset names, or rulesets.
 * @param {String|Array.<String|Numbas.jme.rules.Ruleset>} set - A comma-separated string of ruleset names, or an array of names/Ruleset objects.
 * @param {Object.<Numbas.jme.rules.Ruleset>} scopeSets - Dictionary of rulesets defined in the current scope.
 * @returns Numbas.jme.rules.Ruleset
 */
var collectRuleset = jme.rules.collectRuleset = function(set,scopeSets)
{
    scopeSets = util.copyobj(scopeSets);
    if(!set)
        return new Ruleset([],{});
    if(!scopeSets)
        throw(new Numbas.Error('jme.display.collectRuleset.no sets'));
    var rules = [];
    var flags = {};
    if(typeof(set)=='string') {
        set = set.split(',');
        set.splice(0,0,'basic');
    }
    else {
        flags = util.extend_object(flags,set.flags);
        if(set.rules)
            set = set.rules;
    }
    for(var i=0; i<set.length; i++ )
    {
        if(typeof(set[i])=='string')
        {
            var m = /^\s*(!)?(.*)\s*$/.exec(set[i]);
            var neg = m[1]=='!' ? true : false;
            var name = m[2].trim().toLowerCase();
            if(name in displayFlags)
            {
                flags[name]= !neg;
            }
            else if(name.length>0)
            {
                if(!(name in scopeSets))
                {
                    throw(new Numbas.Error('jme.display.collectRuleset.set not defined',{name:name}));
                }
                var sub = collectRuleset(scopeSets[name],scopeSets);
                flags = util.extend_object(flags,sub.flags);
                scopeSets[name] = sub;
                if(neg)
                {
                    for(var j=0; j<sub.rules.length; j++)
                    {
                        if((m=rules.indexOf(sub.rules[j]))>=0)
                        {
                            rules.splice(m,1);
                        }
                    }
                }
                else
                {
                    for(var j=0; j<sub.rules.length; j++)
                    {
                        if(!(rules.contains(sub.rules[j])))
                        {
                            rules.push(sub.rules[j]);
                        }
                    }
                }
            }
        }
        else
            rules.push(set[i]);
    }
    return new Ruleset(rules,flags);
}
/** Built-in simplification rules
 * @enum {Numbas.jme.rules.Rule[]}
 * @memberof Numbas.jme.rules
 */
var simplificationRules = jme.rules.simplificationRules = {
    basic: [
        ['?;x',['x isa "number"','x<0'],'-eval(-x)'],   // the value of a TNumber should be non-negative - pull the negation out as unary minus
        ['+(?;x)',[],'x'],                    //get rid of unary plus
        ['?;x+(-?;y)',[],'x-y'],            //plus minus = minus
        ['?;x+?;y',['y isa "number"','y<0'],'x-eval(-y)'],
        ['?;x-?;y',['y isa "number"','y<0'],'x+eval(-y)'],
        ['?;x-(-?;y)',[],'x+y'],            //minus minus = plus
        ['-(-?;x)',[],'x'],                //unary minus minus = plus
        ['-?;x',['x isa "complex"','re(x)<0'],'eval(-x)'],
        ['?;x+?;y',['x isa "number"','y isa "complex"','re(y)=0'],'eval(x+y)'],
        ['-?;x+?;y',['x isa "number"','y isa "complex"','re(y)=0'],'-eval(x-y)'],
        ['(-?;x)/?;y',[],'-(x/y)'],            //take negation to left of fraction
        ['?;x/(-?;y)',[],'-(x/y)'],
        ['(-?;x)*?;y',['not (x isa "complex")'],'-(x*y)'],            //take negation to left of multiplication
        ['?;x*(-?;y)',['not (y isa "complex")'],'-(x*y)'],
        ['?;x+(?;y+?;z)',[],'(x+y)+z'],        //make sure sums calculated left-to-right
        ['?;x-(?;y+?;z)',[],'(x-y)-z'],
        ['?;x+(?;y-?;z)',[],'(x+y)-z'],
        ['?;x-(?;y-?;z)',[],'(x-y)+z'],
        ['(?;x*?;y)*?;z',[],'x*(y*z)'],        //make sure multiplications go right-to-left
        ['?;n*i',['n isa "number"'],'eval(n*i)'],            //always collect multiplication by i
        ['i*?;n',['n isa "number"'],'eval(n*i)']
    ],
    unitFactor: [
        ['1*?;x',[],'x'],
        ['?;x*1',[],'x']
    ],
    unitPower: [
        ['?;x^1',[],'x']
    ],
    unitDenominator: [
        ['?;x/1',[],'x']
    ],
    zeroFactor: [
        ['?;x*0',[],'0'],
        ['0*?;x',[],'0'],
        ['0/?;x',[],'0']
    ],
    zeroTerm: [
        ['0+?;x',[],'x'],
        ['?;x+0',[],'x'],
        ['?;x-0',[],'x'],
        ['0-?;x',[],'-x']
    ],
    zeroPower: [
        ['?;x^0',[],'1']
    ],
    noLeadingMinus: [
        ['-?;x+?;y',[],'y-x'],                                            //don't start with a unary minus
        ['-0',[],'0']
    ],
    collectNumbers: [
        ['-?;x-?;y',['x isa "number"','y isa "number"'],'-(x+y)'],                                        //collect minuses
        ['?;n+?;m',['n isa "number"','m isa "number"'],'eval(n+m)'],    //add numbers
        ['?;n-?;m',['n isa "number"','m isa "number"'],'eval(n-m)'],    //subtract numbers
        ['?;n+?;x',['n isa "number"','!(x isa "number")'],'x+n'],        //add numbers last
        ['(?;x+?;n)+?;m',['n isa "number"','m isa "number"'],'x+eval(n+m)'],    //collect number sums
        ['(?;x-?;n)+?;m',['n isa "number"','m isa "number"'],'x+eval(m-n)'],
        ['(?;x+?;n)-?;m',['n isa "number"','m isa "number"'],'x+eval(n-m)'],
        ['(?;x-?;n)-?;m',['n isa "number"','m isa "number"'],'x-eval(n+m)'],
        ['(?;x+?;n)+?;y',['n isa "number"'],'(x+y)+n'],                        //shift numbers to right hand side
        ['(?;x+?;n)-?;y',['n isa "number"'],'(x-y)+n'],
        ['(?;x-?;n)+?;y',['n isa "number"'],'(x+y)-n'],
        ['(?;x-?;n)-?;y',['n isa "number"'],'(x-y)-n'],
        ['?;n*?;m',['n isa "number"','m isa "number"'],'eval(n*m)'],        //multiply numbers
        ['?;x*?;n',['n isa "number"','!(x isa "number")','n<>i'],'n*x'],            //shift numbers to left hand side
        ['?;m*(?;n*?;x)',['m isa "number"','n isa "number"'],'eval(n*m)*x']
    ],
    simplifyFractions: [
        ['?;n/?;m',['n isa "number"','m isa "number"','gcd_without_pi_or_i(n,m)>1'],'eval(n/gcd_without_pi_or_i(n,m))/eval(m/gcd_without_pi_or_i(n,m))'],            //cancel simple fraction
        ['(?;n*?;x)/?;m',['n isa "number"','m isa "number"','gcd_without_pi_or_i(n,m)>1'],'(eval(n/gcd_without_pi_or_i(n,m))*x)/eval(m/gcd_without_pi_or_i(n,m))'],    //cancel algebraic fraction
        ['?;n/(?;m*?;x)',['n isa "number"','m isa "number"','gcd_without_pi_or_i(n,m)>1'],'eval(n/gcd_without_pi_or_i(n,m))/(eval(m/gcd_without_pi_or_i(n,m))*x)'],
        ['(?;n*?;x)/(?;m*?;y)',['n isa "number"','m isa "number"','gcd_without_pi_or_i(n,m)>1'],'(eval(n/gcd_without_pi_or_i(n,m))*x)/(eval(m/gcd_without_pi_or_i(n,m))*y)'],
        ['?;n/?;m',['n isa "complex"','m isa "complex"','re(n)=0','re(m)=0'],'eval(n/i)/eval(m/i)']            // cancel i when numerator and denominator are both purely imaginary
    ],
    zeroBase: [
        ['0^?;x',[],'0']
    ],
    constantsFirst: [
        ['?;x*?;n',['n isa "number"','!(x isa "number")','n<>i'],'n*x'],
        ['?;x*(?;n*?;y)',['n isa "number"','n<>i','!(x isa "number")'],'n*(x*y)']
    ],
    sqrtProduct: [
        ['sqrt(?;x)*sqrt(?;y)',[],'sqrt(x*y)']
    ],
    sqrtDivision: [
        ['sqrt(?;x)/sqrt(?;y)',[],'sqrt(x/y)']
    ],
    sqrtSquare: [
        ['sqrt(?;x^2)',[],'x'],
        ['sqrt(?;x)^2',[],'x'],
        ['sqrt(?;n)',['n isa "number"','isint(sqrt(n))'],'eval(sqrt(n))']
    ],
    trig: [
        ['sin(?;n)',['n isa "number"','isint(2*n/pi)'],'eval(sin(n))'],
        ['cos(?;n)',['n isa "number"','isint(2*n/pi)'],'eval(cos(n))'],
        ['tan(?;n)',['n isa "number"','isint(n/pi)'],'0'],
        ['cosh(0)',[],'1'],
        ['sinh(0)',[],'0'],
        ['tanh(0)',[],'0']
    ],
    trigPowers: [
        ['sin^(?;n)(?;x)',[],'sin(x)^n']
    ],
    otherNumbers: [
        ['?;n^?;m',['n isa "number"','m isa "number"'],'eval(n^m)']
    ],
    cancelTerms: [
        // x+y or rest+x+y
        ['(?;rest+?;n*?;x) + ?;m*?;y',['n isa "number"','m isa "number"','canonical_compare(x,y)=0'],'rest+eval(n+m)*x'],
        ['(?;rest+?;n*?;x) + ?;y',['n isa "number"','canonical_compare(x,y)=0'],'rest+eval(n+1)*x'],
        ['(?;rest+?;x) + ?;n*?;y',['n isa "number"','canonical_compare(x,y)=0'],'rest+eval(n+1)*x'],
        ['(?;rest+?;x) + ?;y',['canonical_compare(x,y)=0'],'rest+2*x'],
        ['?;n*?;x+?;m*?;y',['n isa "number"','m isa "number"','canonical_compare(x,y)=0'],'eval(n+m)*x'],
        ['?;n*?;x+?;y',['n isa "number"','canonical_compare(x,y)=0'],'eval(n+1)*x'],
        ['-?;x+?;n*?;y',['n isa "number"','canonical_compare(x,y)=0'],'eval(n-1)*x'],
        ['-?;x+?;y',['canonical_compare(x,y)=0'],'0*x'],
        ['?;x+?;n*?;y',['n isa "number"','canonical_compare(x,y)=0'],'eval(n+1)*x'],
        ['?;x+?;y',['canonical_compare(x,y)=0'],'2*x'],
        // x-y or rest+x-y
        ['(?;rest+?;n*?;x) - ?;m*?;y',['n isa "number"','m isa "number"','canonical_compare(x,y)=0'],'rest+eval(n-m)*x'],
        ['(?;rest+?;n*?;x) - ?;y',['n isa "number"','canonical_compare(x,y)=0'],'rest+eval(n-1)*x'],
        ['(?;rest+?;x) - ?;n*?;y',['n isa "number"','canonical_compare(x,y)=0'],'rest+eval(1-n)*x'],
        ['(?;rest+?;x) - ?;y',['canonical_compare(x,y)=0'],'rest+0*x'],
        ['?;n*?;x-?;m*?;y',['n isa "number"','m isa "number"','canonical_compare(x,y)=0'],'eval(n-m)*x'],
        ['?;n*?;x-?;y',['n isa "number"','canonical_compare(x,y)=0'],'eval(n-1)*x'],
        ['-?;x-?;n*?;y',['n isa "number"','canonical_compare(x,y)=0'],'eval(-1-n)*x'],
        ['-?;x-?;y',['canonical_compare(x,y)=0'],'-2*x'],
        ['-(?;n*?;x)-?;m*?;y',['n isa "number"','m isa "number"','canonical_compare(x,y)=0'],'eval(-n-m)*x'],
        ['-(?;n*?;x)-?;y',['n isa "number"','canonical_compare(x,y)=0'],'eval(-n-1)*x'],
        ['?;x-?;n*?;y',['n isa "number"','canonical_compare(x,y)=0'],'eval(1-n)*x'],
        ['?;x-?;y',['canonical_compare(x,y)=0'],'0*x'],
        // rest-x-y or rest-x+y
        ['(?;rest-?;n*?;x) + ?;m*?;y',['n isa "number"','m isa "number"','canonical_compare(x,y)=0'],'rest+eval(m-n)*x'],
        ['(?;rest-?;n*?;x) + ?;y',['n isa "number"','canonical_compare(x,y)=0'],'rest+eval(1-n)*x'],
        ['(?;rest-?;x) + ?;n*?;y',['n isa "number"','canonical_compare(x,y)=0'],'rest+eval(1-n)*x'],
        ['(?;rest-?;n*?;x) - ?;m*?;y',['n isa "number"','m isa "number"','canonical_compare(x,y)=0'],'rest-eval(n+m)*x'],
        ['(?;rest-?;n*?;x) - ?;y',['n isa "number"','canonical_compare(x,y)=0'],'rest-eval(n+1)*x'],
        ['(?;rest-?;x) - ?;n*?;y',['n isa "number"','canonical_compare(x,y)=0'],'rest-eval(1+n)*x'],
        ['(?;rest-?;x) - ?;y',['canonical_compare(x,y)=0'],'rest-2*x'],
        ['(?;rest-?;x) + ?;y',['canonical_compare(x,y)=0'],'rest+0*x'],
        ['(?;rest+?;n/?;x) + ?;m/?;y',['n isa "number"','m isa "number"','canonical_compare(x,y)=0'],'rest+eval(n+m)/x'],
        ['(?;n)/(?;x)+(?;m)/(?;y)',['n isa "number"','m isa "number"','canonical_compare(x,y)=0'],'eval(n+m)/x'],
        ['(?;rest+?;n/?;x) - ?;m/?;y',['n isa "number"','m isa "number"','canonical_compare(x,y)=0'],'rest+eval(n-m)/x'],
        ['?;n/?;x-?;m/?;y',['n isa "number"','m isa "number"','canonical_compare(x,y)=0'],'eval(n-m)/x'],
        ['(?;rest-?;n/?;x) + ?;m/?;y',['n isa "number"','m isa "number"','canonical_compare(x,y)=0'],'rest+eval(m-n)/x'],
        ['(?;rest-?;n/?;x) - ?;m/?;y',['n isa "number"','m isa "number"','canonical_compare(x,y)=0'],'rest-eval(n+m)/x']
    ],
    cancelFactors: [
        // x*y or rest*x*y
        ['(?;rest*(?;x)^(?;n)) * (?;y)^(?;m)',['n isa "number"','m isa "number"','canonical_compare(x,y)=0'],'rest*x^(n+m)'],
        ['(?;rest*(?;x)^(?;n)) * ?;y',['n isa "number"','canonical_compare(x,y)=0'],'rest*x^eval(n+1)'],
        ['(?;rest*?;x) * (?;y)^(?;n)',['n isa "number"','canonical_compare(x,y)=0'],'rest*x^eval(n+1)'],
        ['(?;rest*?;x) * ?;y',['canonical_compare(x,y)=0'],'rest*x^2'],
        ['(?;x)^(?;n)*(?;y)^(?;m)',['n isa "number"','m isa "number"','canonical_compare(x,y)=0'],'x^eval(n+m)'],
        ['(?;x)^(?;n)*?;y',['n isa "number"','canonical_compare(x,y)=0'],'x^eval(n+1)'],
        ['(?;x)^(-?;n)*?;y',['n isa "number"','canonical_compare(x,y)=0'],'x^eval(-n+1)'],
        ['?;x*(?;y)^(?;n)',['n isa "number"','canonical_compare(x,y)=0'],'x^eval(n+1)'],
        ['?;x*(?;y)^(-?;n)',['n isa "number"','canonical_compare(x,y)=0'],'x^eval(-n+1)'],
        ['?;x*?;y',['canonical_compare(x,y)=0'],'x^2'],
        // x/y or rest*x/y
        ['(?;rest*(?;x)^(?;n)) / ((?;y)^(?;m))',['n isa "number"','m isa "number"','canonical_compare(x,y)=0'],'rest*x^eval(n-m)'],
        ['(?;rest*(?;x)^(?;n)) / ?;y',['n isa "number"','canonical_compare(x,y)=0'],'rest*x^eval(n-1)'],
        ['(?;rest*?;x) / ((?;y)^(?;n))',['n isa "number"','canonical_compare(x,y)=0'],'rest*x^eval(1-n)'],
        ['(?;rest*?;x) / ?;y',['canonical_compare(x,y)=0'],'rest*x^0'],
        ['(?;x)^(?;n) / (?;y)^(?;m)',['n isa "number"','m isa "number"','canonical_compare(x,y)=0'],'x^eval(n-m)'],
        ['(?;x)^(?;n) / ?;y',['n isa "number"','canonical_compare(x,y)=0'],'x^eval(n-1)'],
        ['?;x / ((?;y)^(?;n))',['n isa "number"','canonical_compare(x,y)=0'],'x^eval(1-n)'],
        ['?;x / ?;y',['canonical_compare(x,y)=0'],'x^0'],
        // rest/x/y or rest/x*y
        ['(?;rest/((?;x)^(?;n))) * (?;y)^(?;m)',['n isa "number"','m isa "number"','canonical_compare(x,y)=0'],'rest*x^eval(m-n)'],
        ['(?;rest/((?;x)^(?;n))) * ?;y',['n isa "number"','canonical_compare(x,y)=0'],'rest*x^eval(1-n)'],
        ['(?;rest/?;x) * (?;y)^(?;n)',['n isa "number"','canonical_compare(x,y)=0'],'rest*x^eval(1-n)'],
        ['(?;rest/((?;x)^(?;n))) / ((?;y)^(?;m))',['n isa "number"','m isa "number"','canonical_compare(x,y)=0'],'rest/(x^eval(n+m))'],
        ['(?;rest/((?;x)^(?;n))) / ?;y',['n isa "number"','canonical_compare(x,y)=0'],'rest/(x^eval(n+1))'],
        ['(?;rest/?;x) / ((?;y)^(?;n))',['n isa "number"','canonical_compare(x,y)=0'],'rest/(x^eval(1+n))'],
        ['(?;rest/?;x) / ?;y',['canonical_compare(x,y)=0'],'rest/(x^2)'],
        ['(?;rest/?;x) * ?;y',['canonical_compare(x,y)=0'],'rest/(x^0)']
    ],
    collectLikeFractions: [
        ['?;a/?;b+?;c/?;d',['canonical_compare(b,d)=0'],'(a+c)/b']
    ]
};
// these rules conflict with noLeadingMinus
var canonicalOrderRules = [
    ['?;x+?;y',['canonical_compare(x,y)=1'],'y+x'],
    ['?;x-?;y',['canonical_compare(x,y)=1'],'(-y)+x'],
    ['-?;x+?;y',['canonical_compare(x,y)=1'],'y-x'],
    ['-?;x-?;y',['canonical_compare(x,y)=1'],'(-y)-x'],
    ['(?;x+?;y)+?;z',['canonical_compare(y,z)=1'],'(x+z)+y'],
    ['(?;x+?;y)-?;z',['canonical_compare(y,z)=1'],'(x-z)+y'],
    ['(?;x-?;y)+?;z',['canonical_compare(y,z)=1'],'(x+z)-y'],
    ['(?;x-?;y)-?;z',['canonical_compare(y,z)=1'],'(x-z)-y'],
    ['?;x*?;y',['canonical_compare(x,y)=-1'],'y*x'],
    ['(?;x*?;y)*?;z',['canonical_compare(y,z)=-1'],'(x*z)*y'],
    ['?;x*(?;y*?;z)',['canonical_compare(x,y)=-1'],'y*(x*z)'],
]
var expandBracketsRules = [
    ['(?;x+?;y)*?;z',[],'x*z+y*z'],
    ['?;x*(?;y+?;z)',[],'x*y+x*z'],
    ['(?;x-?;y)*?;z',[],'x*z-y*z'],
    ['?;x*(?;y-?;z)',[],'x*y-x*z']
]
/** Compile an array of rules (in the form `[pattern,conditions[],result]` to {@link Numbas.jme.rules.Rule} objects
 * @param {Array} rules
 * @returns {Numbas.jme.rules.Ruleset}
 */
var compileRules = jme.rules.compileRules = function(rules,name)
{
    for(var i=0;i<rules.length;i++)
    {
        var pattern = rules[i][0];
        var conditions = rules[i][1];
        var result = rules[i][2];
        rules[i] = new Rule(pattern,conditions,result,name);
    }
    return new Ruleset(rules,{});
}
var all=[];
var compiledSimplificationRules = {};
var notAll = ['canonicalOrder','expandBrackets'];
for(var x in simplificationRules)
{
    compiledSimplificationRules[x] = compiledSimplificationRules[x.toLowerCase()] = compileRules(simplificationRules[x],x);
    if(!notAll.contains(x)) {
    all = all.concat(compiledSimplificationRules[x].rules);
    }
}
compiledSimplificationRules['canonicalorder'] = compileRules(canonicalOrderRules);
compiledSimplificationRules['expandbrackets'] = compileRules(expandBracketsRules);
compiledSimplificationRules['all'] = new Ruleset(all,{});
jme.rules.simplificationRules = compiledSimplificationRules;
});

/*
Copyright 2011-14 Newcastle University
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/** @file Stuff to do with making new functions from JME or JavaScript code,
 * generating question variables,
 * and substituting variables into maths or the DOM
 *
 * Provides {@link Numbas.jme.variables}
 */
Numbas.queueScript('jme-variables',['base','jme','util'],function() {
var jme = Numbas.jme;
var util = Numbas.util;
/** @namespace Numbas.jme.variables */

/** A dictionary describing a variable to be evaluated
 * @typedef {Object} Numbas.jme.variables.variable_data_dict
 * @property {Numbas.jme.tree} tree - definition of variable
 * @property {String[]} vars - names of variables this variable depends on
 */

/** The definition of a custom JME function.
 * @typedef Numbas.jme.variables.func_data
 * @type {Object}
 * @property {String} name
 * @property {String} definition - definition of the function, either in {@link JME} or JavaScript
 * @property {String} language - either `"jme"` or `"javascript"`
 * @property {String} outtype - name of the {@link Numbas.jme.token} type this function returns
 * @property {Array.<Object>} parameters - Definition of the function's calling signature: an array of objects with properties `name` and `type` for each of the function's parameters.
 */

jme.variables = /** @lends Numbas.jme.variables */ {
    /** Make a new function, whose definition is written in JME.
     * @param {Object} fn - contains `definition` and `paramNames`.
     * @param {Numbas.jme.Scope} scope
     * @returns {function} - function which evaluates arguments and adds them to the scope, then evaluates `fn.definition` over that scope.
     */
    makeJMEFunction: function(fn,scope) {
        fn.tree = jme.compile(fn.definition,scope,true);
        return function(args,scope) {
            var oscope = scope;
            scope = new jme.Scope(scope);
            for(var j=0;j<args.length;j++)
            {
                scope.setVariable(fn.paramNames[j],args[j]);
            }
            return jme.evaluate(this.tree,scope);
        }
    },
    /** Make a new function, whose definition is written in JavaScript.
     *
     * The JavaScript is wrapped with `(function(<paramNames>){ ` and ` }`)
     *
     * @param {Object} fn - contains `definition` and `paramNames`.
     * @param {Object} withEnv - dictionary of local variables for javascript functions
     * @returns {function} - function which evaluates arguments, unwraps them to JavaScript values, then evalutes the JavaScript function and returns the result, wrapped as a {@link Numbas.jme.token}
     */
    makeJavascriptFunction: function(fn,withEnv) {
        var paramNames = fn.paramNames.slice();
        paramNames.push('scope');
        var preamble='fn.jfn=(function('+paramNames.join(',')+'){\n';
        var math = Numbas.math;
        var util = Numbas.util;
        withEnv = withEnv || {};
        try {
            with(withEnv) {
                var jfn = eval(preamble+fn.definition+'\n})');
            }
        } catch(e) {
            throw(new Numbas.Error('jme.variables.syntax error in function definition'));
        }
        return function(args,scope) {
            args = args.map(function(a){return jme.unwrapValue(a)});
            args.push(scope);
            try {
                var val = jfn.apply(this,args);
                if(val===undefined) {
                    throw(new Numbas.Error('jme.user javascript.returned undefined',{name:fn.name}));
                }
                val = jme.wrapValue(val,fn.outtype);
                if(!val.type)
                    val = new fn.outcons(val);
                return val;
            }
            catch(e)
            {
                throw(new Numbas.Error('jme.user javascript.error',{name:fn.name,message:e.message}));
            }
        }
    },
    /** Make a custom function.
     *
     * @param {Object} tmpfn - contains `definition`, `name`, `language`, `parameters`
     * @param {Numbas.jme.Scope} scope
     * @param {Object} withEnv - dictionary of local variables for javascript functions
     * @returns {Object} - contains `outcons`, `intype`, `evaluate`
     */
    makeFunction: function(tmpfn,scope,withEnv) {
        var intype = [],
            paramNames = [];
        tmpfn.parameters.map(function(p) {
            intype.push(jme.types[p.type]);
            paramNames.push(p.name);
        });
        var outcons = jme.types[tmpfn.outtype];
        var fn = new jme.funcObj(tmpfn.name,intype,outcons,null,true);
        fn.outcons = outcons;
        fn.intype = intype;
        fn.paramNames = paramNames;
        fn.definition = tmpfn.definition;
        fn.name = tmpfn.name;
        fn.language = tmpfn.language;
        try {
            switch(fn.language)
            {
            case 'jme':
                fn.evaluate = jme.variables.makeJMEFunction(fn,scope);
                break;
            case 'javascript':
                fn.evaluate = jme.variables.makeJavascriptFunction(fn,withEnv);
                break;
            }
        } catch(e) {
            throw(new Numbas.Error('jme.variables.error making function',{name:fn.name,message:e.message}));
        }
        return fn
    },
    /** Make up custom functions
     * @param {Numbas.jme.variables.func_data[]} tmpFunctions
     * @param {Numbas.jme.Scope} scope
     * @param {Object} withEnv - dictionary of local variables for javascript functions
     * @returns {Object.<Numbas.jme.funcObj>}
     * @see Numbas.jme.variables.makeFunction
     */
    makeFunctions: function(tmpFunctions,scope,withEnv)
    {
        scope = new jme.Scope(scope);
        var functions = scope.functions;
        var tmpFunctions2 = [];
        for(var i=0;i<tmpFunctions.length;i++)
        {
            var cfn = jme.variables.makeFunction(tmpFunctions[i],scope,withEnv);
            if(functions[cfn.name]===undefined)
                functions[cfn.name] = [];
            functions[cfn.name].push(cfn);
        }
        return functions;
    },
    /** Evaluate a variable, evaluating all its dependencies first.
     * @param {String} name - the name of the variable to evaluate
     * @param {Numbas.jme.variables.variable_data_dict} todo - dictionary of variables still to evaluate
     * @param {Numbas.jme.Scope} scope
     * @param {String[]} path - Breadcrumbs - variable names currently being evaluated, so we can detect circular dependencies
     * @returns {Numbas.jme.token}
     */
    computeVariable: function(name,todo,scope,path,computeFn)
    {
        if(scope.getVariable(name)!==undefined)
            return scope.variables[name];
        if(path===undefined)
            path=[];
        computeFn = computeFn || jme.variables.computeVariable;
        if(path.contains(name))
        {
            throw(new Numbas.Error('jme.variables.circular reference',{name:name,path:path}));
        }
        var v = todo[name];
        if(v===undefined)
            throw(new Numbas.Error('jme.variables.variable not defined',{name:name}));
        //work out dependencies
        for(var i=0;i<v.vars.length;i++)
        {
            var x=v.vars[i];
            if(scope.variables[x]===undefined)
            {
                var newpath = path.slice(0);
                newpath.splice(0,0,name);
                try {
                    computeFn(x,todo,scope,newpath,computeFn);
                }
                catch(e) {
                    if(e.originalMessage == 'jme.variables.circular reference' || e.originalMessage == 'jme.variables.variable not defined') {
                        throw(e);
                    } else {
                        throw(new Numbas.Error('jme.variables.error computing dependency',{name:x, message: e.message}));
                    }
                }
            }
        }
        if(!v.tree) {
            throw(new Numbas.Error('jme.variables.empty definition',{name:name}));
        }
        try {
            var value = jme.evaluate(v.tree,scope);
            scope.setVariable(name,value);
        } catch(e) {
            throw(new Numbas.Error('jme.variables.error evaluating variable',{name:name,message:e.message}));
        }
        return value;
    },
    /** Evaluate dictionary of variables
     * @param {Numbas.jme.variables.variable_data_dict} todo - dictionary of variables mapped to their definitions
     * @param {Numbas.jme.Scope} scope
     * @param {Numbas.jme.tree} condition - condition on the values of the variables which must be satisfied
     * @param {function} computeFn - a function to compute a variable. Default is Numbas.jme.variables.computeVariable
     * @returns {Object} - {variables: dictionary of evaluated variables, conditionSatisfied: was the condition satisfied?}
     */
    makeVariables: function(todo,scope,condition,computeFn)
    {
        computeFn = computeFn || jme.variables.computeVariable;
        var conditionSatisfied = true;
        if(condition) {
            var condition_vars = jme.findvars(condition);
            condition_vars.map(function(v) {
                computeFn(v,todo,scope,undefined,computeFn);
            });
            conditionSatisfied = jme.evaluate(condition,scope).value;
        }
        if(conditionSatisfied) {
            for(var x in todo)
            {
                computeFn(x,todo,scope,undefined,computeFn);
            }
        }
        return {variables: scope.variables, conditionSatisfied: conditionSatisfied, scope: scope};
    },
    /** Collect together a ruleset, evaluating all its dependencies first.
     * @param {String} name - the name of the ruleset to evaluate
     * @param {Object.<String[]>} todo - dictionary of rulesets still to evaluate
     * @param {Numbas.jme.Scope} scope
     * @param {String[]} path - Breadcrumbs - rulesets names currently being evaluated, so we can detect circular dependencies
     * @returns {Numbas.jme.rules.Ruleset}
     */
    computeRuleset: function(name,todo,scope,path) {
        if(scope.getRuleset(name.toLowerCase()) || (name.toLowerCase() in jme.displayFlags)) {
            return;
        }
        if(path.contains(name)) {
            throw(new Numbas.Error('ruleset.circular reference',{name:name}));
        }
        var newpath = path.slice();
        newpath.push(name);
        if(todo[name]===undefined) {
            throw(new Numbas.Error('ruleset.set not defined',{name:name}));
        }
        todo[name].forEach(function(name) {
            if(typeof(name)!=='string') {
                return;
            }
            var m = /^\s*(!)?(.*)\s*$/.exec(name);
            var name2 = m[2].trim();
            jme.variables.computeRuleset(name2,todo,scope,newpath);
        });
        var ruleset = Numbas.jme.collectRuleset(todo[name],scope.allRulesets());
        scope.setRuleset(name,ruleset);
        return ruleset;
    },
    /** Gather together a set of ruleset definitions
     * @param {Object.<String[]>} todo - a dictionary mapping ruleset names to definitions
     * @param {Numbas.jme.Scope} scope - the scope to gather the rulesets in. The rulesets are added to this scope as a side-effect.
     * @returns {Object.<Numbas.jme.rules.Ruleset>} a dictionary of rulesets
     */
    makeRulesets: function(todo,scope) {
        var out = {};
        for(var name in todo) {
            out[name] = jme.variables.computeRuleset(name,todo,scope,[]);
        }
        return out;
    },
    /** Given a todo dictionary of variables, return a dictionary with only the variables depending on the given list of variables
     * @param {Object} todo - dictionary of variables mapped to their definitions
     * @param {String[]} ancestors - list of variable names whose dependants we should find
     * @returns {Object} - a copy of the todo list, only including the dependants of the given variables
     */
    variableDependants: function(todo,ancestors) {
        // a dictionary mapping variable names to lists of names of variables they depend on
        var dependants = {};
        function findDependants(name,path) {
            path = path || [];
            // stop at circular references
            if(path.contains(name)) {
                return [];
            }
            // if we've already done this, variable, return it
            if(name in dependants) {
                return dependants[name];
            }
            // for each variable used in this variable, find its dependants
            var d = [];
            if(name in todo) {
                var newpath = path.slice();
                newpath.push(name);
                todo[name].vars.map(function(name2) {
                    d = d.concat(name2,findDependants(name2,newpath));
                });
            }
            // make a new list with duplicates removed
            var o = [];
            d.map(function(name2) {
                if(!o.contains(name2)) {
                    o.push(name2);
                }
            });
            dependants[name] = o;
            return o;
        }
        for(var name in todo) {
            findDependants(name);
        }
        var out = {};
        for(var name in dependants) {
            for(var i=0;i<ancestors.length;i++) {
                var ancestor = ancestors[i].toLowerCase()
                if(dependants[name].contains(ancestor)) {
                    out[name] = todo[name];
                    break;
                }
            }
        }
        return out;
    },
    /** Substitute variables into a DOM element (works recursively on the element's children)
     *
     * Ignores iframes and elements with the attribute `nosubvars`.
     * @param {Element} element
     * @param {Numbas.jme.Scope} scope
     */
    DOMcontentsubvars: function(element, scope) {
        var subber = new DOMcontentsubber(scope);
        return subber.subvars(element);
    },
    /** Substitute variables into the contents of a text node. Substituted values might contain HTML elements, so the return value is a collection of DOM elements, not another string.
     * @param {String} str - the contents of the text node
     * @param {Numbas.jme.Scope} scope
     * @param {Document} doc - the document the text node belongs to.
     * @returns {Node[]} - array of DOM nodes to replace the string with
     */
    DOMsubvars: function(str,scope,doc) {
        doc = doc || document;
        var bits = util.splitbrackets(str,'{','}');
        if(bits.length==1)
            return [doc.createTextNode(str)];
        function doToken(token) {
            switch(token.type){
            case 'html':
                return token.value;
            case 'string':
                return token.value.replace(/\\([{}])/g,'$1');
            case 'list':
                return '[ '+token.value.map(function(item){return doToken(item)}).join(', ')+' ]';
            default:
                return jme.tokenToDisplayString(token);
            }
        }
        var out = [];
        for(var i=0; i<bits.length; i++)
        {
            if(i % 2)
            {
                var v = jme.evaluate(jme.compile(bits[i],scope),scope);
                if(v===null) {
                    throw(new Numbas.Error('jme.subvars.null substitution',{str:bits[i]}));
                }
                v = doToken(v);
            }
            else
            {
                v = bits[i];
            }
            if(typeof v == 'string') {
                if(out.length>0 && typeof out[out.length-1]=='string')
                    out[out.length-1]+=v;
                else
                    out.push(v);
            }
            else {
                out.push(v);
            }
        }
        for(var i=0;i<out.length;i++) {
            if(typeof out[i] == 'string') {
                var d = document.createElement('div');
                d.innerHTML = out[i];
                d = importNode(doc,d,true);
                out[i] = $(d).contents();
            }
        }
        return out;
    }
};
// cross-browser importNode from http://www.alistapart.com/articles/crossbrowserscripting/
// because IE8 is completely mentile and won't let you copy nodes between documents in anything approaching a reasonable way
function importNode(doc,node,allChildren) {
    var ELEMENT_NODE = 1;
    var TEXT_NODE = 3;
    var CDATA_SECTION_NODE = 4;
    var COMMENT_NODE = 8;
    switch (node.nodeType) {
        case ELEMENT_NODE:
            var newNode = doc.createElement(node.nodeName);
            var il;
            /* does the node have any attributes to add? */
            if (node.attributes && (il=node.attributes.length) > 0) {
                for (var i = 0; i < il; i++)
                    newNode.setAttribute(node.attributes[i].nodeName, node.getAttribute(node.attributes[i].nodeName));
            }
            /* are we going after children too, and does the node have any? */
            if (allChildren && node.childNodes && (il=node.childNodes.length) > 0) {
                for (var i = 0; i<il; i++)
                    newNode.appendChild(importNode(doc,node.childNodes[i], allChildren));
            }
            return newNode;
        case TEXT_NODE:
        case CDATA_SECTION_NODE:
            return doc.createTextNode(node.nodeValue);
        case COMMENT_NODE:
            return doc.createComment(node.nodeValue);
    }
};
function DOMcontentsubber(scope) {
    this.scope = scope;
    this.re_end = undefined;
}
DOMcontentsubber.prototype = {
    subvars: function(element) {
        switch(element.nodeType) {
            case 1: //element
                this.sub_element(element);
                break;
            case 3: //text
                this.sub_text(element);
                break;
            default:
                return;
        }
    },
    sub_element: function(element) {
        var subber = this;
        var scope = this.scope;
        if($.nodeName(element,'iframe')) {
            return element;
        } else if(element.hasAttribute('nosubvars')) {
            return element;
        } else if($.nodeName(element,'object')) {
            function go() {
                jme.variables.DOMcontentsubvars(element.contentDocument.rootElement,scope);
            }
            if(element.contentDocument && element.contentDocument.rootElement) {
                go();
            } else {
                element.addEventListener('load',go,false);
            }
            return;
        }
        if(element.hasAttribute('data-jme-visible')) {
            var condition = element.getAttribute('data-jme-visible');
            var result = scope.evaluate(condition);
            if(!(result.type=='boolean' && result.value==true)) {
                $(element).remove();
                return;
            }
        }
        var new_attrs = {};
        for(var i=0;i<element.attributes.length;i++) {
            var m;
            var attr = element.attributes[i];
            if(m = attr.name.match(/^eval-(.*)/)) {
                var name = m[1];
                var value = jme.subvars(attr.value,scope,true);
                new_attrs[name] = value;
            }
        }
        for(var name in new_attrs) {
            element.setAttribute(name,new_attrs[name]);
        }
        var subber = this;
        var o_re_end = this.re_end;
        $(element).contents().each(function() {
            subber.subvars(this);
        });
        this.re_end = o_re_end; // make sure that any maths environment only applies to children of this element; otherwise, an unended maths environment could leak into later tags
        return;
    },
    sub_text: function(node) {
        var selector = $(node);
        var str = node.nodeValue;
        var bits = util.contentsplitbrackets(str,this.re_end);    //split up string by TeX delimiters. eg "let $X$ = \[expr\]" becomes ['let ','$','X','$',' = ','\[','expr','\]','']
        this.re_end = bits.re_end;
        var i=0;
        var l = bits.length;
        for(var i=0; i<l; i+=4) {
            var textsubs = jme.variables.DOMsubvars(bits[i],this.scope,node.ownerDocument);
            for(var j=0;j<textsubs.length;j++) {
                selector.before(textsubs[j]);
            }
            var startDelimiter = bits[i+1] || '';
            var tex = bits[i+2] || '';
            var endDelimiter = bits[i+3] || '';
            var n = node.ownerDocument.createTextNode(startDelimiter+tex+endDelimiter);
            selector.before(n);
        }
        selector.remove();
    }
}
});

/*
Copyright 2011-14 Newcastle University
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/** @file Sets up the JME compiler and evaluator.
 *
 * Provides {@link Numbas.jme}
 */
Numbas.queueScript('jme',['jme-base','jme-builtins','jme-rules'],function(){
    var jme = Numbas.jme;
    /** For backwards compatibility, copy references to some members of jme.rules to jme.
     * These items used to belong to Numbas.jme, but were spun out to Numbas.jme.rules.
     */
    ['displayFlags','Ruleset','collectRuleset'].forEach(function(name) {
        jme[name] = jme.rules[name];
    });
});
Numbas.queueScript('jme-base',['base','math','util'],function() {
var util = Numbas.util;
var math = Numbas.math;

/** A JME expression.
 * @typedef JME
 * @type {String}
 * @see {@link http://numbas-editor.readthedocs.io/en/latest/jme-reference.html}
 */

/** @typedef Numbas.jme.tree
  * @type {Object}
  * @property {Array.<Numbas.jme.tree>} args - the token's arguments (if it's an op or function)
  * @property {Numbas.jme.token} tok - the token at this node
  */

/** @namespace Numbas.jme */
var jme = Numbas.jme = /** @lends Numbas.jme */ {
    /** Mathematical constants */
    constants: {
        'e': Math.E,
        'pi': Math.PI,
        'π': Math.PI,
        'i': math.complex(0,1),
        'infinity': Infinity,
        'infty': Infinity,
        'nan': NaN,
        '∞': Infinity
    },
    /** Escape a string so that it will be interpreted correctly by the JME parser
     * @param {String} str
     * @returns {String}
     * @see Numbas.jme.unescape
     */
    escape: function(str) {
        return str
            .replace(/\\/g,'\\\\')
            .replace(/\\([{}])/g,'$1')
            .replace(/\n/g,'\\n')
            .replace(/"/g,'\\"')
            .replace(/'/g,"\\'")
        ;
    },

    /** Wrapper around {@link Numbas.jme.Parser#compile}
     * @param {JME} expr
     * @see Numbas.jme.Parser#compile
     * @returns {Numbas.jme.tree}
     */
    compile: function(expr) {
        var parser = new jme.Parser();
        return parser.compile(expr);
    },

    /** Options for a JME operator
     * @typedef {Object} Numbas.jme.operatorOptions
     * @property {Array.<String>} synonyms - synonyms for this operator. See {@link Numbas.jme.opSynonyms}.
     * @property {Number} precedence - an operator with lower precedence is evaluated before one with high precedence. Only makes sense for binary operators. See {@link Numbas.jme.precedence}.
     * @property {Boolean} commutative - Is this operator commutative? Only makes sense for binary operators.
     * @property {Boolean} rightAssociative - Is this operator right-associative? Only makes sense for unary operators.
     */

    /** Set properties for a given operator.
     * @param {String} name - the name of the operator
     * @param {Numbas.jme.operatorOptions} options
     */
    setOperatorProperties: function(name,options) {
        if(!options) {
            return;
        }
        if('precedence' in options) {
            precedence[name] = options.precedence;
        }
        if('synonyms' in options) {
            options.synonyms.forEach(function(synonym) {
                if(!opSynonyms[synonym]) {
                    opSynonyms[synonym] = name;
                }
            });
        }
        if(options.rightAssociative) {
            rightAssociative[name] = true;
        }
        if(options.commutative) {
            commutative[name] = true;
        }
    },

    /** Add a binary operator to the parser
     * @param {String} name
     * @param {Numbas.jme.operatorOptions} options
     */
    addBinaryOperator: function(name,options) {
        jme.Parser.prototype.ops.push(name);
        jme.setOperatorProperties(name,options);
    },

    /** Add a prefix operator to the parser
     * @param {String} name
     * @param {String} alt - the "interpreted" name of the operator, e.g. '!' is interpreted as 'fact'. If not given, the value of `name` is used.
     * @param {Numbas.jme.operatorOptions} options
     */
    addPrefixOperator: function(name,alt,options) {
        jme.Parser.prototype.ops.push(name);
        prefixForm[name] = alt || name;
        arity[name] = 1;
        jme.setOperatorProperties(name,options);
    },

    /** Add a postfix operator to the parser
     * @param {String} name
     * @param {String} alt - the "interpreted" name of the operator, e.g. '!' is interpreted as 'fact'. If not given, the value of `name` is used.
     * @param {Numbas.jme.operatorOptions} options
     */
    addPostfixOperator: function(name,alt,options) {
        jme.Parser.prototype.ops.push(name);
        postfixForm[name] = alt || name;
        arity[name] = 1;
        jme.setOperatorProperties(name,options);
    },

    /** Wrapper around {@link Numbas.jme.Parser#tokenise}
     * @param {JME} expr
     * @see Numbas.jme.Parser#tokenise
     * @returns {Numbas.jme.token[]}
     */
    tokenise: function(expr) {
        var parser = new jme.Parser();
        return parser.tokenise(expr);
    },

    /** Wrapper around {@link Numbas.jme.Parser#shunt}
     * @param {Numbas.jme.token[]} tokens
     * @see Numbas.jme.Parser#shunt
     * @returns {Numbas.jme.tree}
     */
    shunt: function(tokens) {
        var parser = new jme.Parser();
        return parser.shunt(expr);
    },

    /** Unescape a string - backslashes escape special characters
     * @param {String} str
     * @returns {String}
     * @see Numbas.jme.escape
     */
    unescape: function(str) {
        var estr = '';
        while(true) {
            var i = str.indexOf('\\');
            if(i==-1)
                break;
            else {
                estr += str.slice(0,i);
                var c;
                if((c=str.charAt(i+1))=='n') {
                    estr+='\n';
                }
                else if(c=='{' || c=='}') {
                    estr+='\\'+c;
                }
                else {
                    estr+=c;
                }
                str=str.slice(i+2);
            }
        }
        estr+=str;
        return estr;
    },
    /** Substitute variables defined in `scope` into the given syntax tree (in place).
     * @param {Numbas.jme.tree} tree
     * @param {Numbas.jme.Scope} scope
     * @param {Boolean} [allowUnbound=false] - allow unbound variables to remain in the returned tree
     * @returns {Numbas.jme.tree}
     */
    substituteTree: function(tree,scope,allowUnbound)
    {
        if(!tree)
            return null;
        if(tree.tok.bound)
            return tree;
        if(tree.args===undefined)
        {
            if(tree.tok.type=='name')
            {
                var name = tree.tok.name.toLowerCase();
                var v = scope.getVariable(name);
                if(v===undefined)
                {
                    if(allowUnbound)
                        return {tok: new TName(name)};
                    else
                        throw new Numbas.Error('jme.substituteTree.undefined variable',{name:name});
                }
                else
                {
                    if(v.tok) {
                        return v;
                    } else {
                        return {tok: v};
                    }
                }
            }
            else {
                return tree;
            }
        } else if((tree.tok.type=='function' || tree.tok.type=='op') && tree.tok.name in substituteTreeOps) {
            tree = {tok: tree.tok,
                    args: tree.args.slice()};
            substituteTreeOps[tree.tok.name](tree,scope,allowUnbound);
            return tree;
        } else {
            tree = {
                tok: tree.tok,
                args: tree.args.slice()
            };
            for(var i=0;i<tree.args.length;i++) {
                tree.args[i] = jme.substituteTree(tree.args[i],scope,allowUnbound);
            }
            return tree;
        }
    },
    /** Evaluate a syntax tree (or string, which is compiled to a syntax tree), with respect to the given scope.
     * @param {Numbas.jme.tree|String} tree
     * @param {Numbas.jme.Scope} scope
     * @returns {Numbas.jme.token}
     */
    evaluate: function(tree,scope)
    {
        if(!scope) {
            throw(new Numbas.Error('jme.evaluate.no scope given'));
        }
        return scope.evaluate(tree);
    },
    /** Compile a list of expressions, separated by commas
     * @param {JME} expr
     * @see Numbas.jme.tokenise
     * @see Numbas.jme.shunt
     * @returns {Numbas.jme.tree[]}
     */
    compileList: function(expr,scope) {
        expr+='';    //make sure expression is a string and not a number or anything like that
        if(!expr.trim().length)
            return null;
        //typecheck
        scope = new Scope(scope);
        //tokenise expression
        var tokens = jme.tokenise(expr);
        var bits = [];
        var brackets = [];
        var start = 0;
        for(var i=0;i<tokens.length;i++) {
            switch(tokens[i].type) {
                case '(':
                case '[':
                    brackets.push(tokens[i]);
                    break;
                case ')':
                    if(!brackets.length || brackets.pop().type!='(') {
                        throw(new Numbas.Error('jme.compile list.mismatched bracket'));
                    }
                    break;
                case ']':
                    if(!brackets.length || brackets.pop().type!='[') {
                        throw(new Numbas.Error('jme.compile list.mismatched bracket'));
                    }
                    break;
                case ',':
                    if(brackets.length==0) {
                        bits.push(tokens.slice(start,i));
                        start = i+1;
                    }
                    break;
            }
        }
        if(brackets.length) {
            throw(new Numbas.Error('jme.compile list.missing right bracket'));
        }
        bits.push(tokens.slice(start));
        //compile to parse tree
        var trees = bits.map(function(b){return jme.shunt(b)});
        return trees;
    },
    /** Settings for {@link Numbas.jme.compare}
     * @typedef {Object} Numbas.jme.compare_settings
     * @property {String} checkingType - The name of the method to determine if two results are equal. See {@link Numbas.jme.checkingFunctions}.
     * @property {Number} vsetRangeStart - The lower bound of the range to pick variable values from.
     * @property {Number} vsetRangeEnd - The upper bound of the range to pick variable values from.
     * @property {Number} vsetRangePoints - The number of values to pick for each variable.
     * @property {Number} checkingAccuracy - A parameter for the checking function to determine if two results are equal. See {@link Numbas.jme.checkingFunctions}.
     * @property {Number} failureRate - The number of times the comparison must fail to declare that the expressions are unequal.
     */
    /** Compare two expressions over some randomly selected points in the space of variables, to decide if they're equal.
     * @param {JME} expr1
     * @param {JME} expr2
     * @param {Numbas.jme.compare_settings} settings
     * @param {Numbas.jme.Scope} scope
     * @returns {Boolean}
     */
    compare: function(expr1,expr2,settings,scope) {
        expr1 += '';
        expr2 += '';
        var compile = jme.compile, evaluate = jme.evaluate;
        var checkingFunction = checkingFunctions[settings.checkingType.toLowerCase()];    //work out which checking type is being used
        try {
            var tree1 = compile(expr1,scope);
            var tree2 = compile(expr2,scope);
            if(tree1 == null || tree2 == null)
            {    //one or both expressions are invalid, can't compare
                return false;
            }
            //find variable names used in both expressions - can't compare if different
            var vars1 = findvars(tree1);
            var vars2 = findvars(tree2);
            for(var v in scope.allVariables()) {
                delete vars1[v];
                delete vars2[v];
            }
            if( !varnamesAgree(vars1,vars2) )
            {    //whoops, differing variables
                return false;
            }
            if(vars1.length)
            {    // if variables are used,  evaluate both expressions over a random selection of values and compare results
                var errors = 0;
                var rs = randoms(vars1, settings.vsetRangeStart, settings.vsetRangeEnd, settings.vsetRangePoints);
                for(var i = 0; i<rs.length; i++) {
                    var nscope = new jme.Scope([scope,{variables:rs[i]}]);
                    var r1 = evaluate(tree1,nscope);
                    var r2 = evaluate(tree2,nscope);
                    if( !resultsEqual(r1,r2,checkingFunction,settings.checkingAccuracy) ) { errors++; }
                }
                if(errors < settings.failureRate) {
                    return true;
                }else{
                    return false;
                }
            } else {
                //if no variables used, can just evaluate both expressions once and compare
                r1 = evaluate(tree1,scope);
                r2 = evaluate(tree2,scope);
                return resultsEqual(r1,r2,checkingFunction,settings.checkingAccuracy);
            }
        }
        catch(e) {
            return false;
        }
    },
    /** Substitute variables into content. To substitute variables, use {@link Numbas.jme.variables.DOMcontentsubvars}.
     * @param {String} str
     * @param {Numbas.jme.Scope} scope
     * @returns {String}
     */
    contentsubvars: function(str, scope)
    {
        var bits = util.contentsplitbrackets(str);    //split up string by TeX delimiters. eg "let $X$ = \[expr\]" becomes ['let ','$','X','$',' = ','\[','expr','\]','']
        for(var i=0; i<bits.length; i+=4)
        {
            bits[i] = jme.subvars(bits[i],scope,true);
        }
        return bits.join('');
    },
    /** Split up a TeX expression, finding the \var and \simplify commands.
     * Returns an array [normal tex,var or simplify,options,argument,normal tex,...]a
     * @param {String} s
     * @returns {Array.<String>}
     */
    texsplit: function(s)
    {
        var cmdre = /^((?:.|[\n\r])*?)\\(var|simplify)/m;
        var out = [];
        var m;
        while( m = s.match(cmdre) )
        {
            out.push(m[1]);
            var cmd = m[2];
            out.push(cmd);
            var i = m[0].length;
            var args = '';
            var argbrackets = false;
            if( s.charAt(i) == '[' )
            {
                argbrackets = true;
                var si = i+1;
                while(i<s.length && s.charAt(i)!=']')
                    i++;
                if(i==s.length)
                    throw(new Numbas.Error('jme.texsubvars.no right bracket',{op:cmd}));
                else
                {
                    args = s.slice(si,i);
                    i++;
                }
            }
            if(!argbrackets)
                args='all';
            out.push(args);
            if(s.charAt(i)!='{')
            {
                throw(new Numbas.Error('jme.texsubvars.missing parameter',{op:cmd,parameter:s}));
            }
            var brackets=1;
            var si = i+1;
            while(i<s.length-1 && brackets>0)
            {
                i++;
                if(s.charAt(i)=='{')
                    brackets++;
                else if(s.charAt(i)=='}')
                    brackets--;
            }
            if(i == s.length-1 && brackets>0)
                throw(new Numbas.Error('jme.texsubvars.no right brace',{op:cmd}));
            var expr = s.slice(si,i);
            s = s.slice(i+1);
            out.push(expr);
        }
        out.push(s);
        return out;
    },
    /** Dictionary of functions
     * type: function(value,display:boolean) -> string
     * which convert a JME token to a string for display
     */
    typeToDisplayString: {
        'number': function(v) {
            return ''+Numbas.math.niceNumber(v.value)+'';
        },
        'string': function(v,display) {
            return v.value;
        },
    },
    /** Produce a string representation of the given token, for display
     * @param {Numbas.jme.token} v
     * @see Numbas.jme.typeToDisplayString
     * @returns {String}
     */
    tokenToDisplayString: function(v) {
        if(v.type in jme.typeToDisplayString) {
            return jme.typeToDisplayString[v.type](v);
        } else {
            return jme.display.treeToJME({tok:v});
        }
    },
    /** Substitute variables into a text string (not maths).
     * @param {String} str
     * @param {Numbas.jme.Scope} scope
     * @param {Boolean} [display=false] - Is this string going to be displayed to the user? If so, avoid unnecessary brackets and quotes.
     */
    subvars: function(str, scope,display)
    {
        var bits = util.splitbrackets(str,'{','}');
        if(bits.length==1)
        {
            return str;
        }
        var out = '';
        for(var i=0; i<bits.length; i++)
        {
            if(i % 2)
            {
                var v = jme.evaluate(jme.compile(bits[i],scope),scope);
                if(v===null) {
                    throw(new Numbas.Error('jme.subvars.null substitution',{str:str}));
                }
                if(display) {
                    v = jme.tokenToDisplayString(v);
                } else {
                    if(v.type=='number') {
                        v = '('+Numbas.jme.display.treeToJME({tok:v},{niceNumber: false})+')';
                    } else if(v.type=='string') {
                        v = "'"+v.value+"'";
                    } else {
                        v = jme.display.treeToJME({tok:v},{niceNumber: false});
                    }
                }
                out += v;
            }
            else
            {
                out+=bits[i];
            }
        }
        return out;
    },
    /** Unwrap a {@link Numbas.jme.token} into a plain JavaScript value
     * @param {Numbas.jme.token} v
     * @returns {Object}
     */
    unwrapValue: function(v) {
        switch(v.type) {
            case 'list':
                return v.value.map(jme.unwrapValue);
            case 'dict':
                var o = {};
                Object.keys(v.value).forEach(function(key) {
                    o[key] = jme.unwrapValue(v.value[key]);
                });
                return o;
            case 'name':
                return v.name;
            case 'expression':
                return v.tree;
            case 'nothing':
                return undefined;
            default:
                return v.value;
        }
    },

    /** Mark a token as 'safe', so it doesn't have {@link Numbas.jme.subvars} applied to it, or any strings it contains, when it's evaluated
     * @param {Numbas.jme.token} t
     * @returns {Numbas.jme.token}
     */
    makeSafe: function(t) {
        if(!t) {
            return t;
        }
        switch(t.type) {
            case 'string':
                t.safe = true;
                var t2 = new TString(t.value);
                if(t.latex!==undefined) {
                    t2.latex = t.latex;
                }
                t2.safe = true;
                return t2;
            case 'list':
                return new TList(t.value.map(jme.makeSafe));
            case 'dict':
                var o = {};
                for(var x in t.value) {
                    o[x] = jme.makeSafe(t.value[x]);
                }
                return new TDict(o);
            default:
                return t;
        }
    },

    /** Wrap up a plain JavaScript value (number, string, bool or array) as a {@link Numbas.jme.token}.
     * @param {Object} v
     * @param {String} typeHint - name of the expected type (to differentiate between, for example, matrices, vectors and lists
     * @returns {Numbas.jme.token}
     */
    wrapValue: function(v,typeHint) {
        switch(typeof v) {
        case 'number':
            return new jme.types.TNum(v);
        case 'string':
            var s = new jme.types.TString(v);
            s.safe = true;
            return s;
        case 'boolean':
            return new jme.types.TBool(v);
        default:
            switch(typeHint) {
                case 'html':
                    return v;
                default:
                    if(Array.isArray(v)) {
                        // it would be nice to abstract this, but some types need the arguments to be wrapped, while others don't
                        switch(typeHint) {
                        case 'matrix':
                            return new jme.types.TMatrix(v);
                        case 'vector':
                            return new jme.types.TVector(v);
                        case 'range':
                            return new jme.types.TRange(v);
                        case 'set':
                            v = v.map(jme.wrapValue);
                            return new jme.types.TSet(v);
                        default:
                            v = v.map(jme.wrapValue);
                            return new jme.types.TList(v);
                        }
                    } else if(v===null || v===undefined) { // CONTROVERSIAL! Cast null to the empty string, because we don't have a null type.
                        return new jme.types.TString('');
                    } else if(v!==null && typeof v=='object' && v.type===undefined) {
                        var o = {};
                        Object.keys(v).forEach(function(key) {
                            o[key] = jme.wrapValue(v[key]);
                        });
                        return new jme.types.TDict(o);
                    }
                    return v;
            }
        }
    },
    /** Is a token a TOp?
     *
     * @param {Numbas.jme.token}
     *
     * @returns {Boolean}
     */
    isOp: function(tok,op) {
        return tok.type=='op' && tok.name==op;
    },
    /** Is a token a TName?
     *
     * @param {Numbas.jme.token}
     *
     * @returns {Boolean}
     */
    isName: function(tok,name) {
        return tok.type=='name' && tok.name==name;
    },
    /** Is a token a TFunction?
     *
     * @param {Numbas.jme.token}
     *
     * @returns {Boolean}
     */
    isFunction: function(tok,name) {
        return tok.type=='function' && tok.name==name;
    },
    /** Does this expression behave randomly?
     *  True if it contains any instances of functions or operations, defined in the given scope, which could behave randomly.
     *
     *  @param {Numbas.jme.tree} expr
     *  @param {Numbas.jme.Scope} scope
     *  @returns {Boolean}
     */
    isRandom: function(expr,scope) {
        switch(expr.tok.type) {
            case 'op':
            case 'function':
                // a function application is random if its definition is marked as random,
                // or if any of its arguments are random
                var op = expr.tok.name.toLowerCase();
                var fns = scope.getFunction(op);
                if(fns) {
                    for(var i=0;i<fns.length;i++) {
                        var fn = fns[i]
                        if(fn.random===undefined && fn.language=='jme') {
                            fn.random = false; // put false in to avoid infinite recursion if fn is defined in terms of another function which itself uses fn
                            fn.random = jme.isRandom(fn.tree,scope);
                        }
                        if(fn.random) {
                            return true;
                        }
                    }
                }
                for(var i=0;i<expr.args.length;i++) {
                    if(jme.isRandom(expr.args[i],scope)) {
                        return true;
                    }
                }
                return false;
            default:
                if(!expr.args) {
                    return false;
                }
                for(var i=0;i<expr.args.length;i++) {
                    if(jme.isRandom(expr.args[i],scope)) {
                        return true;
                    }
                }
                return false;
        }
    },

    /** Is this a monomial - a single term of the form x^n or m*x^n, where m and n are numbers?
     * @param {Numbas.jme.tree}
     * @returns {Object} the base, degree and coefficient of the monomial, as trees.
     */
    isMonomial: function(tree) {
        function unwrapUnaryMinus(tree) {
            while(jme.isOp(tree.tok,'-u')) {
                tree = tree.args[0];
            }
            return tree;
        }
        var coefficient;
        if(jme.isOp(tree.tok,'*')) {
            if(unwrapUnaryMinus(tree.args[0]).tok.type!='number') {
                return false;
            }
            coefficient = tree.args[0];
            tree = tree.args[1];
        } else if(jme.isOp(tree.tok,'-u')) {
            coefficient = {tok:new TNum(-1)};
            tree = tree.args[0];
        } else {
            coefficient = {tok:new TNum(1)};
        }
        if(tree.tok.type=='name') {
            return {base:tree, degree:{tok:new TNum(1)}, coefficient: coefficient};
        }
        if(jme.isOp(tree.tok,'^') && tree.args[0].tok.type=='name' && unwrapUnaryMinus(tree.args[1]).tok.type=='number') {
            return {base:tree.args[0], degree:tree.args[1], coefficient: coefficient};
        }
        return false;
    }
};

/** Options for {@link Numbas.jme.Parser}
 *
 * @typedef {Object} Numbas.jme.parser_options
 * @property {Boolean} closeMissingBrackets - Silently ignore "missing right bracket" errors?
 * @property {Boolean} addMissingArguments - When an op or function call is missing required arguments, insert `?` as a placeholder.
 */

/** A parser for {@link JME} expressions
 * @memberof Numbas.jme
 * @constructor
 * 
 * @param {Numbas.jme.parser_options} options
 */
var Parser = jme.Parser = function(options) {
    this.options = util.extend_object({}, this.option_defaults, options);
}
jme.Parser.prototype = /** @lends Numbas.jme.Parser.prototype */ {
    /** Default options for new parsers
     * @type {Numbas.jme.parser_options}
     */
    option_defaults: {
        closeMissingBrackets: false,
        addMissingArguments: false
    },

    /** Binary operations
     * @type {Array.<String>}
     */
    ops: ['not','and','or','xor','implies','isa','except','in','divides'],

    /** Regular expressions to match tokens 
     * @type {Object.<RegExp>}
     */
    re: {
        re_bool: /^(true|false)(?![a-zA-Z_0-9'])/i,
        re_number: /^[0-9]+(?:\x2E[0-9]+)?/,
        re_name: /^{?((?:(?:[a-zA-Z]+):)*)((?:\$?[a-zA-Z_][a-zA-Z0-9_]*'*)|\?\??|[π∞])}?/i,
        re_op: /^(\.\.|#|<=|>=|<>|&&|\|\||[\|*+\-\/\^<>=!&;÷×∈∧∨⟹≠≥≤]|(?:(__ANY_OP__)([^a-zA-Z0-9_']|$)))/i,
        re_punctuation: /^([\(\),\[\]])/,
        re_string: /^("""|'''|['"])((?:[^\1\\]|\\.)*?)\1/,
        re_comment: /^\/\/.*(?:\n|$)/,
        re_keypair: /^:/
    },
    /** Convert given expression string to a list of tokens. Does some tidying, e.g. inserts implied multiplication symbols.
     * @param {JME} expr
     * @returns {Array.<Numbas.jme.token>}
     * @see Numbas.jme.Parser#compile
     */
    tokenise: function(expr) {
        if(!expr)
            return [];
        expr += '';
        var oexpr = expr;
        var pos = 0;
        var olen = expr.length;
        expr = expr.replace(this.re.re_strip_whitespace, '');    //get rid of whitespace
        pos += olen - expr.length;
        var tokens = [];
        var i = 0;
        var re_op = new RegExp(this.re.re_op.source.replace('__ANY_OP__',this.ops.join('|')),'i');
        while( expr.length ) {
            olen = expr.length;
            expr = expr.replace(this.re.re_strip_whitespace, '');    //get rid of whitespace
            pos += olen-expr.length;
            var token_pos= pos;
            var result;
            var token;
            while(result=expr.match(this.re.re_comment)) {
                olen = expr.length;
                expr=expr.slice(result[0].length).replace(this.re.re_strip_whitespace,'');
                pos += olen-expr.length;
            }
            if(result = expr.match(this.re.re_number)) {
                token = new TNum(result[0]);
                if(tokens.length>0 && (tokens[tokens.length-1].type==')' || tokens[tokens.length-1].type=='name'))    //right bracket followed by a number is interpreted as multiplying contents of brackets by number
                {
                    tokens.push(new TOp('*'));
                }
            } else if (result = expr.match(this.re.re_bool)) {
                token = new TBool(util.parseBool(result[0]));
                result[0] = result[1];
            } else if (result = expr.match(re_op)) {
                if(result[2])        //if word-ish operator
                    result[0] = result[2];
                token = result[0].toLowerCase();
                //work out if operation is being used prefix or postfix
                var nt;
                var postfix = false;
                var prefix = false;
                if(token in opSynonyms) {
                    token = opSynonyms[token];
                }
                if( tokens.length==0 || (nt=tokens[tokens.length-1].type)=='(' || nt==',' || nt=='[' || (nt=='op' && !tokens[tokens.length-1].postfix) || nt=='keypair' )
                {
                    if(token in prefixForm) {
                        token = prefixForm[token];
                        prefix = true;
                    }
                }
                else
                {
                    if(token in postfixForm) {
                        token = postfixForm[token];
                        postfix = true;
                    }
                }
                token=new TOp(token,postfix,prefix);
            } else if (result = expr.match(this.re.re_name)) {
                var name = result[2];
                var annotation = result[1] ? result[1].split(':').slice(0,-1) : null;
                if(!annotation) {
                    var lname = name.toLowerCase();
                    // fill in constants here to avoid having more 'variables' than necessary
                    if(lname in jme.constants) {
                        token = new TNum(jme.constants[lname]);
                    } else {
                        token = new TName(name);
                    }
                } else {
                    token = new TName(name,annotation);
                }
                if(tokens.length>0 && (tokens[tokens.length-1].type=='number' || tokens[tokens.length-1].type=='name' || tokens[tokens.length-1].type==')')) {    //number or right bracket or name followed by a name, eg '3y', is interpreted to mean multiplication, eg '3*y'
                    tokens.push(new TOp('*'));
                }
            } else if (result = expr.match(this.re.re_punctuation)) {
                if(result[0]=='(' && tokens.length>0 && (tokens[tokens.length-1].type=='number' || tokens[tokens.length-1].type==')')) {    //number or right bracket followed by left parenthesis is also interpreted to mean multiplication
                    tokens.push(new TOp('*'));
                }
                token = new TPunc(result[0]);
            } else if (result = expr.match(this.re.re_string)) {
                var str = result[2];
                token = new TString(jme.unescape(str));
            } else if(result = expr.match(this.re.re_keypair)) {
                if(tokens.length==0 || tokens[tokens.length-1].type!='string') {
                    throw(new Numbas.Error('jme.tokenise.keypair key not a string',{type: tokens[tokens.length-1].type}));
                }
                token = new TKeyPair(tokens.pop().value);
            } else if(expr.length) {
                //invalid character or not able to match a token
                var position = oexpr.length - expr.length;
                var nearby = oexpr.slice(Math.max(0,position), position+5);
                throw(new Numbas.Error('jme.tokenise.invalid near',{expression:oexpr, position: position, nearby: nearby}));
            } else {
                break;
            }
            expr=expr.slice(result[0].length);    //chop found token off the expression
            pos += result[0].length;
            token.pos = token_pos;
            tokens.push(token);
        }
        return(tokens);
    },
    /** Shunt list of tokens into a syntax tree. Uses the shunting yard algorithm (wikipedia has a good description)
     * @param {Array.<Numbas.jme.token>} tokens
     * @returns {Numbas.jme.tree}
     * @see Numbas.jme.Parser#tokenise
     * @see Numbas.jme.Parser#compile
     */
    shunt: function(tokens) {
        var parser = this;
        var output = [];
        var stack = [];
        var numvars=[],olength=[],listmode=[];
        function addoutput(tok) {
            if(tok.vars!==undefined) {
                if(output.length<tok.vars) {
                    if(!parser.options.addMissingArguments) {
                        throw(new Numbas.Error('jme.shunt.not enough arguments',{op:tok.name || tok.type}));
                    } else {
                        for(var i=output.length;i<tok.vars;i++) {
                            var tvar = new types.TName('?');
                            tvar.added_missing = true;
                            output.push({tok:tvar});
                        }
                    }
                }
                var thing = {
                    tok: tok,
                    args: output.splice(output.length-tok.vars,tok.vars)
                };
                if(tok.type=='list') {
                    var mode = null;
                    for(var i=0;i<thing.args.length;i++) {
                        var argmode = thing.args[i].tok.type=='keypair' ? 'dictionary' : 'list';
                        if(i>0 && argmode!=mode) {
                            throw(new Numbas.Error('jme.shunt.list mixed argument types',{mode: mode, argmode: argmode}));
                        }
                        mode = argmode;
                    }
                    if(mode=='dictionary') {
                        thing.tok = new TDict();
                    }
                }
                output.push(thing);
            }
            else {
                output.push({tok:tok});
            }
        }
        var type_actions = {
            'number': addoutput,
            'string': addoutput,
            'boolean': addoutput,
            'name': function(tok) {
                // if followed by an open bracket, this is a function application
                if( i<tokens.length-1 && tokens[i+1].type=="(") {
                        if(funcSynonyms[tok.name]) {
                            tok.name=funcSynonyms[tok.name];
                        }
                        stack.push(new TFunc(tok.name,tok.annotation));
                        numvars.push(0);
                        olength.push(output.length);
                } else {
                    //this is a variable otherwise
                    addoutput(tok);
                }
            },
            ',': function(tok) {
                //reached end of expression defining function parameter, so pop all of its operations off stack and onto output
                while( stack.length && stack[stack.length-1].type != "(" && stack[stack.length-1].type != '[') {
                    addoutput(stack.pop())
                }
                numvars[numvars.length-1]++;
                if( ! stack.length ) {
                    throw(new Numbas.Error('jme.shunt.no left bracket in function'));
                }
            },
            'op': function(tok) {
                if(!tok.prefix) {
                    var o1 = precedence[tok.name];
                    //while ops on stack have lower precedence, pop them onto output because they need to be calculated before this one. left-associative operators also pop off operations with equal precedence
                    while(
                            stack.length &&
                            stack[stack.length-1].type=="op" &&
                            (
                             (o1 > precedence[stack[stack.length-1].name]) ||
                             (
                              leftAssociative(tok.name) &&
                              o1 == precedence[stack[stack.length-1].name]
                             )
                            )
                    ) {
                        addoutput(stack.pop());
                    }
                }
                stack.push(tok);
            },
            '[': function(tok) {
                if(i==0 || tokens[i-1].type=='(' || tokens[i-1].type=='[' || tokens[i-1].type==',' || tokens[i-1].type=='op' || tokens[i-1].type=='keypair') {
                    listmode.push('new');
                }
                else {
                    listmode.push('index');
                }
                stack.push(tok);
                numvars.push(0);
                olength.push(output.length);
            },
            ']': function(tok) {
                while( stack.length && stack[stack.length-1].type != "[" ) {
                    addoutput(stack.pop());
                }
                if( ! stack.length ) {
                    throw(new Numbas.Error('jme.shunt.no left square bracket'));
                } else {
                    stack.pop();    //get rid of left bracket
                }
                //work out size of list
                var n = numvars.pop();
                var l = olength.pop();
                if(output.length>l) {
                    n++;
                }
                switch(listmode.pop()) {
                case 'new':
                    addoutput(new TList(n))
                    break;
                case 'index':
                    var f = new TFunc('listval');
                    f.vars = 2;
                    addoutput(f);
                    break;
                }
            },
            '(': function(tok) {
                stack.push(tok);
            },
            ')': function(tok) {
                while( stack.length && stack[stack.length-1].type != "(" ) {
                    addoutput(stack.pop());
                }
                if( ! stack.length ) {
                    throw(new Numbas.Error('jme.shunt.no left bracket'));
                } else {
                    stack.pop();    //get rid of left bracket
                    //if this is a function call, then the next thing on the stack should be a function name, which we need to pop
                    if( stack.length && stack[stack.length-1].type=="function")
                    {
                        //work out arity of function
                        var n = numvars.pop();
                        var l = olength.pop();
                        if(output.length>l)
                            n++;
                        var f = stack.pop();
                        f.vars = n;
                        addoutput(f);
                    }
                }
            },
            'keypair': function(tok) {
                stack.push(tok);
            }
        };
        function shunt_token(tok) {
            if(tok.type in type_actions) {
                type_actions[tok.type](tok);
            }
        }
        for(var i = 0;i < tokens.length; i++ ) {
            var tok = tokens[i];
            shunt_token(tok);
        }
        //pop all remaining ops on stack into output
        while(stack.length) {
            var x = stack[stack.length-1];
            if(x.type=="(") {
                if(!this.options.closeMissingBrackets) {
                    throw(new Numbas.Error('jme.shunt.no right bracket'));
                } else {
                    type_actions[')']();
                }
            } else {
                stack.pop();
                addoutput(x);
            }
        }
        if(listmode.length>0) {
            throw(new Numbas.Error('jme.shunt.no right square bracket'));
        }
        if(output.length>1) {
            throw(new Numbas.Error('jme.shunt.missing operator'));
        }
        return(output[0]);
    },

    /** Compile an expression string to a syntax tree. (Runs {@link Numbas.jme.tokenise} then {@Link Numbas.jme.shunt})
     * @param {JME} expr
     * @see Numbas.jme.Parser#tokenise
     * @see Numbas.jme.Parser#shunt
     * @returns {Numbas.jme.tree}
     */
    compile: function(expr) {
        //make sure expression is a string and not a number or anything like that
        expr += '';
        if(!expr.trim().length) {
            return null;
        }
        //tokenise expression
        var tokens = this.tokenise(expr);
        //compile to parse tree
        var tree = this.shunt(tokens);
        if(tree===null) {
            return;
        }
        return(tree);
    },
}
/** Regular expression to match whitespace (because '\s' doesn't match *everything*) */
jme.Parser.prototype.re.re_whitespace = '(?:[\\s \\f\\n\\r\\t\\v\\u00A0\\u2028\\u2029]|(?:\&nbsp;))';
jme.Parser.prototype.re.re_strip_whitespace = new RegExp('^'+jme.Parser.prototype.re.re_whitespace+'+');

/** Regular expressions for parser tokens.
 * Included for backwards-compatibility
 * @type {Object.<RegExp>}
 * @see {Numbas.jme.Parser.re}
 */
jme.re = jme.Parser.prototype.re;

var fnSort = util.sortBy('id');
/** Options for the {@link Numbas.jme.funcObj} constructor
 * @typedef {Object} Numbas.jme.scope_deletions
 * @property {Object} variables - Names of deleted variables.
 * @property {Object} functions - Names of deleted functions.
 * @property {Object} rulesets - Names of deleted rulesets.
 */

/**
 * A JME evaluation environment.
 * Stores variable, function, and ruleset definitions.
 *
 * A scope may have a parent; elements of the scope are resolved by searching up through the hierarchy of parents until a match is found.
 *
 * @memberof Numbas.jme
 * @constructor
 * @property {Object.<Numbas.jme.token>} variables - Dictionary of variables defined **at this level in the scope**. To resolve a variable in the scope, use {@link Numbas.jme.Scope.getVariable}.
 * @property {Object.<Array.<Numbas.jme.funcObj>>} functions - Dictionary of functions defined at this level in the scope. Function names map to lists of functions: there can be more than one function for each name because of multiple dispatch. To resolve a function name in the scope, use {@link Numbas.jme.Scope.getFunction}.
 * @property {Object.<Numbas.jme.rules.Ruleset>} rulesets - Dictionary of rulesets defined at this level in the scope. To resolve a ruleset in the scope, use {@link Numbas.jme.Scope.getRuleset}.
 * @property {Numbas.jme.scope_deletions} deleted - Names of deleted variables/functions/rulesets.
 * @property {Numbas.Question} question - The question this scope belongs to.
 *
 * @param {Numbas.jme.Scope[]} scopes - Either: nothing, in which case this scope has no parents; a parent Scope object; a list whose first element is a parent scope, and the second element is a dictionary of extra variables/functions/rulesets to store in this scope
 */
var Scope = jme.Scope = function(scopes) {
    this.variables = {};
    this.functions = {};
    this._resolved_functions = {};
    this.rulesets = {};
    this.deleted = {
        variables: {},
        functions: {},
        rulesets: {}
    }
    if(scopes===undefined) {
        return;
    }
    if(!Array.isArray(scopes)) {
        scopes = [scopes,undefined];
    }
    this.question = scopes[0].question || this.question;
    var extras;
    if(!scopes[0].evaluate) {
        extras = scopes[0];
    } else {
        this.parent = scopes[0];
        extras = scopes[1] || {};
    }
    if(extras) {
        if(extras.variables) {
            for(var x in extras.variables) {
                this.setVariable(x,extras.variables[x]);
            }
        }
        this.rulesets = extras.rulesets || this.rulesets;
        this.functions = extras.functions || this.functions;
    }
    return;
}
Scope.prototype = /** @lends Numbas.jme.Scope.prototype */ {
    /** Add a JME function to the scope.
     * @param {Numbas.jme.funcObj} fn - function to add
     */
    addFunction: function(fn) {
        if(!(fn.name in this.functions)) {
            this.functions[fn.name] = [fn];
        } else {
            this.functions[fn.name].push(fn);
            delete this._resolved_functions[fn.name];
        }
        this.deleted.functions[fn.name] = false;
    },
    /** Mark the given variable name as deleted from the scope.
     * @param {String} name
     */
    deleteVariable: function(name) {
        this.deleted.variables[name] = true;
    },
    /** Mark the given function name as deleted from the scope.
     * @param {String} name
     */
    deleteFunction: function(name) {
        this.deleted.functions[name] = true;
    },
    /** Mark the given ruleset name as deleted from the scope.
     * @param {String} name
     */
    deleteRuleset: function(name) {
        this.deleted.rulesets[name] = true;
    },
    /** Get the object with given name from the given collection
     * @param {String} collection - name of the collection. A property of this Scope object, i.e. one of `variables`, `functions`, `rulesets`.
     * @param {String} name - the name of the object to retrieve
     * @returns {Object}
     */
    resolve: function(collection,name) {
        var scope = this;
        while(scope) {
            if(scope.deleted[collection][name]) {
                return;
            }
            if(scope[collection][name]!==undefined) {
                return scope[collection][name];
            }
            scope = scope.parent;
        }
    },
    /** Find the value of the variable with the given name, if it's defined
     * @param {String} name
     * @returns {Numbas.jme.token}
     */
    getVariable: function(name) {
        return this.resolve('variables',name.toLowerCase());
    },
    /** Set the given variable name
     * @param {String} name
     * @param {Numbas.jme.token} value
     */
    setVariable: function(name, value) {
        name = name.toLowerCase();
        this.variables[name] = value;
        this.deleted.variables[name] = false;
    },
    /** Get all definitions of the given function name.
     * @param {String} name
     * @returns {Numbas.jme.funcObj[]} A list of all definitions of the given name.
     */
    getFunction: function(name) {
        if(!this._resolved_functions[name]) {
            var scope = this;
            var o = [];
            while(scope) {
                if(scope.functions[name]!==undefined) {
                    o = o.merge(scope.functions[name],fnSort);
                }
                scope = scope.parent;
            }
            this._resolved_functions[name] = o;
        }
        return this._resolved_functions[name];
    },
    /** Get the ruleset with the gien name
     * @param {String} name
     * @returns {Numbas.jme.rules.Ruleset}
     */
    getRuleset: function(name) {
        return this.resolve('rulesets',name);
    },
    /** Set the given ruleset name
     * @param {String} name
     * @param {Numbas.jme.rules.Ruleset[]} rules
     */
    setRuleset: function(name, rules) {
        this.rulesets[name] = this.rulesets[name.toLowerCase()] = rules;
        this.deleted.rulesets[name.toLowerCase()] = false;
    },
    /** Collect together all items from the given collection
     * @param {String} collection - name of the collection. A property of this Scope object, i.e. one of `variables`, `functions`, `rulesets`.
     * @returns {Object} a dictionary of names to values
     */
    collect: function(collection,name) {
        var scope = this;
        var deleted = {};
        var out = {};
        var name;
        while(scope) {
            for(var name in scope.deleted[collection]) {
                deleted[name] = scope.deleted[collection][name];
            }
            for(name in scope[collection]) {
                if(!deleted[name]) {
                    out[name] = out[name] || scope[collection][name];
                }
            }
            scope = scope.parent;
        }
        return out;
    },
    /** Gather all variables defined in this scope
     * @returns {Object.<Numbas.jme.token>} a dictionary of variables
     */
    allVariables: function() {
        return this.collect('variables');
    },
    /** Gather all rulesets defined in this scope
     * @returns {Object.<Numbas.jme.rules.Ruleset>} a dictionary of rulesets
     */
    allRulesets: function() {
        return this.collect('rulesets');
    },
    /** Gather all functions defined in this scope
     * @returns {Object.<Numbas.jme.funcObj[]>} a dictionary of function definitions: each name maps to a list of @link{Numbas.jme.funcObj}
     */
    allFunctions: function() {
        var scope = this;
        var out = {}
        var name;
        function add(name,fns) {
            if(!out[name]) {
                out[name] = [];
            }
            out[name] = out[name].merge(fns,fnSort);
        }
        while(scope) {
            for(var name in scope.functions) {
                add(name,scope.functions[name])
            }
            scope = scope.parent;
        }
        return out;
    },
    /** Gather all members of this scope into this scope object.
     * A backwards-compatibility hack for questions that use `question.scope.variables.x`
     * Shouldn't be applied to any scope other than the question scope.
     */
    flatten: function() {
        this.variables = this.allVariables();
        this.rulesets = this.allRulesets();
    },

    /** Return a new scope created by unsetting the members specified by the given object.
     * @param {Object} defs - a dictionary with elements `variables`, `rulesets` and `functions`, each lists of names to unset.
     * @returns {Numbas.jme.Scope}
     */
    unset: function(defs) {
        var s = new Scope([this]);
        if(defs.variables) {
            defs.variables.forEach(function(v) {
                s.deleteVariable(v);
            });
        }
        if(defs.functions) {
            defs.functions.forEach(function(f) {
                s.deleteFunction(f);
            });
        }
        if(defs.rulesets) {
            defs.rulesets.forEach(function(r) {
                s.deleteRuleset(r);
            });
        }
        return s;
    },

    /** Evaluate an expression in this scope - equivalent to `Numbas.jme.evaluate(expr,this)`
     * @param {JME} expr
     * @param {Object.<Numbas.jme.token|Object>} [variables] - Dictionary of variables to sub into expression. Values are automatically wrapped up as JME types, so you can pass raw JavaScript values.
     * @param {Boolean} [noSubstitution] - if true, don't substitute variable values from the scope into the expression.
     * @returns {Numbas.jme.token}
     */
    evaluate: function(expr,variables, noSubstitution) {
        var scope = this;
        if(variables) {
            scope = new Scope([this]);
            for(var name in variables) {
                scope.setVariable(name,jme.wrapValue(variables[name]));
            }
        }
        //if a string is given instead of an expression tree, compile it to a tree
        var tree;
        if( typeof(expr)=='string' ) {
            tree = jme.compile(expr,scope);
        } else {
            tree = expr;
        }
        if(!tree) {
            return null;
        }
        if(!noSubstitution) {
            tree = jme.substituteTree(tree,scope,true);
        }
        var tok = tree.tok;
        switch(tok.type)
        {
        case 'number':
        case 'boolean':
        case 'range':
            return tok;
        case 'list':
            if(tok.value===undefined)
            {
                var value = [];
                for(var i=0;i<tree.args.length;i++)
                {
                    value[i] = scope.evaluate(tree.args[i],null,noSubstitution);
                }
                tok = new TList(value);
            }
            return tok;
        case 'dict':
            if(tok.value===undefined) {
                var value = {};
                for(var i=0;i<tree.args.length;i++) {
                    var kp = tree.args[i];
                    value[kp.tok.key] = scope.evaluate(kp.args[0],null,noSubstitution);
                }
                tok = new TDict(value);
            }
            return tok;
        case 'string':
            var value = tok.value;
            if(!tok.safe && value.contains('{')) {
                value = jme.contentsubvars(value,scope)
                var t = new TString(value);
                if(tok.latex!==undefined) {
                    t.latex = tok.latex
                }
                return t;
            } else {
                return tok;
            }
        case 'name':
            var v = scope.getVariable(tok.name.toLowerCase());
            if(v && !noSubstitution) {
                return v;
            } else {
                tok = new TName(tok.name);
                tok.unboundName = true;
                return tok;
            }
        case 'op':
        case 'function':
            var op = tok.name.toLowerCase();
            if(lazyOps.indexOf(op)>=0) {
                return scope.getFunction(op)[0].evaluate(tree.args,scope);
            }
            else {
                for(var i=0;i<tree.args.length;i++) {
                    tree.args[i] = scope.evaluate(tree.args[i],null,noSubstitution);
                }
                var matchedFunction;
                var fns = scope.getFunction(op);
                if(fns.length==0)
                {
                    if(tok.type=='function') {
                        //check if the user typed something like xtan(y), when they meant x*tan(y)
                        var possibleOp = op.slice(1);
                        if(op.length>1 && scope.getFunction(possibleOp).length) {
                            throw(new Numbas.Error('jme.typecheck.function maybe implicit multiplication',{name:op,first:op[0],possibleOp:possibleOp}));
                        } else {
                            throw(new Numbas.Error('jme.typecheck.function not defined',{op:op,suggestion:op}));
                        }
                    }
                    else {
                        throw(new Numbas.Error('jme.typecheck.op not defined',{op:op}));
                    }
                }
                for(var j=0;j<fns.length; j++)
                {
                    var fn = fns[j];
                    if(fn.typecheck(tree.args))
                    {
                        matchedFunction = fn;
                        break;
                    }
                }
                if(matchedFunction)
                    return matchedFunction.evaluate(tree.args,scope);
                else {
                    for(var i=0;i<=tree.args.length;i++) {
                        if(tree.args[i] && tree.args[i].unboundName) {
                            throw(new Numbas.Error('jme.typecheck.no right type unbound name',{name:tree.args[i].name}));
                        }
                    }
                    throw(new Numbas.Error('jme.typecheck.no right type definition',{op:op}));
                }
            }
        default:
            return tok;
        }
    }
};
/** @typedef {Object} Numbas.jme.token
 * @property {String} type
 * @see Numbas.jme.types
 */
/** The data types supported by JME expressions
 * @namespace Numbas.jme.types
 */
var types = jme.types = {}
/** Nothing type.
 * @memberof Numbas.jme.types
 * @augments Numbas.jme.token
 * @constructor
 */
var TNothing = types.TNothing = types.nothing = function() {};
TNothing.prototype.type = 'nothing';
/** Number type.
 * @memberof Numbas.jme.types
 * @augments Numbas.jme.token
 * @property {Number} value
 * @property {String|Number|complex} originalValue - the value used to construct the token - either a string, a number, or a complex number object
 * @property type "number"
 * @constructor
 * @param {Number} num
 */
var TNum = types.TNum = types.number = function(num)
{
    if(num===undefined)
        return;
    this.originalValue = num;
    switch(typeof(num)) {
        case 'object':
            if(num.complex) {
                this.value = num;
            } else {
                throw(new Numbas.Error("jme.tokenise.number.object not complex"));
            }
            break;
        case "number":
            this.value = num;
            break;
        case "string":
            this.value = parseFloat(num);
            break;
    }
    this.value = num.complex ? num : parseFloat(num);
}
TNum.prototype.type = 'number';
TNum.doc = {
    name: 'number',
    usage: ['0','1','0.234','i','e','pi'],
    description: "@i@, @e@, @infinity@ and @pi@ are reserved keywords for the imaginary unit, the base of the natural logarithm, $\\infty$ and $\\pi$, respectively."
};
/** String type.
 * @memberof Numbas.jme.types
 * @augments Numbas.jme.token
 * @property {String} value
 * @property {Boolean} latex - is this string LaTeX code? If so, it's displayed as-is in math mode
 * @property {Boolean} safe - if true, don't run {@link Numbas.jme.subvars} on this token when it's evaluated
 * @property {String} type "string"
 * @constructor
 * @param {String} s
 */
var TString = types.TString = types.string = function(s)
{
    this.value = s;
}
TString.prototype.type = 'string';
TString.doc = {
    name: 'string',
    usage: ['\'hello\'','"hello"'],
    description: "Use strings to create non-mathematical text."
};
/** Boolean type
 * @memberof Numbas.jme.types
 * @augments Numbas.jme.token
 * @property {Boolean} value
 * @property type "boolean"
 * @constructor
 * @param {Boolean} b
 */
var TBool = types.TBool = types.boolean = function(b)
{
    this.value = b;
}
TBool.prototype.type = 'boolean';
TBool.doc = {
    name: 'boolean',
    usage: ['true','false'],
    description: "Booleans represent either truth or falsity. The logical operations @and@, @or@ and @xor@ operate on and return booleans."
}
/** HTML DOM element
 * @memberof Numbas.jme.types
 * @augments Numbas.jme.token
 * @property {Element} value
 * @property type "html"
 * @constructor
 * @param {Element} html
 */
var THTML = types.THTML = types.html = function(html) {
    if(html.ownerDocument===undefined && !html.jquery) {
        throw(new Numbas.Error('jme.thtml.not html'));
    }
    if(window.jQuery) {
        this.value = $(html);
    } else {
        var elem = document.createElement('div');
        if(typeof html == 'string') {
            elem.innerHTML = html;
        } else {
            elem.appendChild(html);
        }
        this.value = elem.children;
    }
}
THTML.prototype.type = 'html';
THTML.doc = {
    name: 'html',
    usage: ['html(\'<div>things</div>\')'],
    description: "An HTML DOM node."
}
/** List of elements of any data type
 * @memberof Numbas.jme.types
 * @augments Numbas.jme.token
 * @property {Number} vars - Length of list
 * @property {Array.<Numbas.jme.token>} value - Values (may not be filled in if the list was created empty)
 * @property type "html"
 * @constructor
 * @param {Number|Array.<Numbas.jme.token>} value - Either the size of the list, or an array of values
 */
var TList = types.TList = types.list = function(value)
{
    switch(typeof(value))
    {
    case 'number':
        this.vars = value;
        break;
    case 'object':
        this.value = value;
        this.vars = value.length;
        break;
    default:
        this.vars = 0;
    }
}
TList.prototype.type = 'list';
TList.doc = {
    name: 'list',
    usage: ['[0,1,2,3]','[a,b,c]','[true,false,false]'],
    description: "A list of elements of any data type."
};
/** Key-value pair assignment
 * @memberof Numbas.jme.types
 * @augments Numbas.jme.token
 * @property {String} key
 * @constructor
 * @param {String} key
 */
var TKeyPair = types.TKeyPair = types.keypair = function(key) {
    this.key = key;
}
TKeyPair.prototype = {
    type: 'keypair',
    vars: 1
}
/** Dictionary: map strings to values
 * @memberof Numbas.jme.types
 * @augments Numbas.jme.token
 * @property {Object.<Numbas.jme.token>} value - Map strings to tokens. Undefined until this token is evaluated.
 * @property type "dict"
 * @constructor
 * @param {Object.<Numbas.jme.token>} value
 */
var TDict = types.TDict = types.dict = function(value) {
    this.value = value;
}
TDict.prototype = {
    type: 'dict'
}
/** Set type: a collection of elements, with no duplicates
 * @memberof Numbas.jme.types
 * @augments Numbas.jme.token
 * @property {Array.<Numbas.jme.token>} value - Array of elements. Constructor assumes all elements are distinct
 * @property type "set"
 * @constructor
 * @param {Array.<Numbas.jme.token>} value
 */
var TSet = types.TSet = types.set = function(value) {
    this.value = value;
}
TSet.prototype.type = 'set';
/** Vector type
 * @memberof Numbas.jme.types
 * @augments Numbas.jme.token
 * @property {Array.<Number>} value - Array of components
 * @property type "vector"
 * @constructor
 * @param {Array.<Number>} value
 */
var TVector = types.TVector = types.vector = function(value)
{
    this.value = value;
}
TVector.prototype.type = 'vector';
TVector.doc = {
    name: 'vector',
    usage: ['vector(1,2)','vector([1,2,3,4])'],
    description: 'The components of a vector must be numbers.\n\n When combining vectors of different dimensions, the smaller vector is padded with zeros to make up the difference.'
}
/** Matrix type
 * @memberof Numbas.jme.types
 * @augments Numbas.jme.token
 * @property {matrix} value - Array of rows (which are arrays of numbers)
 * @property type "matrix"
 * @constructor
 * @param {matrix} value
 */
var TMatrix = types.TMatrix = types.matrix = function(value)
{
    this.value = value;
    if(arguments.length>0) {
        if(value.length!=value.rows) {
            throw(new Numbas.Error("jme.matrix.reports bad size"));
        }
        if(value.rows>0 && value[0].length!=value.columns) {
            throw(new Numbas.Error("jme.matrix.reports bad size"));
        }
    }
}
TMatrix.prototype.type = 'matrix';
TMatrix.doc = {
    name: 'matrix',
    usage: ['matrix([1,2,3],[4,5,6])','matrix(row1,row2)'],
    description: "Matrices are constructed from lists of numbers, representing the rows.\n\n When combining matrices of different dimensions, the smaller matrix is padded with zeros to make up the difference."
}
/** A range of numerical values - either discrete or continuous
 * @memberof Numbas.jme.types
 * @augments Numbas.jme.token
 * @property {Array.<Number>} value - `[start,end,step]`
 * @property {Number} size - the number of values in the range (if it's discrete, `undefined` otherwise)
 * @property {Number} start - the lower bound of the range
 * @property {Number} end - the upper bound of the range
 * @property {Number} step - the difference between elements in the range
 * @property type "range"
 * @constructor
 * @param {Array.<Number>} range - `[start,end,step]`
 */
var TRange = types.TRange = types.range = function(range)
{
    this.value = range;
    if(this.value!==undefined)
    {
        this.start = this.value[0];
        this.end = this.value[1];
        this.step = this.value[2];
        this.size = Math.floor((this.end-this.start)/this.step);
    }
}
TRange.prototype.type = 'range';
TRange.doc = {
    name: 'range',
    usage: ['1..3','1..3#0.1','1..3#0'],
    description: 'A range @a..b#c@ represents the set of numbers $\\{a+nc | 0 \\leq n \\leq \\frac{b-a}{c} \\}$. If the step size is zero, then the range is the continuous interval $\[a,b\]$.'
}
/** Variable name token
 * @memberof Numbas.jme.types
 * @augments Numbas.jme.token
 * @property {String} name
 * @property {String} value - Same as `name`
 * @property {Array.<String>} annotation - List of annotations (used to modify display)
 * @property type "name"
 * @constructor
 * @param {String} name
 * @param {Array.<String>} annotation
 */
var TName = types.TName = types.name = function(name,annotation)
{
    this.name = name;
    this.value = name;
    this.annotation = annotation;
}
TName.prototype.type = 'name';
TName.doc = {
    name: 'name',
    usage: ['x','X','x1','longName','dot:x','vec:x'],
    description: 'A variable or function name. Names are case-insensitive, so @x@ represents the same thing as @X@. \
\n\n\
@e@, @i@ and @pi@ are reserved names representing mathematical constants. They are rewritten by the interpreter to their respective numerical values before evaluation. \
\n\n\
Names can be given _annotations_ to change how they are displayed. The following annotations are built-in:\
\n\n\
* @verb@ - does nothing, but names like @i@, @pi@ and @e@ are not interpreted as the famous mathematical constants.\n\
* @op@ - denote the name as the name of an operator -- wraps the name in the LaTeX @\\operatorname@ command when displayed\n\
* @v@ or @vector@ - denote the name as representing a vector -- the name is displayed in boldface\n\
* @unit@ - denote the name as representing a unit vector -- places a hat above the name when displayed\n\
* @dot@ - places a dot above the name when displayed, for example when representing a derivative\n\
* @m@ or @matrix@ - denote the name as representing a matrix -- displayed using a non-italic font\
\n\n\
Any other annotation is taken to be a LaTeX command. For example, a name @vec:x@ is rendered in LaTeX as <code>\\vec{x}</code>, which places an arrow above the name.\
    '
};
/** JME function token
 * @memberof Numbas.jme.types
 * @augments Numbas.jme.token
 * @property {String} name
 * @property {Array.<String>} annotation - List of annotations (used to modify display)
 * @property {Number} vars - Arity of the function
 * @property type "function"
 * @constructor
 * @param {String} name
 * @param {Array.<String>} annotation
 */
var TFunc = types.TFunc = types['function'] = function(name,annotation)
{
    this.name = name;
    this.annotation = annotation;
}
TFunc.prototype.type = 'function';
TFunc.prototype.vars = 0;
/** Unary/binary operation token
 * @memberof Numbas.jme.types
 * @augments Numbas.jme.token
 * @property {String} name
 * @property {Number} vars - Arity of the operation
 * @property {Boolean} postfix
 * @property {Boolean} prefix
 * @properrty type "op"
 * @constructor
 * @param {String} op - Name of the operation
 * @param {Boolean} postfix
 * @param {Boolean} prefix
 */
var TOp = types.TOp = types.op = function(op,postfix,prefix)
{
    var arity = 2;
    if(jme.arity[op]!==undefined)
        arity = jme.arity[op];
    this.name = op;
    this.postfix = postfix || false;
    this.prefix = prefix || false;
    this.vars = arity;
}
TOp.prototype.type = 'op';
/** Punctuation token
 * @memberof Numbas.jme.types
 * @augments Numbas.jme.token
 * @property {String} type - The punctuation character
 * @constructor
 * @param {String} kind - The punctuation character
 */
var TPunc = types.TPunc = function(kind)
{
    this.type = kind;
}
var TExpression = types.TExpression = types.expression = function(tree) {
    if(typeof(tree)=='string') {
        tree = jme.compile(tree);
    }
    this.tree = tree;
}
TExpression.prototype = {
    type: 'expression'
}
/** Arities of built-in operations
 * @readonly
 * @memberof Numbas.jme
 * @enum {Number} */
var arity = jme.arity = {
    '!': 1,
    'not': 1,
    'fact': 1,
    '+u': 1,
    '-u': 1
}
/** Some names represent different operations when used as prefix. This dictionary translates them.
 * @readonly
 * @memberof Numbas.jme
 * @enum {String}
 */
var prefixForm = {
    '+': '+u',
    '-': '-u',
    '!': 'not'
}
/** Some names represent different operations when used as prefix. This dictionary translates them.
 * @readonly
 * @memberof Numbas.jme
 * @enum {String}
 */
var postfixForm = {
    '!': 'fact'
}
/** Operator precedence - operators with lower precedence are evaluated first
 * @enum {Number}
 * @memberof Numbas.jme
 * @readonly
 */
var precedence = jme.precedence = {
    ';': 0,
    'fact': 1,
    'not': 1,
    '+u': 2.5,
    '-u': 2.5,
    '^': 2,
    '*': 3,
    '/': 3,
    '+': 4,
    '-': 4,
    '|': 5,
    '..': 5,
    '#':6,
    'except': 6.5,
    'in': 6.5,
    '<': 7,
    '>': 7,
    '<=': 7,
    '>=': 7,
    '<>': 8,
    '=': 8,
    'isa': 9,
    'and': 11,
    'or': 12,
    'xor': 13,
    'implies': 14,
    ':': 100
};
/** Synonyms of operator names - keys in this dictionary are translated to their corresponding values
 * @enum {String}
 * @memberof Numbas.jme
 * @readonly
 */
var opSynonyms = jme.opSynonyms = {
    '&':'and',
    '&&':'and',
    'divides': '|',
    '||':'or',
    '÷': '/',
    '×': '*',
    '∈': 'in',
    '∧': 'and',
    '∨': 'or',
    '⟹': 'implies',
    '≠': '<>',
    '≥': '>=',
    '≤': '<='
}
/** Synonyms of function names - keys in this dictionary are translated to their corresponding values
 * @enum {String}
 * @memberof Numbas.jme
 * @readonly
 */
var funcSynonyms = jme.funcSynonyms = {
    'sqr':'sqrt',
    'gcf': 'gcd',
    'sgn':'sign',
    'len': 'abs',
    'length': 'abs',
    'verb': 'verbatim'
};
/** Operations which evaluate lazily - they don't need to evaluate all of their arguments
 * @memberof Numbas.jme
 */
var lazyOps = jme.lazyOps = [];
var rightAssociative = {
    '^': true,
    '+u': true,
    '-u': true
}
function leftAssociative(op) {
    return !(op in rightAssociative);
};
/** Operations which commute.
 * @enum {Boolean}
 * @memberof Numbas.jme
 * @readonly
 */
var commutative = jme.commutative =
{
    '*': true,
    '+': true,
    'and': true,
    '=': true
};
/** A function which checks whether a {@link Numbas.jme.funcObj} can be applied to the given arguments.
 * @callback Numbas.jme.typecheck_fn
 * @param {Array.<Numbas.jme.token>} variables
 * @returns {Boolean}
 */
/** Evaluate a JME function on a list of arguments and in a given scope.
 * @callback Numbas.jme.evaluate_fn
 * @param {Array.<Numbas.jme.tree|Numbas.jme.token|Object>} args - Arguments of the function. If the function is {@link Numbas.jme.lazyOps|lazy}, syntax trees are passed, otherwise arguments are evaluated to JME tokens first. If the {@link Numbas.jme.funcObj_options|unwrapValues} option is set, the arguments are unwrapped to raw JavaScript values.
 * @param {Numbas.jme.Scope} scope - Scope in which the function is evaluated.
 * @returns {Numbas.jme.token|Object} If {@link Numbas.jme.funcObj_options|unwrapValues} is set,
 */
/** Options for the {@link Numbas.jme.funcObj} constructor
 * @typedef {Object} Numbas.jme.funcObj_options
 * @property {Numbas.jme.typecheck_fn} typecheck - Check that this function can be evaluated on the given arguments.
 * @property {Numbas.jme.evaluate_fn} evaluate - Evaluate the function on a list of arguments and in a given scope.
 * @property {Boolean} unwrapValues - Unwrap list elements in arguments into javascript primitives before passing to the evaluate function?
 */
var funcObjAcc = 0;    //accumulator for ids for funcObjs, so they can be sorted
/**
 * A JME function. Capable of confirming that it can be evaluated on a given list of arguments, and returning the result of its evaluation on a list of arguments inside a given scope.
 *
 * @memberof Numbas.jme
 * @constructor
 * @param {String} name
 * @param {Array.<function|String>} intype - A list of data type constructors for the function's paramters' types. Use the string '?' to match any type. Or, give the type's name with a '*' in front to match any number of that type. If `null`, then `options.typecheck` is used.
 * @param {function} outcons - The constructor for the output value of the function
 * @param {Numbas.jme.evaluate_fn} fn - JavaScript code which evaluates the function.
 * @param {Numbas.jme.funcObj_options} options
 *
 */
var funcObj = jme.funcObj = function(name,intype,outcons,fn,options)
{
    /** Globally unique ID of this function object
     * @name id
     * @member {Number}
     * @memberof Numbas.jme.funcObj
     */
    this.id = funcObjAcc++;
    options = options || {};
    for(var i=0;i<intype.length;i++)
    {
        if(intype[i]!='?' && intype[i]!='*?')
        {
            if(intype[i][0]=='*')
            {
                var type = types[intype[i].slice(1)];
                intype[i] = '*'+type.prototype.type;
            }
            else
            {
                intype[i]=intype[i].prototype.type;
            }
        }
    }
    name = name.toLowerCase();
    /** Name
     * @name name
     * @member {String}
     * @memberof Numbas.jme.funcObj
     */
    this.name=name;
    /** Calling signature of this function. A list of types - either token constructors; '?', representing any type; a type name. A type name or '?' followed by '*' means any number of arguments matching that type.
     *
     * @name intype
     * @member {Array.<Numbas.jme.token|String>}
     * @memberof Numbas.jme.funcObj
     */
    this.intype = intype;
    /** The return type of this function. Either a Numbas.jme.token constructor function, or the string '?', meaning unknown type.
     * @name outtype
     * @member {function|String}
     * @memberof Numbas.jme.funcObj
     */
    if(typeof(outcons)=='function')
        this.outtype = outcons.prototype.type;
    else
        this.outtype = '?';
    this.outcons = outcons;
    /** Javascript function for the body of this function
     * @name fn
     * @member {function}
     * @memberof Numbas.jme.funcObj
     */
    this.fn = fn;
    /** Can this function be called with the given list of arguments?
     * @function typecheck
     * @param {Numbas.jme.token[]} variables
     * @returns {Boolean}
     * @memberof Numbas.jme.funcObj
     */
    this.typecheck = options.typecheck || function(variables)
    {
        variables = variables.slice();    //take a copy of the array
        for( var i=0; i<this.intype.length; i++ )
        {
            if(this.intype[i][0]=='*')    //arbitrarily many
            {
                var ntype = this.intype[i].slice(1);
                while(variables.length)
                {
                    if(variables[0].type==ntype || ntype=='?' || variables[0].type=='?')
                        variables = variables.slice(1);
                    else
                        break;
                }
            }else{
                if(variables.length==0)
                    return false;
                if(variables[0].type==this.intype[i] || this.intype[i]=='?' || variables[0].type=='?')
                    variables = variables.slice(1);
                else
                    return false;
            }
        }
        if(variables.length>0)    //too many args supplied
            return false;
        else
            return true;
    };
    /** Evaluate this function on the given arguments, in the given scope.
     *
     * @function evaluate
     * @param {Numbas.jme.token[]} args
     * @param {Numbas.jme.Scope} scope
     * @returns {Numbas.jme.token}
     * @memberof Numbas.jme.funcObj
     */
    this.evaluate = options.evaluate || function(args,scope)
    {
        var nargs = [];
        for(var i=0; i<args.length; i++) {
            if(options.unwrapValues)
                nargs.push(jme.unwrapValue(args[i]));
            else
                nargs.push(args[i].value);
        }
        var result = this.fn.apply(null,nargs);
        if(options.unwrapValues) {
            result = jme.wrapValue(result);
            if(!result.type)
                result = new this.outcons(result);
        }
        else
            result = new this.outcons(result);
        if(options.latex) {
            result.latex = true;
        }
        return result;
    }
    this.doc = options.doc;
    /** Does this function behave randomly?
     * @name random
     * @member {Boolean}
     * @memberof Numbas.jme.funcObj
     */
    this.random = options.random;
}
function randoms(varnames,min,max,times)
{
    times *= varnames.length;
    var rs = [];
    for( var i=0; i<times; i++ )
    {
        var r = {};
        for( var j=0; j<varnames.length; j++ )
        {
            r[varnames[j]] = new TNum(Numbas.math.randomrange(min,max));
        }
        rs.push(r);
    }
    return rs;
}
function varnamesAgree(array1, array2) {
    var name;
    for(var i=0; i<array1.length; i++) {
        if( (name=array1[i])[0]!='$' && !array2.contains(name) )
            return false;
    }
    return true;
};
/** Decide if two numbers are close enough to count as equal.
 * @callback Numbas.jme.checkingFunction
 * @param {Number} r1
 * @param {Number} r2
 * @param {Number} tolerance - A measure of how close the results need to be to count as equal. What this means depends on the checking function.
 * @returns {Boolean} - True if `r1` and `r2` are close enough to be equal.
 */
/**
 * Numerical comparison functions
 * @enum {Numbas.jme.checkingFunction}
 * @memberof Numbas.jme
 */
var checkingFunctions = jme.checkingFunctions =
{
    /** Absolute difference between variables - fail if `Math.abs(r1-r2)` is bigger than `tolerance` */
    absdiff: function(r1,r2,tolerance)
    {
        if(r1===Infinity || r1===-Infinity)
            return r1===r2;
        return math.leq(math.abs(math.sub(r1,r2)), Math.abs(tolerance));
    },
    /** Relative (proportional) difference between variables - fail if `r1/r2 - 1` is bigger than `tolerance` */
    reldiff: function(r1,r2,tolerance) {
        if(r1===Infinity || r1===-Infinity)
            return r1===r2;
        //
        if(r2!=0) {
            return math.leq(Math.abs(math.sub(r1,r2)), Math.abs(math.mul(tolerance,r2)));
        } else {    //or if correct answer is 0, checks abs difference
            return math.leq(Math.abs(math.sub(r1,r2)), tolerance);
        }
    },
    /** Round both values to `tolerance` decimal places, and fail if unequal. */
    dp: function(r1,r2,tolerance) {
        if(r1===Infinity || r1===-Infinity)
            return r1===r2;
        tolerance = Math.floor(Math.abs(tolerance));
        return math.eq( math.precround(r1,tolerance), math.precround(r2,tolerance) );
    },
    /** Round both values to `tolerance` significant figures, and fail if unequal. */
    sigfig: function(r1,r2,tolerance) {
        if(r1===Infinity || r1===-Infinity)
            return r1===r2;
        tolerance = Math.floor(Math.abs(tolerance));
        return math.eq(math.siground(r1,tolerance), math.siground(r2,tolerance));
    }
};
/** Custom substituteTree behaviour for specific functions - for a given usage of a function, substitute in variable values from the scope.
 *
 * Functions have the signature <tree with function call at the top, scope, allowUnbound>
 *
 * @memberof Numbas.jme
 * @enum {Numbas.jme.substituteTree}
 * @see Numbas.jme.substituteTree
 */
var substituteTreeOps = jme.substituteTreeOps = {};
/** Custom findvars behaviour for specific functions - for a given usage of a function, work out which variables it depends on.
 *
 * @memberof Numbas.jme
 * @enum {Numbas.jme.findvars}
 * @see Numbas.jme.findvars
 */
var findvarsOps = jme.findvarsOps = {}
/** Find all variables used in given syntax tree
 * @memberof Numbas.jme
 * @method
 * @param {Numbas.jme.tree} tree
 * @param {Array.<String>} boundvars - variables to be considered as bound (don't include them)
 * @param {Numbas.jme.Scope} scope
 * @returns {Array.<String>}
 */
var findvars = jme.findvars = function(tree,boundvars,scope)
{
    if(!scope)
        scope = jme.builtinScope;
    if(boundvars===undefined)
        boundvars = [];
    if(tree.tok.type=='function' && tree.tok.name in findvarsOps) {
        return findvarsOps[tree.tok.name](tree,boundvars,scope);
    }
    if(tree.args===undefined)
    {
        switch(tree.tok.type)
        {
        case 'name':
            var name = tree.tok.name.toLowerCase();
            if(boundvars.indexOf(name)==-1)
                return [name];
            else
                return [];
            break;
        case 'string':
            if(tree.tok.safe) {
                return [];
            }
            var bits = util.contentsplitbrackets(tree.tok.value);
            var out = [];
            for(var i=0;i<bits.length;i+=4)
            {
                var plain = bits[i];
                var sbits = util.splitbrackets(plain,'{','}');
                for(var k=1;k<sbits.length-1;k+=2)
                {
                    var tree2 = jme.compile(sbits[k],scope,true);
                    out = out.merge(findvars(tree2,boundvars));
                }
                if(i<=bits.length-3) {
                    var tex = bits[i+2];
                    var tbits = jme.texsplit(tex);
                    for(var j=0;j<tbits.length;j+=4) {
                        var cmd = tbits[j+1];
                        var expr = tbits[j+3];
                        switch(cmd)
                        {
                        case 'var':
                            var tree2 = jme.compile(expr,scope,true);
                            out = out.merge(findvars(tree2,boundvars));
                            break;
                        case 'simplify':
                            var sbits = util.splitbrackets(expr,'{','}');
                            for(var k=1;k<sbits.length-1;k+=2)
                            {
                                var tree2 = jme.compile(sbits[k],scope,true);
                                out = out.merge(findvars(tree2,boundvars));
                            }
                            break;
                        }
                    }
                }
            }
            return out;
        default:
            return [];
        }
    }
    else
    {
        var vars = [];
        for(var i=0;i<tree.args.length;i++)
            vars = vars.merge(findvars(tree.args[i],boundvars));
        return vars;
    }
}
/** Check that two values are equal
 * @memberof Numbas.jme
 * @method
 * @param {Numbas.jme.token} r1
 * @param {Numbas.jme.token} r2
 * @param {function} checkingFunction - one of {@link Numbas.jme.checkingFunctions}
 * @param {Number} checkingAccuracy
 * @returns {Boolean}
 */
var resultsEqual = jme.resultsEqual = function(r1,r2,checkingFunction,checkingAccuracy)
{    // first checks both expressions are of same type, then uses given checking type to compare results
    var v1 = r1.value, v2 = r2.value;
    if(r1.type != r2.type)
    {
        return false;
    }
    switch(r1.type)
    {
    case 'number':
        if(v1.complex || v2.complex)
        {
            if(!v1.complex)
                v1 = {re:v1, im:0, complex:true};
            if(!v2.complex)
                v2 = {re:v2, im:0, complex:true};
            return checkingFunction(v1.re, v2.re, checkingAccuracy) && checkingFunction(v1.im,v2.im,checkingAccuracy);
        }
        else
        {
            return checkingFunction( v1, v2, checkingAccuracy );
        }
        break;
    case 'vector':
        if(v1.length != v2.length)
            return false;
        for(var i=0;i<v1.length;i++)
        {
            if(!resultsEqual(new TNum(v1[i]),new TNum(v2[i]),checkingFunction,checkingAccuracy))
                return false;
        }
        return true;
        break;
    case 'matrix':
        if(v1.rows != v2.rows || v1.columns != v2.columns)
            return false;
        for(var i=0;i<v1.rows;i++)
        {
            for(var j=0;j<v1.columns;j++)
            {
                if(!resultsEqual(new TNum(v1[i][j]||0),new TNum(v2[i][j]||0),checkingFunction,checkingAccuracy))
                    return false;
            }
        }
        return true;
        break;
    case 'list':
        if(v1.length != v2.length)
            return false;
        for(var i=0;i<v1.length;i++)
        {
            if(!resultsEqual(v1[i],v2[i],checkingFunction,checkingAccuracy))
                return false;
        }
        return true;
    default:
        return util.eq(r1,r2);
    }
};

/** List names of variables used in `tree`, obtained by depth-first search.
 *
 * Differs from {@link Numbas.jme.findvars} by including duplicates, and ignoring {@link Numbas.jme.findvarsOps}.
 * 
 * @memberof Numbas.jme
 * @method
 * @param {Numbas.jme.tree} tree
 * @returns {String[]}
 */
var varsUsed = jme.varsUsed = function(tree) {
    switch(tree.tok.type) {
        case 'name':
            return [tree.tok.name];
        case 'op':
        case 'function':
            var o = [];
            for(var i=0;i<tree.args.length;i++) {
                o = o.concat(jme.varsUsed(tree.args[i]));
            }
            return o;
        default:
            return [];
    }
};

/** Use JS comparison operators to compare the `value` property of both tokens.
 * Used when the token wraps a JS built-in type, such as string, number or boolean.
 * @see @Numbas.jme.tokenComparisons
 */
var compareTokensByValue = jme.compareTokensByValue = function(a,b) {
    return a.value>b.value ? 1 : a.value<b.value ? -1 : 0;
}

/** Functions to compare two tokens of the same type.
 * Returns -1 if a<b, 0 if a=b, and 1 if a>b
 * @see Numbas.jme.compareTokens
 */
var tokenComparisons = Numbas.jme.tokenComparisons = {
    'number': compareTokensByValue,
    'string': compareTokensByValue,
    'boolean': compareTokensByValue
}

/** Compare two tokens, for the purposes of sorting.
 * Uses JavaScript comparison for numbers, strings and booleans, and {@link Numbas.jme.compareTrees} for everything else, or when types differ.
 *
 * @param {Numbas.jme.token} a
 * @param {Numbas.jme.token} b
 * @see Numbas.jme.tokenComparisons
 * @returns {Number} -1 if `a < b`, 1 if `a > b`, else 0.
 */
var compareTokens = jme.compareTokens = function(a,b) {
    if(a.type!=b.type) {
        return jme.compareTrees({tok:a},{tok:b});
    } else {
        var compare = tokenComparisons[a.type];
        if(compare) {
            return compare(a,b);
        } else {
            return jme.compareTrees({tok:a},{tok:b});
        }
    }
}

/** Compare two trees.
 *
 * * Compare lists of variables lexically using {@link Numbas.jme.varsUsed}; longest goes first if one is a prefix of the other
 * * then monomials before anything else
 * * then by data type
 * * then by function name
 * * otherwise return 0
 *
 * @memberof Numbas.jme
 * @method
 * @param {Numbas.jme.tree} a
 * @param {Numbas.jme.tree} b
 * @returns {Number} -1 if `a` should appear to the left of `b`, 0 if equal, 1 if `a` should appear to the right of `b`
 */
var compareTrees = jme.compareTrees = function(a,b) {
    var sign_a = 1;
    while(jme.isOp(a.tok,'-u')) {
        a = a.args[0];
        sign_a *= -1;
    }
    var sign_b = 1;
    while(jme.isOp(b.tok,'-u')) {
        b = b.args[0];
        sign_b *= -1;
    }
    var va = jme.varsUsed(a);
    var vb = jme.varsUsed(b);
    for(var i=0;i<va.length;i++) {
        if(i>=vb.length) {
            return -1;
        }
        if(va[i]!=vb[i]) {
            return va[i]<vb[i] ? -1 : 1;
        }
    }
    if(vb.length>va.length) {
        return 1;
    }

    var ma = jme.isMonomial(a);
    var mb = jme.isMonomial(b);
    var isma = ma!==false;
    var ismb = mb!==false;
    if(isma!=ismb) {
        return isma ? -1 : 1;
    }
    if(isma && ismb && !(a.tok.type=='name' && b.tok.type=='name')) {
        var d = jme.compareTrees(ma.base,mb.base);
        if(d==0) {
            var dd = jme.compareTrees(mb.degree,ma.degree);
            return dd!=0 ? dd : compareTrees(ma.coefficient,mb.coefficient);
        } else {
            return d;
        }
    }

    if(a.tok.type!=b.tok.type) {
        var order = ['op','function'];
        var oa = order.indexOf(a.tok.type);
        var ob = order.indexOf(b.tok.type);
        if(oa!=ob) {
            return oa>ob ? -1 : 1;
        } else {
            return a.tok.type<b.tok.type ? -1 : 1;
        }
    }
    switch(a.tok.type) {
        case 'op':
        case 'function':
            function is_pow(t) {
                return t.tok.name=='^' || (t.tok.name=='*' && t.args[1].tok.name=='^') || (t.tok.name=='/' && t.args[1].tok.name=='^');
            }
            var pa = is_pow(a);
            var pb = is_pow(b);
            if(pa && !pb) {
                return -1;
            } else if(!pa && pb) {
                return 1;
            }
            if(a.tok.name!=b.tok.name) {
                return a.tok.name<b.tok.name ? -1 : 1;
            }
            if(a.args.length!=b.args.length) {
                return a.args.length<b.args.length ? -1 : 1;
            }
            for(var i=0;i<a.args.length;i++) {
                var c = jme.compareTrees(a.args[i],b.args[i]);
                if(c!=0) {
                    return c;
                }
            }
            break;
        case 'expression':
            return jme.compareTrees(a.tok.tree, b.tok.tree);
        case 'number':
            var na = a.tok.value;
            var nb = b.tok.value;
            if(na.complex || nb.complex) {
                na = na.complex ? na : {re:na,im:0};
                nb = nb.complex ? nb : {re:nb,im:0};
                var gt = na.re > nb.re || (na.re==nb.re && na.im>nb.im);
                var eq = na.re==nb.re && na.im==nb.im && sign_a==sign_b;
                return gt ? 1 : eq ? 0 : -1;
            } else {
                return a.tok.value<b.tok.value ? -1 : a.tok.value>b.tok.value ? 1 : sign_a==sign_b ? 0 : sign_a ? 1 : -1;
            }
    }
    return sign_a==sign_b ? 0 : sign_a ? 1 : -1;
}
});

Numbas.queueScript('jquery-ui',['jquery'],function(module) {
/*! jQuery UI - v1.10.2 - 2013-03-25
* http://jqueryui.com
* Includes: jquery.ui.core.js, jquery.ui.position.js
* Copyright 2013 jQuery Foundation and other contributors Licensed MIT */
(function(e,t){function i(t,i){var a,n,r,o=t.nodeName.toLowerCase();return"area"===o?(a=t.parentNode,n=a.name,t.href&&n&&"map"===a.nodeName.toLowerCase()?(r=e("img[usemap=#"+n+"]")[0],!!r&&s(r)):!1):(/input|select|textarea|button|object/.test(o)?!t.disabled:"a"===o?t.href||i:i)&&s(t)}function s(t){return e.expr.filters.visible(t)&&!e(t).parents().addBack().filter(function(){return"hidden"===e.css(this,"visibility")}).length}var a=0,n=/^ui-id-\d+$/;e.ui=e.ui||{},e.extend(e.ui,{version:"1.10.2",keyCode:{BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,NUMPAD_ADD:107,NUMPAD_DECIMAL:110,NUMPAD_DIVIDE:111,NUMPAD_ENTER:108,NUMPAD_MULTIPLY:106,NUMPAD_SUBTRACT:109,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38}}),e.fn.extend({focus:function(t){return function(i,s){return"number"==typeof i?this.each(function(){var t=this;setTimeout(function(){e(t).focus(),s&&s.call(t)},i)}):t.apply(this,arguments)}}(e.fn.focus),scrollParent:function(){var t;return t=e.ui.ie&&/(static|relative)/.test(this.css("position"))||/absolute/.test(this.css("position"))?this.parents().filter(function(){return/(relative|absolute|fixed)/.test(e.css(this,"position"))&&/(auto|scroll)/.test(e.css(this,"overflow")+e.css(this,"overflow-y")+e.css(this,"overflow-x"))}).eq(0):this.parents().filter(function(){return/(auto|scroll)/.test(e.css(this,"overflow")+e.css(this,"overflow-y")+e.css(this,"overflow-x"))}).eq(0),/fixed/.test(this.css("position"))||!t.length?e(document):t},zIndex:function(i){if(i!==t)return this.css("zIndex",i);if(this.length)for(var s,a,n=e(this[0]);n.length&&n[0]!==document;){if(s=n.css("position"),("absolute"===s||"relative"===s||"fixed"===s)&&(a=parseInt(n.css("zIndex"),10),!isNaN(a)&&0!==a))return a;n=n.parent()}return 0},uniqueId:function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++a)})},removeUniqueId:function(){return this.each(function(){n.test(this.id)&&e(this).removeAttr("id")})}}),e.extend(e.expr[":"],{data:e.expr.createPseudo?e.expr.createPseudo(function(t){return function(i){return!!e.data(i,t)}}):function(t,i,s){return!!e.data(t,s[3])},focusable:function(t){return i(t,!isNaN(e.attr(t,"tabindex")))},tabbable:function(t){var s=e.attr(t,"tabindex"),a=isNaN(s);return(a||s>=0)&&i(t,!a)}}),e("<a>").outerWidth(1).jquery||e.each(["Width","Height"],function(i,s){function a(t,i,s,a){return e.each(n,function(){i-=parseFloat(e.css(t,"padding"+this))||0,s&&(i-=parseFloat(e.css(t,"border"+this+"Width"))||0),a&&(i-=parseFloat(e.css(t,"margin"+this))||0)}),i}var n="Width"===s?["Left","Right"]:["Top","Bottom"],r=s.toLowerCase(),o={innerWidth:e.fn.innerWidth,innerHeight:e.fn.innerHeight,outerWidth:e.fn.outerWidth,outerHeight:e.fn.outerHeight};e.fn["inner"+s]=function(i){return i===t?o["inner"+s].call(this):this.each(function(){e(this).css(r,a(this,i)+"px")})},e.fn["outer"+s]=function(t,i){return"number"!=typeof t?o["outer"+s].call(this,t):this.each(function(){e(this).css(r,a(this,t,!0,i)+"px")})}}),e.fn.addBack||(e.fn.addBack=function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}),e("<a>").data("a-b","a").removeData("a-b").data("a-b")&&(e.fn.removeData=function(t){return function(i){return arguments.length?t.call(this,e.camelCase(i)):t.call(this)}}(e.fn.removeData)),e.ui.ie=!!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase()),e.support.selectstart="onselectstart"in document.createElement("div"),e.fn.extend({disableSelection:function(){return this.bind((e.support.selectstart?"selectstart":"mousedown")+".ui-disableSelection",function(e){e.preventDefault()})},enableSelection:function(){return this.unbind(".ui-disableSelection")}}),e.extend(e.ui,{plugin:{add:function(t,i,s){var a,n=e.ui[t].prototype;for(a in s)n.plugins[a]=n.plugins[a]||[],n.plugins[a].push([i,s[a]])},call:function(e,t,i){var s,a=e.plugins[t];if(a&&e.element[0].parentNode&&11!==e.element[0].parentNode.nodeType)for(s=0;a.length>s;s++)e.options[a[s][0]]&&a[s][1].apply(e.element,i)}},hasScroll:function(t,i){if("hidden"===e(t).css("overflow"))return!1;var s=i&&"left"===i?"scrollLeft":"scrollTop",a=!1;return t[s]>0?!0:(t[s]=1,a=t[s]>0,t[s]=0,a)}})})(jQuery);(function(t,e){function i(t,e,i){return[parseFloat(t[0])*(p.test(t[0])?e/100:1),parseFloat(t[1])*(p.test(t[1])?i/100:1)]}function s(e,i){return parseInt(t.css(e,i),10)||0}function n(e){var i=e[0];return 9===i.nodeType?{width:e.width(),height:e.height(),offset:{top:0,left:0}}:t.isWindow(i)?{width:e.width(),height:e.height(),offset:{top:e.scrollTop(),left:e.scrollLeft()}}:i.preventDefault?{width:0,height:0,offset:{top:i.pageY,left:i.pageX}}:{width:e.outerWidth(),height:e.outerHeight(),offset:e.offset()}}t.ui=t.ui||{};var a,o=Math.max,r=Math.abs,h=Math.round,l=/left|center|right/,c=/top|center|bottom/,u=/[\+\-]\d+(\.[\d]+)?%?/,d=/^\w+/,p=/%$/,f=t.fn.position;t.position={scrollbarWidth:function(){if(a!==e)return a;var i,s,n=t("<div style='display:block;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),o=n.children()[0];return t("body").append(n),i=o.offsetWidth,n.css("overflow","scroll"),s=o.offsetWidth,i===s&&(s=n[0].clientWidth),n.remove(),a=i-s},getScrollInfo:function(e){var i=e.isWindow?"":e.element.css("overflow-x"),s=e.isWindow?"":e.element.css("overflow-y"),n="scroll"===i||"auto"===i&&e.width<e.element[0].scrollWidth,a="scroll"===s||"auto"===s&&e.height<e.element[0].scrollHeight;return{width:a?t.position.scrollbarWidth():0,height:n?t.position.scrollbarWidth():0}},getWithinInfo:function(e){var i=t(e||window),s=t.isWindow(i[0]);return{element:i,isWindow:s,offset:i.offset()||{left:0,top:0},scrollLeft:i.scrollLeft(),scrollTop:i.scrollTop(),width:s?i.width():i.outerWidth(),height:s?i.height():i.outerHeight()}}},t.fn.position=function(e){if(!e||!e.of)return f.apply(this,arguments);e=t.extend({},e);var a,p,m,g,v,_,b=t(e.of),y=t.position.getWithinInfo(e.within),w=t.position.getScrollInfo(y),x=(e.collision||"flip").split(" "),k={};return _=n(b),b[0].preventDefault&&(e.at="left top"),p=_.width,m=_.height,g=_.offset,v=t.extend({},g),t.each(["my","at"],function(){var t,i,s=(e[this]||"").split(" ");1===s.length&&(s=l.test(s[0])?s.concat(["center"]):c.test(s[0])?["center"].concat(s):["center","center"]),s[0]=l.test(s[0])?s[0]:"center",s[1]=c.test(s[1])?s[1]:"center",t=u.exec(s[0]),i=u.exec(s[1]),k[this]=[t?t[0]:0,i?i[0]:0],e[this]=[d.exec(s[0])[0],d.exec(s[1])[0]]}),1===x.length&&(x[1]=x[0]),"right"===e.at[0]?v.left+=p:"center"===e.at[0]&&(v.left+=p/2),"bottom"===e.at[1]?v.top+=m:"center"===e.at[1]&&(v.top+=m/2),a=i(k.at,p,m),v.left+=a[0],v.top+=a[1],this.each(function(){var n,l,c=t(this),u=c.outerWidth(),d=c.outerHeight(),f=s(this,"marginLeft"),_=s(this,"marginTop"),D=u+f+s(this,"marginRight")+w.width,T=d+_+s(this,"marginBottom")+w.height,C=t.extend({},v),M=i(k.my,c.outerWidth(),c.outerHeight());"right"===e.my[0]?C.left-=u:"center"===e.my[0]&&(C.left-=u/2),"bottom"===e.my[1]?C.top-=d:"center"===e.my[1]&&(C.top-=d/2),C.left+=M[0],C.top+=M[1],t.support.offsetFractions||(C.left=h(C.left),C.top=h(C.top)),n={marginLeft:f,marginTop:_},t.each(["left","top"],function(i,s){t.ui.position[x[i]]&&t.ui.position[x[i]][s](C,{targetWidth:p,targetHeight:m,elemWidth:u,elemHeight:d,collisionPosition:n,collisionWidth:D,collisionHeight:T,offset:[a[0]+M[0],a[1]+M[1]],my:e.my,at:e.at,within:y,elem:c})}),e.using&&(l=function(t){var i=g.left-C.left,s=i+p-u,n=g.top-C.top,a=n+m-d,h={target:{element:b,left:g.left,top:g.top,width:p,height:m},element:{element:c,left:C.left,top:C.top,width:u,height:d},horizontal:0>s?"left":i>0?"right":"center",vertical:0>a?"top":n>0?"bottom":"middle"};u>p&&p>r(i+s)&&(h.horizontal="center"),d>m&&m>r(n+a)&&(h.vertical="middle"),h.important=o(r(i),r(s))>o(r(n),r(a))?"horizontal":"vertical",e.using.call(this,t,h)}),c.offset(t.extend(C,{using:l}))})},t.ui.position={fit:{left:function(t,e){var i,s=e.within,n=s.isWindow?s.scrollLeft:s.offset.left,a=s.width,r=t.left-e.collisionPosition.marginLeft,h=n-r,l=r+e.collisionWidth-a-n;e.collisionWidth>a?h>0&&0>=l?(i=t.left+h+e.collisionWidth-a-n,t.left+=h-i):t.left=l>0&&0>=h?n:h>l?n+a-e.collisionWidth:n:h>0?t.left+=h:l>0?t.left-=l:t.left=o(t.left-r,t.left)},top:function(t,e){var i,s=e.within,n=s.isWindow?s.scrollTop:s.offset.top,a=e.within.height,r=t.top-e.collisionPosition.marginTop,h=n-r,l=r+e.collisionHeight-a-n;e.collisionHeight>a?h>0&&0>=l?(i=t.top+h+e.collisionHeight-a-n,t.top+=h-i):t.top=l>0&&0>=h?n:h>l?n+a-e.collisionHeight:n:h>0?t.top+=h:l>0?t.top-=l:t.top=o(t.top-r,t.top)}},flip:{left:function(t,e){var i,s,n=e.within,a=n.offset.left+n.scrollLeft,o=n.width,h=n.isWindow?n.scrollLeft:n.offset.left,l=t.left-e.collisionPosition.marginLeft,c=l-h,u=l+e.collisionWidth-o-h,d="left"===e.my[0]?-e.elemWidth:"right"===e.my[0]?e.elemWidth:0,p="left"===e.at[0]?e.targetWidth:"right"===e.at[0]?-e.targetWidth:0,f=-2*e.offset[0];0>c?(i=t.left+d+p+f+e.collisionWidth-o-a,(0>i||r(c)>i)&&(t.left+=d+p+f)):u>0&&(s=t.left-e.collisionPosition.marginLeft+d+p+f-h,(s>0||u>r(s))&&(t.left+=d+p+f))},top:function(t,e){var i,s,n=e.within,a=n.offset.top+n.scrollTop,o=n.height,h=n.isWindow?n.scrollTop:n.offset.top,l=t.top-e.collisionPosition.marginTop,c=l-h,u=l+e.collisionHeight-o-h,d="top"===e.my[1],p=d?-e.elemHeight:"bottom"===e.my[1]?e.elemHeight:0,f="top"===e.at[1]?e.targetHeight:"bottom"===e.at[1]?-e.targetHeight:0,m=-2*e.offset[1];0>c?(s=t.top+p+f+m+e.collisionHeight-o-a,t.top+p+f+m>c&&(0>s||r(c)>s)&&(t.top+=p+f+m)):u>0&&(i=t.top-e.collisionPosition.marginTop+p+f+m-h,t.top+p+f+m>u&&(i>0||u>r(i))&&(t.top+=p+f+m))}},flipfit:{left:function(){t.ui.position.flip.left.apply(this,arguments),t.ui.position.fit.left.apply(this,arguments)},top:function(){t.ui.position.flip.top.apply(this,arguments),t.ui.position.fit.top.apply(this,arguments)}}},function(){var e,i,s,n,a,o=document.getElementsByTagName("body")[0],r=document.createElement("div");e=document.createElement(o?"div":"body"),s={visibility:"hidden",width:0,height:0,border:0,margin:0,background:"none"},o&&t.extend(s,{position:"absolute",left:"-1000px",top:"-1000px"});for(a in s)e.style[a]=s[a];e.appendChild(r),i=o||document.documentElement,i.insertBefore(e,i.firstChild),r.style.cssText="position: absolute; left: 10.7432222px;",n=t(r).offset().left,t.support.offsetFractions=n>10&&11>n,e.innerHTML="",i.removeChild(e)}()})(jQuery);
});
Numbas.queueScript('jquery',[],function() {
/*! jQuery v1.10.2 | (c) 2005, 2013 jQuery Foundation, Inc. | jquery.org/license
//@ sourceMappingURL=jquery-1.10.2.min.map
*/
(function(e,t){var n,r,i=typeof t,o=e.location,a=e.document,s=a.documentElement,l=e.jQuery,u=e.$,c={},p=[],f="1.10.2",d=p.concat,h=p.push,g=p.slice,m=p.indexOf,y=c.toString,v=c.hasOwnProperty,b=f.trim,x=function(e,t){return new x.fn.init(e,t,r)},w=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,T=/\S+/g,C=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,N=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,k=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,E=/^[\],:{}\s]*$/,S=/(?:^|:|,)(?:\s*\[)+/g,A=/\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,j=/"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,D=/^-ms-/,L=/-([\da-z])/gi,H=function(e,t){return t.toUpperCase()},q=function(e){(a.addEventListener||"load"===e.type||"complete"===a.readyState)&&(_(),x.ready())},_=function(){a.addEventListener?(a.removeEventListener("DOMContentLoaded",q,!1),e.removeEventListener("load",q,!1)):(a.detachEvent("onreadystatechange",q),e.detachEvent("onload",q))};x.fn=x.prototype={jquery:f,constructor:x,init:function(e,n,r){var i,o;if(!e)return this;if("string"==typeof e){if(i="<"===e.charAt(0)&&">"===e.charAt(e.length-1)&&e.length>=3?[null,e,null]:N.exec(e),!i||!i[1]&&n)return!n||n.jquery?(n||r).find(e):this.constructor(n).find(e);if(i[1]){if(n=n instanceof x?n[0]:n,x.merge(this,x.parseHTML(i[1],n&&n.nodeType?n.ownerDocument||n:a,!0)),k.test(i[1])&&x.isPlainObject(n))for(i in n)x.isFunction(this[i])?this[i](n[i]):this.attr(i,n[i]);return this}if(o=a.getElementById(i[2]),o&&o.parentNode){if(o.id!==i[2])return r.find(e);this.length=1,this[0]=o}return this.context=a,this.selector=e,this}return e.nodeType?(this.context=this[0]=e,this.length=1,this):x.isFunction(e)?r.ready(e):(e.selector!==t&&(this.selector=e.selector,this.context=e.context),x.makeArray(e,this))},selector:"",length:0,toArray:function(){return g.call(this)},get:function(e){return null==e?this.toArray():0>e?this[this.length+e]:this[e]},pushStack:function(e){var t=x.merge(this.constructor(),e);return t.prevObject=this,t.context=this.context,t},each:function(e,t){return x.each(this,e,t)},ready:function(e){return x.ready.promise().done(e),this},slice:function(){return this.pushStack(g.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(0>e?t:0);return this.pushStack(n>=0&&t>n?[this[n]]:[])},map:function(e){return this.pushStack(x.map(this,function(t,n){return e.call(t,n,t)}))},end:function(){return this.prevObject||this.constructor(null)},push:h,sort:[].sort,splice:[].splice},x.fn.init.prototype=x.fn,x.extend=x.fn.extend=function(){var e,n,r,i,o,a,s=arguments[0]||{},l=1,u=arguments.length,c=!1;for("boolean"==typeof s&&(c=s,s=arguments[1]||{},l=2),"object"==typeof s||x.isFunction(s)||(s={}),u===l&&(s=this,--l);u>l;l++)if(null!=(o=arguments[l]))for(i in o)e=s[i],r=o[i],s!==r&&(c&&r&&(x.isPlainObject(r)||(n=x.isArray(r)))?(n?(n=!1,a=e&&x.isArray(e)?e:[]):a=e&&x.isPlainObject(e)?e:{},s[i]=x.extend(c,a,r)):r!==t&&(s[i]=r));return s},x.extend({expando:"jQuery"+(f+Math.random()).replace(/\D/g,""),noConflict:function(t){return e.$===x&&(e.$=u),t&&e.jQuery===x&&(e.jQuery=l),x},isReady:!1,readyWait:1,holdReady:function(e){e?x.readyWait++:x.ready(!0)},ready:function(e){if(e===!0?!--x.readyWait:!x.isReady){if(!a.body)return setTimeout(x.ready);x.isReady=!0,e!==!0&&--x.readyWait>0||(n.resolveWith(a,[x]),x.fn.trigger&&x(a).trigger("ready").off("ready"))}},isFunction:function(e){return"function"===x.type(e)},isArray:Array.isArray||function(e){return"array"===x.type(e)},isWindow:function(e){return null!=e&&e==e.window},isNumeric:function(e){return!isNaN(parseFloat(e))&&isFinite(e)},type:function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?c[y.call(e)]||"object":typeof e},isPlainObject:function(e){var n;if(!e||"object"!==x.type(e)||e.nodeType||x.isWindow(e))return!1;try{if(e.constructor&&!v.call(e,"constructor")&&!v.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(r){return!1}if(x.support.ownLast)for(n in e)return v.call(e,n);for(n in e);return n===t||v.call(e,n)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},error:function(e){throw Error(e)},parseHTML:function(e,t,n){if(!e||"string"!=typeof e)return null;"boolean"==typeof t&&(n=t,t=!1),t=t||a;var r=k.exec(e),i=!n&&[];return r?[t.createElement(r[1])]:(r=x.buildFragment([e],t,i),i&&x(i).remove(),x.merge([],r.childNodes))},parseJSON:function(n){return e.JSON&&e.JSON.parse?e.JSON.parse(n):null===n?n:"string"==typeof n&&(n=x.trim(n),n&&E.test(n.replace(A,"@").replace(j,"]").replace(S,"")))?Function("return "+n)():(x.error("Invalid JSON: "+n),t)},parseXML:function(n){var r,i;if(!n||"string"!=typeof n)return null;try{e.DOMParser?(i=new DOMParser,r=i.parseFromString(n,"text/xml")):(r=new ActiveXObject("Microsoft.XMLDOM"),r.async="false",r.loadXML(n))}catch(o){r=t}return r&&r.documentElement&&!r.getElementsByTagName("parsererror").length||x.error("Invalid XML: "+n),r},noop:function(){},globalEval:function(t){t&&x.trim(t)&&(e.execScript||function(t){e.eval.call(e,t)})(t)},camelCase:function(e){return e.replace(D,"ms-").replace(L,H)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t,n){var r,i=0,o=e.length,a=M(e);if(n){if(a){for(;o>i;i++)if(r=t.apply(e[i],n),r===!1)break}else for(i in e)if(r=t.apply(e[i],n),r===!1)break}else if(a){for(;o>i;i++)if(r=t.call(e[i],i,e[i]),r===!1)break}else for(i in e)if(r=t.call(e[i],i,e[i]),r===!1)break;return e},trim:b&&!b.call("\ufeff\u00a0")?function(e){return null==e?"":b.call(e)}:function(e){return null==e?"":(e+"").replace(C,"")},makeArray:function(e,t){var n=t||[];return null!=e&&(M(Object(e))?x.merge(n,"string"==typeof e?[e]:e):h.call(n,e)),n},inArray:function(e,t,n){var r;if(t){if(m)return m.call(t,e,n);for(r=t.length,n=n?0>n?Math.max(0,r+n):n:0;r>n;n++)if(n in t&&t[n]===e)return n}return-1},merge:function(e,n){var r=n.length,i=e.length,o=0;if("number"==typeof r)for(;r>o;o++)e[i++]=n[o];else while(n[o]!==t)e[i++]=n[o++];return e.length=i,e},grep:function(e,t,n){var r,i=[],o=0,a=e.length;for(n=!!n;a>o;o++)r=!!t(e[o],o),n!==r&&i.push(e[o]);return i},map:function(e,t,n){var r,i=0,o=e.length,a=M(e),s=[];if(a)for(;o>i;i++)r=t(e[i],i,n),null!=r&&(s[s.length]=r);else for(i in e)r=t(e[i],i,n),null!=r&&(s[s.length]=r);return d.apply([],s)},guid:1,proxy:function(e,n){var r,i,o;return"string"==typeof n&&(o=e[n],n=e,e=o),x.isFunction(e)?(r=g.call(arguments,2),i=function(){return e.apply(n||this,r.concat(g.call(arguments)))},i.guid=e.guid=e.guid||x.guid++,i):t},access:function(e,n,r,i,o,a,s){var l=0,u=e.length,c=null==r;if("object"===x.type(r)){o=!0;for(l in r)x.access(e,n,l,r[l],!0,a,s)}else if(i!==t&&(o=!0,x.isFunction(i)||(s=!0),c&&(s?(n.call(e,i),n=null):(c=n,n=function(e,t,n){return c.call(x(e),n)})),n))for(;u>l;l++)n(e[l],r,s?i:i.call(e[l],l,n(e[l],r)));return o?e:c?n.call(e):u?n(e[0],r):a},now:function(){return(new Date).getTime()},swap:function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=a[o];return i}}),x.ready.promise=function(t){if(!n)if(n=x.Deferred(),"complete"===a.readyState)setTimeout(x.ready);else if(a.addEventListener)a.addEventListener("DOMContentLoaded",q,!1),e.addEventListener("load",q,!1);else{a.attachEvent("onreadystatechange",q),e.attachEvent("onload",q);var r=!1;try{r=null==e.frameElement&&a.documentElement}catch(i){}r&&r.doScroll&&function o(){if(!x.isReady){try{r.doScroll("left")}catch(e){return setTimeout(o,50)}_(),x.ready()}}()}return n.promise(t)},x.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(e,t){c["[object "+t+"]"]=t.toLowerCase()});function M(e){var t=e.length,n=x.type(e);return x.isWindow(e)?!1:1===e.nodeType&&t?!0:"array"===n||"function"!==n&&(0===t||"number"==typeof t&&t>0&&t-1 in e)}r=x(a),function(e,t){var n,r,i,o,a,s,l,u,c,p,f,d,h,g,m,y,v,b="sizzle"+-new Date,w=e.document,T=0,C=0,N=st(),k=st(),E=st(),S=!1,A=function(e,t){return e===t?(S=!0,0):0},j=typeof t,D=1<<31,L={}.hasOwnProperty,H=[],q=H.pop,_=H.push,M=H.push,O=H.slice,F=H.indexOf||function(e){var t=0,n=this.length;for(;n>t;t++)if(this[t]===e)return t;return-1},B="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",P="[\\x20\\t\\r\\n\\f]",R="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",W=R.replace("w","w#"),$="\\["+P+"*("+R+")"+P+"*(?:([*^$|!~]?=)"+P+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+W+")|)|)"+P+"*\\]",I=":("+R+")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|"+$.replace(3,8)+")*)|.*)\\)|)",z=RegExp("^"+P+"+|((?:^|[^\\\\])(?:\\\\.)*)"+P+"+$","g"),X=RegExp("^"+P+"*,"+P+"*"),U=RegExp("^"+P+"*([>+~]|"+P+")"+P+"*"),V=RegExp(P+"*[+~]"),Y=RegExp("="+P+"*([^\\]'\"]*)"+P+"*\\]","g"),J=RegExp(I),G=RegExp("^"+W+"$"),Q={ID:RegExp("^#("+R+")"),CLASS:RegExp("^\\.("+R+")"),TAG:RegExp("^("+R.replace("w","w*")+")"),ATTR:RegExp("^"+$),PSEUDO:RegExp("^"+I),CHILD:RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+P+"*(even|odd|(([+-]|)(\\d*)n|)"+P+"*(?:([+-]|)"+P+"*(\\d+)|))"+P+"*\\)|)","i"),bool:RegExp("^(?:"+B+")$","i"),needsContext:RegExp("^"+P+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+P+"*((?:-\\d)?\\d*)"+P+"*\\)|)(?=[^-]|$)","i")},K=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,et=/^(?:input|select|textarea|button)$/i,tt=/^h\d$/i,nt=/'|\\/g,rt=RegExp("\\\\([\\da-f]{1,6}"+P+"?|("+P+")|.)","ig"),it=function(e,t,n){var r="0x"+t-65536;return r!==r||n?t:0>r?String.fromCharCode(r+65536):String.fromCharCode(55296|r>>10,56320|1023&r)};try{M.apply(H=O.call(w.childNodes),w.childNodes),H[w.childNodes.length].nodeType}catch(ot){M={apply:H.length?function(e,t){_.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function at(e,t,n,i){var o,a,s,l,u,c,d,m,y,x;if((t?t.ownerDocument||t:w)!==f&&p(t),t=t||f,n=n||[],!e||"string"!=typeof e)return n;if(1!==(l=t.nodeType)&&9!==l)return[];if(h&&!i){if(o=Z.exec(e))if(s=o[1]){if(9===l){if(a=t.getElementById(s),!a||!a.parentNode)return n;if(a.id===s)return n.push(a),n}else if(t.ownerDocument&&(a=t.ownerDocument.getElementById(s))&&v(t,a)&&a.id===s)return n.push(a),n}else{if(o[2])return M.apply(n,t.getElementsByTagName(e)),n;if((s=o[3])&&r.getElementsByClassName&&t.getElementsByClassName)return M.apply(n,t.getElementsByClassName(s)),n}if(r.qsa&&(!g||!g.test(e))){if(m=d=b,y=t,x=9===l&&e,1===l&&"object"!==t.nodeName.toLowerCase()){c=mt(e),(d=t.getAttribute("id"))?m=d.replace(nt,"\\$&"):t.setAttribute("id",m),m="[id='"+m+"'] ",u=c.length;while(u--)c[u]=m+yt(c[u]);y=V.test(e)&&t.parentNode||t,x=c.join(",")}if(x)try{return M.apply(n,y.querySelectorAll(x)),n}catch(T){}finally{d||t.removeAttribute("id")}}}return kt(e.replace(z,"$1"),t,n,i)}function st(){var e=[];function t(n,r){return e.push(n+=" ")>o.cacheLength&&delete t[e.shift()],t[n]=r}return t}function lt(e){return e[b]=!0,e}function ut(e){var t=f.createElement("div");try{return!!e(t)}catch(n){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function ct(e,t){var n=e.split("|"),r=e.length;while(r--)o.attrHandle[n[r]]=t}function pt(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&(~t.sourceIndex||D)-(~e.sourceIndex||D);if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function ft(e){return function(t){var n=t.nodeName.toLowerCase();return"input"===n&&t.type===e}}function dt(e){return function(t){var n=t.nodeName.toLowerCase();return("input"===n||"button"===n)&&t.type===e}}function ht(e){return lt(function(t){return t=+t,lt(function(n,r){var i,o=e([],n.length,t),a=o.length;while(a--)n[i=o[a]]&&(n[i]=!(r[i]=n[i]))})})}s=at.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return t?"HTML"!==t.nodeName:!1},r=at.support={},p=at.setDocument=function(e){var n=e?e.ownerDocument||e:w,i=n.defaultView;return n!==f&&9===n.nodeType&&n.documentElement?(f=n,d=n.documentElement,h=!s(n),i&&i.attachEvent&&i!==i.top&&i.attachEvent("onbeforeunload",function(){p()}),r.attributes=ut(function(e){return e.className="i",!e.getAttribute("className")}),r.getElementsByTagName=ut(function(e){return e.appendChild(n.createComment("")),!e.getElementsByTagName("*").length}),r.getElementsByClassName=ut(function(e){return e.innerHTML="<div class='a'></div><div class='a i'></div>",e.firstChild.className="i",2===e.getElementsByClassName("i").length}),r.getById=ut(function(e){return d.appendChild(e).id=b,!n.getElementsByName||!n.getElementsByName(b).length}),r.getById?(o.find.ID=function(e,t){if(typeof t.getElementById!==j&&h){var n=t.getElementById(e);return n&&n.parentNode?[n]:[]}},o.filter.ID=function(e){var t=e.replace(rt,it);return function(e){return e.getAttribute("id")===t}}):(delete o.find.ID,o.filter.ID=function(e){var t=e.replace(rt,it);return function(e){var n=typeof e.getAttributeNode!==j&&e.getAttributeNode("id");return n&&n.value===t}}),o.find.TAG=r.getElementsByTagName?function(e,n){return typeof n.getElementsByTagName!==j?n.getElementsByTagName(e):t}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},o.find.CLASS=r.getElementsByClassName&&function(e,n){return typeof n.getElementsByClassName!==j&&h?n.getElementsByClassName(e):t},m=[],g=[],(r.qsa=K.test(n.querySelectorAll))&&(ut(function(e){e.innerHTML="<select><option selected=''></option></select>",e.querySelectorAll("[selected]").length||g.push("\\["+P+"*(?:value|"+B+")"),e.querySelectorAll(":checked").length||g.push(":checked")}),ut(function(e){var t=n.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("t",""),e.querySelectorAll("[t^='']").length&&g.push("[*^$]="+P+"*(?:''|\"\")"),e.querySelectorAll(":enabled").length||g.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),g.push(",.*:")})),(r.matchesSelector=K.test(y=d.webkitMatchesSelector||d.mozMatchesSelector||d.oMatchesSelector||d.msMatchesSelector))&&ut(function(e){r.disconnectedMatch=y.call(e,"div"),y.call(e,"[s!='']:x"),m.push("!=",I)}),g=g.length&&RegExp(g.join("|")),m=m.length&&RegExp(m.join("|")),v=K.test(d.contains)||d.compareDocumentPosition?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},A=d.compareDocumentPosition?function(e,t){if(e===t)return S=!0,0;var i=t.compareDocumentPosition&&e.compareDocumentPosition&&e.compareDocumentPosition(t);return i?1&i||!r.sortDetached&&t.compareDocumentPosition(e)===i?e===n||v(w,e)?-1:t===n||v(w,t)?1:c?F.call(c,e)-F.call(c,t):0:4&i?-1:1:e.compareDocumentPosition?-1:1}:function(e,t){var r,i=0,o=e.parentNode,a=t.parentNode,s=[e],l=[t];if(e===t)return S=!0,0;if(!o||!a)return e===n?-1:t===n?1:o?-1:a?1:c?F.call(c,e)-F.call(c,t):0;if(o===a)return pt(e,t);r=e;while(r=r.parentNode)s.unshift(r);r=t;while(r=r.parentNode)l.unshift(r);while(s[i]===l[i])i++;return i?pt(s[i],l[i]):s[i]===w?-1:l[i]===w?1:0},n):f},at.matches=function(e,t){return at(e,null,null,t)},at.matchesSelector=function(e,t){if((e.ownerDocument||e)!==f&&p(e),t=t.replace(Y,"='$1']"),!(!r.matchesSelector||!h||m&&m.test(t)||g&&g.test(t)))try{var n=y.call(e,t);if(n||r.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(i){}return at(t,f,null,[e]).length>0},at.contains=function(e,t){return(e.ownerDocument||e)!==f&&p(e),v(e,t)},at.attr=function(e,n){(e.ownerDocument||e)!==f&&p(e);var i=o.attrHandle[n.toLowerCase()],a=i&&L.call(o.attrHandle,n.toLowerCase())?i(e,n,!h):t;return a===t?r.attributes||!h?e.getAttribute(n):(a=e.getAttributeNode(n))&&a.specified?a.value:null:a},at.error=function(e){throw Error("Syntax error, unrecognized expression: "+e)},at.uniqueSort=function(e){var t,n=[],i=0,o=0;if(S=!r.detectDuplicates,c=!r.sortStable&&e.slice(0),e.sort(A),S){while(t=e[o++])t===e[o]&&(i=n.push(o));while(i--)e.splice(n[i],1)}return e},a=at.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=a(e)}else if(3===i||4===i)return e.nodeValue}else for(;t=e[r];r++)n+=a(t);return n},o=at.selectors={cacheLength:50,createPseudo:lt,match:Q,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(rt,it),e[3]=(e[4]||e[5]||"").replace(rt,it),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||at.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&at.error(e[0]),e},PSEUDO:function(e){var n,r=!e[5]&&e[2];return Q.CHILD.test(e[0])?null:(e[3]&&e[4]!==t?e[2]=e[4]:r&&J.test(r)&&(n=mt(r,!0))&&(n=r.indexOf(")",r.length-n)-r.length)&&(e[0]=e[0].slice(0,n),e[2]=r.slice(0,n)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(rt,it).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=N[e+" "];return t||(t=RegExp("(^|"+P+")"+e+"("+P+"|$)"))&&N(e,function(e){return t.test("string"==typeof e.className&&e.className||typeof e.getAttribute!==j&&e.getAttribute("class")||"")})},ATTR:function(e,t,n){return function(r){var i=at.attr(r,e);return null==i?"!="===t:t?(i+="","="===t?i===n:"!="===t?i!==n:"^="===t?n&&0===i.indexOf(n):"*="===t?n&&i.indexOf(n)>-1:"$="===t?n&&i.slice(-n.length)===n:"~="===t?(" "+i+" ").indexOf(n)>-1:"|="===t?i===n||i.slice(0,n.length+1)===n+"-":!1):!0}},CHILD:function(e,t,n,r,i){var o="nth"!==e.slice(0,3),a="last"!==e.slice(-4),s="of-type"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,l){var u,c,p,f,d,h,g=o!==a?"nextSibling":"previousSibling",m=t.parentNode,y=s&&t.nodeName.toLowerCase(),v=!l&&!s;if(m){if(o){while(g){p=t;while(p=p[g])if(s?p.nodeName.toLowerCase()===y:1===p.nodeType)return!1;h=g="only"===e&&!h&&"nextSibling"}return!0}if(h=[a?m.firstChild:m.lastChild],a&&v){c=m[b]||(m[b]={}),u=c[e]||[],d=u[0]===T&&u[1],f=u[0]===T&&u[2],p=d&&m.childNodes[d];while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if(1===p.nodeType&&++f&&p===t){c[e]=[T,d,f];break}}else if(v&&(u=(t[b]||(t[b]={}))[e])&&u[0]===T)f=u[1];else while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if((s?p.nodeName.toLowerCase()===y:1===p.nodeType)&&++f&&(v&&((p[b]||(p[b]={}))[e]=[T,f]),p===t))break;return f-=i,f===r||0===f%r&&f/r>=0}}},PSEUDO:function(e,t){var n,r=o.pseudos[e]||o.setFilters[e.toLowerCase()]||at.error("unsupported pseudo: "+e);return r[b]?r(t):r.length>1?(n=[e,e,"",t],o.setFilters.hasOwnProperty(e.toLowerCase())?lt(function(e,n){var i,o=r(e,t),a=o.length;while(a--)i=F.call(e,o[a]),e[i]=!(n[i]=o[a])}):function(e){return r(e,0,n)}):r}},pseudos:{not:lt(function(e){var t=[],n=[],r=l(e.replace(z,"$1"));return r[b]?lt(function(e,t,n,i){var o,a=r(e,null,i,[]),s=e.length;while(s--)(o=a[s])&&(e[s]=!(t[s]=o))}):function(e,i,o){return t[0]=e,r(t,null,o,n),!n.pop()}}),has:lt(function(e){return function(t){return at(e,t).length>0}}),contains:lt(function(e){return function(t){return(t.textContent||t.innerText||a(t)).indexOf(e)>-1}}),lang:lt(function(e){return G.test(e||"")||at.error("unsupported lang: "+e),e=e.replace(rt,it).toLowerCase(),function(t){var n;do if(n=h?t.lang:t.getAttribute("xml:lang")||t.getAttribute("lang"))return n=n.toLowerCase(),n===e||0===n.indexOf(e+"-");while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===d},focus:function(e){return e===f.activeElement&&(!f.hasFocus||f.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:function(e){return e.disabled===!1},disabled:function(e){return e.disabled===!0},checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeName>"@"||3===e.nodeType||4===e.nodeType)return!1;return!0},parent:function(e){return!o.pseudos.empty(e)},header:function(e){return tt.test(e.nodeName)},input:function(e){return et.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||t.toLowerCase()===e.type)},first:ht(function(){return[0]}),last:ht(function(e,t){return[t-1]}),eq:ht(function(e,t,n){return[0>n?n+t:n]}),even:ht(function(e,t){var n=0;for(;t>n;n+=2)e.push(n);return e}),odd:ht(function(e,t){var n=1;for(;t>n;n+=2)e.push(n);return e}),lt:ht(function(e,t,n){var r=0>n?n+t:n;for(;--r>=0;)e.push(r);return e}),gt:ht(function(e,t,n){var r=0>n?n+t:n;for(;t>++r;)e.push(r);return e})}},o.pseudos.nth=o.pseudos.eq;for(n in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})o.pseudos[n]=ft(n);for(n in{submit:!0,reset:!0})o.pseudos[n]=dt(n);function gt(){}gt.prototype=o.filters=o.pseudos,o.setFilters=new gt;function mt(e,t){var n,r,i,a,s,l,u,c=k[e+" "];if(c)return t?0:c.slice(0);s=e,l=[],u=o.preFilter;while(s){(!n||(r=X.exec(s)))&&(r&&(s=s.slice(r[0].length)||s),l.push(i=[])),n=!1,(r=U.exec(s))&&(n=r.shift(),i.push({value:n,type:r[0].replace(z," ")}),s=s.slice(n.length));for(a in o.filter)!(r=Q[a].exec(s))||u[a]&&!(r=u[a](r))||(n=r.shift(),i.push({value:n,type:a,matches:r}),s=s.slice(n.length));if(!n)break}return t?s.length:s?at.error(e):k(e,l).slice(0)}function yt(e){var t=0,n=e.length,r="";for(;n>t;t++)r+=e[t].value;return r}function vt(e,t,n){var r=t.dir,o=n&&"parentNode"===r,a=C++;return t.first?function(t,n,i){while(t=t[r])if(1===t.nodeType||o)return e(t,n,i)}:function(t,n,s){var l,u,c,p=T+" "+a;if(s){while(t=t[r])if((1===t.nodeType||o)&&e(t,n,s))return!0}else while(t=t[r])if(1===t.nodeType||o)if(c=t[b]||(t[b]={}),(u=c[r])&&u[0]===p){if((l=u[1])===!0||l===i)return l===!0}else if(u=c[r]=[p],u[1]=e(t,n,s)||i,u[1]===!0)return!0}}function bt(e){return e.length>1?function(t,n,r){var i=e.length;while(i--)if(!e[i](t,n,r))return!1;return!0}:e[0]}function xt(e,t,n,r,i){var o,a=[],s=0,l=e.length,u=null!=t;for(;l>s;s++)(o=e[s])&&(!n||n(o,r,i))&&(a.push(o),u&&t.push(s));return a}function wt(e,t,n,r,i,o){return r&&!r[b]&&(r=wt(r)),i&&!i[b]&&(i=wt(i,o)),lt(function(o,a,s,l){var u,c,p,f=[],d=[],h=a.length,g=o||Nt(t||"*",s.nodeType?[s]:s,[]),m=!e||!o&&t?g:xt(g,f,e,s,l),y=n?i||(o?e:h||r)?[]:a:m;if(n&&n(m,y,s,l),r){u=xt(y,d),r(u,[],s,l),c=u.length;while(c--)(p=u[c])&&(y[d[c]]=!(m[d[c]]=p))}if(o){if(i||e){if(i){u=[],c=y.length;while(c--)(p=y[c])&&u.push(m[c]=p);i(null,y=[],u,l)}c=y.length;while(c--)(p=y[c])&&(u=i?F.call(o,p):f[c])>-1&&(o[u]=!(a[u]=p))}}else y=xt(y===a?y.splice(h,y.length):y),i?i(null,a,y,l):M.apply(a,y)})}function Tt(e){var t,n,r,i=e.length,a=o.relative[e[0].type],s=a||o.relative[" "],l=a?1:0,c=vt(function(e){return e===t},s,!0),p=vt(function(e){return F.call(t,e)>-1},s,!0),f=[function(e,n,r){return!a&&(r||n!==u)||((t=n).nodeType?c(e,n,r):p(e,n,r))}];for(;i>l;l++)if(n=o.relative[e[l].type])f=[vt(bt(f),n)];else{if(n=o.filter[e[l].type].apply(null,e[l].matches),n[b]){for(r=++l;i>r;r++)if(o.relative[e[r].type])break;return wt(l>1&&bt(f),l>1&&yt(e.slice(0,l-1).concat({value:" "===e[l-2].type?"*":""})).replace(z,"$1"),n,r>l&&Tt(e.slice(l,r)),i>r&&Tt(e=e.slice(r)),i>r&&yt(e))}f.push(n)}return bt(f)}function Ct(e,t){var n=0,r=t.length>0,a=e.length>0,s=function(s,l,c,p,d){var h,g,m,y=[],v=0,b="0",x=s&&[],w=null!=d,C=u,N=s||a&&o.find.TAG("*",d&&l.parentNode||l),k=T+=null==C?1:Math.random()||.1;for(w&&(u=l!==f&&l,i=n);null!=(h=N[b]);b++){if(a&&h){g=0;while(m=e[g++])if(m(h,l,c)){p.push(h);break}w&&(T=k,i=++n)}r&&((h=!m&&h)&&v--,s&&x.push(h))}if(v+=b,r&&b!==v){g=0;while(m=t[g++])m(x,y,l,c);if(s){if(v>0)while(b--)x[b]||y[b]||(y[b]=q.call(p));y=xt(y)}M.apply(p,y),w&&!s&&y.length>0&&v+t.length>1&&at.uniqueSort(p)}return w&&(T=k,u=C),x};return r?lt(s):s}l=at.compile=function(e,t){var n,r=[],i=[],o=E[e+" "];if(!o){t||(t=mt(e)),n=t.length;while(n--)o=Tt(t[n]),o[b]?r.push(o):i.push(o);o=E(e,Ct(i,r))}return o};function Nt(e,t,n){var r=0,i=t.length;for(;i>r;r++)at(e,t[r],n);return n}function kt(e,t,n,i){var a,s,u,c,p,f=mt(e);if(!i&&1===f.length){if(s=f[0]=f[0].slice(0),s.length>2&&"ID"===(u=s[0]).type&&r.getById&&9===t.nodeType&&h&&o.relative[s[1].type]){if(t=(o.find.ID(u.matches[0].replace(rt,it),t)||[])[0],!t)return n;e=e.slice(s.shift().value.length)}a=Q.needsContext.test(e)?0:s.length;while(a--){if(u=s[a],o.relative[c=u.type])break;if((p=o.find[c])&&(i=p(u.matches[0].replace(rt,it),V.test(s[0].type)&&t.parentNode||t))){if(s.splice(a,1),e=i.length&&yt(s),!e)return M.apply(n,i),n;break}}}return l(e,f)(i,t,!h,n,V.test(e)),n}r.sortStable=b.split("").sort(A).join("")===b,r.detectDuplicates=S,p(),r.sortDetached=ut(function(e){return 1&e.compareDocumentPosition(f.createElement("div"))}),ut(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||ct("type|href|height|width",function(e,n,r){return r?t:e.getAttribute(n,"type"===n.toLowerCase()?1:2)}),r.attributes&&ut(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||ct("value",function(e,n,r){return r||"input"!==e.nodeName.toLowerCase()?t:e.defaultValue}),ut(function(e){return null==e.getAttribute("disabled")})||ct(B,function(e,n,r){var i;return r?t:(i=e.getAttributeNode(n))&&i.specified?i.value:e[n]===!0?n.toLowerCase():null}),x.find=at,x.expr=at.selectors,x.expr[":"]=x.expr.pseudos,x.unique=at.uniqueSort,x.text=at.getText,x.isXMLDoc=at.isXML,x.contains=at.contains}(e);var O={};function F(e){var t=O[e]={};return x.each(e.match(T)||[],function(e,n){t[n]=!0}),t}x.Callbacks=function(e){e="string"==typeof e?O[e]||F(e):x.extend({},e);var n,r,i,o,a,s,l=[],u=!e.once&&[],c=function(t){for(r=e.memory&&t,i=!0,a=s||0,s=0,o=l.length,n=!0;l&&o>a;a++)if(l[a].apply(t[0],t[1])===!1&&e.stopOnFalse){r=!1;break}n=!1,l&&(u?u.length&&c(u.shift()):r?l=[]:p.disable())},p={add:function(){if(l){var t=l.length;(function i(t){x.each(t,function(t,n){var r=x.type(n);"function"===r?e.unique&&p.has(n)||l.push(n):n&&n.length&&"string"!==r&&i(n)})})(arguments),n?o=l.length:r&&(s=t,c(r))}return this},remove:function(){return l&&x.each(arguments,function(e,t){var r;while((r=x.inArray(t,l,r))>-1)l.splice(r,1),n&&(o>=r&&o--,a>=r&&a--)}),this},has:function(e){return e?x.inArray(e,l)>-1:!(!l||!l.length)},empty:function(){return l=[],o=0,this},disable:function(){return l=u=r=t,this},disabled:function(){return!l},lock:function(){return u=t,r||p.disable(),this},locked:function(){return!u},fireWith:function(e,t){return!l||i&&!u||(t=t||[],t=[e,t.slice?t.slice():t],n?u.push(t):c(t)),this},fire:function(){return p.fireWith(this,arguments),this},fired:function(){return!!i}};return p},x.extend({Deferred:function(e){var t=[["resolve","done",x.Callbacks("once memory"),"resolved"],["reject","fail",x.Callbacks("once memory"),"rejected"],["notify","progress",x.Callbacks("memory")]],n="pending",r={state:function(){return n},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var e=arguments;return x.Deferred(function(n){x.each(t,function(t,o){var a=o[0],s=x.isFunction(e[t])&&e[t];i[o[1]](function(){var e=s&&s.apply(this,arguments);e&&x.isFunction(e.promise)?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[a+"With"](this===r?n.promise():this,s?[e]:arguments)})}),e=null}).promise()},promise:function(e){return null!=e?x.extend(e,r):r}},i={};return r.pipe=r.then,x.each(t,function(e,o){var a=o[2],s=o[3];r[o[1]]=a.add,s&&a.add(function(){n=s},t[1^e][2].disable,t[2][2].lock),i[o[0]]=function(){return i[o[0]+"With"](this===i?r:this,arguments),this},i[o[0]+"With"]=a.fireWith}),r.promise(i),e&&e.call(i,i),i},when:function(e){var t=0,n=g.call(arguments),r=n.length,i=1!==r||e&&x.isFunction(e.promise)?r:0,o=1===i?e:x.Deferred(),a=function(e,t,n){return function(r){t[e]=this,n[e]=arguments.length>1?g.call(arguments):r,n===s?o.notifyWith(t,n):--i||o.resolveWith(t,n)}},s,l,u;if(r>1)for(s=Array(r),l=Array(r),u=Array(r);r>t;t++)n[t]&&x.isFunction(n[t].promise)?n[t].promise().done(a(t,u,n)).fail(o.reject).progress(a(t,l,s)):--i;return i||o.resolveWith(u,n),o.promise()}}),x.support=function(t){var n,r,o,s,l,u,c,p,f,d=a.createElement("div");if(d.setAttribute("className","t"),d.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",n=d.getElementsByTagName("*")||[],r=d.getElementsByTagName("a")[0],!r||!r.style||!n.length)return t;s=a.createElement("select"),u=s.appendChild(a.createElement("option")),o=d.getElementsByTagName("input")[0],r.style.cssText="top:1px;float:left;opacity:.5",t.getSetAttribute="t"!==d.className,t.leadingWhitespace=3===d.firstChild.nodeType,t.tbody=!d.getElementsByTagName("tbody").length,t.htmlSerialize=!!d.getElementsByTagName("link").length,t.style=/top/.test(r.getAttribute("style")),t.hrefNormalized="/a"===r.getAttribute("href"),t.opacity=/^0.5/.test(r.style.opacity),t.cssFloat=!!r.style.cssFloat,t.checkOn=!!o.value,t.optSelected=u.selected,t.enctype=!!a.createElement("form").enctype,t.html5Clone="<:nav></:nav>"!==a.createElement("nav").cloneNode(!0).outerHTML,t.inlineBlockNeedsLayout=!1,t.shrinkWrapBlocks=!1,t.pixelPosition=!1,t.deleteExpando=!0,t.noCloneEvent=!0,t.reliableMarginRight=!0,t.boxSizingReliable=!0,o.checked=!0,t.noCloneChecked=o.cloneNode(!0).checked,s.disabled=!0,t.optDisabled=!u.disabled;try{delete d.test}catch(h){t.deleteExpando=!1}o=a.createElement("input"),o.setAttribute("value",""),t.input=""===o.getAttribute("value"),o.value="t",o.setAttribute("type","radio"),t.radioValue="t"===o.value,o.setAttribute("checked","t"),o.setAttribute("name","t"),l=a.createDocumentFragment(),l.appendChild(o),t.appendChecked=o.checked,t.checkClone=l.cloneNode(!0).cloneNode(!0).lastChild.checked,d.attachEvent&&(d.attachEvent("onclick",function(){t.noCloneEvent=!1}),d.cloneNode(!0).click());for(f in{submit:!0,change:!0,focusin:!0})d.setAttribute(c="on"+f,"t"),t[f+"Bubbles"]=c in e||d.attributes[c].expando===!1;d.style.backgroundClip="content-box",d.cloneNode(!0).style.backgroundClip="",t.clearCloneStyle="content-box"===d.style.backgroundClip;for(f in x(t))break;return t.ownLast="0"!==f,x(function(){var n,r,o,s="padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",l=a.getElementsByTagName("body")[0];l&&(n=a.createElement("div"),n.style.cssText="border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",l.appendChild(n).appendChild(d),d.innerHTML="<table><tr><td></td><td>t</td></tr></table>",o=d.getElementsByTagName("td"),o[0].style.cssText="padding:0;margin:0;border:0;display:none",p=0===o[0].offsetHeight,o[0].style.display="",o[1].style.display="none",t.reliableHiddenOffsets=p&&0===o[0].offsetHeight,d.innerHTML="",d.style.cssText="box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;",x.swap(l,null!=l.style.zoom?{zoom:1}:{},function(){t.boxSizing=4===d.offsetWidth}),e.getComputedStyle&&(t.pixelPosition="1%"!==(e.getComputedStyle(d,null)||{}).top,t.boxSizingReliable="4px"===(e.getComputedStyle(d,null)||{width:"4px"}).width,r=d.appendChild(a.createElement("div")),r.style.cssText=d.style.cssText=s,r.style.marginRight=r.style.width="0",d.style.width="1px",t.reliableMarginRight=!parseFloat((e.getComputedStyle(r,null)||{}).marginRight)),typeof d.style.zoom!==i&&(d.innerHTML="",d.style.cssText=s+"width:1px;padding:1px;display:inline;zoom:1",t.inlineBlockNeedsLayout=3===d.offsetWidth,d.style.display="block",d.innerHTML="<div></div>",d.firstChild.style.width="5px",t.shrinkWrapBlocks=3!==d.offsetWidth,t.inlineBlockNeedsLayout&&(l.style.zoom=1)),l.removeChild(n),n=d=o=r=null)}),n=s=l=u=r=o=null,t
}({});var B=/(?:\{[\s\S]*\}|\[[\s\S]*\])$/,P=/([A-Z])/g;function R(e,n,r,i){if(x.acceptData(e)){var o,a,s=x.expando,l=e.nodeType,u=l?x.cache:e,c=l?e[s]:e[s]&&s;if(c&&u[c]&&(i||u[c].data)||r!==t||"string"!=typeof n)return c||(c=l?e[s]=p.pop()||x.guid++:s),u[c]||(u[c]=l?{}:{toJSON:x.noop}),("object"==typeof n||"function"==typeof n)&&(i?u[c]=x.extend(u[c],n):u[c].data=x.extend(u[c].data,n)),a=u[c],i||(a.data||(a.data={}),a=a.data),r!==t&&(a[x.camelCase(n)]=r),"string"==typeof n?(o=a[n],null==o&&(o=a[x.camelCase(n)])):o=a,o}}function W(e,t,n){if(x.acceptData(e)){var r,i,o=e.nodeType,a=o?x.cache:e,s=o?e[x.expando]:x.expando;if(a[s]){if(t&&(r=n?a[s]:a[s].data)){x.isArray(t)?t=t.concat(x.map(t,x.camelCase)):t in r?t=[t]:(t=x.camelCase(t),t=t in r?[t]:t.split(" ")),i=t.length;while(i--)delete r[t[i]];if(n?!I(r):!x.isEmptyObject(r))return}(n||(delete a[s].data,I(a[s])))&&(o?x.cleanData([e],!0):x.support.deleteExpando||a!=a.window?delete a[s]:a[s]=null)}}}x.extend({cache:{},noData:{applet:!0,embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"},hasData:function(e){return e=e.nodeType?x.cache[e[x.expando]]:e[x.expando],!!e&&!I(e)},data:function(e,t,n){return R(e,t,n)},removeData:function(e,t){return W(e,t)},_data:function(e,t,n){return R(e,t,n,!0)},_removeData:function(e,t){return W(e,t,!0)},acceptData:function(e){if(e.nodeType&&1!==e.nodeType&&9!==e.nodeType)return!1;var t=e.nodeName&&x.noData[e.nodeName.toLowerCase()];return!t||t!==!0&&e.getAttribute("classid")===t}}),x.fn.extend({data:function(e,n){var r,i,o=null,a=0,s=this[0];if(e===t){if(this.length&&(o=x.data(s),1===s.nodeType&&!x._data(s,"parsedAttrs"))){for(r=s.attributes;r.length>a;a++)i=r[a].name,0===i.indexOf("data-")&&(i=x.camelCase(i.slice(5)),$(s,i,o[i]));x._data(s,"parsedAttrs",!0)}return o}return"object"==typeof e?this.each(function(){x.data(this,e)}):arguments.length>1?this.each(function(){x.data(this,e,n)}):s?$(s,e,x.data(s,e)):null},removeData:function(e){return this.each(function(){x.removeData(this,e)})}});function $(e,n,r){if(r===t&&1===e.nodeType){var i="data-"+n.replace(P,"-$1").toLowerCase();if(r=e.getAttribute(i),"string"==typeof r){try{r="true"===r?!0:"false"===r?!1:"null"===r?null:+r+""===r?+r:B.test(r)?x.parseJSON(r):r}catch(o){}x.data(e,n,r)}else r=t}return r}function I(e){var t;for(t in e)if(("data"!==t||!x.isEmptyObject(e[t]))&&"toJSON"!==t)return!1;return!0}x.extend({queue:function(e,n,r){var i;return e?(n=(n||"fx")+"queue",i=x._data(e,n),r&&(!i||x.isArray(r)?i=x._data(e,n,x.makeArray(r)):i.push(r)),i||[]):t},dequeue:function(e,t){t=t||"fx";var n=x.queue(e,t),r=n.length,i=n.shift(),o=x._queueHooks(e,t),a=function(){x.dequeue(e,t)};"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,a,o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return x._data(e,n)||x._data(e,n,{empty:x.Callbacks("once memory").add(function(){x._removeData(e,t+"queue"),x._removeData(e,n)})})}}),x.fn.extend({queue:function(e,n){var r=2;return"string"!=typeof e&&(n=e,e="fx",r--),r>arguments.length?x.queue(this[0],e):n===t?this:this.each(function(){var t=x.queue(this,e,n);x._queueHooks(this,e),"fx"===e&&"inprogress"!==t[0]&&x.dequeue(this,e)})},dequeue:function(e){return this.each(function(){x.dequeue(this,e)})},delay:function(e,t){return e=x.fx?x.fx.speeds[e]||e:e,t=t||"fx",this.queue(t,function(t,n){var r=setTimeout(t,e);n.stop=function(){clearTimeout(r)}})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,n){var r,i=1,o=x.Deferred(),a=this,s=this.length,l=function(){--i||o.resolveWith(a,[a])};"string"!=typeof e&&(n=e,e=t),e=e||"fx";while(s--)r=x._data(a[s],e+"queueHooks"),r&&r.empty&&(i++,r.empty.add(l));return l(),o.promise(n)}});var z,X,U=/[\t\r\n\f]/g,V=/\r/g,Y=/^(?:input|select|textarea|button|object)$/i,J=/^(?:a|area)$/i,G=/^(?:checked|selected)$/i,Q=x.support.getSetAttribute,K=x.support.input;x.fn.extend({attr:function(e,t){return x.access(this,x.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){x.removeAttr(this,e)})},prop:function(e,t){return x.access(this,x.prop,e,t,arguments.length>1)},removeProp:function(e){return e=x.propFix[e]||e,this.each(function(){try{this[e]=t,delete this[e]}catch(n){}})},addClass:function(e){var t,n,r,i,o,a=0,s=this.length,l="string"==typeof e&&e;if(x.isFunction(e))return this.each(function(t){x(this).addClass(e.call(this,t,this.className))});if(l)for(t=(e||"").match(T)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(U," "):" ")){o=0;while(i=t[o++])0>r.indexOf(" "+i+" ")&&(r+=i+" ");n.className=x.trim(r)}return this},removeClass:function(e){var t,n,r,i,o,a=0,s=this.length,l=0===arguments.length||"string"==typeof e&&e;if(x.isFunction(e))return this.each(function(t){x(this).removeClass(e.call(this,t,this.className))});if(l)for(t=(e||"").match(T)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(U," "):"")){o=0;while(i=t[o++])while(r.indexOf(" "+i+" ")>=0)r=r.replace(" "+i+" "," ");n.className=e?x.trim(r):""}return this},toggleClass:function(e,t){var n=typeof e;return"boolean"==typeof t&&"string"===n?t?this.addClass(e):this.removeClass(e):x.isFunction(e)?this.each(function(n){x(this).toggleClass(e.call(this,n,this.className,t),t)}):this.each(function(){if("string"===n){var t,r=0,o=x(this),a=e.match(T)||[];while(t=a[r++])o.hasClass(t)?o.removeClass(t):o.addClass(t)}else(n===i||"boolean"===n)&&(this.className&&x._data(this,"__className__",this.className),this.className=this.className||e===!1?"":x._data(this,"__className__")||"")})},hasClass:function(e){var t=" "+e+" ",n=0,r=this.length;for(;r>n;n++)if(1===this[n].nodeType&&(" "+this[n].className+" ").replace(U," ").indexOf(t)>=0)return!0;return!1},val:function(e){var n,r,i,o=this[0];{if(arguments.length)return i=x.isFunction(e),this.each(function(n){var o;1===this.nodeType&&(o=i?e.call(this,n,x(this).val()):e,null==o?o="":"number"==typeof o?o+="":x.isArray(o)&&(o=x.map(o,function(e){return null==e?"":e+""})),r=x.valHooks[this.type]||x.valHooks[this.nodeName.toLowerCase()],r&&"set"in r&&r.set(this,o,"value")!==t||(this.value=o))});if(o)return r=x.valHooks[o.type]||x.valHooks[o.nodeName.toLowerCase()],r&&"get"in r&&(n=r.get(o,"value"))!==t?n:(n=o.value,"string"==typeof n?n.replace(V,""):null==n?"":n)}}}),x.extend({valHooks:{option:{get:function(e){var t=x.find.attr(e,"value");return null!=t?t:e.text}},select:{get:function(e){var t,n,r=e.options,i=e.selectedIndex,o="select-one"===e.type||0>i,a=o?null:[],s=o?i+1:r.length,l=0>i?s:o?i:0;for(;s>l;l++)if(n=r[l],!(!n.selected&&l!==i||(x.support.optDisabled?n.disabled:null!==n.getAttribute("disabled"))||n.parentNode.disabled&&x.nodeName(n.parentNode,"optgroup"))){if(t=x(n).val(),o)return t;a.push(t)}return a},set:function(e,t){var n,r,i=e.options,o=x.makeArray(t),a=i.length;while(a--)r=i[a],(r.selected=x.inArray(x(r).val(),o)>=0)&&(n=!0);return n||(e.selectedIndex=-1),o}}},attr:function(e,n,r){var o,a,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return typeof e.getAttribute===i?x.prop(e,n,r):(1===s&&x.isXMLDoc(e)||(n=n.toLowerCase(),o=x.attrHooks[n]||(x.expr.match.bool.test(n)?X:z)),r===t?o&&"get"in o&&null!==(a=o.get(e,n))?a:(a=x.find.attr(e,n),null==a?t:a):null!==r?o&&"set"in o&&(a=o.set(e,r,n))!==t?a:(e.setAttribute(n,r+""),r):(x.removeAttr(e,n),t))},removeAttr:function(e,t){var n,r,i=0,o=t&&t.match(T);if(o&&1===e.nodeType)while(n=o[i++])r=x.propFix[n]||n,x.expr.match.bool.test(n)?K&&Q||!G.test(n)?e[r]=!1:e[x.camelCase("default-"+n)]=e[r]=!1:x.attr(e,n,""),e.removeAttribute(Q?n:r)},attrHooks:{type:{set:function(e,t){if(!x.support.radioValue&&"radio"===t&&x.nodeName(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},propFix:{"for":"htmlFor","class":"className"},prop:function(e,n,r){var i,o,a,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return a=1!==s||!x.isXMLDoc(e),a&&(n=x.propFix[n]||n,o=x.propHooks[n]),r!==t?o&&"set"in o&&(i=o.set(e,r,n))!==t?i:e[n]=r:o&&"get"in o&&null!==(i=o.get(e,n))?i:e[n]},propHooks:{tabIndex:{get:function(e){var t=x.find.attr(e,"tabindex");return t?parseInt(t,10):Y.test(e.nodeName)||J.test(e.nodeName)&&e.href?0:-1}}}}),X={set:function(e,t,n){return t===!1?x.removeAttr(e,n):K&&Q||!G.test(n)?e.setAttribute(!Q&&x.propFix[n]||n,n):e[x.camelCase("default-"+n)]=e[n]=!0,n}},x.each(x.expr.match.bool.source.match(/\w+/g),function(e,n){var r=x.expr.attrHandle[n]||x.find.attr;x.expr.attrHandle[n]=K&&Q||!G.test(n)?function(e,n,i){var o=x.expr.attrHandle[n],a=i?t:(x.expr.attrHandle[n]=t)!=r(e,n,i)?n.toLowerCase():null;return x.expr.attrHandle[n]=o,a}:function(e,n,r){return r?t:e[x.camelCase("default-"+n)]?n.toLowerCase():null}}),K&&Q||(x.attrHooks.value={set:function(e,n,r){return x.nodeName(e,"input")?(e.defaultValue=n,t):z&&z.set(e,n,r)}}),Q||(z={set:function(e,n,r){var i=e.getAttributeNode(r);return i||e.setAttributeNode(i=e.ownerDocument.createAttribute(r)),i.value=n+="","value"===r||n===e.getAttribute(r)?n:t}},x.expr.attrHandle.id=x.expr.attrHandle.name=x.expr.attrHandle.coords=function(e,n,r){var i;return r?t:(i=e.getAttributeNode(n))&&""!==i.value?i.value:null},x.valHooks.button={get:function(e,n){var r=e.getAttributeNode(n);return r&&r.specified?r.value:t},set:z.set},x.attrHooks.contenteditable={set:function(e,t,n){z.set(e,""===t?!1:t,n)}},x.each(["width","height"],function(e,n){x.attrHooks[n]={set:function(e,r){return""===r?(e.setAttribute(n,"auto"),r):t}}})),x.support.hrefNormalized||x.each(["href","src"],function(e,t){x.propHooks[t]={get:function(e){return e.getAttribute(t,4)}}}),x.support.style||(x.attrHooks.style={get:function(e){return e.style.cssText||t},set:function(e,t){return e.style.cssText=t+""}}),x.support.optSelected||(x.propHooks.selected={get:function(e){var t=e.parentNode;return t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex),null}}),x.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){x.propFix[this.toLowerCase()]=this}),x.support.enctype||(x.propFix.enctype="encoding"),x.each(["radio","checkbox"],function(){x.valHooks[this]={set:function(e,n){return x.isArray(n)?e.checked=x.inArray(x(e).val(),n)>=0:t}},x.support.checkOn||(x.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})});var Z=/^(?:input|select|textarea)$/i,et=/^key/,tt=/^(?:mouse|contextmenu)|click/,nt=/^(?:focusinfocus|focusoutblur)$/,rt=/^([^.]*)(?:\.(.+)|)$/;function it(){return!0}function ot(){return!1}function at(){try{return a.activeElement}catch(e){}}x.event={global:{},add:function(e,n,r,o,a){var s,l,u,c,p,f,d,h,g,m,y,v=x._data(e);if(v){r.handler&&(c=r,r=c.handler,a=c.selector),r.guid||(r.guid=x.guid++),(l=v.events)||(l=v.events={}),(f=v.handle)||(f=v.handle=function(e){return typeof x===i||e&&x.event.triggered===e.type?t:x.event.dispatch.apply(f.elem,arguments)},f.elem=e),n=(n||"").match(T)||[""],u=n.length;while(u--)s=rt.exec(n[u])||[],g=y=s[1],m=(s[2]||"").split(".").sort(),g&&(p=x.event.special[g]||{},g=(a?p.delegateType:p.bindType)||g,p=x.event.special[g]||{},d=x.extend({type:g,origType:y,data:o,handler:r,guid:r.guid,selector:a,needsContext:a&&x.expr.match.needsContext.test(a),namespace:m.join(".")},c),(h=l[g])||(h=l[g]=[],h.delegateCount=0,p.setup&&p.setup.call(e,o,m,f)!==!1||(e.addEventListener?e.addEventListener(g,f,!1):e.attachEvent&&e.attachEvent("on"+g,f))),p.add&&(p.add.call(e,d),d.handler.guid||(d.handler.guid=r.guid)),a?h.splice(h.delegateCount++,0,d):h.push(d),x.event.global[g]=!0);e=null}},remove:function(e,t,n,r,i){var o,a,s,l,u,c,p,f,d,h,g,m=x.hasData(e)&&x._data(e);if(m&&(c=m.events)){t=(t||"").match(T)||[""],u=t.length;while(u--)if(s=rt.exec(t[u])||[],d=g=s[1],h=(s[2]||"").split(".").sort(),d){p=x.event.special[d]||{},d=(r?p.delegateType:p.bindType)||d,f=c[d]||[],s=s[2]&&RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),l=o=f.length;while(o--)a=f[o],!i&&g!==a.origType||n&&n.guid!==a.guid||s&&!s.test(a.namespace)||r&&r!==a.selector&&("**"!==r||!a.selector)||(f.splice(o,1),a.selector&&f.delegateCount--,p.remove&&p.remove.call(e,a));l&&!f.length&&(p.teardown&&p.teardown.call(e,h,m.handle)!==!1||x.removeEvent(e,d,m.handle),delete c[d])}else for(d in c)x.event.remove(e,d+t[u],n,r,!0);x.isEmptyObject(c)&&(delete m.handle,x._removeData(e,"events"))}},trigger:function(n,r,i,o){var s,l,u,c,p,f,d,h=[i||a],g=v.call(n,"type")?n.type:n,m=v.call(n,"namespace")?n.namespace.split("."):[];if(u=f=i=i||a,3!==i.nodeType&&8!==i.nodeType&&!nt.test(g+x.event.triggered)&&(g.indexOf(".")>=0&&(m=g.split("."),g=m.shift(),m.sort()),l=0>g.indexOf(":")&&"on"+g,n=n[x.expando]?n:new x.Event(g,"object"==typeof n&&n),n.isTrigger=o?2:3,n.namespace=m.join("."),n.namespace_re=n.namespace?RegExp("(^|\\.)"+m.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,n.result=t,n.target||(n.target=i),r=null==r?[n]:x.makeArray(r,[n]),p=x.event.special[g]||{},o||!p.trigger||p.trigger.apply(i,r)!==!1)){if(!o&&!p.noBubble&&!x.isWindow(i)){for(c=p.delegateType||g,nt.test(c+g)||(u=u.parentNode);u;u=u.parentNode)h.push(u),f=u;f===(i.ownerDocument||a)&&h.push(f.defaultView||f.parentWindow||e)}d=0;while((u=h[d++])&&!n.isPropagationStopped())n.type=d>1?c:p.bindType||g,s=(x._data(u,"events")||{})[n.type]&&x._data(u,"handle"),s&&s.apply(u,r),s=l&&u[l],s&&x.acceptData(u)&&s.apply&&s.apply(u,r)===!1&&n.preventDefault();if(n.type=g,!o&&!n.isDefaultPrevented()&&(!p._default||p._default.apply(h.pop(),r)===!1)&&x.acceptData(i)&&l&&i[g]&&!x.isWindow(i)){f=i[l],f&&(i[l]=null),x.event.triggered=g;try{i[g]()}catch(y){}x.event.triggered=t,f&&(i[l]=f)}return n.result}},dispatch:function(e){e=x.event.fix(e);var n,r,i,o,a,s=[],l=g.call(arguments),u=(x._data(this,"events")||{})[e.type]||[],c=x.event.special[e.type]||{};if(l[0]=e,e.delegateTarget=this,!c.preDispatch||c.preDispatch.call(this,e)!==!1){s=x.event.handlers.call(this,e,u),n=0;while((o=s[n++])&&!e.isPropagationStopped()){e.currentTarget=o.elem,a=0;while((i=o.handlers[a++])&&!e.isImmediatePropagationStopped())(!e.namespace_re||e.namespace_re.test(i.namespace))&&(e.handleObj=i,e.data=i.data,r=((x.event.special[i.origType]||{}).handle||i.handler).apply(o.elem,l),r!==t&&(e.result=r)===!1&&(e.preventDefault(),e.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,e),e.result}},handlers:function(e,n){var r,i,o,a,s=[],l=n.delegateCount,u=e.target;if(l&&u.nodeType&&(!e.button||"click"!==e.type))for(;u!=this;u=u.parentNode||this)if(1===u.nodeType&&(u.disabled!==!0||"click"!==e.type)){for(o=[],a=0;l>a;a++)i=n[a],r=i.selector+" ",o[r]===t&&(o[r]=i.needsContext?x(r,this).index(u)>=0:x.find(r,this,null,[u]).length),o[r]&&o.push(i);o.length&&s.push({elem:u,handlers:o})}return n.length>l&&s.push({elem:this,handlers:n.slice(l)}),s},fix:function(e){if(e[x.expando])return e;var t,n,r,i=e.type,o=e,s=this.fixHooks[i];s||(this.fixHooks[i]=s=tt.test(i)?this.mouseHooks:et.test(i)?this.keyHooks:{}),r=s.props?this.props.concat(s.props):this.props,e=new x.Event(o),t=r.length;while(t--)n=r[t],e[n]=o[n];return e.target||(e.target=o.srcElement||a),3===e.target.nodeType&&(e.target=e.target.parentNode),e.metaKey=!!e.metaKey,s.filter?s.filter(e,o):e},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(e,t){return null==e.which&&(e.which=null!=t.charCode?t.charCode:t.keyCode),e}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(e,n){var r,i,o,s=n.button,l=n.fromElement;return null==e.pageX&&null!=n.clientX&&(i=e.target.ownerDocument||a,o=i.documentElement,r=i.body,e.pageX=n.clientX+(o&&o.scrollLeft||r&&r.scrollLeft||0)-(o&&o.clientLeft||r&&r.clientLeft||0),e.pageY=n.clientY+(o&&o.scrollTop||r&&r.scrollTop||0)-(o&&o.clientTop||r&&r.clientTop||0)),!e.relatedTarget&&l&&(e.relatedTarget=l===e.target?n.toElement:l),e.which||s===t||(e.which=1&s?1:2&s?3:4&s?2:0),e}},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==at()&&this.focus)try{return this.focus(),!1}catch(e){}},delegateType:"focusin"},blur:{trigger:function(){return this===at()&&this.blur?(this.blur(),!1):t},delegateType:"focusout"},click:{trigger:function(){return x.nodeName(this,"input")&&"checkbox"===this.type&&this.click?(this.click(),!1):t},_default:function(e){return x.nodeName(e.target,"a")}},beforeunload:{postDispatch:function(e){e.result!==t&&(e.originalEvent.returnValue=e.result)}}},simulate:function(e,t,n,r){var i=x.extend(new x.Event,n,{type:e,isSimulated:!0,originalEvent:{}});r?x.event.trigger(i,null,t):x.event.dispatch.call(t,i),i.isDefaultPrevented()&&n.preventDefault()}},x.removeEvent=a.removeEventListener?function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n,!1)}:function(e,t,n){var r="on"+t;e.detachEvent&&(typeof e[r]===i&&(e[r]=null),e.detachEvent(r,n))},x.Event=function(e,n){return this instanceof x.Event?(e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||e.returnValue===!1||e.getPreventDefault&&e.getPreventDefault()?it:ot):this.type=e,n&&x.extend(this,n),this.timeStamp=e&&e.timeStamp||x.now(),this[x.expando]=!0,t):new x.Event(e,n)},x.Event.prototype={isDefaultPrevented:ot,isPropagationStopped:ot,isImmediatePropagationStopped:ot,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=it,e&&(e.preventDefault?e.preventDefault():e.returnValue=!1)},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=it,e&&(e.stopPropagation&&e.stopPropagation(),e.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=it,this.stopPropagation()}},x.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(e,t){x.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,o=e.handleObj;return(!i||i!==r&&!x.contains(r,i))&&(e.type=o.origType,n=o.handler.apply(this,arguments),e.type=t),n}}}),x.support.submitBubbles||(x.event.special.submit={setup:function(){return x.nodeName(this,"form")?!1:(x.event.add(this,"click._submit keypress._submit",function(e){var n=e.target,r=x.nodeName(n,"input")||x.nodeName(n,"button")?n.form:t;r&&!x._data(r,"submitBubbles")&&(x.event.add(r,"submit._submit",function(e){e._submit_bubble=!0}),x._data(r,"submitBubbles",!0))}),t)},postDispatch:function(e){e._submit_bubble&&(delete e._submit_bubble,this.parentNode&&!e.isTrigger&&x.event.simulate("submit",this.parentNode,e,!0))},teardown:function(){return x.nodeName(this,"form")?!1:(x.event.remove(this,"._submit"),t)}}),x.support.changeBubbles||(x.event.special.change={setup:function(){return Z.test(this.nodeName)?(("checkbox"===this.type||"radio"===this.type)&&(x.event.add(this,"propertychange._change",function(e){"checked"===e.originalEvent.propertyName&&(this._just_changed=!0)}),x.event.add(this,"click._change",function(e){this._just_changed&&!e.isTrigger&&(this._just_changed=!1),x.event.simulate("change",this,e,!0)})),!1):(x.event.add(this,"beforeactivate._change",function(e){var t=e.target;Z.test(t.nodeName)&&!x._data(t,"changeBubbles")&&(x.event.add(t,"change._change",function(e){!this.parentNode||e.isSimulated||e.isTrigger||x.event.simulate("change",this.parentNode,e,!0)}),x._data(t,"changeBubbles",!0))}),t)},handle:function(e){var n=e.target;return this!==n||e.isSimulated||e.isTrigger||"radio"!==n.type&&"checkbox"!==n.type?e.handleObj.handler.apply(this,arguments):t},teardown:function(){return x.event.remove(this,"._change"),!Z.test(this.nodeName)}}),x.support.focusinBubbles||x.each({focus:"focusin",blur:"focusout"},function(e,t){var n=0,r=function(e){x.event.simulate(t,e.target,x.event.fix(e),!0)};x.event.special[t]={setup:function(){0===n++&&a.addEventListener(e,r,!0)},teardown:function(){0===--n&&a.removeEventListener(e,r,!0)}}}),x.fn.extend({on:function(e,n,r,i,o){var a,s;if("object"==typeof e){"string"!=typeof n&&(r=r||n,n=t);for(a in e)this.on(a,n,r,e[a],o);return this}if(null==r&&null==i?(i=n,r=n=t):null==i&&("string"==typeof n?(i=r,r=t):(i=r,r=n,n=t)),i===!1)i=ot;else if(!i)return this;return 1===o&&(s=i,i=function(e){return x().off(e),s.apply(this,arguments)},i.guid=s.guid||(s.guid=x.guid++)),this.each(function(){x.event.add(this,e,i,r,n)})},one:function(e,t,n,r){return this.on(e,t,n,r,1)},off:function(e,n,r){var i,o;if(e&&e.preventDefault&&e.handleObj)return i=e.handleObj,x(e.delegateTarget).off(i.namespace?i.origType+"."+i.namespace:i.origType,i.selector,i.handler),this;if("object"==typeof e){for(o in e)this.off(o,n,e[o]);return this}return(n===!1||"function"==typeof n)&&(r=n,n=t),r===!1&&(r=ot),this.each(function(){x.event.remove(this,e,r,n)})},trigger:function(e,t){return this.each(function(){x.event.trigger(e,t,this)})},triggerHandler:function(e,n){var r=this[0];return r?x.event.trigger(e,n,r,!0):t}});var st=/^.[^:#\[\.,]*$/,lt=/^(?:parents|prev(?:Until|All))/,ut=x.expr.match.needsContext,ct={children:!0,contents:!0,next:!0,prev:!0};x.fn.extend({find:function(e){var t,n=[],r=this,i=r.length;if("string"!=typeof e)return this.pushStack(x(e).filter(function(){for(t=0;i>t;t++)if(x.contains(r[t],this))return!0}));for(t=0;i>t;t++)x.find(e,r[t],n);return n=this.pushStack(i>1?x.unique(n):n),n.selector=this.selector?this.selector+" "+e:e,n},has:function(e){var t,n=x(e,this),r=n.length;return this.filter(function(){for(t=0;r>t;t++)if(x.contains(this,n[t]))return!0})},not:function(e){return this.pushStack(ft(this,e||[],!0))},filter:function(e){return this.pushStack(ft(this,e||[],!1))},is:function(e){return!!ft(this,"string"==typeof e&&ut.test(e)?x(e):e||[],!1).length},closest:function(e,t){var n,r=0,i=this.length,o=[],a=ut.test(e)||"string"!=typeof e?x(e,t||this.context):0;for(;i>r;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(11>n.nodeType&&(a?a.index(n)>-1:1===n.nodeType&&x.find.matchesSelector(n,e))){n=o.push(n);break}return this.pushStack(o.length>1?x.unique(o):o)},index:function(e){return e?"string"==typeof e?x.inArray(this[0],x(e)):x.inArray(e.jquery?e[0]:e,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){var n="string"==typeof e?x(e,t):x.makeArray(e&&e.nodeType?[e]:e),r=x.merge(this.get(),n);return this.pushStack(x.unique(r))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}});function pt(e,t){do e=e[t];while(e&&1!==e.nodeType);return e}x.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return x.dir(e,"parentNode")},parentsUntil:function(e,t,n){return x.dir(e,"parentNode",n)},next:function(e){return pt(e,"nextSibling")},prev:function(e){return pt(e,"previousSibling")},nextAll:function(e){return x.dir(e,"nextSibling")},prevAll:function(e){return x.dir(e,"previousSibling")},nextUntil:function(e,t,n){return x.dir(e,"nextSibling",n)},prevUntil:function(e,t,n){return x.dir(e,"previousSibling",n)},siblings:function(e){return x.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return x.sibling(e.firstChild)},contents:function(e){return x.nodeName(e,"iframe")?e.contentDocument||e.contentWindow.document:x.merge([],e.childNodes)}},function(e,t){x.fn[e]=function(n,r){var i=x.map(this,t,n);return"Until"!==e.slice(-5)&&(r=n),r&&"string"==typeof r&&(i=x.filter(r,i)),this.length>1&&(ct[e]||(i=x.unique(i)),lt.test(e)&&(i=i.reverse())),this.pushStack(i)}}),x.extend({filter:function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?x.find.matchesSelector(r,e)?[r]:[]:x.find.matches(e,x.grep(t,function(e){return 1===e.nodeType}))},dir:function(e,n,r){var i=[],o=e[n];while(o&&9!==o.nodeType&&(r===t||1!==o.nodeType||!x(o).is(r)))1===o.nodeType&&i.push(o),o=o[n];return i},sibling:function(e,t){var n=[];for(;e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n}});function ft(e,t,n){if(x.isFunction(t))return x.grep(e,function(e,r){return!!t.call(e,r,e)!==n});if(t.nodeType)return x.grep(e,function(e){return e===t!==n});if("string"==typeof t){if(st.test(t))return x.filter(t,e,n);t=x.filter(t,e)}return x.grep(e,function(e){return x.inArray(e,t)>=0!==n})}function dt(e){var t=ht.split("|"),n=e.createDocumentFragment();if(n.createElement)while(t.length)n.createElement(t.pop());return n}var ht="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",gt=/ jQuery\d+="(?:null|\d+)"/g,mt=RegExp("<(?:"+ht+")[\\s/>]","i"),yt=/^\s+/,vt=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,bt=/<([\w:]+)/,xt=/<tbody/i,wt=/<|&#?\w+;/,Tt=/<(?:script|style|link)/i,Ct=/^(?:checkbox|radio)$/i,Nt=/checked\s*(?:[^=]|=\s*.checked.)/i,kt=/^$|\/(?:java|ecma)script/i,Et=/^true\/(.*)/,St=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,At={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],area:[1,"<map>","</map>"],param:[1,"<object>","</object>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:x.support.htmlSerialize?[0,"",""]:[1,"X<div>","</div>"]},jt=dt(a),Dt=jt.appendChild(a.createElement("div"));At.optgroup=At.option,At.tbody=At.tfoot=At.colgroup=At.caption=At.thead,At.th=At.td,x.fn.extend({text:function(e){return x.access(this,function(e){return e===t?x.text(this):this.empty().append((this[0]&&this[0].ownerDocument||a).createTextNode(e))},null,e,arguments.length)},append:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Lt(this,e);t.appendChild(e)}})},prepend:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Lt(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},remove:function(e,t){var n,r=e?x.filter(e,this):this,i=0;for(;null!=(n=r[i]);i++)t||1!==n.nodeType||x.cleanData(Ft(n)),n.parentNode&&(t&&x.contains(n.ownerDocument,n)&&_t(Ft(n,"script")),n.parentNode.removeChild(n));return this},empty:function(){var e,t=0;for(;null!=(e=this[t]);t++){1===e.nodeType&&x.cleanData(Ft(e,!1));while(e.firstChild)e.removeChild(e.firstChild);e.options&&x.nodeName(e,"select")&&(e.options.length=0)}return this},clone:function(e,t){return e=null==e?!1:e,t=null==t?e:t,this.map(function(){return x.clone(this,e,t)})},html:function(e){return x.access(this,function(e){var n=this[0]||{},r=0,i=this.length;if(e===t)return 1===n.nodeType?n.innerHTML.replace(gt,""):t;if(!("string"!=typeof e||Tt.test(e)||!x.support.htmlSerialize&&mt.test(e)||!x.support.leadingWhitespace&&yt.test(e)||At[(bt.exec(e)||["",""])[1].toLowerCase()])){e=e.replace(vt,"<$1></$2>");try{for(;i>r;r++)n=this[r]||{},1===n.nodeType&&(x.cleanData(Ft(n,!1)),n.innerHTML=e);n=0}catch(o){}}n&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var e=x.map(this,function(e){return[e.nextSibling,e.parentNode]}),t=0;return this.domManip(arguments,function(n){var r=e[t++],i=e[t++];i&&(r&&r.parentNode!==i&&(r=this.nextSibling),x(this).remove(),i.insertBefore(n,r))},!0),t?this:this.remove()},detach:function(e){return this.remove(e,!0)},domManip:function(e,t,n){e=d.apply([],e);var r,i,o,a,s,l,u=0,c=this.length,p=this,f=c-1,h=e[0],g=x.isFunction(h);if(g||!(1>=c||"string"!=typeof h||x.support.checkClone)&&Nt.test(h))return this.each(function(r){var i=p.eq(r);g&&(e[0]=h.call(this,r,i.html())),i.domManip(e,t,n)});if(c&&(l=x.buildFragment(e,this[0].ownerDocument,!1,!n&&this),r=l.firstChild,1===l.childNodes.length&&(l=r),r)){for(a=x.map(Ft(l,"script"),Ht),o=a.length;c>u;u++)i=l,u!==f&&(i=x.clone(i,!0,!0),o&&x.merge(a,Ft(i,"script"))),t.call(this[u],i,u);if(o)for(s=a[a.length-1].ownerDocument,x.map(a,qt),u=0;o>u;u++)i=a[u],kt.test(i.type||"")&&!x._data(i,"globalEval")&&x.contains(s,i)&&(i.src?x._evalUrl(i.src):x.globalEval((i.text||i.textContent||i.innerHTML||"").replace(St,"")));l=r=null}return this}});function Lt(e,t){return x.nodeName(e,"table")&&x.nodeName(1===t.nodeType?t:t.firstChild,"tr")?e.getElementsByTagName("tbody")[0]||e.appendChild(e.ownerDocument.createElement("tbody")):e}function Ht(e){return e.type=(null!==x.find.attr(e,"type"))+"/"+e.type,e}function qt(e){var t=Et.exec(e.type);return t?e.type=t[1]:e.removeAttribute("type"),e}function _t(e,t){var n,r=0;for(;null!=(n=e[r]);r++)x._data(n,"globalEval",!t||x._data(t[r],"globalEval"))}function Mt(e,t){if(1===t.nodeType&&x.hasData(e)){var n,r,i,o=x._data(e),a=x._data(t,o),s=o.events;if(s){delete a.handle,a.events={};for(n in s)for(r=0,i=s[n].length;i>r;r++)x.event.add(t,n,s[n][r])}a.data&&(a.data=x.extend({},a.data))}}function Ot(e,t){var n,r,i;if(1===t.nodeType){if(n=t.nodeName.toLowerCase(),!x.support.noCloneEvent&&t[x.expando]){i=x._data(t);for(r in i.events)x.removeEvent(t,r,i.handle);t.removeAttribute(x.expando)}"script"===n&&t.text!==e.text?(Ht(t).text=e.text,qt(t)):"object"===n?(t.parentNode&&(t.outerHTML=e.outerHTML),x.support.html5Clone&&e.innerHTML&&!x.trim(t.innerHTML)&&(t.innerHTML=e.innerHTML)):"input"===n&&Ct.test(e.type)?(t.defaultChecked=t.checked=e.checked,t.value!==e.value&&(t.value=e.value)):"option"===n?t.defaultSelected=t.selected=e.defaultSelected:("input"===n||"textarea"===n)&&(t.defaultValue=e.defaultValue)}}x.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){x.fn[e]=function(e){var n,r=0,i=[],o=x(e),a=o.length-1;for(;a>=r;r++)n=r===a?this:this.clone(!0),x(o[r])[t](n),h.apply(i,n.get());return this.pushStack(i)}});function Ft(e,n){var r,o,a=0,s=typeof e.getElementsByTagName!==i?e.getElementsByTagName(n||"*"):typeof e.querySelectorAll!==i?e.querySelectorAll(n||"*"):t;if(!s)for(s=[],r=e.childNodes||e;null!=(o=r[a]);a++)!n||x.nodeName(o,n)?s.push(o):x.merge(s,Ft(o,n));return n===t||n&&x.nodeName(e,n)?x.merge([e],s):s}function Bt(e){Ct.test(e.type)&&(e.defaultChecked=e.checked)}x.extend({clone:function(e,t,n){var r,i,o,a,s,l=x.contains(e.ownerDocument,e);if(x.support.html5Clone||x.isXMLDoc(e)||!mt.test("<"+e.nodeName+">")?o=e.cloneNode(!0):(Dt.innerHTML=e.outerHTML,Dt.removeChild(o=Dt.firstChild)),!(x.support.noCloneEvent&&x.support.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||x.isXMLDoc(e)))for(r=Ft(o),s=Ft(e),a=0;null!=(i=s[a]);++a)r[a]&&Ot(i,r[a]);if(t)if(n)for(s=s||Ft(e),r=r||Ft(o),a=0;null!=(i=s[a]);a++)Mt(i,r[a]);else Mt(e,o);return r=Ft(o,"script"),r.length>0&&_t(r,!l&&Ft(e,"script")),r=s=i=null,o},buildFragment:function(e,t,n,r){var i,o,a,s,l,u,c,p=e.length,f=dt(t),d=[],h=0;for(;p>h;h++)if(o=e[h],o||0===o)if("object"===x.type(o))x.merge(d,o.nodeType?[o]:o);else if(wt.test(o)){s=s||f.appendChild(t.createElement("div")),l=(bt.exec(o)||["",""])[1].toLowerCase(),c=At[l]||At._default,s.innerHTML=c[1]+o.replace(vt,"<$1></$2>")+c[2],i=c[0];while(i--)s=s.lastChild;if(!x.support.leadingWhitespace&&yt.test(o)&&d.push(t.createTextNode(yt.exec(o)[0])),!x.support.tbody){o="table"!==l||xt.test(o)?"<table>"!==c[1]||xt.test(o)?0:s:s.firstChild,i=o&&o.childNodes.length;while(i--)x.nodeName(u=o.childNodes[i],"tbody")&&!u.childNodes.length&&o.removeChild(u)}x.merge(d,s.childNodes),s.textContent="";while(s.firstChild)s.removeChild(s.firstChild);s=f.lastChild}else d.push(t.createTextNode(o));s&&f.removeChild(s),x.support.appendChecked||x.grep(Ft(d,"input"),Bt),h=0;while(o=d[h++])if((!r||-1===x.inArray(o,r))&&(a=x.contains(o.ownerDocument,o),s=Ft(f.appendChild(o),"script"),a&&_t(s),n)){i=0;while(o=s[i++])kt.test(o.type||"")&&n.push(o)}return s=null,f},cleanData:function(e,t){var n,r,o,a,s=0,l=x.expando,u=x.cache,c=x.support.deleteExpando,f=x.event.special;for(;null!=(n=e[s]);s++)if((t||x.acceptData(n))&&(o=n[l],a=o&&u[o])){if(a.events)for(r in a.events)f[r]?x.event.remove(n,r):x.removeEvent(n,r,a.handle);
u[o]&&(delete u[o],c?delete n[l]:typeof n.removeAttribute!==i?n.removeAttribute(l):n[l]=null,p.push(o))}},_evalUrl:function(e){return x.ajax({url:e,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})}}),x.fn.extend({wrapAll:function(e){if(x.isFunction(e))return this.each(function(t){x(this).wrapAll(e.call(this,t))});if(this[0]){var t=x(e,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstChild&&1===e.firstChild.nodeType)e=e.firstChild;return e}).append(this)}return this},wrapInner:function(e){return x.isFunction(e)?this.each(function(t){x(this).wrapInner(e.call(this,t))}):this.each(function(){var t=x(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=x.isFunction(e);return this.each(function(n){x(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(){return this.parent().each(function(){x.nodeName(this,"body")||x(this).replaceWith(this.childNodes)}).end()}});var Pt,Rt,Wt,$t=/alpha\([^)]*\)/i,It=/opacity\s*=\s*([^)]*)/,zt=/^(top|right|bottom|left)$/,Xt=/^(none|table(?!-c[ea]).+)/,Ut=/^margin/,Vt=RegExp("^("+w+")(.*)$","i"),Yt=RegExp("^("+w+")(?!px)[a-z%]+$","i"),Jt=RegExp("^([+-])=("+w+")","i"),Gt={BODY:"block"},Qt={position:"absolute",visibility:"hidden",display:"block"},Kt={letterSpacing:0,fontWeight:400},Zt=["Top","Right","Bottom","Left"],en=["Webkit","O","Moz","ms"];function tn(e,t){if(t in e)return t;var n=t.charAt(0).toUpperCase()+t.slice(1),r=t,i=en.length;while(i--)if(t=en[i]+n,t in e)return t;return r}function nn(e,t){return e=t||e,"none"===x.css(e,"display")||!x.contains(e.ownerDocument,e)}function rn(e,t){var n,r,i,o=[],a=0,s=e.length;for(;s>a;a++)r=e[a],r.style&&(o[a]=x._data(r,"olddisplay"),n=r.style.display,t?(o[a]||"none"!==n||(r.style.display=""),""===r.style.display&&nn(r)&&(o[a]=x._data(r,"olddisplay",ln(r.nodeName)))):o[a]||(i=nn(r),(n&&"none"!==n||!i)&&x._data(r,"olddisplay",i?n:x.css(r,"display"))));for(a=0;s>a;a++)r=e[a],r.style&&(t&&"none"!==r.style.display&&""!==r.style.display||(r.style.display=t?o[a]||"":"none"));return e}x.fn.extend({css:function(e,n){return x.access(this,function(e,n,r){var i,o,a={},s=0;if(x.isArray(n)){for(o=Rt(e),i=n.length;i>s;s++)a[n[s]]=x.css(e,n[s],!1,o);return a}return r!==t?x.style(e,n,r):x.css(e,n)},e,n,arguments.length>1)},show:function(){return rn(this,!0)},hide:function(){return rn(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){nn(this)?x(this).show():x(this).hide()})}}),x.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Wt(e,"opacity");return""===n?"1":n}}}},cssNumber:{columnCount:!0,fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":x.support.cssFloat?"cssFloat":"styleFloat"},style:function(e,n,r,i){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var o,a,s,l=x.camelCase(n),u=e.style;if(n=x.cssProps[l]||(x.cssProps[l]=tn(u,l)),s=x.cssHooks[n]||x.cssHooks[l],r===t)return s&&"get"in s&&(o=s.get(e,!1,i))!==t?o:u[n];if(a=typeof r,"string"===a&&(o=Jt.exec(r))&&(r=(o[1]+1)*o[2]+parseFloat(x.css(e,n)),a="number"),!(null==r||"number"===a&&isNaN(r)||("number"!==a||x.cssNumber[l]||(r+="px"),x.support.clearCloneStyle||""!==r||0!==n.indexOf("background")||(u[n]="inherit"),s&&"set"in s&&(r=s.set(e,r,i))===t)))try{u[n]=r}catch(c){}}},css:function(e,n,r,i){var o,a,s,l=x.camelCase(n);return n=x.cssProps[l]||(x.cssProps[l]=tn(e.style,l)),s=x.cssHooks[n]||x.cssHooks[l],s&&"get"in s&&(a=s.get(e,!0,r)),a===t&&(a=Wt(e,n,i)),"normal"===a&&n in Kt&&(a=Kt[n]),""===r||r?(o=parseFloat(a),r===!0||x.isNumeric(o)?o||0:a):a}}),e.getComputedStyle?(Rt=function(t){return e.getComputedStyle(t,null)},Wt=function(e,n,r){var i,o,a,s=r||Rt(e),l=s?s.getPropertyValue(n)||s[n]:t,u=e.style;return s&&(""!==l||x.contains(e.ownerDocument,e)||(l=x.style(e,n)),Yt.test(l)&&Ut.test(n)&&(i=u.width,o=u.minWidth,a=u.maxWidth,u.minWidth=u.maxWidth=u.width=l,l=s.width,u.width=i,u.minWidth=o,u.maxWidth=a)),l}):a.documentElement.currentStyle&&(Rt=function(e){return e.currentStyle},Wt=function(e,n,r){var i,o,a,s=r||Rt(e),l=s?s[n]:t,u=e.style;return null==l&&u&&u[n]&&(l=u[n]),Yt.test(l)&&!zt.test(n)&&(i=u.left,o=e.runtimeStyle,a=o&&o.left,a&&(o.left=e.currentStyle.left),u.left="fontSize"===n?"1em":l,l=u.pixelLeft+"px",u.left=i,a&&(o.left=a)),""===l?"auto":l});function on(e,t,n){var r=Vt.exec(t);return r?Math.max(0,r[1]-(n||0))+(r[2]||"px"):t}function an(e,t,n,r,i){var o=n===(r?"border":"content")?4:"width"===t?1:0,a=0;for(;4>o;o+=2)"margin"===n&&(a+=x.css(e,n+Zt[o],!0,i)),r?("content"===n&&(a-=x.css(e,"padding"+Zt[o],!0,i)),"margin"!==n&&(a-=x.css(e,"border"+Zt[o]+"Width",!0,i))):(a+=x.css(e,"padding"+Zt[o],!0,i),"padding"!==n&&(a+=x.css(e,"border"+Zt[o]+"Width",!0,i)));return a}function sn(e,t,n){var r=!0,i="width"===t?e.offsetWidth:e.offsetHeight,o=Rt(e),a=x.support.boxSizing&&"border-box"===x.css(e,"boxSizing",!1,o);if(0>=i||null==i){if(i=Wt(e,t,o),(0>i||null==i)&&(i=e.style[t]),Yt.test(i))return i;r=a&&(x.support.boxSizingReliable||i===e.style[t]),i=parseFloat(i)||0}return i+an(e,t,n||(a?"border":"content"),r,o)+"px"}function ln(e){var t=a,n=Gt[e];return n||(n=un(e,t),"none"!==n&&n||(Pt=(Pt||x("<iframe frameborder='0' width='0' height='0'/>").css("cssText","display:block !important")).appendTo(t.documentElement),t=(Pt[0].contentWindow||Pt[0].contentDocument).document,t.write("<!doctype html><html><body>"),t.close(),n=un(e,t),Pt.detach()),Gt[e]=n),n}function un(e,t){var n=x(t.createElement(e)).appendTo(t.body),r=x.css(n[0],"display");return n.remove(),r}x.each(["height","width"],function(e,n){x.cssHooks[n]={get:function(e,r,i){return r?0===e.offsetWidth&&Xt.test(x.css(e,"display"))?x.swap(e,Qt,function(){return sn(e,n,i)}):sn(e,n,i):t},set:function(e,t,r){var i=r&&Rt(e);return on(e,t,r?an(e,n,r,x.support.boxSizing&&"border-box"===x.css(e,"boxSizing",!1,i),i):0)}}}),x.support.opacity||(x.cssHooks.opacity={get:function(e,t){return It.test((t&&e.currentStyle?e.currentStyle.filter:e.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":t?"1":""},set:function(e,t){var n=e.style,r=e.currentStyle,i=x.isNumeric(t)?"alpha(opacity="+100*t+")":"",o=r&&r.filter||n.filter||"";n.zoom=1,(t>=1||""===t)&&""===x.trim(o.replace($t,""))&&n.removeAttribute&&(n.removeAttribute("filter"),""===t||r&&!r.filter)||(n.filter=$t.test(o)?o.replace($t,i):o+" "+i)}}),x(function(){x.support.reliableMarginRight||(x.cssHooks.marginRight={get:function(e,n){return n?x.swap(e,{display:"inline-block"},Wt,[e,"marginRight"]):t}}),!x.support.pixelPosition&&x.fn.position&&x.each(["top","left"],function(e,n){x.cssHooks[n]={get:function(e,r){return r?(r=Wt(e,n),Yt.test(r)?x(e).position()[n]+"px":r):t}}})}),x.expr&&x.expr.filters&&(x.expr.filters.hidden=function(e){return 0>=e.offsetWidth&&0>=e.offsetHeight||!x.support.reliableHiddenOffsets&&"none"===(e.style&&e.style.display||x.css(e,"display"))},x.expr.filters.visible=function(e){return!x.expr.filters.hidden(e)}),x.each({margin:"",padding:"",border:"Width"},function(e,t){x.cssHooks[e+t]={expand:function(n){var r=0,i={},o="string"==typeof n?n.split(" "):[n];for(;4>r;r++)i[e+Zt[r]+t]=o[r]||o[r-2]||o[0];return i}},Ut.test(e)||(x.cssHooks[e+t].set=on)});var cn=/%20/g,pn=/\[\]$/,fn=/\r?\n/g,dn=/^(?:submit|button|image|reset|file)$/i,hn=/^(?:input|select|textarea|keygen)/i;x.fn.extend({serialize:function(){return x.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=x.prop(this,"elements");return e?x.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!x(this).is(":disabled")&&hn.test(this.nodeName)&&!dn.test(e)&&(this.checked||!Ct.test(e))}).map(function(e,t){var n=x(this).val();return null==n?null:x.isArray(n)?x.map(n,function(e){return{name:t.name,value:e.replace(fn,"\r\n")}}):{name:t.name,value:n.replace(fn,"\r\n")}}).get()}}),x.param=function(e,n){var r,i=[],o=function(e,t){t=x.isFunction(t)?t():null==t?"":t,i[i.length]=encodeURIComponent(e)+"="+encodeURIComponent(t)};if(n===t&&(n=x.ajaxSettings&&x.ajaxSettings.traditional),x.isArray(e)||e.jquery&&!x.isPlainObject(e))x.each(e,function(){o(this.name,this.value)});else for(r in e)gn(r,e[r],n,o);return i.join("&").replace(cn,"+")};function gn(e,t,n,r){var i;if(x.isArray(t))x.each(t,function(t,i){n||pn.test(e)?r(e,i):gn(e+"["+("object"==typeof i?t:"")+"]",i,n,r)});else if(n||"object"!==x.type(t))r(e,t);else for(i in t)gn(e+"["+i+"]",t[i],n,r)}x.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(e,t){x.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)}}),x.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)},bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)}});var mn,yn,vn=x.now(),bn=/\?/,xn=/#.*$/,wn=/([?&])_=[^&]*/,Tn=/^(.*?):[ \t]*([^\r\n]*)\r?$/gm,Cn=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Nn=/^(?:GET|HEAD)$/,kn=/^\/\//,En=/^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,Sn=x.fn.load,An={},jn={},Dn="*/".concat("*");try{yn=o.href}catch(Ln){yn=a.createElement("a"),yn.href="",yn=yn.href}mn=En.exec(yn.toLowerCase())||[];function Hn(e){return function(t,n){"string"!=typeof t&&(n=t,t="*");var r,i=0,o=t.toLowerCase().match(T)||[];if(x.isFunction(n))while(r=o[i++])"+"===r[0]?(r=r.slice(1)||"*",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function qn(e,n,r,i){var o={},a=e===jn;function s(l){var u;return o[l]=!0,x.each(e[l]||[],function(e,l){var c=l(n,r,i);return"string"!=typeof c||a||o[c]?a?!(u=c):t:(n.dataTypes.unshift(c),s(c),!1)}),u}return s(n.dataTypes[0])||!o["*"]&&s("*")}function _n(e,n){var r,i,o=x.ajaxSettings.flatOptions||{};for(i in n)n[i]!==t&&((o[i]?e:r||(r={}))[i]=n[i]);return r&&x.extend(!0,e,r),e}x.fn.load=function(e,n,r){if("string"!=typeof e&&Sn)return Sn.apply(this,arguments);var i,o,a,s=this,l=e.indexOf(" ");return l>=0&&(i=e.slice(l,e.length),e=e.slice(0,l)),x.isFunction(n)?(r=n,n=t):n&&"object"==typeof n&&(a="POST"),s.length>0&&x.ajax({url:e,type:a,dataType:"html",data:n}).done(function(e){o=arguments,s.html(i?x("<div>").append(x.parseHTML(e)).find(i):e)}).complete(r&&function(e,t){s.each(r,o||[e.responseText,t,e])}),this},x.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){x.fn[t]=function(e){return this.on(t,e)}}),x.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:yn,type:"GET",isLocal:Cn.test(mn[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Dn,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":x.parseJSON,"text xml":x.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?_n(_n(e,x.ajaxSettings),t):_n(x.ajaxSettings,e)},ajaxPrefilter:Hn(An),ajaxTransport:Hn(jn),ajax:function(e,n){"object"==typeof e&&(n=e,e=t),n=n||{};var r,i,o,a,s,l,u,c,p=x.ajaxSetup({},n),f=p.context||p,d=p.context&&(f.nodeType||f.jquery)?x(f):x.event,h=x.Deferred(),g=x.Callbacks("once memory"),m=p.statusCode||{},y={},v={},b=0,w="canceled",C={readyState:0,getResponseHeader:function(e){var t;if(2===b){if(!c){c={};while(t=Tn.exec(a))c[t[1].toLowerCase()]=t[2]}t=c[e.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return 2===b?a:null},setRequestHeader:function(e,t){var n=e.toLowerCase();return b||(e=v[n]=v[n]||e,y[e]=t),this},overrideMimeType:function(e){return b||(p.mimeType=e),this},statusCode:function(e){var t;if(e)if(2>b)for(t in e)m[t]=[m[t],e[t]];else C.always(e[C.status]);return this},abort:function(e){var t=e||w;return u&&u.abort(t),k(0,t),this}};if(h.promise(C).complete=g.add,C.success=C.done,C.error=C.fail,p.url=((e||p.url||yn)+"").replace(xn,"").replace(kn,mn[1]+"//"),p.type=n.method||n.type||p.method||p.type,p.dataTypes=x.trim(p.dataType||"*").toLowerCase().match(T)||[""],null==p.crossDomain&&(r=En.exec(p.url.toLowerCase()),p.crossDomain=!(!r||r[1]===mn[1]&&r[2]===mn[2]&&(r[3]||("http:"===r[1]?"80":"443"))===(mn[3]||("http:"===mn[1]?"80":"443")))),p.data&&p.processData&&"string"!=typeof p.data&&(p.data=x.param(p.data,p.traditional)),qn(An,p,n,C),2===b)return C;l=p.global,l&&0===x.active++&&x.event.trigger("ajaxStart"),p.type=p.type.toUpperCase(),p.hasContent=!Nn.test(p.type),o=p.url,p.hasContent||(p.data&&(o=p.url+=(bn.test(o)?"&":"?")+p.data,delete p.data),p.cache===!1&&(p.url=wn.test(o)?o.replace(wn,"$1_="+vn++):o+(bn.test(o)?"&":"?")+"_="+vn++)),p.ifModified&&(x.lastModified[o]&&C.setRequestHeader("If-Modified-Since",x.lastModified[o]),x.etag[o]&&C.setRequestHeader("If-None-Match",x.etag[o])),(p.data&&p.hasContent&&p.contentType!==!1||n.contentType)&&C.setRequestHeader("Content-Type",p.contentType),C.setRequestHeader("Accept",p.dataTypes[0]&&p.accepts[p.dataTypes[0]]?p.accepts[p.dataTypes[0]]+("*"!==p.dataTypes[0]?", "+Dn+"; q=0.01":""):p.accepts["*"]);for(i in p.headers)C.setRequestHeader(i,p.headers[i]);if(p.beforeSend&&(p.beforeSend.call(f,C,p)===!1||2===b))return C.abort();w="abort";for(i in{success:1,error:1,complete:1})C[i](p[i]);if(u=qn(jn,p,n,C)){C.readyState=1,l&&d.trigger("ajaxSend",[C,p]),p.async&&p.timeout>0&&(s=setTimeout(function(){C.abort("timeout")},p.timeout));try{b=1,u.send(y,k)}catch(N){if(!(2>b))throw N;k(-1,N)}}else k(-1,"No Transport");function k(e,n,r,i){var c,y,v,w,T,N=n;2!==b&&(b=2,s&&clearTimeout(s),u=t,a=i||"",C.readyState=e>0?4:0,c=e>=200&&300>e||304===e,r&&(w=Mn(p,C,r)),w=On(p,w,C,c),c?(p.ifModified&&(T=C.getResponseHeader("Last-Modified"),T&&(x.lastModified[o]=T),T=C.getResponseHeader("etag"),T&&(x.etag[o]=T)),204===e||"HEAD"===p.type?N="nocontent":304===e?N="notmodified":(N=w.state,y=w.data,v=w.error,c=!v)):(v=N,(e||!N)&&(N="error",0>e&&(e=0))),C.status=e,C.statusText=(n||N)+"",c?h.resolveWith(f,[y,N,C]):h.rejectWith(f,[C,N,v]),C.statusCode(m),m=t,l&&d.trigger(c?"ajaxSuccess":"ajaxError",[C,p,c?y:v]),g.fireWith(f,[C,N]),l&&(d.trigger("ajaxComplete",[C,p]),--x.active||x.event.trigger("ajaxStop")))}return C},getJSON:function(e,t,n){return x.get(e,t,n,"json")},getScript:function(e,n){return x.get(e,t,n,"script")}}),x.each(["get","post"],function(e,n){x[n]=function(e,r,i,o){return x.isFunction(r)&&(o=o||i,i=r,r=t),x.ajax({url:e,type:n,dataType:o,data:r,success:i})}});function Mn(e,n,r){var i,o,a,s,l=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),o===t&&(o=e.mimeType||n.getResponseHeader("Content-Type"));if(o)for(s in l)if(l[s]&&l[s].test(o)){u.unshift(s);break}if(u[0]in r)a=u[0];else{for(s in r){if(!u[0]||e.converters[s+" "+u[0]]){a=s;break}i||(i=s)}a=a||i}return a?(a!==u[0]&&u.unshift(a),r[a]):t}function On(e,t,n,r){var i,o,a,s,l,u={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)u[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!l&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),l=o,o=c.shift())if("*"===o)o=l;else if("*"!==l&&l!==o){if(a=u[l+" "+o]||u["* "+o],!a)for(i in u)if(s=i.split(" "),s[1]===o&&(a=u[l+" "+s[0]]||u["* "+s[0]])){a===!0?a=u[i]:u[i]!==!0&&(o=s[0],c.unshift(s[1]));break}if(a!==!0)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(p){return{state:"parsererror",error:a?p:"No conversion from "+l+" to "+o}}}return{state:"success",data:t}}x.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(e){return x.globalEval(e),e}}}),x.ajaxPrefilter("script",function(e){e.cache===t&&(e.cache=!1),e.crossDomain&&(e.type="GET",e.global=!1)}),x.ajaxTransport("script",function(e){if(e.crossDomain){var n,r=a.head||x("head")[0]||a.documentElement;return{send:function(t,i){n=a.createElement("script"),n.async=!0,e.scriptCharset&&(n.charset=e.scriptCharset),n.src=e.url,n.onload=n.onreadystatechange=function(e,t){(t||!n.readyState||/loaded|complete/.test(n.readyState))&&(n.onload=n.onreadystatechange=null,n.parentNode&&n.parentNode.removeChild(n),n=null,t||i(200,"success"))},r.insertBefore(n,r.firstChild)},abort:function(){n&&n.onload(t,!0)}}}});var Fn=[],Bn=/(=)\?(?=&|$)|\?\?/;x.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Fn.pop()||x.expando+"_"+vn++;return this[e]=!0,e}}),x.ajaxPrefilter("json jsonp",function(n,r,i){var o,a,s,l=n.jsonp!==!1&&(Bn.test(n.url)?"url":"string"==typeof n.data&&!(n.contentType||"").indexOf("application/x-www-form-urlencoded")&&Bn.test(n.data)&&"data");return l||"jsonp"===n.dataTypes[0]?(o=n.jsonpCallback=x.isFunction(n.jsonpCallback)?n.jsonpCallback():n.jsonpCallback,l?n[l]=n[l].replace(Bn,"$1"+o):n.jsonp!==!1&&(n.url+=(bn.test(n.url)?"&":"?")+n.jsonp+"="+o),n.converters["script json"]=function(){return s||x.error(o+" was not called"),s[0]},n.dataTypes[0]="json",a=e[o],e[o]=function(){s=arguments},i.always(function(){e[o]=a,n[o]&&(n.jsonpCallback=r.jsonpCallback,Fn.push(o)),s&&x.isFunction(a)&&a(s[0]),s=a=t}),"script"):t});var Pn,Rn,Wn=0,$n=e.ActiveXObject&&function(){var e;for(e in Pn)Pn[e](t,!0)};function In(){try{return new e.XMLHttpRequest}catch(t){}}function zn(){try{return new e.ActiveXObject("Microsoft.XMLHTTP")}catch(t){}}x.ajaxSettings.xhr=e.ActiveXObject?function(){return!this.isLocal&&In()||zn()}:In,Rn=x.ajaxSettings.xhr(),x.support.cors=!!Rn&&"withCredentials"in Rn,Rn=x.support.ajax=!!Rn,Rn&&x.ajaxTransport(function(n){if(!n.crossDomain||x.support.cors){var r;return{send:function(i,o){var a,s,l=n.xhr();if(n.username?l.open(n.type,n.url,n.async,n.username,n.password):l.open(n.type,n.url,n.async),n.xhrFields)for(s in n.xhrFields)l[s]=n.xhrFields[s];n.mimeType&&l.overrideMimeType&&l.overrideMimeType(n.mimeType),n.crossDomain||i["X-Requested-With"]||(i["X-Requested-With"]="XMLHttpRequest");try{for(s in i)l.setRequestHeader(s,i[s])}catch(u){}l.send(n.hasContent&&n.data||null),r=function(e,i){var s,u,c,p;try{if(r&&(i||4===l.readyState))if(r=t,a&&(l.onreadystatechange=x.noop,$n&&delete Pn[a]),i)4!==l.readyState&&l.abort();else{p={},s=l.status,u=l.getAllResponseHeaders(),"string"==typeof l.responseText&&(p.text=l.responseText);try{c=l.statusText}catch(f){c=""}s||!n.isLocal||n.crossDomain?1223===s&&(s=204):s=p.text?200:404}}catch(d){i||o(-1,d)}p&&o(s,c,p,u)},n.async?4===l.readyState?setTimeout(r):(a=++Wn,$n&&(Pn||(Pn={},x(e).unload($n)),Pn[a]=r),l.onreadystatechange=r):r()},abort:function(){r&&r(t,!0)}}}});var Xn,Un,Vn=/^(?:toggle|show|hide)$/,Yn=RegExp("^(?:([+-])=|)("+w+")([a-z%]*)$","i"),Jn=/queueHooks$/,Gn=[nr],Qn={"*":[function(e,t){var n=this.createTween(e,t),r=n.cur(),i=Yn.exec(t),o=i&&i[3]||(x.cssNumber[e]?"":"px"),a=(x.cssNumber[e]||"px"!==o&&+r)&&Yn.exec(x.css(n.elem,e)),s=1,l=20;if(a&&a[3]!==o){o=o||a[3],i=i||[],a=+r||1;do s=s||".5",a/=s,x.style(n.elem,e,a+o);while(s!==(s=n.cur()/r)&&1!==s&&--l)}return i&&(a=n.start=+a||+r||0,n.unit=o,n.end=i[1]?a+(i[1]+1)*i[2]:+i[2]),n}]};function Kn(){return setTimeout(function(){Xn=t}),Xn=x.now()}function Zn(e,t,n){var r,i=(Qn[t]||[]).concat(Qn["*"]),o=0,a=i.length;for(;a>o;o++)if(r=i[o].call(n,t,e))return r}function er(e,t,n){var r,i,o=0,a=Gn.length,s=x.Deferred().always(function(){delete l.elem}),l=function(){if(i)return!1;var t=Xn||Kn(),n=Math.max(0,u.startTime+u.duration-t),r=n/u.duration||0,o=1-r,a=0,l=u.tweens.length;for(;l>a;a++)u.tweens[a].run(o);return s.notifyWith(e,[u,o,n]),1>o&&l?n:(s.resolveWith(e,[u]),!1)},u=s.promise({elem:e,props:x.extend({},t),opts:x.extend(!0,{specialEasing:{}},n),originalProperties:t,originalOptions:n,startTime:Xn||Kn(),duration:n.duration,tweens:[],createTween:function(t,n){var r=x.Tween(e,u.opts,t,n,u.opts.specialEasing[t]||u.opts.easing);return u.tweens.push(r),r},stop:function(t){var n=0,r=t?u.tweens.length:0;if(i)return this;for(i=!0;r>n;n++)u.tweens[n].run(1);return t?s.resolveWith(e,[u,t]):s.rejectWith(e,[u,t]),this}}),c=u.props;for(tr(c,u.opts.specialEasing);a>o;o++)if(r=Gn[o].call(u,e,c,u.opts))return r;return x.map(c,Zn,u),x.isFunction(u.opts.start)&&u.opts.start.call(e,u),x.fx.timer(x.extend(l,{elem:e,anim:u,queue:u.opts.queue})),u.progress(u.opts.progress).done(u.opts.done,u.opts.complete).fail(u.opts.fail).always(u.opts.always)}function tr(e,t){var n,r,i,o,a;for(n in e)if(r=x.camelCase(n),i=t[r],o=e[n],x.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),a=x.cssHooks[r],a&&"expand"in a){o=a.expand(o),delete e[r];for(n in o)n in e||(e[n]=o[n],t[n]=i)}else t[r]=i}x.Animation=x.extend(er,{tweener:function(e,t){x.isFunction(e)?(t=e,e=["*"]):e=e.split(" ");var n,r=0,i=e.length;for(;i>r;r++)n=e[r],Qn[n]=Qn[n]||[],Qn[n].unshift(t)},prefilter:function(e,t){t?Gn.unshift(e):Gn.push(e)}});function nr(e,t,n){var r,i,o,a,s,l,u=this,c={},p=e.style,f=e.nodeType&&nn(e),d=x._data(e,"fxshow");n.queue||(s=x._queueHooks(e,"fx"),null==s.unqueued&&(s.unqueued=0,l=s.empty.fire,s.empty.fire=function(){s.unqueued||l()}),s.unqueued++,u.always(function(){u.always(function(){s.unqueued--,x.queue(e,"fx").length||s.empty.fire()})})),1===e.nodeType&&("height"in t||"width"in t)&&(n.overflow=[p.overflow,p.overflowX,p.overflowY],"inline"===x.css(e,"display")&&"none"===x.css(e,"float")&&(x.support.inlineBlockNeedsLayout&&"inline"!==ln(e.nodeName)?p.zoom=1:p.display="inline-block")),n.overflow&&(p.overflow="hidden",x.support.shrinkWrapBlocks||u.always(function(){p.overflow=n.overflow[0],p.overflowX=n.overflow[1],p.overflowY=n.overflow[2]}));for(r in t)if(i=t[r],Vn.exec(i)){if(delete t[r],o=o||"toggle"===i,i===(f?"hide":"show"))continue;c[r]=d&&d[r]||x.style(e,r)}if(!x.isEmptyObject(c)){d?"hidden"in d&&(f=d.hidden):d=x._data(e,"fxshow",{}),o&&(d.hidden=!f),f?x(e).show():u.done(function(){x(e).hide()}),u.done(function(){var t;x._removeData(e,"fxshow");for(t in c)x.style(e,t,c[t])});for(r in c)a=Zn(f?d[r]:0,r,u),r in d||(d[r]=a.start,f&&(a.end=a.start,a.start="width"===r||"height"===r?1:0))}}function rr(e,t,n,r,i){return new rr.prototype.init(e,t,n,r,i)}x.Tween=rr,rr.prototype={constructor:rr,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||"swing",this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(x.cssNumber[n]?"":"px")},cur:function(){var e=rr.propHooks[this.prop];return e&&e.get?e.get(this):rr.propHooks._default.get(this)},run:function(e){var t,n=rr.propHooks[this.prop];return this.pos=t=this.options.duration?x.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):rr.propHooks._default.set(this),this}},rr.prototype.init.prototype=rr.prototype,rr.propHooks={_default:{get:function(e){var t;return null==e.elem[e.prop]||e.elem.style&&null!=e.elem.style[e.prop]?(t=x.css(e.elem,e.prop,""),t&&"auto"!==t?t:0):e.elem[e.prop]},set:function(e){x.fx.step[e.prop]?x.fx.step[e.prop](e):e.elem.style&&(null!=e.elem.style[x.cssProps[e.prop]]||x.cssHooks[e.prop])?x.style(e.elem,e.prop,e.now+e.unit):e.elem[e.prop]=e.now}}},rr.propHooks.scrollTop=rr.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},x.each(["toggle","show","hide"],function(e,t){var n=x.fn[t];x.fn[t]=function(e,r,i){return null==e||"boolean"==typeof e?n.apply(this,arguments):this.animate(ir(t,!0),e,r,i)}}),x.fn.extend({fadeTo:function(e,t,n,r){return this.filter(nn).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=x.isEmptyObject(e),o=x.speed(t,n,r),a=function(){var t=er(this,x.extend({},e),o);(i||x._data(this,"finish"))&&t.stop(!0)};return a.finish=a,i||o.queue===!1?this.each(a):this.queue(o.queue,a)},stop:function(e,n,r){var i=function(e){var t=e.stop;delete e.stop,t(r)};return"string"!=typeof e&&(r=n,n=e,e=t),n&&e!==!1&&this.queue(e||"fx",[]),this.each(function(){var t=!0,n=null!=e&&e+"queueHooks",o=x.timers,a=x._data(this);if(n)a[n]&&a[n].stop&&i(a[n]);else for(n in a)a[n]&&a[n].stop&&Jn.test(n)&&i(a[n]);for(n=o.length;n--;)o[n].elem!==this||null!=e&&o[n].queue!==e||(o[n].anim.stop(r),t=!1,o.splice(n,1));(t||!r)&&x.dequeue(this,e)})},finish:function(e){return e!==!1&&(e=e||"fx"),this.each(function(){var t,n=x._data(this),r=n[e+"queue"],i=n[e+"queueHooks"],o=x.timers,a=r?r.length:0;for(n.finish=!0,x.queue(this,e,[]),i&&i.stop&&i.stop.call(this,!0),t=o.length;t--;)o[t].elem===this&&o[t].queue===e&&(o[t].anim.stop(!0),o.splice(t,1));for(t=0;a>t;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete n.finish})}});function ir(e,t){var n,r={height:e},i=0;for(t=t?1:0;4>i;i+=2-t)n=Zt[i],r["margin"+n]=r["padding"+n]=e;return t&&(r.opacity=r.width=e),r}x.each({slideDown:ir("show"),slideUp:ir("hide"),slideToggle:ir("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){x.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),x.speed=function(e,t,n){var r=e&&"object"==typeof e?x.extend({},e):{complete:n||!n&&t||x.isFunction(e)&&e,duration:e,easing:n&&t||t&&!x.isFunction(t)&&t};return r.duration=x.fx.off?0:"number"==typeof r.duration?r.duration:r.duration in x.fx.speeds?x.fx.speeds[r.duration]:x.fx.speeds._default,(null==r.queue||r.queue===!0)&&(r.queue="fx"),r.old=r.complete,r.complete=function(){x.isFunction(r.old)&&r.old.call(this),r.queue&&x.dequeue(this,r.queue)},r},x.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2}},x.timers=[],x.fx=rr.prototype.init,x.fx.tick=function(){var e,n=x.timers,r=0;for(Xn=x.now();n.length>r;r++)e=n[r],e()||n[r]!==e||n.splice(r--,1);n.length||x.fx.stop(),Xn=t},x.fx.timer=function(e){e()&&x.timers.push(e)&&x.fx.start()},x.fx.interval=13,x.fx.start=function(){Un||(Un=setInterval(x.fx.tick,x.fx.interval))},x.fx.stop=function(){clearInterval(Un),Un=null},x.fx.speeds={slow:600,fast:200,_default:400},x.fx.step={},x.expr&&x.expr.filters&&(x.expr.filters.animated=function(e){return x.grep(x.timers,function(t){return e===t.elem}).length}),x.fn.offset=function(e){if(arguments.length)return e===t?this:this.each(function(t){x.offset.setOffset(this,e,t)});var n,r,o={top:0,left:0},a=this[0],s=a&&a.ownerDocument;if(s)return n=s.documentElement,x.contains(n,a)?(typeof a.getBoundingClientRect!==i&&(o=a.getBoundingClientRect()),r=or(s),{top:o.top+(r.pageYOffset||n.scrollTop)-(n.clientTop||0),left:o.left+(r.pageXOffset||n.scrollLeft)-(n.clientLeft||0)}):o},x.offset={setOffset:function(e,t,n){var r=x.css(e,"position");"static"===r&&(e.style.position="relative");var i=x(e),o=i.offset(),a=x.css(e,"top"),s=x.css(e,"left"),l=("absolute"===r||"fixed"===r)&&x.inArray("auto",[a,s])>-1,u={},c={},p,f;l?(c=i.position(),p=c.top,f=c.left):(p=parseFloat(a)||0,f=parseFloat(s)||0),x.isFunction(t)&&(t=t.call(e,n,o)),null!=t.top&&(u.top=t.top-o.top+p),null!=t.left&&(u.left=t.left-o.left+f),"using"in t?t.using.call(e,u):i.css(u)}},x.fn.extend({position:function(){if(this[0]){var e,t,n={top:0,left:0},r=this[0];return"fixed"===x.css(r,"position")?t=r.getBoundingClientRect():(e=this.offsetParent(),t=this.offset(),x.nodeName(e[0],"html")||(n=e.offset()),n.top+=x.css(e[0],"borderTopWidth",!0),n.left+=x.css(e[0],"borderLeftWidth",!0)),{top:t.top-n.top-x.css(r,"marginTop",!0),left:t.left-n.left-x.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent||s;while(e&&!x.nodeName(e,"html")&&"static"===x.css(e,"position"))e=e.offsetParent;return e||s})}}),x.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(e,n){var r=/Y/.test(n);x.fn[e]=function(i){return x.access(this,function(e,i,o){var a=or(e);return o===t?a?n in a?a[n]:a.document.documentElement[i]:e[i]:(a?a.scrollTo(r?x(a).scrollLeft():o,r?o:x(a).scrollTop()):e[i]=o,t)},e,i,arguments.length,null)}});function or(e){return x.isWindow(e)?e:9===e.nodeType?e.defaultView||e.parentWindow:!1}x.each({Height:"height",Width:"width"},function(e,n){x.each({padding:"inner"+e,content:n,"":"outer"+e},function(r,i){x.fn[i]=function(i,o){var a=arguments.length&&(r||"boolean"!=typeof i),s=r||(i===!0||o===!0?"margin":"border");return x.access(this,function(n,r,i){var o;return x.isWindow(n)?n.document.documentElement["client"+e]:9===n.nodeType?(o=n.documentElement,Math.max(n.body["scroll"+e],o["scroll"+e],n.body["offset"+e],o["offset"+e],o["client"+e])):i===t?x.css(n,r,s):x.style(n,r,i,s)},n,a?i:t,a,null)}})}),x.fn.size=function(){return this.length},x.fn.andSelf=x.fn.addBack,"object"==typeof module&&module&&"object"==typeof module.exports?module.exports=x:(e.jQuery=e.$=x,"function"==typeof define&&define.amd&&define("jquery",[],function(){return x}))})(window);
});
Numbas.queueScript('jquery.xslTransform',['jquery','sarissa'],function(module) {
/**
 * xslTransform
 * Tools for XSLT transformations; jQuery wrapper for Sarissa <http://sarissa.sourceforge.net/>.
 * See jQuery.fn.log below for documentation on $.log().
 * See jQuery.fn.getTransform below for documention on the $.getTransform().
 * See var DEBUG below for turning debugging/logging on and off.
 *
 * @version   20071214
 * @since     2006-07-05
 * @copyright Copyright (c) 2006 Glyphix Studio, Inc. http://www.glyphix.com
 * @author    Brad Brizendine <brizbane@gmail.com>, Matt Antone <antone@glyphix.com>
 * @license   MIT http://www.opensource.org/licenses/mit-license.php
 * @requires  >= jQuery 1.0.3			http://jquery.com/
 * @requires  jquery.debug.js			http://jquery.glyphix.com/
 * @requires  >= sarissa.js 0.9.7.6		http://sarissa.sourceforge.net/
 *
 * @example
 * var r = $.xsl.transform('path-to-xsl.xsl','path-to-xml.xml');
 * @desc Perform a transformation and place the results in var r
 *
 * @example
 * var r = $.xsl.transform('path-to-xsl.xsl','path-to-xml.xml');
 * var str = $.xsl.serialize( r );
 * @desc Perform a transformation, then turn the result into a string
 *
 * @example
 * var doc = $.xsl.load('path-to-xml.xml');
 * @desc Load an xml file and return a parsed xml object
 *
 * @example
 * var xml = '<xmldoc><foo>bar</foo></xmldoc>';
 * var doc = $.xsl.load(xml);
 * @desc Load an xml string and return a parsed xml object
 */
(function($){
    /*
     * JQuery XSLT transformation plugin.
     * Replaces all matched elements with the results of an XSLT transformation.
     * See xslTransform above for more documentation.
     *
     * @example
     * @desc See the xslTransform-example/index.html
     *
     * @param xsl String the url to the xsl file
     * @param xml String the url to the xml file
     * @param options Object various switches you can send to this function
     * 		+ params: an object of key/value pairs to be sent to xsl as parameters
     * 		+ xpath: defines the root node within the provided xml file
     * 		+ eval: if true, will attempt to eval javascript found in the transformed result
     *		+ callback: if a Function, evaluate it when transformation is complete
     * @returns
     */
    $.fn.getTransform = function( xsl, xml, options ){
        var settings = {
            params: {},        // object of key/value pairs ... parameters to send to the XSL stylesheet
            xpath: '',        // xpath, used to send only a portion of the XML file to the XSL stylesheet
            eval: false,        // evaluate <script> blocks found in the transformed result
            callback: ''    // callback function, to be run on completion of the transformation
        };
        // initialize options hash; override the defaults with supplied options
        $.extend( settings, options );
        //$.log( 'getTransform: ' + xsl + '::' + xml + '::' + settings.toString() );
        // must have both xsl and xml
        if( !xsl || !xml ){
            $.log( 'getTransform: missing xsl or xml' );
            return;
        }
        // run the jquery magic on all matched elements
        return this.each( function(){
            // perform the transformation
            var trans = $.xsl.transform( xsl, xml, settings );
            // make sure we have something
            if( !trans.string ){
                $.log('Received nothing from the transformation');
                return false;
            }
            // ie can fail if there's an xml declaration line in the returned result
            var re = trans.string.match(/<\?xml.*?\?>/);
            if( re ){
                trans.string = trans.string.replace( re, '' );
                $.log( 'getTransform(): found an xml declaration and removed it' );
            }
            // place the result in the element
            // 20070202: jquery 1.1.1 can get a "a.appendChild is not a function" error using html() sometimes ...
            //		no idea why yet, so adding a fallback to innerHTML
            //		::warning:: ie6 has trouble with javascript events such as onclick assigned statically within the html when using innerHTML
            try{
                //$(this).html( trans.string );
                $(this)[0].innerHTML = trans.string;
            }catch(e){
                $.log( 'getTransform: error placing results of transform into element, falling back to innerHTML: ' + e.toString() );
                $(this)[0].innerHTML = trans.string;
            }
            // there might not be a scripts property
            if( settings.eval && trans.scripts ){
                if( trans.scripts.length > 0 ){
                    $.log( 'Found text/javascript in transformed result' );
                    // use jquery's globaleval to avoid security issues in adobe air
                    $.globalEval( trans.scripts );
                }
            }
            // run the callback if it's a native function
            if( settings.callback && $.isFunction(settings.callback) ){
                settings.callback.apply();
            }
        });
    };
    // xsl scope
    $.xsl = {
        // version
        version: 20071214,
        // init ... test for requirements
        init: function(){
            // check for v1.0.4 / v1.1 or later of jQuery
            try{
                parseFloat($.fn.jquery) >= 1;
            }catch(e){
                alert('xslTransform requires jQuery 1.0.4 or greater ... please load it prior to xslTransform');
            }
            // check for Sarissa
            try{
                Sarissa;
            }catch(e){
                alert('Missing Sarissa ... please load it prior to xslTransform');
            }
            // if no log function, create a blank one
            if( !$.log ){
                $.log = function(){};
                $.fn.debug = function(){};
            }
            // log the version
            $.log( 'xslTransform:init(): version ' + this.version );
        },
        // initialize Sarissa's serializer
        XMLSerializer: new XMLSerializer(),
        /*
         * serialize
         * Turns the provided object into a string and returns it.
         *
         * @param data Mixed
         * @returns String
         */
        serialize: function( data ){
            $.log( 'serialize(): received ' + typeof(data) );
            // if it's already a string, no further processing required
            if( typeof(data) == 'string' ){
                $.log( 'data is already a string: ' + data );
                return data;
            }
            return this.XMLSerializer.serializeToString( data );
        },
        /*
         * xmlize
         * Turns the provided javascript object into an xml document and returns it.
         *
         * @param data Mixed
         * @returns String
         */
        xmlize: function( data, root ){
            $.log( 'xmlize(): received ' + typeof(data) );
            root = root || 'root';
            return Sarissa.xmlize(data,root);
        },
        /*
         * load
         * Attempts to load xml data by automatically sensing the type of the provided data.
         *
         * @param xml Mixed the xml data
         * @returns Object
         */
        load: function( xml ){
            $.log( 'load(): received ' + typeof(xml) );
            // the result
            var r;
            // if it's an object, assume it's already an XML object, so just return it
            if( typeof(xml) == 'object' ){
                return xml;
            }
            // if it's a string, determine if it's xml data or a path
            // assume that the first character is an opening caret if it's XML data
            if( xml.substring(0,1) == '<' ){
                r = this.loadString( xml );
            }else{
                r = this.loadFile( xml );
            }
            if( r ){
                // the following two lines are needed to get IE (msxml3) to run xpath ... set it on all xml data
                r.setProperty( 'SelectionNamespaces', 'xmlns:xsl="http://www.w3.org/1999/XSL/Transform"' );
                r.setProperty( 'SelectionLanguage', 'XPath' );
                return r;
            }else{
                $.log( 'Unable to load ' + xml );
                return false;
            }
        },
        /*
         * loadString
         * Parses an XML string and returns the result.
         *
         * @param str String the xml string to turn into a parsed XML object
         * @returns Object
         */
        loadString: function( str ){
            //$.log( 'loadString(): ' + str + '::' + typeof(str) );
            // use Sarissa to generate an XML doc
            var p = new DOMParser();
            var xml = p.parseFromString( str, 'text/xml' );
            if( !xml ){
                $.log( 'loadString(): parseFromString() failed' );
                return false;
            }
            return xml;
        },
        /*
         * loadFile
         * Attempts to retrieve the requested path, specified by url.
         * If url is an object, it's assumed it's already loaded, and just returns it.
         *
         * @param url Mixed
         * @returns Object
         */
        loadFile: function( url ){
            //$.log( 'loadFile(): ' + url + '::' + typeof(url) );
            if( !url ){
                $.log( 'ERROR: loadFile() missing url' );
                return false;
            }
            // variable to hold ajax results
            var doc;
            /* ajax functionality provided by jQuery is commented, since it can't handle file:///
            // function to receive data on successful download ... semicolon after brace is necessary for packing
            this.xhrsuccess = function(data,str){
                $.log( 'loadFile() completed successfully (' + str + ')' );
                doc = data;
                return true;
            };
            // function to handle downloading error ... semicolon after brace is necessary for packing
            this.xhrerror = function(xhr,err){
                // set debugging to true in order to force the display of this error
                window.DEBUG = true;
                $.log( 'loadFile() failed to load the requested file: (' + err + ') - xml: ' + xhr.responseXML + ' - text: ' + xhr.responseText );
                doc = null;
                return false;
            };
            // make asynchronous ajax call and call functions defined above on success/error
            $.ajax({
                type:		'GET',
                url:		url,
                async:		false,
                success:	this.xhrsuccess,
                error:		this.xhrerror
            });
            */
            var xmlhttp = new XMLHttpRequest();
            xmlhttp.open('GET', url, false);
            xmlhttp.send('');
            doc = xmlhttp.responseXML;
            // check for total failure
            if( !doc ){
                $.log( 'ERROR: document ' + url + ' not found (404), or unable to load' );
                return false;
            }
            // check for success but no data
            if( doc.length == 0 ){
                $.log( 'ERROR: document ' + url + ' loaded in loadFile() has no data' );
                return false;
            }
            return doc;
        },
        /*
         * transform
         * Central transformation function: takes an xml doc and an xsl doc.
         *
         * @param xsl Mixed the xsl transformation document
         * @param xml Mixed the xml document to be transformed
         * @param options Object various switches you can send to this function
         * 		+ params: an object of key/value pairs to be sent to xsl as parameters
         * 		+ xpath: defines the root node within the provided xml file
         * @returns Object the results of the transformation
         * 		+ xsl: the raw xsl doc
         * 		+ doc: the raw results of the transform
         * 		+ string: the serialized doc
         */
        transform: function( xsl, xml, options ){
            //$.log( 'transform(): ' + xsl + '::' + xml + '::' + (options ? options.toString() : 'no options provided') );
            // set up request and result
            var request = {
                // the source and loaded object for xml
                xsl: {
                    source: xsl,
                    doc: null
                },
                // the source and loaded object for xsl
                xml: {
                    source: xml,
                    doc: null
                },
                // the options
                options: options || {},
                // the result doc and string
                result: {
                    doc: null,
                    string: '',
                    scripts: null,
                    error: ''
                }
            }
            // set up error handler
            var err = function( what ){
                var docerr = '', srcerr = '';
                // build the src error string
                srcerr = (typeof(request[what].source) == 'string') ? ' (' + what + ' loaded from provided path)' : ' (' + what + ' loaded from provided object)';
                // build the text error string
                docerr = (typeof(request[what].doc) == 'object') ? '[success]' : '[failure]';
                // include the root node if we have a doc object and it's xml
                if( what == 'xml' && typeof(request[what].doc) == 'object'  && request[what].doc.getElementsByTagName('*')[0]){
                    docerr += ' root node of "' + request[what].doc.getElementsByTagName('*')[0].nodeName + '"';
                }
                return docerr + ' ' + srcerr;
            }
            // load the files
            try{
                request.xsl.doc = this.load(xsl);
                request.xml.doc = this.load(xml);
            }catch(e){
                $.log('Unable to load either xsl [' + err('xsl') + '] or xml [' + err('xml') + ']');
                throw( err('xsl') + '::' + err('xml') );
                return false;
            }
            // if we have an xpath, replace xml.doc with the results of running it
            // as of 2007-12-03, IE throws a "msxml6: the parameter is incorrect" error, so removing this
            if( request.options.xpath && request.xml.doc && !jQuery.browser.msie ){
                // run the xpath
                request.xml.doc = request.xml.doc.selectSingleNode( request.options.xpath.toString() );
                //$.log( 'transform(): xpath has been run...resulting doc: ' + (this.serialize(request.xml.doc)) );
            }
            // attach the processor
            var processor = new XSLTProcessor();
            // stylesheet must be imported before parameters can be added
            processor.importStylesheet( request.xsl.doc );
            // add parameters to the processor
            if( request.options.params && processor){
                //$.log( 'transform(): received xsl params: ' + request.options.params.toString() );
                for( key in request.options.params ){
                    // name and value must be strings; first parameter is namespace
                    var p = request.options.params[key] ? request.options.params[key].toString() : request.options.params[key];
                    try{
                        processor.setParameter( null, key.toString(), p );
                    }catch(e){
                        $.log('Unable to set parameter "' + key + '"');
                        return false;
                    }
                    //$.log( 'set parameter "' + key.toString() + '" to "' + p + '"' );
                }
            }
            // perform the transformation
            try{
                request.result.doc = processor.transformToDocument( request.xml.doc );
                // handle transform error
                request.result.error = Sarissa.getParseErrorText( request.result.doc );
                if( request.result.error != Sarissa.PARSED_OK ){
                    // throw the error text
                    request.result.error = 'transform(): error in transformation: ' + request.result.error + ' :: using xsl: ' + err('xsl') + ' => xml: ' + err('xml');
                    $.log(request.result.error);
                }
            }catch(e){
                request.result.error = 'Unable to perform transformation :: using xsl: ' + err('xsl') + ' => xml: ' + err('xml');
                $.log(request.result.error);
                throw(request.result.error);
                return request.result;
            }
            // if we made it this far, the transformation was successful
            request.result.string = this.serialize( request.result.doc );
            // store reference to all scripts found in the doc (not result.string)
            request.result.scripts = jQuery('script',request.result.doc).text();
            return request.result;
        }
    };
    // initialize the $.xsl object
    $.xsl.init();
})(jQuery);
});
/** @file Stuff to do with loading from JSON objects. Provides {@link Numbas.json}. */
Numbas.queueScript('json',['base'],function() {
/** @namespace Numbas.json */
var json = Numbas.json = {
    /** Try to load an attribute with name from `attr` from `source` into `target`.
     *  Tries lower-case
     *  @param {Object} source - object to load value(s) from
     *  @param {String|Array.<String>} attrs - the name, or list of names, of attributes to load
     *  @param {Object} target - object to set values in
     *  @param {String|Array.<String>} altnames - the name, or list of names, to set in the target object
     */
    tryLoad: function(source,attrs,target,altnames) {
        if(!source) {
            return;
        }
        if(typeof(attrs)=='string') {
            attrs = [attrs];
            altnames = altnames && [altnames];
        }
        altnames = altnames || [];
        for(var i=0;i<attrs.length;i++) {
            var attr = attrs[i];
            var target_attr = altnames[i] || attr;
            var value = json.tryGet(source, attr);
            if(value!==undefined) {
                if(target_attr in target && typeof target[target_attr] == 'string') {
                    value += '';
                }
                if(target_attr in target && typeof target[target_attr] == 'number') {
                    value = parseFloat(value);
                }
                target[target_attr] = value;
            }
        }
    },
    /** Try to load an attribute with the given name from `source`. The given name and its lower-case equivalent are tried.
     * @param {Object} source
     * @param {String} attr
     */
    tryGet: function(source, attr) {
        if(attr in source) {
            return source[attr];
        } else if(attr.toLowerCase() in source) {
            return source[attr.toLowerCase()]
        }
    }
}
});

Numbas.queueScript('knockout-handlers',['display-base','answer-widgets'],function() {
    Knockout.onError = function(err) {
        Numbas.display.die(err);
    };
    function resizeF() {
        var w = $.textMetrics(this).width;
        $(this).width(Math.max(w+30,60)+'px');
    };
    Knockout.bindingHandlers.horizontalSlideVisible = {
        init: function(element, valueAccessor) {
            var containerWidth = $(element).width();
            Knockout.utils.domData.set(element,'originalWidth',containerWidth);
            $(element).css({display:'inline-block', 'overflow-x': 'hidden'});
            var buttonWidth = $(element).children().outerWidth();
            $(element).children().css({width:buttonWidth});
        },
        update: function(element, valueAccessor) {
            var value = Knockout.utils.unwrapObservable(valueAccessor());
            var originalWidth = Knockout.utils.domData.get(element,'originalWidth');
            $(element).animate({width: value ? originalWidth : 0}, 1000);
        }
    }
    Knockout.bindingHandlers.niceNumber = {
        update: function(element,valueAccessor) {
            var n = Knockout.utils.unwrapObservable(valueAccessor());
            $(element).text(Numbas.math.niceNumber(n));
        }
    }
    Knockout.bindingHandlers.autosize = {
        init: function(element) {
            //resize text inputs to just fit their contents
            $(element).keyup(resizeF).keydown(resizeF).change(resizeF).each(resizeF);
            resizeF.apply(element);
        },
        update: function(element) {
            resizeF.apply(element);
        }
    }
    Knockout.bindingHandlers.test = {
        update: function(element,valueAccessor) {
            console.log(Knockout.utils.unwrapObservable(valueAccessor()));
        }
    }
    Knockout.bindingHandlers.dom = {
        update: function(element,valueAccessor) {
            var html = Knockout.utils.unwrapObservable(valueAccessor());
            $(element).children().remove();
            $(element).append(html);
        }
    }
    Knockout.bindingHandlers.slideVisible = {
        init: function(element,valueAccessor) {
            var v = Knockout.utils.unwrapObservable(valueAccessor());
            $(element).toggle(v);
        },
        update: function(element,valueAccessor) {
            var v = Knockout.utils.unwrapObservable(valueAccessor());
            if(v)
                $(element).stop().slideDown('fast');
            else
                $(element).stop().slideUp('fast');
        }
    }
    Knockout.bindingHandlers.fadeVisible = {
        init: function(element,valueAccessor) {
            var v = Knockout.utils.unwrapObservable(valueAccessor());
            $(element).toggle(v);
        },
        update: function(element,valueAccessor) {
            var v = Knockout.utils.unwrapObservable(valueAccessor());
            if(v)
                $(element).stop().fadeIn();
            else
                $(element).stop().fadeOut();
        }
    }
    Knockout.bindingHandlers.latex = {
        update: function(element,valueAccessor) {
            Knockout.bindingHandlers.html.update.apply(this,arguments);
            Numbas.display.typeset(element);
        }
    }
    Knockout.bindingHandlers.maths = {
        update: function(element,valueAccessor) {
            var val = Knockout.utils.unwrapObservable(valueAccessor());
            $(element).html('<script type="math/tex">'+val+'</script>');
            Numbas.display.typeset(element);
        }
    }
    Knockout.bindingHandlers.typeset = {
        update: function(element, valueAccessor) {
            Knockout.utils.unwrapObservable(valueAccessor());
            Numbas.display.typeset(element);
        }
    }
    Knockout.bindingHandlers.pulse = {
        init: function() {
        },
        update: function(element,valueAccessor) {
            if(valueAccessor()()) {
                $(element).stop(true).animate({opacity:0},200).animate({opacity:1},200);
            }
        }
    };
    Knockout.bindingHandlers.carousel = {
        update: function() {
        }
    }
    Knockout.bindingHandlers.hover = {
        init: function(element,valueAccessor) {
            var val = valueAccessor();
            val(false);
            $(element).hover(
                function() {
                    val(true);
                },
                function() {
                    val(false)
                }
            );
        }
    }
    Knockout.bindingHandlers.realVisible = Knockout.bindingHandlers.visible;
    Knockout.bindingHandlers.visible = {
        init: function(element,valueAccessor) {
            $(element).css('display','');
            Knockout.utils.domData.set(element,'tabindex',$(element).attr('tabindex'));
        },
        update: function(element,valueAccessor) {
            var val = Knockout.unwrap(valueAccessor());
            $(element).toggleClass('invisible',!val);
            $(element).attr('disabled',!val);
            if(val) {
                $(element).attr('tabindex',Knockout.utils.domData.get(element,'tabindex'));
            }
            else {
                $(element).removeAttr('tabindex');
            }
        }
    }
    Knockout.bindingHandlers.visibleIf = {
        init: function(element,valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
            var val = Knockout.utils.unwrapObservable(valueAccessor());
            if(val && !Knockout.utils.domData.get(element,'visible-if-happened')) {
                Knockout.applyBindingsToDescendants(bindingContext,element);
                Knockout.utils.domData.set(element,'visible-if-happened',true);
            }
            $(element).toggleClass('invisible',!val);
            return {controlsDescendantBindings: true};
        },
        update:function(element,valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
            var val = Knockout.utils.unwrapObservable(valueAccessor());
            if(val && !Knockout.utils.domData.get(element,'visible-if-happened')) {
                Knockout.applyBindingsToDescendants(bindingContext,element);
                Knockout.utils.domData.set(element,'visible-if-happened',true);
            }
            $(element).toggleClass('invisible',!val);
        }
    }
    Knockout.bindingHandlers.stopbinding = {
        init: function() {
            return {controlsDescendantBindings: true};
        }
    }
    ko.bindingHandlers.reorder_table = {
        // reorder the rows and columns of a table, including the header
        // value is an object {rows, columns, leaders}
        // rows and columns are permutations
        // leaders is the number of columns at the start of each row to ignore (so column headers aren't moved)
        init: function(element, valueAccessor) {
            var value = ko.unwrap(valueAccessor());
            var row_order = value.rows;
            var column_order = value.columns;
            var leaders = value.leaders || 0;
            Array.prototype.forEach.call(element.querySelectorAll('tr'),function(r) {
                var columns = Array.prototype.slice.call(r.querySelectorAll('td,th'),leaders);
                for(var i=0;i<column_order.length;i++) {
                    r.appendChild(columns[column_order[i]]);
                }
            });
            Array.prototype.forEach.call(element.querySelectorAll('tbody'),function(body) {
                var rows = Array.prototype.slice.call(body.querySelectorAll('tr'));
                for(var i=0;i<row_order.length;i++) {
                    body.appendChild(rows[row_order[i]]);
                }
            })
        }
    }
    ko.bindingHandlers.reorder_list = {
        init: function(element, valueAccessor) {
            var value = ko.unwrap(valueAccessor());
            var order = value.order;
            var leaders = value.leaders || 0;
            var items = Array.prototype.slice.call(element.children, leaders);
            for(var i=0;i<order.length;i++) {
                element.appendChild(items[order[i]]);
            }
        }
    }
});
Numbas.queueScript('knockout',[],function(module) {
/*!
 * Knockout JavaScript library v3.4.2
 * (c) The Knockout.js team - http://knockoutjs.com/
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */
(function() {(function(n){var x=this||(0,eval)("this"),t=x.document,M=x.navigator,u=x.jQuery,H=x.JSON;(function(n){"function"===typeof define&&define.amd?define(["exports","require"],n):"object"===typeof exports&&"object"===typeof module?n(module.exports||exports):n(x.ko={})})(function(N,O){function J(a,c){return null===a||typeof a in R?a===c:!1}function S(b,c){var d;return function(){d||(d=a.a.setTimeout(function(){d=n;b()},c))}}function T(b,c){var d;return function(){clearTimeout(d);d=a.a.setTimeout(b,c)}}function U(a,
c){c&&c!==E?"beforeChange"===c?this.Ob(a):this.Ja(a,c):this.Pb(a)}function V(a,c){null!==c&&c.k&&c.k()}function W(a,c){var d=this.Mc,e=d[s];e.T||(this.ob&&this.Oa[c]?(d.Sb(c,a,this.Oa[c]),this.Oa[c]=null,--this.ob):e.s[c]||d.Sb(c,a,e.t?{$:a}:d.yc(a)),a.Ha&&a.Hc())}function K(b,c,d,e){a.d[b]={init:function(b,g,h,l,m){var k,r;a.m(function(){var q=g(),p=a.a.c(q),p=!d!==!p,A=!r;if(A||c||p!==k)A&&a.xa.Ca()&&(r=a.a.wa(a.f.childNodes(b),!0)),p?(A||a.f.fa(b,a.a.wa(r)),a.hb(e?e(m,q):m,b)):a.f.za(b),k=p},null,
{i:b});return{controlsDescendantBindings:!0}}};a.h.va[b]=!1;a.f.aa[b]=!0}var a="undefined"!==typeof N?N:{};a.b=function(b,c){for(var d=b.split("."),e=a,f=0;f<d.length-1;f++)e=e[d[f]];e[d[d.length-1]]=c};a.H=function(a,c,d){a[c]=d};a.version="3.4.2";a.b("version",a.version);a.options={deferUpdates:!1,useOnlyNativeEvents:!1};a.a=function(){function b(a,b){for(var c in a)a.hasOwnProperty(c)&&b(c,a[c])}function c(a,b){if(b)for(var c in b)b.hasOwnProperty(c)&&(a[c]=b[c]);return a}function d(a,b){a.__proto__=
b;return a}function e(b,c,d,e){var m=b[c].match(r)||[];a.a.r(d.match(r),function(b){a.a.ra(m,b,e)});b[c]=m.join(" ")}var f={__proto__:[]}instanceof Array,g="function"===typeof Symbol,h={},l={};h[M&&/Firefox\/2/i.test(M.userAgent)?"KeyboardEvent":"UIEvents"]=["keyup","keydown","keypress"];h.MouseEvents="click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave".split(" ");b(h,function(a,b){if(b.length)for(var c=0,d=b.length;c<d;c++)l[b[c]]=a});var m={propertychange:!0},k=
t&&function(){for(var a=3,b=t.createElement("div"),c=b.getElementsByTagName("i");b.innerHTML="\x3c!--[if gt IE "+ ++a+"]><i></i><![endif]--\x3e",c[0];);return 4<a?a:n}(),r=/\S+/g;return{gc:["authenticity_token",/^__RequestVerificationToken(_.*)?$/],r:function(a,b){for(var c=0,d=a.length;c<d;c++)b(a[c],c)},o:function(a,b){if("function"==typeof Array.prototype.indexOf)return Array.prototype.indexOf.call(a,b);for(var c=0,d=a.length;c<d;c++)if(a[c]===b)return c;return-1},Vb:function(a,b,c){for(var d=
0,e=a.length;d<e;d++)if(b.call(c,a[d],d))return a[d];return null},Na:function(b,c){var d=a.a.o(b,c);0<d?b.splice(d,1):0===d&&b.shift()},Wb:function(b){b=b||[];for(var c=[],d=0,e=b.length;d<e;d++)0>a.a.o(c,b[d])&&c.push(b[d]);return c},ib:function(a,b){a=a||[];for(var c=[],d=0,e=a.length;d<e;d++)c.push(b(a[d],d));return c},Ma:function(a,b){a=a||[];for(var c=[],d=0,e=a.length;d<e;d++)b(a[d],d)&&c.push(a[d]);return c},ta:function(a,b){if(b instanceof Array)a.push.apply(a,b);else for(var c=0,d=b.length;c<
d;c++)a.push(b[c]);return a},ra:function(b,c,d){var e=a.a.o(a.a.Bb(b),c);0>e?d&&b.push(c):d||b.splice(e,1)},la:f,extend:c,$a:d,ab:f?d:c,D:b,Ea:function(a,b){if(!a)return a;var c={},d;for(d in a)a.hasOwnProperty(d)&&(c[d]=b(a[d],d,a));return c},rb:function(b){for(;b.firstChild;)a.removeNode(b.firstChild)},nc:function(b){b=a.a.W(b);for(var c=(b[0]&&b[0].ownerDocument||t).createElement("div"),d=0,e=b.length;d<e;d++)c.appendChild(a.ba(b[d]));return c},wa:function(b,c){for(var d=0,e=b.length,m=[];d<e;d++){var k=
b[d].cloneNode(!0);m.push(c?a.ba(k):k)}return m},fa:function(b,c){a.a.rb(b);if(c)for(var d=0,e=c.length;d<e;d++)b.appendChild(c[d])},uc:function(b,c){var d=b.nodeType?[b]:b;if(0<d.length){for(var e=d[0],m=e.parentNode,k=0,f=c.length;k<f;k++)m.insertBefore(c[k],e);k=0;for(f=d.length;k<f;k++)a.removeNode(d[k])}},Ba:function(a,b){if(a.length){for(b=8===b.nodeType&&b.parentNode||b;a.length&&a[0].parentNode!==b;)a.splice(0,1);for(;1<a.length&&a[a.length-1].parentNode!==b;)a.length--;if(1<a.length){var c=
a[0],d=a[a.length-1];for(a.length=0;c!==d;)a.push(c),c=c.nextSibling;a.push(d)}}return a},wc:function(a,b){7>k?a.setAttribute("selected",b):a.selected=b},cb:function(a){return null===a||a===n?"":a.trim?a.trim():a.toString().replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")},sd:function(a,b){a=a||"";return b.length>a.length?!1:a.substring(0,b.length)===b},Rc:function(a,b){if(a===b)return!0;if(11===a.nodeType)return!1;if(b.contains)return b.contains(3===a.nodeType?a.parentNode:a);if(b.compareDocumentPosition)return 16==
(b.compareDocumentPosition(a)&16);for(;a&&a!=b;)a=a.parentNode;return!!a},qb:function(b){return a.a.Rc(b,b.ownerDocument.documentElement)},Tb:function(b){return!!a.a.Vb(b,a.a.qb)},A:function(a){return a&&a.tagName&&a.tagName.toLowerCase()},Zb:function(b){return a.onError?function(){try{return b.apply(this,arguments)}catch(c){throw a.onError&&a.onError(c),c;}}:b},setTimeout:function(b,c){return setTimeout(a.a.Zb(b),c)},dc:function(b){setTimeout(function(){a.onError&&a.onError(b);throw b;},0)},q:function(b,
c,d){var e=a.a.Zb(d);d=k&&m[c];if(a.options.useOnlyNativeEvents||d||!u)if(d||"function"!=typeof b.addEventListener)if("undefined"!=typeof b.attachEvent){var f=function(a){e.call(b,a)},l="on"+c;b.attachEvent(l,f);a.a.G.qa(b,function(){b.detachEvent(l,f)})}else throw Error("Browser doesn't support addEventListener or attachEvent");else b.addEventListener(c,e,!1);else u(b).bind(c,e)},Fa:function(b,c){if(!b||!b.nodeType)throw Error("element must be a DOM node when calling triggerEvent");var d;"input"===
a.a.A(b)&&b.type&&"click"==c.toLowerCase()?(d=b.type,d="checkbox"==d||"radio"==d):d=!1;if(a.options.useOnlyNativeEvents||!u||d)if("function"==typeof t.createEvent)if("function"==typeof b.dispatchEvent)d=t.createEvent(l[c]||"HTMLEvents"),d.initEvent(c,!0,!0,x,0,0,0,0,0,!1,!1,!1,!1,0,b),b.dispatchEvent(d);else throw Error("The supplied element doesn't support dispatchEvent");else if(d&&b.click)b.click();else if("undefined"!=typeof b.fireEvent)b.fireEvent("on"+c);else throw Error("Browser doesn't support triggering events");
else u(b).trigger(c)},c:function(b){return a.I(b)?b():b},Bb:function(b){return a.I(b)?b.p():b},fb:function(b,c,d){var k;c&&("object"===typeof b.classList?(k=b.classList[d?"add":"remove"],a.a.r(c.match(r),function(a){k.call(b.classList,a)})):"string"===typeof b.className.baseVal?e(b.className,"baseVal",c,d):e(b,"className",c,d))},bb:function(b,c){var d=a.a.c(c);if(null===d||d===n)d="";var e=a.f.firstChild(b);!e||3!=e.nodeType||a.f.nextSibling(e)?a.f.fa(b,[b.ownerDocument.createTextNode(d)]):e.data=
d;a.a.Wc(b)},vc:function(a,b){a.name=b;if(7>=k)try{a.mergeAttributes(t.createElement("<input name='"+a.name+"'/>"),!1)}catch(c){}},Wc:function(a){9<=k&&(a=1==a.nodeType?a:a.parentNode,a.style&&(a.style.zoom=a.style.zoom))},Sc:function(a){if(k){var b=a.style.width;a.style.width=0;a.style.width=b}},nd:function(b,c){b=a.a.c(b);c=a.a.c(c);for(var d=[],e=b;e<=c;e++)d.push(e);return d},W:function(a){for(var b=[],c=0,d=a.length;c<d;c++)b.push(a[c]);return b},bc:function(a){return g?Symbol(a):a},xd:6===k,
yd:7===k,C:k,ic:function(b,c){for(var d=a.a.W(b.getElementsByTagName("input")).concat(a.a.W(b.getElementsByTagName("textarea"))),e="string"==typeof c?function(a){return a.name===c}:function(a){return c.test(a.name)},k=[],m=d.length-1;0<=m;m--)e(d[m])&&k.push(d[m]);return k},kd:function(b){return"string"==typeof b&&(b=a.a.cb(b))?H&&H.parse?H.parse(b):(new Function("return "+b))():null},Gb:function(b,c,d){if(!H||!H.stringify)throw Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js");
return H.stringify(a.a.c(b),c,d)},ld:function(c,d,e){e=e||{};var k=e.params||{},m=e.includeFields||this.gc,f=c;if("object"==typeof c&&"form"===a.a.A(c))for(var f=c.action,l=m.length-1;0<=l;l--)for(var g=a.a.ic(c,m[l]),h=g.length-1;0<=h;h--)k[g[h].name]=g[h].value;d=a.a.c(d);var r=t.createElement("form");r.style.display="none";r.action=f;r.method="post";for(var n in d)c=t.createElement("input"),c.type="hidden",c.name=n,c.value=a.a.Gb(a.a.c(d[n])),r.appendChild(c);b(k,function(a,b){var c=t.createElement("input");
c.type="hidden";c.name=a;c.value=b;r.appendChild(c)});t.body.appendChild(r);e.submitter?e.submitter(r):r.submit();setTimeout(function(){r.parentNode.removeChild(r)},0)}}}();a.b("utils",a.a);a.b("utils.arrayForEach",a.a.r);a.b("utils.arrayFirst",a.a.Vb);a.b("utils.arrayFilter",a.a.Ma);a.b("utils.arrayGetDistinctValues",a.a.Wb);a.b("utils.arrayIndexOf",a.a.o);a.b("utils.arrayMap",a.a.ib);a.b("utils.arrayPushAll",a.a.ta);a.b("utils.arrayRemoveItem",a.a.Na);a.b("utils.extend",a.a.extend);a.b("utils.fieldsIncludedWithJsonPost",
a.a.gc);a.b("utils.getFormFields",a.a.ic);a.b("utils.peekObservable",a.a.Bb);a.b("utils.postJson",a.a.ld);a.b("utils.parseJson",a.a.kd);a.b("utils.registerEventHandler",a.a.q);a.b("utils.stringifyJson",a.a.Gb);a.b("utils.range",a.a.nd);a.b("utils.toggleDomNodeCssClass",a.a.fb);a.b("utils.triggerEvent",a.a.Fa);a.b("utils.unwrapObservable",a.a.c);a.b("utils.objectForEach",a.a.D);a.b("utils.addOrRemoveItem",a.a.ra);a.b("utils.setTextContent",a.a.bb);a.b("unwrap",a.a.c);Function.prototype.bind||(Function.prototype.bind=
function(a){var c=this;if(1===arguments.length)return function(){return c.apply(a,arguments)};var d=Array.prototype.slice.call(arguments,1);return function(){var e=d.slice(0);e.push.apply(e,arguments);return c.apply(a,e)}});a.a.e=new function(){function a(b,g){var h=b[d];if(!h||"null"===h||!e[h]){if(!g)return n;h=b[d]="ko"+c++;e[h]={}}return e[h]}var c=0,d="__ko__"+(new Date).getTime(),e={};return{get:function(c,d){var e=a(c,!1);return e===n?n:e[d]},set:function(c,d,e){if(e!==n||a(c,!1)!==n)a(c,!0)[d]=
e},clear:function(a){var b=a[d];return b?(delete e[b],a[d]=null,!0):!1},J:function(){return c++ +d}}};a.b("utils.domData",a.a.e);a.b("utils.domData.clear",a.a.e.clear);a.a.G=new function(){function b(b,c){var e=a.a.e.get(b,d);e===n&&c&&(e=[],a.a.e.set(b,d,e));return e}function c(d){var e=b(d,!1);if(e)for(var e=e.slice(0),l=0;l<e.length;l++)e[l](d);a.a.e.clear(d);a.a.G.cleanExternalData(d);if(f[d.nodeType])for(e=d.firstChild;d=e;)e=d.nextSibling,8===d.nodeType&&c(d)}var d=a.a.e.J(),e={1:!0,8:!0,9:!0},
f={1:!0,9:!0};return{qa:function(a,c){if("function"!=typeof c)throw Error("Callback must be a function");b(a,!0).push(c)},tc:function(c,e){var f=b(c,!1);f&&(a.a.Na(f,e),0==f.length&&a.a.e.set(c,d,n))},ba:function(b){if(e[b.nodeType]&&(c(b),f[b.nodeType])){var d=[];a.a.ta(d,b.getElementsByTagName("*"));for(var l=0,m=d.length;l<m;l++)c(d[l])}return b},removeNode:function(b){a.ba(b);b.parentNode&&b.parentNode.removeChild(b)},cleanExternalData:function(a){u&&"function"==typeof u.cleanData&&u.cleanData([a])}}};
a.ba=a.a.G.ba;a.removeNode=a.a.G.removeNode;a.b("cleanNode",a.ba);a.b("removeNode",a.removeNode);a.b("utils.domNodeDisposal",a.a.G);a.b("utils.domNodeDisposal.addDisposeCallback",a.a.G.qa);a.b("utils.domNodeDisposal.removeDisposeCallback",a.a.G.tc);(function(){var b=[0,"",""],c=[1,"<table>","</table>"],d=[3,"<table><tbody><tr>","</tr></tbody></table>"],e=[1,"<select multiple='multiple'>","</select>"],f={thead:c,tbody:c,tfoot:c,tr:[2,"<table><tbody>","</tbody></table>"],td:d,th:d,option:e,optgroup:e},
g=8>=a.a.C;a.a.na=function(c,d){var e;if(u)if(u.parseHTML)e=u.parseHTML(c,d)||[];else{if((e=u.clean([c],d))&&e[0]){for(var k=e[0];k.parentNode&&11!==k.parentNode.nodeType;)k=k.parentNode;k.parentNode&&k.parentNode.removeChild(k)}}else{(e=d)||(e=t);var k=e.parentWindow||e.defaultView||x,r=a.a.cb(c).toLowerCase(),q=e.createElement("div"),p;p=(r=r.match(/^<([a-z]+)[ >]/))&&f[r[1]]||b;r=p[0];p="ignored<div>"+p[1]+c+p[2]+"</div>";"function"==typeof k.innerShiv?q.appendChild(k.innerShiv(p)):(g&&e.appendChild(q),
q.innerHTML=p,g&&q.parentNode.removeChild(q));for(;r--;)q=q.lastChild;e=a.a.W(q.lastChild.childNodes)}return e};a.a.Eb=function(b,c){a.a.rb(b);c=a.a.c(c);if(null!==c&&c!==n)if("string"!=typeof c&&(c=c.toString()),u)u(b).html(c);else for(var d=a.a.na(c,b.ownerDocument),e=0;e<d.length;e++)b.appendChild(d[e])}})();a.b("utils.parseHtmlFragment",a.a.na);a.b("utils.setHtml",a.a.Eb);a.N=function(){function b(c,e){if(c)if(8==c.nodeType){var f=a.N.pc(c.nodeValue);null!=f&&e.push({Qc:c,hd:f})}else if(1==c.nodeType)for(var f=
0,g=c.childNodes,h=g.length;f<h;f++)b(g[f],e)}var c={};return{yb:function(a){if("function"!=typeof a)throw Error("You can only pass a function to ko.memoization.memoize()");var b=(4294967296*(1+Math.random())|0).toString(16).substring(1)+(4294967296*(1+Math.random())|0).toString(16).substring(1);c[b]=a;return"\x3c!--[ko_memo:"+b+"]--\x3e"},Bc:function(a,b){var f=c[a];if(f===n)throw Error("Couldn't find any memo with ID "+a+". Perhaps it's already been unmemoized.");try{return f.apply(null,b||[]),
!0}finally{delete c[a]}},Cc:function(c,e){var f=[];b(c,f);for(var g=0,h=f.length;g<h;g++){var l=f[g].Qc,m=[l];e&&a.a.ta(m,e);a.N.Bc(f[g].hd,m);l.nodeValue="";l.parentNode&&l.parentNode.removeChild(l)}},pc:function(a){return(a=a.match(/^\[ko_memo\:(.*?)\]$/))?a[1]:null}}}();a.b("memoization",a.N);a.b("memoization.memoize",a.N.yb);a.b("memoization.unmemoize",a.N.Bc);a.b("memoization.parseMemoText",a.N.pc);a.b("memoization.unmemoizeDomNodeAndDescendants",a.N.Cc);a.Z=function(){function b(){if(e)for(var b=
e,c=0,m;g<e;)if(m=d[g++]){if(g>b){if(5E3<=++c){g=e;a.a.dc(Error("'Too much recursion' after processing "+c+" task groups."));break}b=e}try{m()}catch(k){a.a.dc(k)}}}function c(){b();g=e=d.length=0}var d=[],e=0,f=1,g=0;return{scheduler:x.MutationObserver?function(a){var b=t.createElement("div");(new MutationObserver(a)).observe(b,{attributes:!0});return function(){b.classList.toggle("foo")}}(c):t&&"onreadystatechange"in t.createElement("script")?function(a){var b=t.createElement("script");b.onreadystatechange=
function(){b.onreadystatechange=null;t.documentElement.removeChild(b);b=null;a()};t.documentElement.appendChild(b)}:function(a){setTimeout(a,0)},Za:function(b){e||a.Z.scheduler(c);d[e++]=b;return f++},cancel:function(a){a-=f-e;a>=g&&a<e&&(d[a]=null)},resetForTesting:function(){var a=e-g;g=e=d.length=0;return a},rd:b}}();a.b("tasks",a.Z);a.b("tasks.schedule",a.Z.Za);a.b("tasks.runEarly",a.Z.rd);a.Aa={throttle:function(b,c){b.throttleEvaluation=c;var d=null;return a.B({read:b,write:function(e){clearTimeout(d);
d=a.a.setTimeout(function(){b(e)},c)}})},rateLimit:function(a,c){var d,e,f;"number"==typeof c?d=c:(d=c.timeout,e=c.method);a.gb=!1;f="notifyWhenChangesStop"==e?T:S;a.Wa(function(a){return f(a,d)})},deferred:function(b,c){if(!0!==c)throw Error("The 'deferred' extender only accepts the value 'true', because it is not supported to turn deferral off once enabled.");b.gb||(b.gb=!0,b.Wa(function(c){var e,f=!1;return function(){if(!f){a.Z.cancel(e);e=a.Z.Za(c);try{f=!0,b.notifySubscribers(n,"dirty")}finally{f=
!1}}}}))},notify:function(a,c){a.equalityComparer="always"==c?null:J}};var R={undefined:1,"boolean":1,number:1,string:1};a.b("extenders",a.Aa);a.zc=function(b,c,d){this.$=b;this.jb=c;this.Pc=d;this.T=!1;a.H(this,"dispose",this.k)};a.zc.prototype.k=function(){this.T=!0;this.Pc()};a.K=function(){a.a.ab(this,D);D.ub(this)};var E="change",D={ub:function(a){a.F={change:[]};a.Qb=1},Y:function(b,c,d){var e=this;d=d||E;var f=new a.zc(e,c?b.bind(c):b,function(){a.a.Na(e.F[d],f);e.Ka&&e.Ka(d)});e.ua&&e.ua(d);
e.F[d]||(e.F[d]=[]);e.F[d].push(f);return f},notifySubscribers:function(b,c){c=c||E;c===E&&this.Kb();if(this.Ra(c)){var d=c===E&&this.Fc||this.F[c].slice(0);try{a.l.Xb();for(var e=0,f;f=d[e];++e)f.T||f.jb(b)}finally{a.l.end()}}},Pa:function(){return this.Qb},Zc:function(a){return this.Pa()!==a},Kb:function(){++this.Qb},Wa:function(b){var c=this,d=a.I(c),e,f,g,h;c.Ja||(c.Ja=c.notifySubscribers,c.notifySubscribers=U);var l=b(function(){c.Ha=!1;d&&h===c&&(h=c.Mb?c.Mb():c());var a=f||c.Ua(g,h);f=e=!1;
a&&c.Ja(g=h)});c.Pb=function(a){c.Fc=c.F[E].slice(0);c.Ha=e=!0;h=a;l()};c.Ob=function(a){e||(g=a,c.Ja(a,"beforeChange"))};c.Hc=function(){c.Ua(g,c.p(!0))&&(f=!0)}},Ra:function(a){return this.F[a]&&this.F[a].length},Xc:function(b){if(b)return this.F[b]&&this.F[b].length||0;var c=0;a.a.D(this.F,function(a,b){"dirty"!==a&&(c+=b.length)});return c},Ua:function(a,c){return!this.equalityComparer||!this.equalityComparer(a,c)},extend:function(b){var c=this;b&&a.a.D(b,function(b,e){var f=a.Aa[b];"function"==
typeof f&&(c=f(c,e)||c)});return c}};a.H(D,"subscribe",D.Y);a.H(D,"extend",D.extend);a.H(D,"getSubscriptionsCount",D.Xc);a.a.la&&a.a.$a(D,Function.prototype);a.K.fn=D;a.lc=function(a){return null!=a&&"function"==typeof a.Y&&"function"==typeof a.notifySubscribers};a.b("subscribable",a.K);a.b("isSubscribable",a.lc);a.xa=a.l=function(){function b(a){d.push(e);e=a}function c(){e=d.pop()}var d=[],e,f=0;return{Xb:b,end:c,sc:function(b){if(e){if(!a.lc(b))throw Error("Only subscribable things can act as dependencies");
e.jb.call(e.Lc,b,b.Gc||(b.Gc=++f))}},w:function(a,d,e){try{return b(),a.apply(d,e||[])}finally{c()}},Ca:function(){if(e)return e.m.Ca()},Va:function(){if(e)return e.Va}}}();a.b("computedContext",a.xa);a.b("computedContext.getDependenciesCount",a.xa.Ca);a.b("computedContext.isInitial",a.xa.Va);a.b("ignoreDependencies",a.wd=a.l.w);var F=a.a.bc("_latestValue");a.O=function(b){function c(){if(0<arguments.length)return c.Ua(c[F],arguments[0])&&(c.ia(),c[F]=arguments[0],c.ha()),this;a.l.sc(c);return c[F]}
c[F]=b;a.a.la||a.a.extend(c,a.K.fn);a.K.fn.ub(c);a.a.ab(c,B);a.options.deferUpdates&&a.Aa.deferred(c,!0);return c};var B={equalityComparer:J,p:function(){return this[F]},ha:function(){this.notifySubscribers(this[F])},ia:function(){this.notifySubscribers(this[F],"beforeChange")}};a.a.la&&a.a.$a(B,a.K.fn);var I=a.O.md="__ko_proto__";B[I]=a.O;a.Qa=function(b,c){return null===b||b===n||b[I]===n?!1:b[I]===c?!0:a.Qa(b[I],c)};a.I=function(b){return a.Qa(b,a.O)};a.Da=function(b){return"function"==typeof b&&
b[I]===a.O||"function"==typeof b&&b[I]===a.B&&b.$c?!0:!1};a.b("observable",a.O);a.b("isObservable",a.I);a.b("isWriteableObservable",a.Da);a.b("isWritableObservable",a.Da);a.b("observable.fn",B);a.H(B,"peek",B.p);a.H(B,"valueHasMutated",B.ha);a.H(B,"valueWillMutate",B.ia);a.ma=function(b){b=b||[];if("object"!=typeof b||!("length"in b))throw Error("The argument passed when initializing an observable array must be an array, or null, or undefined.");b=a.O(b);a.a.ab(b,a.ma.fn);return b.extend({trackArrayChanges:!0})};
a.ma.fn={remove:function(b){for(var c=this.p(),d=[],e="function"!=typeof b||a.I(b)?function(a){return a===b}:b,f=0;f<c.length;f++){var g=c[f];e(g)&&(0===d.length&&this.ia(),d.push(g),c.splice(f,1),f--)}d.length&&this.ha();return d},removeAll:function(b){if(b===n){var c=this.p(),d=c.slice(0);this.ia();c.splice(0,c.length);this.ha();return d}return b?this.remove(function(c){return 0<=a.a.o(b,c)}):[]},destroy:function(b){var c=this.p(),d="function"!=typeof b||a.I(b)?function(a){return a===b}:b;this.ia();
for(var e=c.length-1;0<=e;e--)d(c[e])&&(c[e]._destroy=!0);this.ha()},destroyAll:function(b){return b===n?this.destroy(function(){return!0}):b?this.destroy(function(c){return 0<=a.a.o(b,c)}):[]},indexOf:function(b){var c=this();return a.a.o(c,b)},replace:function(a,c){var d=this.indexOf(a);0<=d&&(this.ia(),this.p()[d]=c,this.ha())}};a.a.la&&a.a.$a(a.ma.fn,a.O.fn);a.a.r("pop push reverse shift sort splice unshift".split(" "),function(b){a.ma.fn[b]=function(){var a=this.p();this.ia();this.Yb(a,b,arguments);
var d=a[b].apply(a,arguments);this.ha();return d===a?this:d}});a.a.r(["slice"],function(b){a.ma.fn[b]=function(){var a=this();return a[b].apply(a,arguments)}});a.b("observableArray",a.ma);a.Aa.trackArrayChanges=function(b,c){function d(){if(!e){e=!0;l=b.notifySubscribers;b.notifySubscribers=function(a,b){b&&b!==E||++h;return l.apply(this,arguments)};var c=[].concat(b.p()||[]);f=null;g=b.Y(function(d){d=[].concat(d||[]);if(b.Ra("arrayChange")){var e;if(!f||1<h)f=a.a.lb(c,d,b.kb);e=f}c=d;f=null;h=0;
e&&e.length&&b.notifySubscribers(e,"arrayChange")})}}b.kb={};c&&"object"==typeof c&&a.a.extend(b.kb,c);b.kb.sparse=!0;if(!b.Yb){var e=!1,f=null,g,h=0,l,m=b.ua,k=b.Ka;b.ua=function(a){m&&m.call(b,a);"arrayChange"===a&&d()};b.Ka=function(a){k&&k.call(b,a);"arrayChange"!==a||b.Ra("arrayChange")||(l&&(b.notifySubscribers=l,l=n),g.k(),e=!1)};b.Yb=function(b,c,d){function k(a,b,c){return m[m.length]={status:a,value:b,index:c}}if(e&&!h){var m=[],l=b.length,g=d.length,G=0;switch(c){case "push":G=l;case "unshift":for(c=
0;c<g;c++)k("added",d[c],G+c);break;case "pop":G=l-1;case "shift":l&&k("deleted",b[G],G);break;case "splice":c=Math.min(Math.max(0,0>d[0]?l+d[0]:d[0]),l);for(var l=1===g?l:Math.min(c+(d[1]||0),l),g=c+g-2,G=Math.max(l,g),n=[],s=[],w=2;c<G;++c,++w)c<l&&s.push(k("deleted",b[c],c)),c<g&&n.push(k("added",d[w],c));a.a.hc(s,n);break;default:return}f=m}}}};var s=a.a.bc("_state");a.m=a.B=function(b,c,d){function e(){if(0<arguments.length){if("function"===typeof f)f.apply(g.sb,arguments);else throw Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.");
return this}a.l.sc(e);(g.V||g.t&&e.Sa())&&e.U();return g.M}"object"===typeof b?d=b:(d=d||{},b&&(d.read=b));if("function"!=typeof d.read)throw Error("Pass a function that returns the value of the ko.computed");var f=d.write,g={M:n,da:!0,V:!0,Ta:!1,Hb:!1,T:!1,Ya:!1,t:!1,od:d.read,sb:c||d.owner,i:d.disposeWhenNodeIsRemoved||d.i||null,ya:d.disposeWhen||d.ya,pb:null,s:{},L:0,fc:null};e[s]=g;e.$c="function"===typeof f;a.a.la||a.a.extend(e,a.K.fn);a.K.fn.ub(e);a.a.ab(e,z);d.pure?(g.Ya=!0,g.t=!0,a.a.extend(e,
Y)):d.deferEvaluation&&a.a.extend(e,Z);a.options.deferUpdates&&a.Aa.deferred(e,!0);g.i&&(g.Hb=!0,g.i.nodeType||(g.i=null));g.t||d.deferEvaluation||e.U();g.i&&e.ca()&&a.a.G.qa(g.i,g.pb=function(){e.k()});return e};var z={equalityComparer:J,Ca:function(){return this[s].L},Sb:function(a,c,d){if(this[s].Ya&&c===this)throw Error("A 'pure' computed must not be called recursively");this[s].s[a]=d;d.Ia=this[s].L++;d.pa=c.Pa()},Sa:function(){var a,c,d=this[s].s;for(a in d)if(d.hasOwnProperty(a)&&(c=d[a],this.oa&&
c.$.Ha||c.$.Zc(c.pa)))return!0},gd:function(){this.oa&&!this[s].Ta&&this.oa(!1)},ca:function(){var a=this[s];return a.V||0<a.L},qd:function(){this.Ha?this[s].V&&(this[s].da=!0):this.ec()},yc:function(a){if(a.gb&&!this[s].i){var c=a.Y(this.gd,this,"dirty"),d=a.Y(this.qd,this);return{$:a,k:function(){c.k();d.k()}}}return a.Y(this.ec,this)},ec:function(){var b=this,c=b.throttleEvaluation;c&&0<=c?(clearTimeout(this[s].fc),this[s].fc=a.a.setTimeout(function(){b.U(!0)},c)):b.oa?b.oa(!0):b.U(!0)},U:function(b){var c=
this[s],d=c.ya,e=!1;if(!c.Ta&&!c.T){if(c.i&&!a.a.qb(c.i)||d&&d()){if(!c.Hb){this.k();return}}else c.Hb=!1;c.Ta=!0;try{e=this.Vc(b)}finally{c.Ta=!1}c.L||this.k();return e}},Vc:function(b){var c=this[s],d=!1,e=c.Ya?n:!c.L,f={Mc:this,Oa:c.s,ob:c.L};a.l.Xb({Lc:f,jb:W,m:this,Va:e});c.s={};c.L=0;f=this.Uc(c,f);this.Ua(c.M,f)&&(c.t||this.notifySubscribers(c.M,"beforeChange"),c.M=f,c.t?this.Kb():b&&this.notifySubscribers(c.M),d=!0);e&&this.notifySubscribers(c.M,"awake");return d},Uc:function(b,c){try{var d=
b.od;return b.sb?d.call(b.sb):d()}finally{a.l.end(),c.ob&&!b.t&&a.a.D(c.Oa,V),b.da=b.V=!1}},p:function(a){var c=this[s];(c.V&&(a||!c.L)||c.t&&this.Sa())&&this.U();return c.M},Wa:function(b){a.K.fn.Wa.call(this,b);this.Mb=function(){this[s].da?this.U():this[s].V=!1;return this[s].M};this.oa=function(a){this.Ob(this[s].M);this[s].V=!0;a&&(this[s].da=!0);this.Pb(this)}},k:function(){var b=this[s];!b.t&&b.s&&a.a.D(b.s,function(a,b){b.k&&b.k()});b.i&&b.pb&&a.a.G.tc(b.i,b.pb);b.s=null;b.L=0;b.T=!0;b.da=
!1;b.V=!1;b.t=!1;b.i=null}},Y={ua:function(b){var c=this,d=c[s];if(!d.T&&d.t&&"change"==b){d.t=!1;if(d.da||c.Sa())d.s=null,d.L=0,c.U()&&c.Kb();else{var e=[];a.a.D(d.s,function(a,b){e[b.Ia]=a});a.a.r(e,function(a,b){var e=d.s[a],l=c.yc(e.$);l.Ia=b;l.pa=e.pa;d.s[a]=l})}d.T||c.notifySubscribers(d.M,"awake")}},Ka:function(b){var c=this[s];c.T||"change"!=b||this.Ra("change")||(a.a.D(c.s,function(a,b){b.k&&(c.s[a]={$:b.$,Ia:b.Ia,pa:b.pa},b.k())}),c.t=!0,this.notifySubscribers(n,"asleep"))},Pa:function(){var b=
this[s];b.t&&(b.da||this.Sa())&&this.U();return a.K.fn.Pa.call(this)}},Z={ua:function(a){"change"!=a&&"beforeChange"!=a||this.p()}};a.a.la&&a.a.$a(z,a.K.fn);var P=a.O.md;a.m[P]=a.O;z[P]=a.m;a.bd=function(b){return a.Qa(b,a.m)};a.cd=function(b){return a.Qa(b,a.m)&&b[s]&&b[s].Ya};a.b("computed",a.m);a.b("dependentObservable",a.m);a.b("isComputed",a.bd);a.b("isPureComputed",a.cd);a.b("computed.fn",z);a.H(z,"peek",z.p);a.H(z,"dispose",z.k);a.H(z,"isActive",z.ca);a.H(z,"getDependenciesCount",z.Ca);a.rc=
function(b,c){if("function"===typeof b)return a.m(b,c,{pure:!0});b=a.a.extend({},b);b.pure=!0;return a.m(b,c)};a.b("pureComputed",a.rc);(function(){function b(a,f,g){g=g||new d;a=f(a);if("object"!=typeof a||null===a||a===n||a instanceof RegExp||a instanceof Date||a instanceof String||a instanceof Number||a instanceof Boolean)return a;var h=a instanceof Array?[]:{};g.save(a,h);c(a,function(c){var d=f(a[c]);switch(typeof d){case "boolean":case "number":case "string":case "function":h[c]=d;break;case "object":case "undefined":var k=
g.get(d);h[c]=k!==n?k:b(d,f,g)}});return h}function c(a,b){if(a instanceof Array){for(var c=0;c<a.length;c++)b(c);"function"==typeof a.toJSON&&b("toJSON")}else for(c in a)b(c)}function d(){this.keys=[];this.Lb=[]}a.Ac=function(c){if(0==arguments.length)throw Error("When calling ko.toJS, pass the object you want to convert.");return b(c,function(b){for(var c=0;a.I(b)&&10>c;c++)b=b();return b})};a.toJSON=function(b,c,d){b=a.Ac(b);return a.a.Gb(b,c,d)};d.prototype={save:function(b,c){var d=a.a.o(this.keys,
b);0<=d?this.Lb[d]=c:(this.keys.push(b),this.Lb.push(c))},get:function(b){b=a.a.o(this.keys,b);return 0<=b?this.Lb[b]:n}}})();a.b("toJS",a.Ac);a.b("toJSON",a.toJSON);(function(){a.j={u:function(b){switch(a.a.A(b)){case "option":return!0===b.__ko__hasDomDataOptionValue__?a.a.e.get(b,a.d.options.zb):7>=a.a.C?b.getAttributeNode("value")&&b.getAttributeNode("value").specified?b.value:b.text:b.value;case "select":return 0<=b.selectedIndex?a.j.u(b.options[b.selectedIndex]):n;default:return b.value}},ja:function(b,
c,d){switch(a.a.A(b)){case "option":switch(typeof c){case "string":a.a.e.set(b,a.d.options.zb,n);"__ko__hasDomDataOptionValue__"in b&&delete b.__ko__hasDomDataOptionValue__;b.value=c;break;default:a.a.e.set(b,a.d.options.zb,c),b.__ko__hasDomDataOptionValue__=!0,b.value="number"===typeof c?c:""}break;case "select":if(""===c||null===c)c=n;for(var e=-1,f=0,g=b.options.length,h;f<g;++f)if(h=a.j.u(b.options[f]),h==c||""==h&&c===n){e=f;break}if(d||0<=e||c===n&&1<b.size)b.selectedIndex=e;break;default:if(null===
c||c===n)c="";b.value=c}}}})();a.b("selectExtensions",a.j);a.b("selectExtensions.readValue",a.j.u);a.b("selectExtensions.writeValue",a.j.ja);a.h=function(){function b(b){b=a.a.cb(b);123===b.charCodeAt(0)&&(b=b.slice(1,-1));var c=[],d=b.match(e),r,h=[],p=0;if(d){d.push(",");for(var A=0,y;y=d[A];++A){var v=y.charCodeAt(0);if(44===v){if(0>=p){c.push(r&&h.length?{key:r,value:h.join("")}:{unknown:r||h.join("")});r=p=0;h=[];continue}}else if(58===v){if(!p&&!r&&1===h.length){r=h.pop();continue}}else 47===
v&&A&&1<y.length?(v=d[A-1].match(f))&&!g[v[0]]&&(b=b.substr(b.indexOf(y)+1),d=b.match(e),d.push(","),A=-1,y="/"):40===v||123===v||91===v?++p:41===v||125===v||93===v?--p:r||h.length||34!==v&&39!==v||(y=y.slice(1,-1));h.push(y)}}return c}var c=["true","false","null","undefined"],d=/^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i,e=RegExp("\"(?:[^\"\\\\]|\\\\.)*\"|'(?:[^'\\\\]|\\\\.)*'|/(?:[^/\\\\]|\\\\.)*/w*|[^\\s:,/][^,\"'{}()/:[\\]]*[^\\s,\"'{}()/:[\\]]|[^\\s]","g"),f=/[\])"'A-Za-z0-9_$]+$/,
g={"in":1,"return":1,"typeof":1},h={};return{va:[],ga:h,Ab:b,Xa:function(e,m){function k(b,e){var m;if(!A){var l=a.getBindingHandler(b);if(l&&l.preprocess&&!(e=l.preprocess(e,b,k)))return;if(l=h[b])m=e,0<=a.a.o(c,m)?m=!1:(l=m.match(d),m=null===l?!1:l[1]?"Object("+l[1]+")"+l[2]:m),l=m;l&&g.push("'"+b+"':function(_z){"+m+"=_z}")}p&&(e="function(){return "+e+" }");f.push("'"+b+"':"+e)}m=m||{};var f=[],g=[],p=m.valueAccessors,A=m.bindingParams,y="string"===typeof e?b(e):e;a.a.r(y,function(a){k(a.key||
a.unknown,a.value)});g.length&&k("_ko_property_writers","{"+g.join(",")+" }");return f.join(",")},fd:function(a,b){for(var c=0;c<a.length;c++)if(a[c].key==b)return!0;return!1},Ga:function(b,c,d,e,f){if(b&&a.I(b))!a.Da(b)||f&&b.p()===e||b(e);else if((b=c.get("_ko_property_writers"))&&b[d])b[d](e)}}}();a.b("expressionRewriting",a.h);a.b("expressionRewriting.bindingRewriteValidators",a.h.va);a.b("expressionRewriting.parseObjectLiteral",a.h.Ab);a.b("expressionRewriting.preProcessBindings",a.h.Xa);a.b("expressionRewriting._twoWayBindings",
a.h.ga);a.b("jsonExpressionRewriting",a.h);a.b("jsonExpressionRewriting.insertPropertyAccessorsIntoJson",a.h.Xa);(function(){function b(a){return 8==a.nodeType&&g.test(f?a.text:a.nodeValue)}function c(a){return 8==a.nodeType&&h.test(f?a.text:a.nodeValue)}function d(a,d){for(var e=a,f=1,l=[];e=e.nextSibling;){if(c(e)&&(f--,0===f))return l;l.push(e);b(e)&&f++}if(!d)throw Error("Cannot find closing comment tag to match: "+a.nodeValue);return null}function e(a,b){var c=d(a,b);return c?0<c.length?c[c.length-
1].nextSibling:a.nextSibling:null}var f=t&&"\x3c!--test--\x3e"===t.createComment("test").text,g=f?/^\x3c!--\s*ko(?:\s+([\s\S]+))?\s*--\x3e$/:/^\s*ko(?:\s+([\s\S]+))?\s*$/,h=f?/^\x3c!--\s*\/ko\s*--\x3e$/:/^\s*\/ko\s*$/,l={ul:!0,ol:!0};a.f={aa:{},childNodes:function(a){return b(a)?d(a):a.childNodes},za:function(c){if(b(c)){c=a.f.childNodes(c);for(var d=0,e=c.length;d<e;d++)a.removeNode(c[d])}else a.a.rb(c)},fa:function(c,d){if(b(c)){a.f.za(c);for(var e=c.nextSibling,f=0,l=d.length;f<l;f++)e.parentNode.insertBefore(d[f],
e)}else a.a.fa(c,d)},qc:function(a,c){b(a)?a.parentNode.insertBefore(c,a.nextSibling):a.firstChild?a.insertBefore(c,a.firstChild):a.appendChild(c)},kc:function(c,d,e){e?b(c)?c.parentNode.insertBefore(d,e.nextSibling):e.nextSibling?c.insertBefore(d,e.nextSibling):c.appendChild(d):a.f.qc(c,d)},firstChild:function(a){return b(a)?!a.nextSibling||c(a.nextSibling)?null:a.nextSibling:a.firstChild},nextSibling:function(a){b(a)&&(a=e(a));return a.nextSibling&&c(a.nextSibling)?null:a.nextSibling},Yc:b,vd:function(a){return(a=
(f?a.text:a.nodeValue).match(g))?a[1]:null},oc:function(d){if(l[a.a.A(d)]){var k=d.firstChild;if(k){do if(1===k.nodeType){var f;f=k.firstChild;var g=null;if(f){do if(g)g.push(f);else if(b(f)){var h=e(f,!0);h?f=h:g=[f]}else c(f)&&(g=[f]);while(f=f.nextSibling)}if(f=g)for(g=k.nextSibling,h=0;h<f.length;h++)g?d.insertBefore(f[h],g):d.appendChild(f[h])}while(k=k.nextSibling)}}}}})();a.b("virtualElements",a.f);a.b("virtualElements.allowedBindings",a.f.aa);a.b("virtualElements.emptyNode",a.f.za);a.b("virtualElements.insertAfter",
a.f.kc);a.b("virtualElements.prepend",a.f.qc);a.b("virtualElements.setDomNodeChildren",a.f.fa);(function(){a.S=function(){this.Kc={}};a.a.extend(a.S.prototype,{nodeHasBindings:function(b){switch(b.nodeType){case 1:return null!=b.getAttribute("data-bind")||a.g.getComponentNameForNode(b);case 8:return a.f.Yc(b);default:return!1}},getBindings:function(b,c){var d=this.getBindingsString(b,c),d=d?this.parseBindingsString(d,c,b):null;return a.g.Rb(d,b,c,!1)},getBindingAccessors:function(b,c){var d=this.getBindingsString(b,
c),d=d?this.parseBindingsString(d,c,b,{valueAccessors:!0}):null;return a.g.Rb(d,b,c,!0)},getBindingsString:function(b){switch(b.nodeType){case 1:return b.getAttribute("data-bind");case 8:return a.f.vd(b);default:return null}},parseBindingsString:function(b,c,d,e){try{var f=this.Kc,g=b+(e&&e.valueAccessors||""),h;if(!(h=f[g])){var l,m="with($context){with($data||{}){return{"+a.h.Xa(b,e)+"}}}";l=new Function("$context","$element",m);h=f[g]=l}return h(c,d)}catch(k){throw k.message="Unable to parse bindings.\nBindings value: "+
b+"\nMessage: "+k.message,k;}}});a.S.instance=new a.S})();a.b("bindingProvider",a.S);(function(){function b(a){return function(){return a}}function c(a){return a()}function d(b){return a.a.Ea(a.l.w(b),function(a,c){return function(){return b()[c]}})}function e(c,e,k){return"function"===typeof c?d(c.bind(null,e,k)):a.a.Ea(c,b)}function f(a,b){return d(this.getBindings.bind(this,a,b))}function g(b,c,d){var e,k=a.f.firstChild(c),f=a.S.instance,m=f.preprocessNode;if(m){for(;e=k;)k=a.f.nextSibling(e),
m.call(f,e);k=a.f.firstChild(c)}for(;e=k;)k=a.f.nextSibling(e),h(b,e,d)}function h(b,c,d){var e=!0,k=1===c.nodeType;k&&a.f.oc(c);if(k&&d||a.S.instance.nodeHasBindings(c))e=m(c,null,b,d).shouldBindDescendants;e&&!r[a.a.A(c)]&&g(b,c,!k)}function l(b){var c=[],d={},e=[];a.a.D(b,function X(k){if(!d[k]){var f=a.getBindingHandler(k);f&&(f.after&&(e.push(k),a.a.r(f.after,function(c){if(b[c]){if(-1!==a.a.o(e,c))throw Error("Cannot combine the following bindings, because they have a cyclic dependency: "+e.join(", "));
X(c)}}),e.length--),c.push({key:k,jc:f}));d[k]=!0}});return c}function m(b,d,e,k){var m=a.a.e.get(b,q);if(!d){if(m)throw Error("You cannot apply bindings multiple times to the same element.");a.a.e.set(b,q,!0)}!m&&k&&a.xc(b,e);var g;if(d&&"function"!==typeof d)g=d;else{var h=a.S.instance,r=h.getBindingAccessors||f,p=a.B(function(){(g=d?d(e,b):r.call(h,b,e))&&e.Q&&e.Q();return g},null,{i:b});g&&p.ca()||(p=null)}var s;if(g){var t=p?function(a){return function(){return c(p()[a])}}:function(a){return g[a]},
u=function(){return a.a.Ea(p?p():g,c)};u.get=function(a){return g[a]&&c(t(a))};u.has=function(a){return a in g};k=l(g);a.a.r(k,function(c){var d=c.jc.init,k=c.jc.update,f=c.key;if(8===b.nodeType&&!a.f.aa[f])throw Error("The binding '"+f+"' cannot be used with virtual elements");try{"function"==typeof d&&a.l.w(function(){var a=d(b,t(f),u,e.$data,e);if(a&&a.controlsDescendantBindings){if(s!==n)throw Error("Multiple bindings ("+s+" and "+f+") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.");
s=f}}),"function"==typeof k&&a.B(function(){k(b,t(f),u,e.$data,e)},null,{i:b})}catch(m){throw m.message='Unable to process binding "'+f+": "+g[f]+'"\nMessage: '+m.message,m;}})}return{shouldBindDescendants:s===n}}function k(b){return b&&b instanceof a.R?b:new a.R(b)}a.d={};var r={script:!0,textarea:!0,template:!0};a.getBindingHandler=function(b){return a.d[b]};a.R=function(b,c,d,e,k){function f(){var k=g?b():b,m=a.a.c(k);c?(c.Q&&c.Q(),a.a.extend(l,c),l.Q=r):(l.$parents=[],l.$root=m,l.ko=a);l.$rawData=
k;l.$data=m;d&&(l[d]=m);e&&e(l,c,m);return l.$data}function m(){return h&&!a.a.Tb(h)}var l=this,g="function"==typeof b&&!a.I(b),h,r;k&&k.exportDependencies?f():(r=a.B(f,null,{ya:m,i:!0}),r.ca()&&(l.Q=r,r.equalityComparer=null,h=[],r.Dc=function(b){h.push(b);a.a.G.qa(b,function(b){a.a.Na(h,b);h.length||(r.k(),l.Q=r=n)})}))};a.R.prototype.createChildContext=function(b,c,d,e){return new a.R(b,this,c,function(a,b){a.$parentContext=b;a.$parent=b.$data;a.$parents=(b.$parents||[]).slice(0);a.$parents.unshift(a.$parent);
d&&d(a)},e)};a.R.prototype.extend=function(b){return new a.R(this.Q||this.$data,this,null,function(c,d){c.$rawData=d.$rawData;a.a.extend(c,"function"==typeof b?b():b)})};a.R.prototype.ac=function(a,b){return this.createChildContext(a,b,null,{exportDependencies:!0})};var q=a.a.e.J(),p=a.a.e.J();a.xc=function(b,c){if(2==arguments.length)a.a.e.set(b,p,c),c.Q&&c.Q.Dc(b);else return a.a.e.get(b,p)};a.La=function(b,c,d){1===b.nodeType&&a.f.oc(b);return m(b,c,k(d),!0)};a.Ic=function(b,c,d){d=k(d);return a.La(b,
e(c,d,b),d)};a.hb=function(a,b){1!==b.nodeType&&8!==b.nodeType||g(k(a),b,!0)};a.Ub=function(a,b){!u&&x.jQuery&&(u=x.jQuery);if(b&&1!==b.nodeType&&8!==b.nodeType)throw Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node");b=b||x.document.body;h(k(a),b,!0)};a.nb=function(b){switch(b.nodeType){case 1:case 8:var c=a.xc(b);if(c)return c;if(b.parentNode)return a.nb(b.parentNode)}return n};a.Oc=function(b){return(b=a.nb(b))?b.$data:n};a.b("bindingHandlers",
a.d);a.b("applyBindings",a.Ub);a.b("applyBindingsToDescendants",a.hb);a.b("applyBindingAccessorsToNode",a.La);a.b("applyBindingsToNode",a.Ic);a.b("contextFor",a.nb);a.b("dataFor",a.Oc)})();(function(b){function c(c,e){var m=f.hasOwnProperty(c)?f[c]:b,k;m?m.Y(e):(m=f[c]=new a.K,m.Y(e),d(c,function(b,d){var e=!(!d||!d.synchronous);g[c]={definition:b,dd:e};delete f[c];k||e?m.notifySubscribers(b):a.Z.Za(function(){m.notifySubscribers(b)})}),k=!0)}function d(a,b){e("getConfig",[a],function(c){c?e("loadComponent",
[a,c],function(a){b(a,c)}):b(null,null)})}function e(c,d,f,k){k||(k=a.g.loaders.slice(0));var g=k.shift();if(g){var q=g[c];if(q){var p=!1;if(q.apply(g,d.concat(function(a){p?f(null):null!==a?f(a):e(c,d,f,k)}))!==b&&(p=!0,!g.suppressLoaderExceptions))throw Error("Component loaders must supply values by invoking the callback, not by returning values synchronously.");}else e(c,d,f,k)}else f(null)}var f={},g={};a.g={get:function(d,e){var f=g.hasOwnProperty(d)?g[d]:b;f?f.dd?a.l.w(function(){e(f.definition)}):
a.Z.Za(function(){e(f.definition)}):c(d,e)},$b:function(a){delete g[a]},Nb:e};a.g.loaders=[];a.b("components",a.g);a.b("components.get",a.g.get);a.b("components.clearCachedDefinition",a.g.$b)})();(function(){function b(b,c,d,e){function g(){0===--y&&e(h)}var h={},y=2,v=d.template;d=d.viewModel;v?f(c,v,function(c){a.g.Nb("loadTemplate",[b,c],function(a){h.template=a;g()})}):g();d?f(c,d,function(c){a.g.Nb("loadViewModel",[b,c],function(a){h[l]=a;g()})}):g()}function c(a,b,d){if("function"===typeof b)d(function(a){return new b(a)});
else if("function"===typeof b[l])d(b[l]);else if("instance"in b){var e=b.instance;d(function(){return e})}else"viewModel"in b?c(a,b.viewModel,d):a("Unknown viewModel value: "+b)}function d(b){switch(a.a.A(b)){case "script":return a.a.na(b.text);case "textarea":return a.a.na(b.value);case "template":if(e(b.content))return a.a.wa(b.content.childNodes)}return a.a.wa(b.childNodes)}function e(a){return x.DocumentFragment?a instanceof DocumentFragment:a&&11===a.nodeType}function f(a,b,c){"string"===typeof b.require?
O||x.require?(O||x.require)([b.require],c):a("Uses require, but no AMD loader is present"):c(b)}function g(a){return function(b){throw Error("Component '"+a+"': "+b);}}var h={};a.g.register=function(b,c){if(!c)throw Error("Invalid configuration for "+b);if(a.g.wb(b))throw Error("Component "+b+" is already registered");h[b]=c};a.g.wb=function(a){return h.hasOwnProperty(a)};a.g.ud=function(b){delete h[b];a.g.$b(b)};a.g.cc={getConfig:function(a,b){b(h.hasOwnProperty(a)?h[a]:null)},loadComponent:function(a,
c,d){var e=g(a);f(e,c,function(c){b(a,e,c,d)})},loadTemplate:function(b,c,f){b=g(b);if("string"===typeof c)f(a.a.na(c));else if(c instanceof Array)f(c);else if(e(c))f(a.a.W(c.childNodes));else if(c.element)if(c=c.element,x.HTMLElement?c instanceof HTMLElement:c&&c.tagName&&1===c.nodeType)f(d(c));else if("string"===typeof c){var l=t.getElementById(c);l?f(d(l)):b("Cannot find element with ID "+c)}else b("Unknown element type: "+c);else b("Unknown template value: "+c)},loadViewModel:function(a,b,d){c(g(a),
b,d)}};var l="createViewModel";a.b("components.register",a.g.register);a.b("components.isRegistered",a.g.wb);a.b("components.unregister",a.g.ud);a.b("components.defaultLoader",a.g.cc);a.g.loaders.push(a.g.cc);a.g.Ec=h})();(function(){function b(b,e){var f=b.getAttribute("params");if(f){var f=c.parseBindingsString(f,e,b,{valueAccessors:!0,bindingParams:!0}),f=a.a.Ea(f,function(c){return a.m(c,null,{i:b})}),g=a.a.Ea(f,function(c){var e=c.p();return c.ca()?a.m({read:function(){return a.a.c(c())},write:a.Da(e)&&
function(a){c()(a)},i:b}):e});g.hasOwnProperty("$raw")||(g.$raw=f);return g}return{$raw:{}}}a.g.getComponentNameForNode=function(b){var c=a.a.A(b);if(a.g.wb(c)&&(-1!=c.indexOf("-")||"[object HTMLUnknownElement]"==""+b||8>=a.a.C&&b.tagName===c))return c};a.g.Rb=function(c,e,f,g){if(1===e.nodeType){var h=a.g.getComponentNameForNode(e);if(h){c=c||{};if(c.component)throw Error('Cannot use the "component" binding on a custom element matching a component');var l={name:h,params:b(e,f)};c.component=g?function(){return l}:
l}}return c};var c=new a.S;9>a.a.C&&(a.g.register=function(a){return function(b){t.createElement(b);return a.apply(this,arguments)}}(a.g.register),t.createDocumentFragment=function(b){return function(){var c=b(),f=a.g.Ec,g;for(g in f)f.hasOwnProperty(g)&&c.createElement(g);return c}}(t.createDocumentFragment))})();(function(b){function c(b,c,d){c=c.template;if(!c)throw Error("Component '"+b+"' has no template");b=a.a.wa(c);a.f.fa(d,b)}function d(a,b,c,d){var e=a.createViewModel;return e?e.call(a,
d,{element:b,templateNodes:c}):d}var e=0;a.d.component={init:function(f,g,h,l,m){function k(){var a=r&&r.dispose;"function"===typeof a&&a.call(r);q=r=null}var r,q,p=a.a.W(a.f.childNodes(f));a.a.G.qa(f,k);a.m(function(){var l=a.a.c(g()),h,v;"string"===typeof l?h=l:(h=a.a.c(l.name),v=a.a.c(l.params));if(!h)throw Error("No component name specified");var n=q=++e;a.g.get(h,function(e){if(q===n){k();if(!e)throw Error("Unknown component '"+h+"'");c(h,e,f);var l=d(e,f,p,v);e=m.createChildContext(l,b,function(a){a.$component=
l;a.$componentTemplateNodes=p});r=l;a.hb(e,f)}})},null,{i:f});return{controlsDescendantBindings:!0}}};a.f.aa.component=!0})();var Q={"class":"className","for":"htmlFor"};a.d.attr={update:function(b,c){var d=a.a.c(c())||{};a.a.D(d,function(c,d){d=a.a.c(d);var g=!1===d||null===d||d===n;g&&b.removeAttribute(c);8>=a.a.C&&c in Q?(c=Q[c],g?b.removeAttribute(c):b[c]=d):g||b.setAttribute(c,d.toString());"name"===c&&a.a.vc(b,g?"":d.toString())})}};(function(){a.d.checked={after:["value","attr"],init:function(b,
c,d){function e(){var e=b.checked,f=p?g():e;if(!a.xa.Va()&&(!l||e)){var h=a.l.w(c);if(k){var m=r?h.p():h;q!==f?(e&&(a.a.ra(m,f,!0),a.a.ra(m,q,!1)),q=f):a.a.ra(m,f,e);r&&a.Da(h)&&h(m)}else a.h.Ga(h,d,"checked",f,!0)}}function f(){var d=a.a.c(c());b.checked=k?0<=a.a.o(d,g()):h?d:g()===d}var g=a.rc(function(){return d.has("checkedValue")?a.a.c(d.get("checkedValue")):d.has("value")?a.a.c(d.get("value")):b.value}),h="checkbox"==b.type,l="radio"==b.type;if(h||l){var m=c(),k=h&&a.a.c(m)instanceof Array,
r=!(k&&m.push&&m.splice),q=k?g():n,p=l||k;l&&!b.name&&a.d.uniqueName.init(b,function(){return!0});a.m(e,null,{i:b});a.a.q(b,"click",e);a.m(f,null,{i:b});m=n}}};a.h.ga.checked=!0;a.d.checkedValue={update:function(b,c){b.value=a.a.c(c())}}})();a.d.css={update:function(b,c){var d=a.a.c(c());null!==d&&"object"==typeof d?a.a.D(d,function(c,d){d=a.a.c(d);a.a.fb(b,c,d)}):(d=a.a.cb(String(d||"")),a.a.fb(b,b.__ko__cssValue,!1),b.__ko__cssValue=d,a.a.fb(b,d,!0))}};a.d.enable={update:function(b,c){var d=a.a.c(c());
d&&b.disabled?b.removeAttribute("disabled"):d||b.disabled||(b.disabled=!0)}};a.d.disable={update:function(b,c){a.d.enable.update(b,function(){return!a.a.c(c())})}};a.d.event={init:function(b,c,d,e,f){var g=c()||{};a.a.D(g,function(g){"string"==typeof g&&a.a.q(b,g,function(b){var m,k=c()[g];if(k){try{var r=a.a.W(arguments);e=f.$data;r.unshift(e);m=k.apply(e,r)}finally{!0!==m&&(b.preventDefault?b.preventDefault():b.returnValue=!1)}!1===d.get(g+"Bubble")&&(b.cancelBubble=!0,b.stopPropagation&&b.stopPropagation())}})})}};
a.d.foreach={mc:function(b){return function(){var c=b(),d=a.a.Bb(c);if(!d||"number"==typeof d.length)return{foreach:c,templateEngine:a.X.vb};a.a.c(c);return{foreach:d.data,as:d.as,includeDestroyed:d.includeDestroyed,afterAdd:d.afterAdd,beforeRemove:d.beforeRemove,afterRender:d.afterRender,beforeMove:d.beforeMove,afterMove:d.afterMove,templateEngine:a.X.vb}}},init:function(b,c){return a.d.template.init(b,a.d.foreach.mc(c))},update:function(b,c,d,e,f){return a.d.template.update(b,a.d.foreach.mc(c),
d,e,f)}};a.h.va.foreach=!1;a.f.aa.foreach=!0;a.d.hasfocus={init:function(b,c,d){function e(e){b.__ko_hasfocusUpdating=!0;var f=b.ownerDocument;if("activeElement"in f){var g;try{g=f.activeElement}catch(k){g=f.body}e=g===b}f=c();a.h.Ga(f,d,"hasfocus",e,!0);b.__ko_hasfocusLastValue=e;b.__ko_hasfocusUpdating=!1}var f=e.bind(null,!0),g=e.bind(null,!1);a.a.q(b,"focus",f);a.a.q(b,"focusin",f);a.a.q(b,"blur",g);a.a.q(b,"focusout",g)},update:function(b,c){var d=!!a.a.c(c());b.__ko_hasfocusUpdating||b.__ko_hasfocusLastValue===
d||(d?b.focus():b.blur(),!d&&b.__ko_hasfocusLastValue&&b.ownerDocument.body.focus(),a.l.w(a.a.Fa,null,[b,d?"focusin":"focusout"]))}};a.h.ga.hasfocus=!0;a.d.hasFocus=a.d.hasfocus;a.h.ga.hasFocus=!0;a.d.html={init:function(){return{controlsDescendantBindings:!0}},update:function(b,c){a.a.Eb(b,c())}};K("if");K("ifnot",!1,!0);K("with",!0,!1,function(a,c){return a.ac(c)});var L={};a.d.options={init:function(b){if("select"!==a.a.A(b))throw Error("options binding applies only to SELECT elements");for(;0<
b.length;)b.remove(0);return{controlsDescendantBindings:!0}},update:function(b,c,d){function e(){return a.a.Ma(b.options,function(a){return a.selected})}function f(a,b,c){var d=typeof b;return"function"==d?b(a):"string"==d?a[b]:c}function g(c,e){if(A&&k)a.j.ja(b,a.a.c(d.get("value")),!0);else if(p.length){var f=0<=a.a.o(p,a.j.u(e[0]));a.a.wc(e[0],f);A&&!f&&a.l.w(a.a.Fa,null,[b,"change"])}}var h=b.multiple,l=0!=b.length&&h?b.scrollTop:null,m=a.a.c(c()),k=d.get("valueAllowUnset")&&d.has("value"),r=
d.get("optionsIncludeDestroyed");c={};var q,p=[];k||(h?p=a.a.ib(e(),a.j.u):0<=b.selectedIndex&&p.push(a.j.u(b.options[b.selectedIndex])));m&&("undefined"==typeof m.length&&(m=[m]),q=a.a.Ma(m,function(b){return r||b===n||null===b||!a.a.c(b._destroy)}),d.has("optionsCaption")&&(m=a.a.c(d.get("optionsCaption")),null!==m&&m!==n&&q.unshift(L)));var A=!1;c.beforeRemove=function(a){b.removeChild(a)};m=g;d.has("optionsAfterRender")&&"function"==typeof d.get("optionsAfterRender")&&(m=function(b,c){g(0,c);
a.l.w(d.get("optionsAfterRender"),null,[c[0],b!==L?b:n])});a.a.Db(b,q,function(c,e,g){g.length&&(p=!k&&g[0].selected?[a.j.u(g[0])]:[],A=!0);e=b.ownerDocument.createElement("option");c===L?(a.a.bb(e,d.get("optionsCaption")),a.j.ja(e,n)):(g=f(c,d.get("optionsValue"),c),a.j.ja(e,a.a.c(g)),c=f(c,d.get("optionsText"),g),a.a.bb(e,c));return[e]},c,m);a.l.w(function(){k?a.j.ja(b,a.a.c(d.get("value")),!0):(h?p.length&&e().length<p.length:p.length&&0<=b.selectedIndex?a.j.u(b.options[b.selectedIndex])!==p[0]:
p.length||0<=b.selectedIndex)&&a.a.Fa(b,"change")});a.a.Sc(b);l&&20<Math.abs(l-b.scrollTop)&&(b.scrollTop=l)}};a.d.options.zb=a.a.e.J();a.d.selectedOptions={after:["options","foreach"],init:function(b,c,d){a.a.q(b,"change",function(){var e=c(),f=[];a.a.r(b.getElementsByTagName("option"),function(b){b.selected&&f.push(a.j.u(b))});a.h.Ga(e,d,"selectedOptions",f)})},update:function(b,c){if("select"!=a.a.A(b))throw Error("values binding applies only to SELECT elements");var d=a.a.c(c()),e=b.scrollTop;
d&&"number"==typeof d.length&&a.a.r(b.getElementsByTagName("option"),function(b){var c=0<=a.a.o(d,a.j.u(b));b.selected!=c&&a.a.wc(b,c)});b.scrollTop=e}};a.h.ga.selectedOptions=!0;a.d.style={update:function(b,c){var d=a.a.c(c()||{});a.a.D(d,function(c,d){d=a.a.c(d);if(null===d||d===n||!1===d)d="";b.style[c]=d})}};a.d.submit={init:function(b,c,d,e,f){if("function"!=typeof c())throw Error("The value for a submit binding must be a function");a.a.q(b,"submit",function(a){var d,e=c();try{d=e.call(f.$data,
b)}finally{!0!==d&&(a.preventDefault?a.preventDefault():a.returnValue=!1)}})}};a.d.text={init:function(){return{controlsDescendantBindings:!0}},update:function(b,c){a.a.bb(b,c())}};a.f.aa.text=!0;(function(){if(x&&x.navigator)var b=function(a){if(a)return parseFloat(a[1])},c=x.opera&&x.opera.version&&parseInt(x.opera.version()),d=x.navigator.userAgent,e=b(d.match(/^(?:(?!chrome).)*version\/([^ ]*) safari/i)),f=b(d.match(/Firefox\/([^ ]*)/));if(10>a.a.C)var g=a.a.e.J(),h=a.a.e.J(),l=function(b){var c=
this.activeElement;(c=c&&a.a.e.get(c,h))&&c(b)},m=function(b,c){var d=b.ownerDocument;a.a.e.get(d,g)||(a.a.e.set(d,g,!0),a.a.q(d,"selectionchange",l));a.a.e.set(b,h,c)};a.d.textInput={init:function(b,d,g){function l(c,d){a.a.q(b,c,d)}function h(){var c=a.a.c(d());if(null===c||c===n)c="";u!==n&&c===u?a.a.setTimeout(h,4):b.value!==c&&(s=c,b.value=c)}function y(){t||(u=b.value,t=a.a.setTimeout(v,4))}function v(){clearTimeout(t);u=t=n;var c=b.value;s!==c&&(s=c,a.h.Ga(d(),g,"textInput",c))}var s=b.value,
t,u,x=9==a.a.C?y:v;10>a.a.C?(l("propertychange",function(a){"value"===a.propertyName&&x(a)}),8==a.a.C&&(l("keyup",v),l("keydown",v)),8<=a.a.C&&(m(b,x),l("dragend",y))):(l("input",v),5>e&&"textarea"===a.a.A(b)?(l("keydown",y),l("paste",y),l("cut",y)):11>c?l("keydown",y):4>f&&(l("DOMAutoComplete",v),l("dragdrop",v),l("drop",v)));l("change",v);a.m(h,null,{i:b})}};a.h.ga.textInput=!0;a.d.textinput={preprocess:function(a,b,c){c("textInput",a)}}})();a.d.uniqueName={init:function(b,c){if(c()){var d="ko_unique_"+
++a.d.uniqueName.Nc;a.a.vc(b,d)}}};a.d.uniqueName.Nc=0;a.d.value={after:["options","foreach"],init:function(b,c,d){if("input"!=b.tagName.toLowerCase()||"checkbox"!=b.type&&"radio"!=b.type){var e=["change"],f=d.get("valueUpdate"),g=!1,h=null;f&&("string"==typeof f&&(f=[f]),a.a.ta(e,f),e=a.a.Wb(e));var l=function(){h=null;g=!1;var e=c(),f=a.j.u(b);a.h.Ga(e,d,"value",f)};!a.a.C||"input"!=b.tagName.toLowerCase()||"text"!=b.type||"off"==b.autocomplete||b.form&&"off"==b.form.autocomplete||-1!=a.a.o(e,"propertychange")||
(a.a.q(b,"propertychange",function(){g=!0}),a.a.q(b,"focus",function(){g=!1}),a.a.q(b,"blur",function(){g&&l()}));a.a.r(e,function(c){var d=l;a.a.sd(c,"after")&&(d=function(){h=a.j.u(b);a.a.setTimeout(l,0)},c=c.substring(5));a.a.q(b,c,d)});var m=function(){var e=a.a.c(c()),f=a.j.u(b);if(null!==h&&e===h)a.a.setTimeout(m,0);else if(e!==f)if("select"===a.a.A(b)){var g=d.get("valueAllowUnset"),f=function(){a.j.ja(b,e,g)};f();g||e===a.j.u(b)?a.a.setTimeout(f,0):a.l.w(a.a.Fa,null,[b,"change"])}else a.j.ja(b,
e)};a.m(m,null,{i:b})}else a.La(b,{checkedValue:c})},update:function(){}};a.h.ga.value=!0;a.d.visible={update:function(b,c){var d=a.a.c(c()),e="none"!=b.style.display;d&&!e?b.style.display="":!d&&e&&(b.style.display="none")}};(function(b){a.d[b]={init:function(c,d,e,f,g){return a.d.event.init.call(this,c,function(){var a={};a[b]=d();return a},e,f,g)}}})("click");a.P=function(){};a.P.prototype.renderTemplateSource=function(){throw Error("Override renderTemplateSource");};a.P.prototype.createJavaScriptEvaluatorBlock=
function(){throw Error("Override createJavaScriptEvaluatorBlock");};a.P.prototype.makeTemplateSource=function(b,c){if("string"==typeof b){c=c||t;var d=c.getElementById(b);if(!d)throw Error("Cannot find template with ID "+b);return new a.v.n(d)}if(1==b.nodeType||8==b.nodeType)return new a.v.sa(b);throw Error("Unknown template type: "+b);};a.P.prototype.renderTemplate=function(a,c,d,e){a=this.makeTemplateSource(a,e);return this.renderTemplateSource(a,c,d,e)};a.P.prototype.isTemplateRewritten=function(a,
c){return!1===this.allowTemplateRewriting?!0:this.makeTemplateSource(a,c).data("isRewritten")};a.P.prototype.rewriteTemplate=function(a,c,d){a=this.makeTemplateSource(a,d);c=c(a.text());a.text(c);a.data("isRewritten",!0)};a.b("templateEngine",a.P);a.Ib=function(){function b(b,c,d,h){b=a.h.Ab(b);for(var l=a.h.va,m=0;m<b.length;m++){var k=b[m].key;if(l.hasOwnProperty(k)){var r=l[k];if("function"===typeof r){if(k=r(b[m].value))throw Error(k);}else if(!r)throw Error("This template engine does not support the '"+
k+"' binding within its templates");}}d="ko.__tr_ambtns(function($context,$element){return(function(){return{ "+a.h.Xa(b,{valueAccessors:!0})+" } })()},'"+d.toLowerCase()+"')";return h.createJavaScriptEvaluatorBlock(d)+c}var c=/(<([a-z]+\d*)(?:\s+(?!data-bind\s*=\s*)[a-z0-9\-]+(?:=(?:\"[^\"]*\"|\'[^\']*\'|[^>]*))?)*\s+)data-bind\s*=\s*(["'])([\s\S]*?)\3/gi,d=/\x3c!--\s*ko\b\s*([\s\S]*?)\s*--\x3e/g;return{Tc:function(b,c,d){c.isTemplateRewritten(b,d)||c.rewriteTemplate(b,function(b){return a.Ib.jd(b,
c)},d)},jd:function(a,f){return a.replace(c,function(a,c,d,e,k){return b(k,c,d,f)}).replace(d,function(a,c){return b(c,"\x3c!-- ko --\x3e","#comment",f)})},Jc:function(b,c){return a.N.yb(function(d,h){var l=d.nextSibling;l&&l.nodeName.toLowerCase()===c&&a.La(l,b,h)})}}}();a.b("__tr_ambtns",a.Ib.Jc);(function(){a.v={};a.v.n=function(b){if(this.n=b){var c=a.a.A(b);this.eb="script"===c?1:"textarea"===c?2:"template"==c&&b.content&&11===b.content.nodeType?3:4}};a.v.n.prototype.text=function(){var b=1===
this.eb?"text":2===this.eb?"value":"innerHTML";if(0==arguments.length)return this.n[b];var c=arguments[0];"innerHTML"===b?a.a.Eb(this.n,c):this.n[b]=c};var b=a.a.e.J()+"_";a.v.n.prototype.data=function(c){if(1===arguments.length)return a.a.e.get(this.n,b+c);a.a.e.set(this.n,b+c,arguments[1])};var c=a.a.e.J();a.v.n.prototype.nodes=function(){var b=this.n;if(0==arguments.length)return(a.a.e.get(b,c)||{}).mb||(3===this.eb?b.content:4===this.eb?b:n);a.a.e.set(b,c,{mb:arguments[0]})};a.v.sa=function(a){this.n=
a};a.v.sa.prototype=new a.v.n;a.v.sa.prototype.text=function(){if(0==arguments.length){var b=a.a.e.get(this.n,c)||{};b.Jb===n&&b.mb&&(b.Jb=b.mb.innerHTML);return b.Jb}a.a.e.set(this.n,c,{Jb:arguments[0]})};a.b("templateSources",a.v);a.b("templateSources.domElement",a.v.n);a.b("templateSources.anonymousTemplate",a.v.sa)})();(function(){function b(b,c,d){var e;for(c=a.f.nextSibling(c);b&&(e=b)!==c;)b=a.f.nextSibling(e),d(e,b)}function c(c,d){if(c.length){var e=c[0],f=c[c.length-1],g=e.parentNode,h=
a.S.instance,n=h.preprocessNode;if(n){b(e,f,function(a,b){var c=a.previousSibling,d=n.call(h,a);d&&(a===e&&(e=d[0]||b),a===f&&(f=d[d.length-1]||c))});c.length=0;if(!e)return;e===f?c.push(e):(c.push(e,f),a.a.Ba(c,g))}b(e,f,function(b){1!==b.nodeType&&8!==b.nodeType||a.Ub(d,b)});b(e,f,function(b){1!==b.nodeType&&8!==b.nodeType||a.N.Cc(b,[d])});a.a.Ba(c,g)}}function d(a){return a.nodeType?a:0<a.length?a[0]:null}function e(b,e,f,h,q){q=q||{};var p=(b&&d(b)||f||{}).ownerDocument,n=q.templateEngine||g;
a.Ib.Tc(f,n,p);f=n.renderTemplate(f,h,q,p);if("number"!=typeof f.length||0<f.length&&"number"!=typeof f[0].nodeType)throw Error("Template engine must return an array of DOM nodes");p=!1;switch(e){case "replaceChildren":a.f.fa(b,f);p=!0;break;case "replaceNode":a.a.uc(b,f);p=!0;break;case "ignoreTargetNode":break;default:throw Error("Unknown renderMode: "+e);}p&&(c(f,h),q.afterRender&&a.l.w(q.afterRender,null,[f,h.$data]));return f}function f(b,c,d){return a.I(b)?b():"function"===typeof b?b(c,d):b}
var g;a.Fb=function(b){if(b!=n&&!(b instanceof a.P))throw Error("templateEngine must inherit from ko.templateEngine");g=b};a.Cb=function(b,c,k,h,q){k=k||{};if((k.templateEngine||g)==n)throw Error("Set a template engine before calling renderTemplate");q=q||"replaceChildren";if(h){var p=d(h);return a.B(function(){var g=c&&c instanceof a.R?c:new a.R(c,null,null,null,{exportDependencies:!0}),n=f(b,g.$data,g),g=e(h,q,n,g,k);"replaceNode"==q&&(h=g,p=d(h))},null,{ya:function(){return!p||!a.a.qb(p)},i:p&&
"replaceNode"==q?p.parentNode:p})}return a.N.yb(function(d){a.Cb(b,c,k,d,"replaceNode")})};a.pd=function(b,d,g,h,q){function p(a,b){c(b,t);g.afterRender&&g.afterRender(b,a);t=null}function s(a,c){t=q.createChildContext(a,g.as,function(a){a.$index=c});var d=f(b,a,t);return e(null,"ignoreTargetNode",d,t,g)}var t;return a.B(function(){var b=a.a.c(d)||[];"undefined"==typeof b.length&&(b=[b]);b=a.a.Ma(b,function(b){return g.includeDestroyed||b===n||null===b||!a.a.c(b._destroy)});a.l.w(a.a.Db,null,[h,b,
s,g,p])},null,{i:h})};var h=a.a.e.J();a.d.template={init:function(b,c){var d=a.a.c(c());if("string"==typeof d||d.name)a.f.za(b);else{if("nodes"in d){if(d=d.nodes||[],a.I(d))throw Error('The "nodes" option must be a plain, non-observable array.');}else d=a.f.childNodes(b);d=a.a.nc(d);(new a.v.sa(b)).nodes(d)}return{controlsDescendantBindings:!0}},update:function(b,c,d,e,f){var g=c();c=a.a.c(g);d=!0;e=null;"string"==typeof c?c={}:(g=c.name,"if"in c&&(d=a.a.c(c["if"])),d&&"ifnot"in c&&(d=!a.a.c(c.ifnot)));
"foreach"in c?e=a.pd(g||b,d&&c.foreach||[],c,b,f):d?(f="data"in c?f.ac(c.data,c.as):f,e=a.Cb(g||b,f,c,b)):a.f.za(b);f=e;(c=a.a.e.get(b,h))&&"function"==typeof c.k&&c.k();a.a.e.set(b,h,f&&f.ca()?f:n)}};a.h.va.template=function(b){b=a.h.Ab(b);return 1==b.length&&b[0].unknown||a.h.fd(b,"name")?null:"This template engine does not support anonymous templates nested within its templates"};a.f.aa.template=!0})();a.b("setTemplateEngine",a.Fb);a.b("renderTemplate",a.Cb);a.a.hc=function(a,c,d){if(a.length&&
c.length){var e,f,g,h,l;for(e=f=0;(!d||e<d)&&(h=a[f]);++f){for(g=0;l=c[g];++g)if(h.value===l.value){h.moved=l.index;l.moved=h.index;c.splice(g,1);e=g=0;break}e+=g}}};a.a.lb=function(){function b(b,d,e,f,g){var h=Math.min,l=Math.max,m=[],k,n=b.length,q,p=d.length,s=p-n||1,t=n+p+1,v,u,x;for(k=0;k<=n;k++)for(u=v,m.push(v=[]),x=h(p,k+s),q=l(0,k-1);q<=x;q++)v[q]=q?k?b[k-1]===d[q-1]?u[q-1]:h(u[q]||t,v[q-1]||t)+1:q+1:k+1;h=[];l=[];s=[];k=n;for(q=p;k||q;)p=m[k][q]-1,q&&p===m[k][q-1]?l.push(h[h.length]={status:e,
value:d[--q],index:q}):k&&p===m[k-1][q]?s.push(h[h.length]={status:f,value:b[--k],index:k}):(--q,--k,g.sparse||h.push({status:"retained",value:d[q]}));a.a.hc(s,l,!g.dontLimitMoves&&10*n);return h.reverse()}return function(a,d,e){e="boolean"===typeof e?{dontLimitMoves:e}:e||{};a=a||[];d=d||[];return a.length<d.length?b(a,d,"added","deleted",e):b(d,a,"deleted","added",e)}}();a.b("utils.compareArrays",a.a.lb);(function(){function b(b,c,d,h,l){var m=[],k=a.B(function(){var k=c(d,l,a.a.Ba(m,b))||[];0<
m.length&&(a.a.uc(m,k),h&&a.l.w(h,null,[d,k,l]));m.length=0;a.a.ta(m,k)},null,{i:b,ya:function(){return!a.a.Tb(m)}});return{ea:m,B:k.ca()?k:n}}var c=a.a.e.J(),d=a.a.e.J();a.a.Db=function(e,f,g,h,l){function m(b,c){w=q[c];u!==c&&(D[b]=w);w.tb(u++);a.a.Ba(w.ea,e);t.push(w);z.push(w)}function k(b,c){if(b)for(var d=0,e=c.length;d<e;d++)c[d]&&a.a.r(c[d].ea,function(a){b(a,d,c[d].ka)})}f=f||[];h=h||{};var r=a.a.e.get(e,c)===n,q=a.a.e.get(e,c)||[],p=a.a.ib(q,function(a){return a.ka}),s=a.a.lb(p,f,h.dontLimitMoves),
t=[],v=0,u=0,x=[],z=[];f=[];for(var D=[],p=[],w,C=0,B,E;B=s[C];C++)switch(E=B.moved,B.status){case "deleted":E===n&&(w=q[v],w.B&&(w.B.k(),w.B=n),a.a.Ba(w.ea,e).length&&(h.beforeRemove&&(t.push(w),z.push(w),w.ka===d?w=null:f[C]=w),w&&x.push.apply(x,w.ea)));v++;break;case "retained":m(C,v++);break;case "added":E!==n?m(C,E):(w={ka:B.value,tb:a.O(u++)},t.push(w),z.push(w),r||(p[C]=w))}a.a.e.set(e,c,t);k(h.beforeMove,D);a.a.r(x,h.beforeRemove?a.ba:a.removeNode);for(var C=0,r=a.f.firstChild(e),F;w=z[C];C++){w.ea||
a.a.extend(w,b(e,g,w.ka,l,w.tb));for(v=0;s=w.ea[v];r=s.nextSibling,F=s,v++)s!==r&&a.f.kc(e,s,F);!w.ad&&l&&(l(w.ka,w.ea,w.tb),w.ad=!0)}k(h.beforeRemove,f);for(C=0;C<f.length;++C)f[C]&&(f[C].ka=d);k(h.afterMove,D);k(h.afterAdd,p)}})();a.b("utils.setDomNodeChildrenFromArrayMapping",a.a.Db);a.X=function(){this.allowTemplateRewriting=!1};a.X.prototype=new a.P;a.X.prototype.renderTemplateSource=function(b,c,d,e){if(c=(9>a.a.C?0:b.nodes)?b.nodes():null)return a.a.W(c.cloneNode(!0).childNodes);b=b.text();
return a.a.na(b,e)};a.X.vb=new a.X;a.Fb(a.X.vb);a.b("nativeTemplateEngine",a.X);(function(){a.xb=function(){var a=this.ed=function(){if(!u||!u.tmpl)return 0;try{if(0<=u.tmpl.tag.tmpl.open.toString().indexOf("__"))return 2}catch(a){}return 1}();this.renderTemplateSource=function(b,e,f,g){g=g||t;f=f||{};if(2>a)throw Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");var h=b.data("precompiled");h||(h=b.text()||"",h=u.template(null,"{{ko_with $item.koBindingContext}}"+
h+"{{/ko_with}}"),b.data("precompiled",h));b=[e.$data];e=u.extend({koBindingContext:e},f.templateOptions);e=u.tmpl(h,b,e);e.appendTo(g.createElement("div"));u.fragments={};return e};this.createJavaScriptEvaluatorBlock=function(a){return"{{ko_code ((function() { return "+a+" })()) }}"};this.addTemplate=function(a,b){t.write("<script type='text/html' id='"+a+"'>"+b+"\x3c/script>")};0<a&&(u.tmpl.tag.ko_code={open:"__.push($1 || '');"},u.tmpl.tag.ko_with={open:"with($1) {",close:"} "})};a.xb.prototype=
new a.P;var b=new a.xb;0<b.ed&&a.Fb(b);a.b("jqueryTmplTemplateEngine",a.xb)})()})})();})();
window.Knockout = ko;
});
Numbas.queueScript('localisation',['i18next','localisation-resources'],function() {
    i18next.init({
        lng: Numbas.locale.preferred_locale,
        lowerCaseLng: true,
        keySeparator: false,
        nsSeparator: false,
        interpolation: {
            unescapePrefix: '-',
            format: function(value,format) {
                if(format=='niceNumber') {
                    return Numbas.math.niceNumber(value);
                }
            }
        },
        resources: Numbas.locale.resources
    });
    window.R = function(){{ return i18next.t.apply(i18next,arguments) }};
});
Numbas.queueScript('marking',['jme','localisation','jme-variables'],function() {
    /** @namespace Numbas.marking */
    var marking = Numbas.marking = {};

    var jme = Numbas.jme;
    var math = Numbas.math;
    var TNothing = jme.types.TNothing;
    var TString = jme.types.TString;
    var TList = jme.types.TList;
    var TName = jme.types.TName;
    var TNum = jme.types.TNum;
    var TBool = jme.types.TBool;
    var TDict = jme.types.TDict;

    /** A line of feedback to give to the student, produced while marking their answer.
     * Can modify the credit awarded.
     *
     * @typedef {Object} Numbas.marking.feedback_item
     *
     * @property {String} op - The operation to perform. See {@link Numbas.marking.FeedbackOps}
     * @property {Number} [credit] - Parameter to change the credit awarded. The exact meaning depends on `op`.
     * @property {String} [reason] - An extra note about why the op is being applied. For 'correct' and 'incorrect' feedback, this helps distinguish cases when the credit awarded doesn't change. 'invalid' means the answer could not be marked.
     * @property {String} [message] - A message to display to the student.
     */

    /** Kinds of feedback item
     * @readonly
     * @enum {String}
     * @memberof Numbas.marking
     */
    var FeedbackOps = Numbas.marking.FeedbackOps = {
        /** Set the credit to the given value */
        SET_CREDIT: 'set_credit',

        /** Add the given amount of credit */
        ADD_CREDIT: 'add_credit',

        /** Multiply the current credit by the given amount */
        MULTIPLY_CREDIT: 'multiply_credit',

        /** Subtract the given amount of credit */
        SUB_CREDIT: 'sub_credit',

        /** End marking */
        END: 'end',

        /** Give the student a warning next to the answer widget */
        WARNING: 'warning',

        /** Give the student a message */
        FEEDBACK: 'feedback',

        /** Add the given list of items to the end of the current list of feedback items */
        CONCAT: 'concat'
    }

    var feedback = Numbas.marking.feedback = {
        set_credit: function(credit,reason,message) {
            return {op: FeedbackOps.SET_CREDIT, credit: credit, reason: reason, message: message}
        },
        add_credit: function(credit,message) {
            return {op: FeedbackOps.ADD_CREDIT, credit: credit, message: message};
        },
        sub_credit: function(credit,message) {
            return {op: FeedbackOps.SUB_CREDIT, credit: credit, message: message};
        },
        multiply_credit: function(factor,message) {
            return {op: FeedbackOps.MULTIPLY_CREDIT, factor: factor, message: message}
        },
        end: function(invalid) {
            return {op: FeedbackOps.END, invalid: invalid || false}
        },
        warning: function(message) {
            return {op: FeedbackOps.WARNING, message: message}
        },
        feedback: function(message) {
            return {op: FeedbackOps.FEEDBACK, message: message}
        },
        concat: function(messages, scale) {
            return {op: FeedbackOps.CONCAT, messages: messages, scale: scale};
        }
    }

    function state_fn(name, args, outtype, fn) {
        return new jme.funcObj(name,args,outtype,null,{
            evaluate: function(args, scope) {
                if(jme.lazyOps.contains(name)) {
                    var res = fn.apply(this, arguments);
                } else {
                    var res = fn.apply(this, args.map(jme.unwrapValue));
                }
                var p = scope;
                while(p.state===undefined) {
                    p = p.parent;
                }
                p.state = p.state.concat(res.state);
                return jme.wrapValue(res.return);
            }
        });
    }

    var state_functions = [];
    state_functions.push(state_fn('correct',[],TBool,function(message) {
        return {
            return: true,
            state: [feedback.set_credit(1, 'correct', R('part.marking.correct'))]
        };
    }));
    state_functions.push(state_fn('correct',[TString],TBool,function(message) {
        return {
            return: true,
            state: [feedback.set_credit(1, 'correct', message)]
        };
    }));
    state_functions.push(state_fn('incorrect',[],TBool,function(message) {
        return {
            return: false,
            state: [feedback.set_credit(0, 'incorrect', R('part.marking.incorrect'))]
        };
    }));
    state_functions.push(state_fn('incorrect',[TString],TBool,function(message) {
        return {
            return: false,
            state: [feedback.set_credit(0, 'incorrect', message)]
        };
    }));
    correctif = function(condition,correctMessage,incorrectMessage) {
        var state;
        if(condition) {
            state = feedback.set_credit(1, 'correct', correctMessage || R('part.marking.correct'));
        } else {
            state = feedback.set_credit(0, 'incorrect', incorrectMessage || R('part.marking.incorrect'));
        }
        return {
            return: condition,
            state: [state]
        };
    }
    state_functions.push(state_fn('correctif',[TBool],TBool,correctif));
    state_functions.push(state_fn('correctif',[TBool,TString,TString],TBool,correctif));
    state_functions.push(state_fn('set_credit',[TNum,TString],TNum,function(n, message) {
        return {
            return: n,
            state: [feedback.set_credit(n, undefined, message)]
        }
    }));
    state_functions.push(state_fn('multiply_credit',[TNum,TString],TNum,function(n, message) {
        return {
            return: n,
            state: [feedback.multiply_credit(n, message)]
        }
    }));
    state_functions.push(state_fn('add_credit',[TNum,TString],TNum,function(n, message) {
        return {
            return: n,
            state: [feedback.add_credit(n, message)]
        }
    }));
    state_functions.push(state_fn('sub_credit',[TNum,TString],TNum,function(n, message) {
        return {
            return: n,
            state: [feedback.sub_credit(n, message)]
        }
    }));
    state_functions.push(state_fn('end',[],TBool,function() {
        return {
            return: true,
            state: [feedback.end()]
        }
    }));
    state_functions.push(state_fn('fail',[TString],TString,function(message) {
        return {
            return: message,
            state: [
                feedback.set_credit(0, 'invalid', message),
                feedback.end(true)
            ]
        };
    }));
    state_functions.push(state_fn('warn',[TString],TString,function(message) {
        return {
            return: message,
            state: [feedback.warning(message)]
        }
    }));
    state_functions.push(state_fn('feedback',[TString],TString,function(message) {
        return {
            return: message,
            state: [feedback.feedback(message)]
        }
    }));
    state_functions.push(new jme.funcObj(';',['?','?'],'?',null, {
        evaluate: function(args,cope) {
            return args[1];
        }
    }));
    state_functions.push(state_fn('apply',[TName],TName,function(args,scope) {
        if(args[0].tok.type=='name') {
            var name = args[0].tok.name.toLowerCase();
            var p = scope;
            while(p && p.state===undefined) {
                p = p.parent;
            }
            var state = p.states[name];
            return {
                return: new TNothing(),
                state: state || []
            };
        } else {
            var feedback = scope.evaluate(args[0]);
            if(feedback.type!='list') {
                throw(new Numbas.Error('marking.apply.not a list'));
            }
            return {
                return: feedback,
                state: jme.unwrapValue(feedback)
            }
        }
    }));
    jme.lazyOps.push('apply');
    jme.substituteTreeOps.apply = function(tree,scope,allowUnbound) {
        return tree;
    }

    function submit_part(part,answer) {
        var originalAnswer = part.stagedAnswer;
        if(answer!==undefined) {
            part.stagedAnswer = answer;
        }
        part.submit();
        part.stagedAnswer = originalAnswer;
        part.setStudentAnswer();
        return jme.wrapValue({
            credit: part.credit,
            marks: part.marks,
            feedback: part.finalised_result.states,
            answered: part.answered
        });
    }

    state_functions.push(new jme.funcObj('submit_part',[TString],TDict,null,{
        evaluate: function(args, scope) {
            var part = scope.question.getPart(args[0].value);
            return submit_part(part);
        }
    }));
    state_functions.push(new jme.funcObj('submit_part',[TString,'?'],TDict,null,{
        evaluate: function(args, scope) {
            var part = scope.question.getPart(args[0].value);
            var answer = jme.unwrapValue(args[1]);
            return submit_part(part,answer);
        }
    }));

    state_functions.push(new jme.funcObj('apply_marking_script',[TString,'?',TDict,TNum],TDict,null,{
        evaluate: function(args, scope) {
            var script_name = args[0].value;
            var script = Numbas.marking_scripts[script_name];
            if(!script) {
                throw(new Numbas.Error('marking.apply marking script.script not found',{name: script_name}));
            }
            var nscope = new StatefulScope([scope]);
            for(var x in scope.states) {
                nscope.deleteVariable(x);
            }
            var result = script.evaluate(
                nscope,
                {
                    studentAnswer: args[1],
                    settings: args[2],
                    marks: args[3]
                }
            );
            if(result.state_errors.mark) {
                throw(result.state_errors.mark);
            }
            var notes = {};
            Object.keys(result.states).forEach(function(name) {
                notes[name] = {
                    feedback: result.states[name],
                    value: result.values[name],
                    valid: result.state_valid[name]
                }
            });
            return jme.wrapValue(notes);
        }
    }));
    state_functions.push(new jme.funcObj('mark_part',[TString,'?'],TDict,null,{
        evaluate: function(args, scope) {
            var part = scope.question.getPart(args[0].value);
            var answer = args[1];
            var part_result;
            if(answer.type=='nothing') {
                part.setCredit(0,R('part.marking.nothing entered'));
                part_result = {
                    states: {mark: []},
                    state_valid: {},
                    state_errors: {},
                    values: {interpreted_answer:answer}
                }
            } else {
                var part_result = part.mark_answer(answer,scope);
            }
            var result = marking.finalise_state(part_result.states.mark);
            return jme.wrapValue({
                marks: part.marks,
                credit: result.credit,
                feedback: result.states,
                valid: result.valid,
                states: part_result.states,
                state_valid: part_result.state_valid,
                values: part_result.values
            });
        }
    }));
    state_functions.push(state_fn('concat_feedback',[TList,TNum],TList,function(messages, scale) {
        return {
            return: messages,
            state: [feedback.concat(messages, scale)]
        }
    }));


    /** A JME scope with marking state attached.
     *  The "current" state is a list of feedback items. 
     *  The scope can also refer to previously computed states by name.
     *  The state can be modified by functions as they are called.
     *  This should be the base 
     *
     *  @memberof Numbas.marking
     *  @augments Numbas.jme.Scope
     *  @constructor
     *  @property {Numbas.marking.feedback_item[]} state
     *  @property {Object.<Numbas.marking.feedback_item[]>} states - Previously computed states
     *  @property {Object.<Boolean>} state_valid - Record of whether previously computed states were valid
     *  @property {Object.<Error>} state_errors - The errors that caused states to become invalid, if any.
     */
    var StatefulScope = marking.StatefulScope = function() {
        this.nesting_depth = 0;
        this.state = [];
        this.states = {};
        this.state_valid = {};
        this.state_errors = {};
        var scope = this;
        state_functions.forEach(function(fn) {
            scope.addFunction(fn);
        });
    }
    StatefulScope.prototype = /** @lends Numbas.marking.StatefulScope.prototype */ { 
        evaluate: function(expr, variables) {
            var is_top = this.state===undefined || this.nesting_depth==0;
            this.nesting_depth += 1;
            var old_state = is_top ? [] : (this.state || []);
            this.state = [];
            try {
                var v = jme.Scope.prototype.evaluate.apply(this,[expr, variables]);
            } catch(e) {
                this.nesting_depth -= 1;
                throw(e);
            }
            this.nesting_depth -= 1;
            this.state = old_state.concat(this.state);
            return v;
        }
    }
    StatefulScope = marking.StatefulScope = Numbas.util.extend(jme.Scope,StatefulScope);

    var re_note = /^(\$?[a-zA-Z_][a-zA-Z0-9_]*'*)(?:\s*\(([^)]*)\))?\s*:\s*((?:.|\n)*)$/m;


    /** A definition of a marking note.
     *
     *  The note's name, followed by an optional description enclosed in parentheses, then a colon, and finally a {@link JME} expression to evaluate.
     *
     * @typedef {String} Numbas.marking.note_definition
     */

    /** A note forming part of a marking script.
     *  Evaluates to a JME value and a list of feedback items.
     *
     *  @memberof Numbas.marking
     *  @constructor
     *
     *  @property {String} name
     *  @property {String} description
     *  @property {Numbas.marking.note_definition} expr - The JME expression to evaluate to compute this note.
     *  @property {Numbas.jme.tree} tree - The compiled form of the expression
     *  @property {String[]} vars - The names of the variables this note depends on
     *  
     *  @param {JME} source
     */
    var MarkingNote = marking.MarkingNote = function(source) {
        source = source.trim();
        var m = re_note.exec(source);
        if(!m) {
            var hint;
            if(/^[a-zA-Z_][a-zA-Z0-9+]*'*(?:\s*\(([^)]*)\))?$/.test(source)) {
                hint = R('marking.note.invalid definition.missing colon');
            } else if(/^[a-zA-Z_][a-zA-Z0-9+]*'*\s*\(/.test(source)) {
                hint = R('marking.note.invalid definition.description missing closing bracket');
            }
            throw(new Numbas.Error("marking.note.invalid definition",{source: source, hint: hint}));
        }
        this.name = m[1];
        this.description = m[2];
        this.expr = m[3];
        if(!this.expr) {
            throw(new Numbas.Error("marking.note.empty expression",{name:this.name}));
        }
        try {
            this.tree = jme.compile(this.expr);
        } catch(e) {
            throw(new Numbas.Error("marking.note.compilation error",{name:this.name, message:e.message}));
        }
        this.vars = jme.findvars(this.tree);
    }

    /** The result of a marking script.
     *
     * @typedef {Object} Numbas.marking.marking_script_result
     *
     * @property {Object.<Numbas.marking.feedback_item[]>} states - the feedback resulting from each of the notes
     * @property {Object.<Numbas.jme.token>} values - the values of each of the notes
     * @property {Object.<Boolean>} state_valid - See {@link Numbas.marking.StatefulScope#state_valid}
     * @property {Object.<Error>} state_errors - See {@link Numbas.marking.StatefulScope#state_errors}
     */

    /** A script to mark a part.
     *  A list of notes, which can refer to each other. The dependencies must form a directed acyclic graph, like for JME variables.
     *
     *  Two notes are required:
     *  
     *  * The `mark` note is the final note, used to provide feedback on the part.
     *  * The value of the `interpreted_answer` note is used to represent the student's answer, as the script interpreted it.
     *  
     *  @memberof Numbas.marking
     *  @constructor
     *  
     *  @param {String} source - The definitions of the script's notes.
     *  @param {Numbas.marking.MarkingScript} [base] - a base script to extend.
     *
     *  @property {Numbas.marking.MarkingNote[]} notes
     */
    var MarkingScript = marking.MarkingScript = function(source, base) {
        this.source = source;
        try {
            var notes = source.split(/\n(\s*\n)+/);
            var ntodo = {};
            var todo = {};
            notes.forEach(function(note) {
                if(note.trim().length) {
                    var res = new MarkingNote(note);
                    var name = res.name.toLowerCase();
                    ntodo[name] = todo[name] = res;
                }
            });
            if(base) {
                Object.keys(base.notes).forEach(function(name) {
                    if(name in ntodo) {
                        todo['base_'+name] = base.notes[name];
                    } else {
                        todo[name] = base.notes[name];
                    }
                });
            }
        } catch(e) {
            throw(new Numbas.Error("marking.script.error parsing notes",{message:e.message}));
        }
        this.notes = todo;
    }
    MarkingScript.prototype = /** @lends Numbas.marking.MarkingScript.prototype */ {

        /** The source code of the script
         * @type {String}
         */
        source: '',

        /** Evaluate all of this script's notes in the given scope.
         *
         * @param {Numbas.jme.Scope} scope
         * @param {Object.<Numbas.jme.token>} - Extra variables defined in the scope
         *
         * @returns {Numbas.marking.marking_script_result}
         */
        evaluate: function(scope, variables) {
            scope = new jme.Scope([scope]);

            // if any names used by notes are already defined as variables in this scope, delete them
            Object.keys(this.notes).forEach(function(name) {
                scope.deleteVariable(name);
            });

            scope = new StatefulScope([
                scope, {variables: variables}
            ]);

            var result = jme.variables.makeVariables(this.notes,scope,null,compute_note);
            return {
                states: scope.states,
                values: result.variables,
                state_valid: scope.state_valid,
                state_errors: scope.state_errors
            };
        }
    }

    /** Compute the marking note with the given name in the given scope
     *
     * @memberof Numbas.marking
     * @function
     * @see Numbas.jme.variables.computeVariable
     *
     * @param {String} name
     * @param {Object} todo - dictionary of notes still to evaluate
     * @param {Numbas.marking.StatefulScope} scope
     *
     * @returns {Numbas.jme.token}
     */
    var compute_note = marking.compute_note = function(name,todo,scope) {
        if(scope.getVariable(name)) {
            return;
        }
        if(!scope.states[name]) {
            try {
                var res = jme.variables.computeVariable.apply(this,arguments);
                scope.setVariable(name, res);
                scope.state_valid[name] = true;
                for(var i=0;i<scope.state.length;i++) {
                    if(scope.state[i].op=='end' && scope.state[i].invalid) {
                        scope.state_valid[name] = false;
                        break;
                    }
                }
            } catch(e) {
                scope.state_errors[name] = e;
                var invalid_dep = null;
                for(var i=0;i<todo[name].vars.length;i++) {
                    var x = todo[name].vars[i];
                    if(x in todo) {
                        if(!scope.state_valid[x]) {
                            invalid_dep = x;
                            break;
                        }
                    }
                }
                if(invalid_dep || Numbas.marking.ignore_note_errors) {
                    scope.state_valid[name] = false;
                } else {
                    throw(new Numbas.Error("marking.note.error evaluating note",{name:name, message:e.message}));
                }
            }
            scope.states[name] = scope.state.slice().map(function(s){s.note = s.note || name; return s});
        }
        return scope.variables[name];
    }
    /** The result of attempting to mark a part.
     * @typedef Numbas.marking.finalised_state
     * @type {Object}
     * @property {Boolean} valid - Can the answer be marked?
     * @property {Number} credit - Proportion of the credit to award
     * @property {Array.<Object>} states - Feedback actions
     */

    /** Run through a sequence of state operations, accumulating credit.
     * It might look like this is duplicated in `Numbas.parts.Part#apply_feedback`, but we need to be able to get a description of what a sequence of operations does in abstract so it can be reused in marking scripts for parent parts.
     * @see Numbas.parts.Part#apply_feedback
     * @function
     * @memberof Numbas.marking
     * @param {Numbas.marking.feedback_item[]} states
     * @returns {Numbas.marking.finalised_state}
     */
    var finalise_state = marking.finalise_state = function(states) {
        var valid = true;
        var end = false;
        var credit = 0;
        var out_states = [];
        var num_lifts = 0;
        for(var i=0;i<states.length;i++) {
            var state = states[i];
            switch(state.op) {
                case FeedbackOps.SET_CREDIT:
                    out_states.push(state);
                    credit = state.credit;
                    break;
                case FeedbackOps.MULTIPLY_CREDIT:
                    out_states.push(state);
                    credit *= state.factor;
                    break;
                case FeedbackOps.ADD_CREDIT:
                    out_states.push(state);
                    credit += state.credit;
                    break;
                case FeedbackOps.SUB_CREDIT:
                    out_states.push(state);
                    credit -= state.credit;
                    break;
                case FeedbackOps.END:
                    if(num_lifts) {
                        while(i+1<states.length && states[i+1].op!="end_lift") {
                            i += 1;
                        }
                    } else {
                        end = true;
                        if(state.invalid) {
                            valid = false;
                        }
                    }
                    break;
                case FeedbackOps.CONCAT:
                    states = states.slice(0,i+1).concat(
                        [{op:"start_lift",scale:state.scale}],
                        state.messages,
                        [{op:"end_lift"}],
                        states.slice(i+1)
                    );
                    break;
                case "start_lift":
                    num_lifts += 1;
                    out_states.push(state);
                    break;
                case "end_lift":
                    num_lifts -= 1;
                    out_states.push(state);
                    break;
                default:
                    out_states.push(state);
            }
            if(end) {
                break;
            }
        }
        return {
            valid: valid,
            credit: credit,
            states: out_states
        }
    }
});

/*
Copyright 2011-14 Newcastle University
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/** @file Mathematical functions, providing stuff that the built-in `Math` object doesn't, as well as vector and matrix math operations.
 *
 * Provides {@link Numbas.math}, {@link Numbas.vectormath} and {@link Numbas.matrixmath}
 */
Numbas.queueScript('math',['base'],function() {
/** Mathematical functions, providing stuff that the built-in `Math` object doesn't
 * @namespace Numbas.math */
/** A complex number.
 * @typedef complex
 * @property {Number} re
 * @property {Number} im
 */
/** @typedef range
 * @desc A range of numbers, separated by a constant interval and between fixed lower and upper bounds.
 * @type {Array.<Number>}
 * @property {Number} 0 Minimum value
 * @property {Number} 1 Maximum value
 * @property {Number} 2 Step size
 * @see Numbas.math.defineRange
 */
var math = Numbas.math = /** @lends Numbas.math */ {
    /** Regex to match numbers in scientific notation */
    re_scientificNumber: /(\-?(?:0|[1-9]\d*)(?:\.\d+)?)[eE]([\+\-]?\d+)/,
    /** Construct a complex number from real and imaginary parts.
     *
     * Elsewhere in this documentation, `{Number}` will refer to either a JavaScript float or a {@link complex} object, interchangeably.
     * @param {Number} re
     * @param {Number} im
     * @returns {complex}
     */
    complex: function(re,im)
    {
        if(!im)
            return re;
        else
            return {re: re, im: im, complex: true,
            toString: math.complexToString}
    },
    /** String version of a complex number
     * @returns {String}
     * @method
     * @memberof! complex
     */
    complexToString: function()
    {
        return math.niceNumber(this);
    },
    /** Negate a number.
     * @param {Number} n
     * @returns {Number}
     */
    negate: function(n)
    {
        if(n.complex)
            return math.complex(-n.re,-n.im);
        else
            return -n;
    },
    /** Complex conjugate
     * @param {Number} n
     * @returns {Number}
     */
    conjugate: function(n)
    {
        if(n.complex)
            return math.complex(n.re,-n.im);
        else
            return n;
    },
    /** Add two numbers
     * @param {Number} a
     * @param {Number} b
     * @returns {Number}
     */
    add: function(a,b)
    {
        if(a.complex)
        {
            if(b.complex)
                return math.complex(a.re+b.re, a.im + b.im);
            else
                return math.complex(a.re+b, a.im);
        }
        else
        {
            if(b.complex)
                return math.complex(a + b.re, b.im);
            else
                return a+b;
        }
    },
    /** Subtract one number from another
     * @param {Number} a
     * @param {Number} b
     * @returns {Number}
     */
    sub: function(a,b)
    {
        if(a.complex)
        {
            if(b.complex)
                return math.complex(a.re-b.re, a.im - b.im);
            else
                return math.complex(a.re-b, a.im);
        }
        else
        {
            if(b.complex)
                return math.complex(a - b.re, -b.im);
            else
                return a-b;
        }
    },
    /** Multiply two numbers
     * @param {Number} a
     * @param {Number} b
     * @returns {Number}
     */
    mul: function(a,b)
    {
        if(a.complex)
        {
            if(b.complex)
                return math.complex(a.re*b.re - a.im*b.im, a.re*b.im + a.im*b.re);
            else
                return math.complex(a.re*b, a.im*b);
        }
        else
        {
            if(b.complex)
                return math.complex(a*b.re, a*b.im);
            else
                return a*b;
        }
    },
    /** Divide one number by another
     * @param {Number} a
     * @param {Number} b
     * @returns {Number}
     */
    div: function(a,b)
    {
        if(a.complex)
        {
            if(b.complex)
            {
                var q = b.re*b.re + b.im*b.im;
                return math.complex((a.re*b.re + a.im*b.im)/q, (a.im*b.re - a.re*b.im)/q);
            }
            else
                return math.complex(a.re/b, a.im/b);
        }
        else
        {
            if(b.complex)
            {
                var q = b.re*b.re + b.im*b.im;
                return math.complex(a*b.re/q, -a*b.im/q);
            }
            else
                return a/b;
        }
    },
    /** Exponentiate a number
     * @param {Number} a
     * @param {Number} b
     * @returns {Number}
     */
    pow: function(a,b)
    {
        if(a.complex && Numbas.util.isInt(b) && Math.abs(b)<100)
        {
            if(b<0)
                return math.div(1,math.pow(a,-b));
            if(b==0)
                return 1;
            var coeffs = math.binomialCoefficients(b);
            var re = 0;
            var im = 0;
            var sign = 1;
            for(var i=0;i<b;i+=2) {
                re += coeffs[i]*Math.pow(a.re,b-i)*Math.pow(a.im,i)*sign;
                im += coeffs[i+1]*Math.pow(a.re,b-i-1)*Math.pow(a.im,i+1)*sign;
                sign = -sign;
            }
            if(b%2==0)
                re += Math.pow(a.im,b)*sign;
            return math.complex(re,im);
        }
        if(a.complex || b.complex || (a<0 && math.fract(b)!=0))
        {
            if(!a.complex)
                a = {re: a, im: 0, complex: true};
            if(!b.complex)
                b = {re: b, im: 0, complex: true};
            var ss = a.re*a.re + a.im*a.im;
            var arg1 = math.arg(a);
            var mag = Math.pow(ss,b.re/2) * Math.exp(-b.im*arg1);
            var arg = b.re*arg1 + (b.im * Math.log(ss))/2;
            return math.complex(mag*Math.cos(arg), mag*Math.sin(arg));
        }
        else
        {
            return Math.pow(a,b);
        }
    },
    /** Calculate the Nth row of Pascal's triangle
     * @param {Number} n
     * @returns {Array.<Number>}
     */
    binomialCoefficients: function(n) {
        var b = [1];
        var f = 1;
        for(var i=1;i<=n;i++) {
            b.push( f*=(n+1-i)/i );
        }
        return b;
    },
    /** a mod b. Always returns a positive number
     * @param {Number} a
     * @param {Number} b
     * @returns {Number}
     */
    mod: function(a,b) {
        if(b==Infinity) {
            return a;
        }
        b = math.abs(b);
        return ((a%b)+b)%b;
    },
    /** Calculate the `b`-th root of `a`
     * @param {Number} a
     * @param {Number} b
     * @returns {Number}
     */
    root: function(a,b)
    {
        return math.pow(a,div(1,b));
    },
    /** Square root
     * @param {Number} n
     * @returns {Number}
     */
    sqrt: function(n)
    {
        if(n.complex)
        {
            var r = math.abs(n);
            return math.complex( Math.sqrt((r+n.re)/2), (n.im<0 ? -1 : 1) * Math.sqrt((r-n.re)/2));
        }
        else if(n<0)
            return math.complex(0,Math.sqrt(-n));
        else
            return Math.sqrt(n)
    },
    /** Natural logarithm (base `e`)
     * @param {Number} n
     * @returns {Number}
     */
    log: function(n)
    {
        if(n.complex)
        {
            var mag = math.abs(n);
            var arg = math.arg(n);
            return math.complex(Math.log(mag), arg);
        }
        else if(n<0)
            return math.complex(Math.log(-n),Math.PI);
        else
            return Math.log(n);
    },
    /** Calculate `e^n`
     * @param {Number} n
     * @returns {Number}
     */
    exp: function(n)
    {
        if(n.complex)
        {
            return math.complex( Math.exp(n.re) * Math.cos(n.im), Math.exp(n.re) * Math.sin(n.im) );
        }
        else
            return Math.exp(n);
    },
    /** Magnitude of a number - absolute value of a real; modulus of a complex number.
     * @param {Number} n
     * @returns {Number}
     */
    abs: function(n)
    {
        if(n.complex)
        {
            if(n.re==0)
                return Math.abs(n.im);
            else if(n.im==0)
                return Math.abs(n.re);
            else
                return Math.sqrt(n.re*n.re + n.im*n.im)
        }
        else
            return Math.abs(n);
    },
    /** Argument of a (complex) number
     * @param {Number} n
     * @returns {Number}
     */
    arg: function(n)
    {
        if(n.complex)
            return Math.atan2(n.im,n.re);
        else
            return Math.atan2(0,n);
    },
    /** Real part of a number
     * @param {Number} n
     * @returns {Number}
     */
    re: function(n)
    {
        if(n.complex)
            return n.re;
        else
            return n;
    },
    /** Imaginary part of a number
     * @param {Number} n
     * @returns {Number}
     */
    im: function(n)
    {
        if(n.complex)
            return n.im;
        else
            return 0;
    },
    /** Is `a` less than `b`?
     * @throws {Numbas.Error} `math.order complex numbers` if `a` or `b` are complex numbers.
     * @param {Number} a
     * @param {Number} b
     * @returns {Boolean}
     */
    lt: function(a,b)
    {
        if(a.complex || b.complex)
            throw(new Numbas.Error('math.order complex numbers'));
        return a<b;
    },
    /** Is `a` greater than `b`?
     * @throws {Numbas.Error} `math.order complex numbers` if `a` or `b` are complex numbers.
     * @param {Number} a
     * @param {Number} b
     * @returns {Boolean}
     */
    gt: function(a,b)
    {
        if(a.complex || b.complex)
            throw(new Numbas.Error('math.order complex numbers'));
        return a>b;
    },
    /** Is `a` less than or equal to `b`?
     * @throws {Numbas.Error} `math.order complex numbers` if `a` or `b` are complex numbers.
     * @param {Number} a
     * @param {Number} b
     * @returns {Boolean}
     */
    leq: function(a,b)
    {
        if(a.complex || b.complex)
            throw(new Numbas.Error('math.order complex numbers'));
        return a<=b;
    },
    /** Is `a` greater than or equal to `b`?
     * @throws {Numbas.Error} `math.order complex numbers` if `a` or `b` are complex numbers.
     * @param {Number} a
     * @param {Number} b
     * @returns {Boolean}
     */
    geq: function(a,b)
    {
        if(a.complex || b.complex)
            throw(new Numbas.Error('math.order complex numbers'));
        return a>=b;
    },
    /** Is `a` equal to `b`?
     * @param {Number} a
     * @param {Number} b
     * @returns {Boolean}
     */
    eq: function(a,b) {
        if(typeof(a)!=='object' && isNaN(a)) {
            return typeof(b)!='object' && isNaN(b);
        }
        if(a.complex)
        {
            if(b.complex)
                return (a.re==b.re && a.im==b.im);
            else
                return (a.re==b && a.im==0);
        }
        else
        {
            if(b.complex)
                return (a==b.re && b.im==0);
            else
                return a==b;
        }
    },
    /** Greatest of two numbers - wraps `Math.max`
     * @throws {Numbas.Error} `math.order complex numbers` if `a` or `b` are complex numbers.
     * @param {Number} a
     * @param {Number} b
     * @returns {Number}
     */
    max: function(a,b)
    {
        if(a.complex || b.complex)
            throw(new Numbas.Error('math.order complex numbers'));
        return Math.max(a,b);
    },
    /** Greatest of a list of numbers
     * @throws {Numbas.Error} `math.order complex numbers` if any element of the list is complex.
     * @param {Array} numbers
     * @returns {Number}
     */
    listmax: function(numbers) {
        if(numbers.length==0) {
            return;
        }
        var best = numbers[0];
        for(var i=1;i<numbers.length;i++) {
            best = math.max(best,numbers[i]);
        }
        return best;
    },
    /** Least of two numbers - wraps `Math.min`
     * @throws {Numbas.Error} `math.order complex numbers` if `a` or `b` are complex numbers.
     * @param {Number} a
     * @param {Number} b
     * @returns {Number}
     */
    min: function(a,b)
    {
        if(a.complex || b.complex)
            throw(new Numbas.Error('math.order complex numbers'));
        return Math.min(a,b);
    },
    /** Least of a list of numbers
     * @throws {Numbas.Error} `math.order complex numbers` if any element of the list is complex.
     * @param {Array} numbers
     * @returns {Number}
     */
    listmin: function(numbers) {
        if(numbers.length==0) {
            return;
        }
        var best = numbers[0];
        for(var i=1;i<numbers.length;i++) {
            best = math.min(best,numbers[i]);
        }
        return best;
    },
    /** Are `a` and `b` unequal?
     * @param {Number} a
     * @param {Number} b
     * @returns {Boolean}
     * @see Numbas.math.eq
     */
    neq: function(a,b)
    {
        return !math.eq(a,b);
    },
    /** If `n` can be written in the form `a*pi^n`, return the biggest possible `n`, otherwise return `0`.
     * @param {Number} n
     * @returns {Number}
     */
    piDegree: function(n)
    {
        n=Math.abs(n);
        if(n>10000)    //so big numbers don't get rounded to a power of pi accidentally
            return 0;
        var degree,a;
        for(degree=1; (a=n/Math.pow(Math.PI,degree))>1 && Math.abs(a-math.round(a))>0.00000001; degree++) {}
        return( a>=1 ? degree : 0 );
    },
    /** Add the given number of zero digits to a string representation of a number.
     * @param {String} n - a string representation of a number
     * @param {Number} digits - the number of digits to add
     * @returns {String}
     */
    addDigits: function(n,digits) {
        n = n+'';
        var m = n.match(/^(-?\d+(?:\.\d+)?)(e[\-+]?\d+)$/);
        if(m) {
            return math.addDigits(m[1],digits)+m[2];
        } else {
            if(n.indexOf('.')==-1) {
                n += '.';
            }
            for(var i=0;i<digits;i++) {
                n += '0';
            }
            return n;
        }
    },
    /** Settings for {@link Numbas.math.niceNumber}
     * @typedef Numbas.math.niceNumber_settings
     * @property {String} precisionType - Either `"dp"` or `"sigfig"`.
     * @property {String} style - Name of a notational style to use. See {@link Numbas.util.numberNotationStyles}.
     */
    /** Display a number nicely - rounds off to 10dp so floating point errors aren't displayed
     * @param {Number} n
     * @param {Numbas.math.niceNumber_settings} options - `precisionType` is either "dp" or "sigfig". `style` is an optional notation style to use.
     * @see Numbas.util.numberNotationStyles
     * @returns {String}
     */
    niceNumber: function(n,options)
    {
        options = options || {};
        if(n===undefined) {
            throw(new Numbas.Error('math.niceNumber.undefined'));
        }
        if(n.complex)
        {
            var re = math.niceNumber(n.re,options);
            var im = math.niceNumber(n.im,options);
            if(math.precround(n.im,10)==0)
                return re+'';
            else if(math.precround(n.re,10)==0)
            {
                if(n.im==1)
                    return 'i';
                else if(n.im==-1)
                    return '-i';
                else
                    return im+'*i';
            }
            else if(n.im<0)
            {
                if(n.im==-1)
                    return re+' - i';
                else
                    return re+im+'*i';
            }
            else
            {
                if(n.im==1)
                    return re+' + '+'i';
                else
                    return re+' + '+im+'*i';
            }
        }
        else
        {
            if(n==Infinity) {
                return 'infinity';
            } else if(n==-Infinity) {
                return '-infinity';
            }
            var piD = 0;
            if(options.precisionType === undefined && (piD = math.piDegree(n)) > 0)
                n /= Math.pow(Math.PI,piD);
            var out;
            switch(options.precisionType) {
            case 'sigfig':
                var precision = options.precision;
                out = math.siground(n,precision)+'';
                var sigFigs = math.countSigFigs(out,true);
                if(sigFigs<precision) {
                    out = math.addDigits(out,precision-sigFigs);
                }
                break;
            case 'dp':
                var precision = options.precision;
                out = math.precround(n,precision)+'';
                var dp = math.countDP(out);
                if(dp<precision) {
                    out = math.addDigits(out,precision-dp);
                }
                break;
            default:
                var a = Math.abs(n);
                if(a<1e-15) {
                    out = '0';
                } else if(Math.abs(n)<1e-8) {
                    out = n+'';
                } else {
                    out = math.precround(n,10)+'';
                }
            }
            out = math.unscientific(out);
            if(options.style && Numbas.util.numberNotationStyles[options.style]) {
                var match_neg = /^(-)?(.*)/.exec(out);
                var minus = match_neg[1] || '';
                var bits = match_neg[2].split('.');
                var integer = bits[0];
                var decimal = bits[1];
                out = minus+Numbas.util.numberNotationStyles[options.style].format(integer,decimal);
            }
            switch(piD)
            {
            case 0:
                return out;
            case 1:
                if(n==1)
                    return 'pi';
                else if(n==-1)
                    return '-pi';
                else
                    return out+'*pi';
            default:
                if(n==1)
                    return 'pi^'+piD;
                else if(n==-1)
                    return '-pi^'+piD;
                else
                    return out+'*pi'+piD;
            }
        }
    },
    /** Get a random number in range `[0..n-1]`
     * @param {Number} n
     * @returns {Number}
     */
    randomint: function(n) {
        return Math.floor(n*(Math.random()%1));
    },
    /** Get a  random shuffling of the numbers `[0..n-1]`
     * @param {Number} n
     * @returns {Array.<Number>}
     */
    deal: function(N)
    {
        var J, K, Q = new Array(N);
        for (J=0 ; J<N ; J++)
            { K = math.randomint(J+1) ; Q[J] = Q[K] ; Q[K] = J; }
        return Q;
    },
    /** Randomly shuffle a list. Returns a new list - the original is unmodified.
     * @param {Array} list
     * @returns {Array}
     */
    shuffle: function(list) {
        var l = list.length;
        var permutation = math.deal(l);
        var list2 = new Array(l);
        for(var i=0;i<l;i++) {
            list2[i]=(list[permutation[i]]);
        }
        return list2;
    },
    /** Calculate the inverse of a shuffling
     * @param {Array.<Number>} l
     * @returns {Array.<Number>} l
     * @see Numbas.math.deal
     */
    inverse: function(l)
    {
        arr = new Array(l.length);
        for(var i=0;i<l.length;i++)
        {
            arr[l[i]]=i;
        }
        return arr;
    },
    /* Just the numbers from 1 to `n` (inclusive) in an array!
     * @param {Number} n
     * @returns {Array.<Number>}
     */
    range: function(n)
    {
        var arr=new Array(n);
        for(var i=0;i<n;i++)
        {
            arr[i]=i;
        }
        return arr;
    },
    /** Round `a` to `b` decimal places. Real and imaginary parts of complex numbers are rounded independently.
     * @param {Number} n
     * @param {Number} b
     * @returns {Number}
     * @throws {Numbas.Error} "math.precround.complex" if b is complex
     */
    precround: function(a,b) {
        if(b.complex)
            throw(new Numbas.Error('math.precround.complex'));
        if(a.complex)
            return math.complex(math.precround(a.re,b),math.precround(a.im,b));
        else
        {
            var be = Math.pow(10,b);
            var fracPart = a % 1;
            var intPart = a - fracPart;
            //test to allow a bit of leeway to account for floating point errors
            //if a*10^b is less than 1e-9 away from having a five as the last digit of its whole part, round it up anyway
            var v = fracPart*be*10 % 1;
            var d = (fracPart>0 ? Math.floor : Math.ceil)(fracPart*be*10 % 10);
            // multiply fractional part by 10^b; we'll throw away the remaining fractional part (stuff < 10^b)
            fracPart *= be;
            if( (d==4 && 1-v<1e-9) || (d==-5 && v>-1e-9 && v<0)) {
                fracPart += 1;
            }
            var rounded_fracPart = Math.round(fracPart);
            // if the fractional part has rounded up to a whole number, just add sgn(fracPart) to the integer part
            if(rounded_fracPart==be || rounded_fracPart==-be) {
                return intPart+math.sign(fracPart);
            }
            // get the fractional part as a string of decimal digits
            var fracPartString = Math.round(Math.abs(fracPart))+'';
            while(fracPartString.length<b) {
                fracPartString = '0'+fracPartString;
            }
            // construct the rounded number as a string, then convert it to a JS float
            var out = parseFloat(intPart+'.'+fracPartString);
            // make sure a negative number remains negative
            if(intPart==0 && a<0) {
                return -out;
            } else {
                return out;
            }
        }
    },
    /** If the given string is scientific notation representing a number, return a string of the form \d+\.\d+
     * For example, '1.23e-5' is returned as '0.0000123'
     * @param {String} str
     * @returns String
     */
    unscientific: function(str) {
        var m = /(-)?(\d+)(?:\.(\d+))?e(-?\d+)/i.exec(str);
        if(!m) {
            return str;
        }
        var minus = m[1] || '';
        var digits = m[2]+(m[3] || '');
        var pow = parseInt(m[4]);
        var l = digits.length;
        var out;
        if(pow>=l-1) {
            out = digits;
            for(var i=l-1;i<pow;i++) {
                out += '0';
            }
        } else if(pow<0) {
            out = digits;
            for(var i=1;i<-pow;i++) {
                out = '0'+out;
            }
            out = '0.'+out;
        } else {
            out = digits.slice(0,pow+1) + '.' + digits.slice(pow+1);
        }
        return minus + out;
    },
    /** Round `a` to `b` significant figures. Real and imaginary parts of complex numbers are rounded independently.
     * @param {Number} n
     * @param {Number} b
     * @returns {Number}
     * @throws {Numbas.Error} "math.precround.complex" if b is complex
     */
    siground: function(a,b) {
        if(b.complex) {
            throw(new Numbas.Error('math.siground.complex'));
        }
        if(a.complex) {
            return math.complex(math.siground(a.re,b),math.siground(a.im,b));
        } else {
            return parseFloat(a.toPrecision(b))
        }
    },
    /** Count the number of decimal places used in the string representation of a number.
     * @param {Number|String} n
     * @returns {Number}
     */
    countDP: function(n) {
        var m = (n+'').match(/(?:\.(\d*))?(?:[Ee]([\-+])?(\d+))?$/);
        if(!m)
            return 0;
        else {
            var dp = m[1] ? m[1].length : 0;
            if(m[2] && m[2]=='-') {
                dp += parseInt(m[3]);
            }
            return dp;
        }
    },
    /** Calculate the significant figures precision of a number.
     * @param {Number|String} n
     * @param {Boolean} [max] - be generous with calculating sig. figs. for whole numbers. e.g. '1000' could be written to 4 sig figs.
     * @returns {Number}
     */
    countSigFigs: function(n,max) {
        n += '';
        var m;
        if(max) {
            m = n.match(/^-?(?:(\d0*)$|(?:([1-9]\d*[1-9]0*)$)|([1-9]\d*\.\d+$)|(0\.0+$)|(?:0\.0*([1-9]\d*))|(?:(\d*(?:\.\d+)?)[Ee][+\-]?\d+)$)/i);
        } else {
            m = n.match(/^-?(?:(\d)0*$|(?:([1-9]\d*[1-9])0*$)|([1-9]\d*\.\d+$)|(0\.0+$)|(?:0\.0*([1-9]\d*))|(?:(\d*(?:\.\d+)?)[Ee][+\-]?\d+)$)/i);
        }
        if(!m)
            return 0;
        var sigFigs = m[1] || m[2] || m[3] || m[4] || m[5] || m[6];
        return sigFigs.replace('.','').length;
    },
    /** Is n given to the desired precision?
     * @param {Number|String} n
     * @param {String} precisionType - either 'dp' or 'sigfig'
     * @param {Number} precision - number of desired digits of precision
     * @param {Boolean} strictPrecision - must trailing zeros be used to get to the desired precision (true), or is it allowed to give fewer digits in that case (false)?
     * @returns {Boolean}
     */
    toGivenPrecision: function(n,precisionType,precision,strictPrecision) {
        if(precisionType=='none') {
            return true;
        }
        n += '';
        var precisionOK = false;
        var counters = {'dp': math.countDP, 'sigfig': math.countSigFigs};
        var counter = counters[precisionType];
        var digits = counter(n);
        if(strictPrecision)
            precisionOK = digits == precision;
        else
            precisionOK = digits <= precision;
        if(precisionType=='sigfig' && !precisionOK && digits < precision && /[1-9]\d*0+$/.test(n)) {    // in cases like 2070, which could be to either 3 or 4 sig figs
            var trailingZeroes = n.match(/0*$/)[0].length;
            if(digits + trailingZeroes >= precision) {
                precisionOK = true;
            }
        }
        return precisionOK;
    },
    /** Is a within +/- tolerance of b?
     * @param {Number} a
     * @param {Number} b
     * @param {Number} tolerance
     * @returns {Boolean}
     */
    withinTolerance: function(a,b,tolerance) {
        if(tolerance==0) {
            return math.eq(a,b);
        } else {
            var upper = math.add(b,tolerance);
            var lower = math.sub(b,tolerance);
            return math.geq(a,lower) && math.leq(a,upper);
        }
    },
    /** Factorial, or Gamma(n+1) if n is not a positive integer.
     * @param {Number} n
     * @returns {Number}
     */
    factorial: function(n)
    {
        if( Numbas.util.isInt(n) && n>=0 )
        {
            if(n<=1) {
                return 1;
            }else{
                var j=1;
                for(var i=2;i<=n;i++)
                {
                    j*=i;
                }
                return j;
            }
        }
        else    //gamma function extends factorial to non-ints and negative numbers
        {
            return math.gamma(math.add(n,1));
        }
    },
    /** Lanczos approximation to the gamma function
     *
     * http://en.wikipedia.org/wiki/Lanczos_approximation#Simple_implementation
     * @param {Number} n
     * @returns {Number}
     */
    gamma: function(n)
    {
        var g = 7;
        var p = [0.99999999999980993, 676.5203681218851, -1259.1392167224028, 771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
        var mul = math.mul, div = math.div, exp = math.exp, neg = math.negate, pow = math.pow, sqrt = math.sqrt, sin = math.sin, add = math.add, sub = math.sub, pi = Math.PI, im = math.complex(0,1);
        if((n.complex && n.re<0.5) || (!n.complex && n<0.5))
        {
            return div(pi,mul(sin(mul(pi,n)),math.gamma(sub(1,n))));
        }
        else
        {
            n = sub(n,1);            //n -= 1
            var x = p[0];
            for(var i=1;i<g+2;i++)
            {
                x = add(x, div(p[i],add(n,i)));    // x += p[i]/(n+i)
            }
            var t = add(n,add(g,0.5));        // t = n+g+0.5
            return mul(sqrt(2*pi),mul(pow(t,add(n,0.5)),mul(exp(neg(t)),x)));    // return sqrt(2*pi)*t^(z+0.5)*exp(-t)*x
        }
    },
    /** Base-10 logarithm
     * @param {Number} n
     * @returns {Number}
     */
    log10: function(n)
    {
        return mul(math.log(n),Math.LOG10E);
    },
    /** Arbitrary base logarithm
     * @param {Number} n
     * @param {Number} b
     * @returns {Number} log(n)/log(b)
     */
    log_base: function(n,b)
    {
        return div(math.log(n),math.log(b));
    },
    /** Convert from degrees to radians
     * @param {Number} x
     * @returns {Number}
     * @see Numbas.math.degrees
     */
    radians: function(x) {
        return mul(x,Math.PI/180);
    },
    /** Convert from radians to degrees
     * @param {Number} x
     * @returns {Number}
     * @see Numbas.math.radians
     */
    degrees: function(x) {
        return mul(x,180/Math.PI);
    },
    /** Cosine
     * @param {Number} x
     * @returns {Number}
     */
    cos: function(x) {
        if(x.complex)
        {
            return math.complex(Math.cos(x.re)*math.cosh(x.im), -Math.sin(x.re)*math.sinh(x.im));
        }
        else
            return Math.cos(x);
    },
    /** Sine
     * @param {Number} x
     * @returns {Number}
     */
    sin: function(x) {
        if(x.complex)
        {
            return math.complex(Math.sin(x.re)*math.cosh(x.im), Math.cos(x.re)*math.sinh(x.im));
        }
        else
            return Math.sin(x);
    },
    /** Tangent
     * @param {Number} x
     * @returns {Number}
     */
    tan: function(x) {
        if(x.complex)
            return div(math.sin(x),math.cos(x));
        else
            return Math.tan(x);
    },
    /** Cosecant
     * @param {Number} x
     * @returns {Number}
     */
    cosec: function(x) {
        return div(1,math.sin(x));
    },
    /** Secant
     * @param {Number} x
     * @returns {Number}
     */
    sec: function(x) {
        return div(1,math.cos(x));
    },
    /** Cotangent
     * @param {Number} x
     * @returns {Number}
     */
    cot: function(x) {
        return div(1,math.tan(x));
    },
    /** Inverse sine
     * @param {Number} x
     * @returns {Number}
     */
    arcsin: function(x) {
        if(x.complex || math.abs(x)>1)
        {
            var i = math.complex(0,1), ni = math.complex(0,-1);
            var ex = add(mul(x,i),math.sqrt(sub(1,mul(x,x)))); //ix+sqrt(1-x^2)
            return mul(ni,math.log(ex));
        }
        else
            return Math.asin(x);
    },
    /** Inverse cosine
     * @param {Number} x
     * @returns {Number}
     */
    arccos: function(x) {
        if(x.complex || math.abs(x)>1)
        {
            var i = math.complex(0,1), ni = math.complex(0,-1);
            var ex = add(x, math.sqrt( sub(mul(x,x),1) ) );    //x+sqrt(x^2-1)
            var result = mul(ni,math.log(ex));
            if(math.re(result)<0 || math.re(result)==0 && math.im(result)<0)
                result = math.negate(result);
            return result;
        }
        else
            return Math.acos(x);
    },
    /** Inverse tangent
     * @param {Number} x
     * @returns {Number}
     */
    arctan: function(x) {
        if(x.complex)
        {
            var i = math.complex(0,1);
            var ex = div(add(i,x),sub(i,x));
            return mul(math.complex(0,0.5), math.log(ex));
        }
        else
            return Math.atan(x);
    },
    /** Hyperbolic sine
     * @param {Number} x
     * @returns {Number}
     */
    sinh: function(x) {
        if(x.complex)
            return div(sub(math.exp(x), math.exp(math.negate(x))),2);
        else
            return (Math.exp(x)-Math.exp(-x))/2;
    },
    /** Hyperbolic cosine
     * @param {Number} x
     * @returns {Number}
     */
    cosh: function(x) {
        if(x.complex)
            return div(add(math.exp(x), math.exp(math.negate(x))),2);
        else
            return (Math.exp(x)+Math.exp(-x))/2
    },
    /** Hyperbolic tangent
     * @param {Number} x
     * @returns {Number}
     */
    tanh: function(x) {
        return div(math.sinh(x),math.cosh(x));
    },
    /** Hyperbolic cosecant
     * @param {Number} x
     * @returns {Number}
     */
    cosech: function(x) {
        return div(1,math.sinh(x));
    },
    /** Hyperbolic secant
     * @param {Number} x
     * @returns {Number}
     */
    sech: function(x) {
        return div(1,math.cosh(x));
    },
    /** Hyperbolic tangent
     * @param {Number} x
     * @returns {Number}
     */
    coth: function(x) {
        return div(1,math.tanh(x));
    },
    /** Inverse hyperbolic sine
     * @param {Number} x
     * @returns {Number}
     */
    arcsinh: function(x) {
        if(x.complex)
            return math.log(add(x, math.sqrt(add(mul(x,x),1))));
        else
            return Math.log(x + Math.sqrt(x*x+1));
    },
    /** Inverse hyperbolic cosine
     * @param {Number} x
     * @returns {Number}
     */
    arccosh: function (x) {
        if(x.complex)
            return math.log(add(x, math.sqrt(sub(mul(x,x),1))));
        else
            return Math.log(x + Math.sqrt(x*x-1));
    },
    /** Inverse hyperbolic tangent
     * @param {Number} x
     * @returns {Number}
     */
    arctanh: function (x) {
        if(x.complex)
            return div(math.log(div(add(1,x),sub(1,x))),2);
        else
            return 0.5 * Math.log((1+x)/(1-x));
    },
    /** Round up to the nearest integer. For complex numbers, real and imaginary parts are rounded independently.
     * @param {Number} x
     * @returns {Number}
     * @see Numbas.math.round
     * @see Numbas.math.floor
     */
    ceil: function(x) {
        if(x.complex)
            return math.complex(math.ceil(x.re),math.ceil(x.im));
        else
            return Math.ceil(x);
    },
    /** Round down to the nearest integer. For complex numbers, real and imaginary parts are rounded independently.
     * @param {Number} x
     * @returns {Number}
     * @see Numbas.math.ceil
     * @see Numbas.math.round
     */
    floor: function(x) {
        if(x.complex)
            return math.complex(math.floor(x.re),math.floor(x.im));
        else
            return Math.floor(x);
    },
    /** Round to the nearest integer; fractional part >= 0.5 rounds up. For complex numbers, real and imaginary parts are rounded independently.
     * @param {Number} x
     * @returns {Number}
     * @see Numbas.math.ceil
     * @see Numbas.math.floor
     */
    round: function(x) {
        if(x.complex)
            return math.complex(Math.round(x.re),Math.round(x.im));
        else
            return Math.round(x);
    },
    /** Integer part of a number - chop off the fractional part. For complex numbers, real and imaginary parts are rounded independently.
     * @param {Number} x
     * @returns {Number}
     * @see Numbas.math.fract
     */
    trunc: function(x) {
        if(x.complex)
            return math.complex(math.trunc(x.re),math.trunc(x.im));
        if(x>0) {
            return Math.floor(x);
        }else{
            return Math.ceil(x);
        }
    },
    /** Fractional part of a number - Take away the whole number part. For complex numbers, real and imaginary parts are rounded independently.
     * @param {Number} x
     * @returns {Number}
     * @see Numbas.math.trunc
     */
    fract: function(x) {
        if(x.complex)
            return math.complex(math.fract(x.re),math.fract(x.im));
        return x-math.trunc(x);
    },
    /** Sign of a number - +1, 0, or -1. For complex numbers, gives the sign of the real and imaginary parts separately.
     * @param {Number} x
     * @returns {Number}
     */
    sign: function(x) {
        if(x.complex)
            return math.complex(math.sign(x.re),math.sign(x.im));
        if(x==0) {
            return 0;
        }else if (x>0) {
            return 1;
        }else {
            return -1;
        }
    },
    /** Get a random real number between `min` and `max` (inclusive)
     * @param {Number} min
     * @param {Number] max
     * @returns {Number}
     * @see Numbas.math.random
     * @see Numbas.math.choose
     */
    randomrange: function(min,max)
    {
        return Math.random()*(max-min)+min;
    },
    /** Get a random number in the specified range.
     *
     * Returns a random choice from `min` to `max` at `step`-sized intervals
     *
     * If all the values in the range are appended to the list, eg `[min,max,step,v1,v2,v3,...]`, just pick randomly from the values.
     *
     * @param {range} range - `[min,max,step]`
     * @returns {Number}
     * @see Numbas.math.randomrange
     */
    random: function(range)
    {
        if(range[2]==0) {
            return math.randomrange(range[0],range[1]);
        } else {
            var num_steps = math.rangeSize(range);
            var n = Math.floor(math.randomrange(0,num_steps));
            return range[0]+n*range[2];
        }
    },
    /** Remove all the values in the list `exclude` from the list `range`
     * @param {Array.<Number>} range
     * @param {Array.<Number>} exclude
     * @returns {Array.<Number>}
     */
    except: function(range,exclude) {
        range = range.filter(function(r) {
            for(var i=0;i<exclude.length;i++) {
                if(math.eq(r,exclude[i]))
                    return false;
            }
            return true;
        });
        return range;
    },
    /** Choose one item from an array, at random
     * @param {Array} selection
     * @throws {Numbas.Error} "math.choose.empty selection" if `selection` has length 0.
     * @see Numbas.math.randomrange
     */
    choose: function(selection)
    {
        if(selection.length==0)
            throw(new Numbas.Error('math.choose.empty selection'));
        var n = Math.floor(math.randomrange(0,selection.length));
        return selection[n];
    },
    /* Product of the numbers in the range `[a..b]`, i.e. $frac{a!}{b!}$.
     *
     * from http://dreaminginjavascript.wordpress.com/2008/11/08/combinations-and-permutations-in-javascript/
     *
     * (public domain)
     * @param {Number} a
     * @param {Number} b
     * @returns {Number}
     */
    productRange: function(a,b) {
        if(a>b)
            return 1;
        var product=a,i=a;
        while (i++<b) {
            product*=i;
        }
        return product;
    },
    /** `nCk` - number of ways of picking `k` unordered elements from `n`.
     * @param {Number} n
     * @param {Number} k
     * @throws {Numbas.Error} "math.combinations.complex" if either of `n` or `k` is complex.
     */
    combinations: function(n,k) {
        if(n.complex || k.complex) {
            throw(new Numbas.Error('math.combinations.complex'));
        }
        if(n<0) {
            throw(new Numbas.Error('math.combinations.n less than zero'));
        }
        if(k<0) {
            throw(new Numbas.Error('math.combinations.k less than zero'));
        }
        if(n<k) {
            throw(new Numbas.Error('math.combinations.n less than k'));
        }
        k=Math.max(k,n-k);
        return math.productRange(k+1,n)/math.productRange(1,n-k);
    },
    /** `nPk` - number of ways of picking `k` ordered elements from `n`.
     * @param {Number} n
     * @param {Number} k
     * @throws {Numbas.Error} "math.combinations.complex" if either of `n` or `k` is complex.
     */
    permutations: function(n,k) {
        if(n.complex || k.complex) {
            throw(new Numbas.Error('math.permutations.complex'));
        }
        if(n<0) {
            throw(new Numbas.Error('math.permutations.n less than zero'));
        }
        if(k<0) {
            throw(new Numbas.Error('math.permutations.k less than zero'));
        }
        if(n<k) {
            throw(new Numbas.Error('math.permutations.n less than k'));
        }
        return math.productRange(n-k+1,n);
    },
    /** Does `a` divide `b`? If either of `a` or `b` is not an integer, return `false`.
     * @param {Number} a
     * @param {Number} b
     * @returns {Boolean}
     */
    divides: function(a,b) {
        if(a.complex || b.complex || !Numbas.util.isInt(a) || !Numbas.util.isInt(b))
            return false;
        return (b % a) == 0;
    },
    /** Greatest common factor (GCF), or greatest common divisor (GCD), of `a` and `b`.
     * @param {Number} a
     * @param {Number} b
     * @returns {Number}
     * @throws {Numbas.Error} "math.gcf.complex" if either of `a` or `b` is complex.
     */
    gcd: function(a,b) {
        if(a.complex || b.complex)
            throw(new Numbas.Error('math.gcf.complex'));
        if(Math.floor(a)!=a || Math.floor(b)!=b)
            return 1;
        a = Math.floor(Math.abs(a));
        b = Math.floor(Math.abs(b));
        var c=0;
        if(a<b) { c=a; a=b; b=c; }
        if(b==0){return 1;}
        while(a % b != 0) {
            c=b;
            b=a % b;
            a=c;
        }
        return b;
    },
    /** Are `a` and `b` coprime? If either of `a` or `b` is not an integer, return `false`.
     * Equivalent to `gcd(a,b) = 1`.
     * @param {Number} a
     * @param {Number} b
     * @see Numbas.math.gcd
     * @returns {Boolean}
     */
    coprime: function(a,b) {
        if(a.complex || b.complex || !Numbas.util.isInt(a) || !Numbas.util.isInt(b)) {
            return true;
        }
        return math.gcd(a,b) == 1;
    },
    /** Lowest common multiple (LCM) of `a` and `b`.
     * @param {Number} a
     * @param {Number} b
     * @returns {Number}
     * @throws {Numbas.Error} "math.gcf.complex" if either of `a` or `b` is complex.
     */
    lcm: function(a,b) {
        if(arguments.length==0) {
            return 1;
        } else if(arguments.length==1) {
            return a;
        }
        if(a.complex || b.complex)
            throw(new Numbas.Error('math.lcm.complex'));
        if(arguments.length>2) {
            a = Math.floor(Math.abs(a));
            for(var i=1;i<arguments.length;i++) {
                if(arguments[i].complex) {
                    throw(new Numbas.Error('math.lcm.complex'));
                }
                b = Math.floor(Math.abs(arguments[i]));
                a = a*b/math.gcf(a,b);
            }
            return a;
        }
        a = Math.floor(Math.abs(a));
        b = Math.floor(Math.abs(b));
        var c = math.gcf(a,b);
        return a*b/c;
    },
    /** Write the range of integers `[a..b]` as an array of the form `[min,max,step]`, for use with {@link Numbas.math.random}. If either number is complex, only the real part is used.
     *
     * @param {Number} a
     * @param {Number} b
     * @returns {range}
     * @see Numbas.math.random
     */
    defineRange: function(a,b)
    {
        if(a.complex)
            a=a.re;
        if(b.complex)
            b=b.re;
        return [a,b,1];
    },
    /** Change the step size of a range created with {@link Numbas.math.defineRange}
     * @param {range} range
     * @param {Number} step
     * @returns {range}
     */
    rangeSteps: function(range,step)
    {
        if(step.complex)
            step = step.re;
        return [range[0],range[1],step];
    },
    /** Convert a range to a list - enumerate all the elements of the range
     * @param {range} range
     * @returns {Number[]}
     */
    rangeToList: function(range) {
        var start = range[0];
        var end = range[1];
        var step_size = range[2];
        var out = [];
        var n = 0;
        var t = start;
        if(step_size==0) {
            throw(new Numbas.Error('math.rangeToList.zero step size'));
        }
        if((end-start)*step_size < 0) {
            return [];
        }
        if(start==end) {
            return [start];
        }
        while(start<end ? t<=end : t>=end)
        {
            out.push(t)
            n += 1;
            t = start + n*step_size;
        }
        return out;
    },
    /** Calculate the number of elements in a range
     * @param {range} range
     * @returns {Number}
     */
    rangeSize: function(range) {
        var diff = range[1]-range[0];
        var num_steps = Math.floor(diff/range[2])+1;
        num_steps += (range[0]+num_steps*range[2] == range[1] ? 1 : 0);
        return num_steps;
    },
    /** Get a rational approximation to a real number by the continued fractions method.
     *
     * If `accuracy` is given, the returned answer will be within `Math.exp(-accuracy)` of the original number
     *
     * @param {Number} n
     * @param {Number} [accuracy]
     * @returns {Array.<Number>} - [numerator,denominator]
     */
    rationalApproximation: function(n,accuracy)
    {
        if(accuracy===undefined) {
            accuracy = 15;
        }
        if(accuracy>30) {
            accuracy = 30;
        }
        accuracy = Math.exp(-accuracy);
        var on = n;
        var e = Math.floor(n);
        if(e==n)
            return [n,1];
        var l = 0;
        var frac = [];
        while(l<100 && Math.abs(on-e)>accuracy)
        {
            l+=1;
            var i = Math.floor(n);
            frac.push(i);
            n = 1/(n-i);
            var e = Infinity;
            for(var j=l-1;j>=0;j--)
            {
                e = frac[j]+1/e;
            }
        }
        if(l==0) {
            return [e,1];
        }
        var f = [1,0];
        for(j=l-1;j>=0;j--)
        {
            f = [frac[j]*f[0]+f[1],f[0]];
        }
        return f;
    },
    /** The first 1000 primes */
    primes: [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001,4003,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,4243,4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,4373,4391,4397,4409,4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,4513,4517,4519,4523,4547,4549,4561,4567,4583,4591,4597,4603,4621,4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,4723,4729,4733,4751,4759,4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,4903,4909,4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999,5003,5009,5011,5021,5023,5039,5051,5059,5077,5081,5087,5099,5101,5107,5113,5119,5147,5153,5167,5171,5179,5189,5197,5209,5227,5231,5233,5237,5261,5273,5279,5281,5297,5303,5309,5323,5333,5347,5351,5381,5387,5393,5399,5407,5413,5417,5419,5431,5437,5441,5443,5449,5471,5477,5479,5483,5501,5503,5507,5519,5521,5527,5531,5557,5563,5569,5573,5581,5591,5623,5639,5641,5647,5651,5653,5657,5659,5669,5683,5689,5693,5701,5711,5717,5737,5741,5743,5749,5779,5783,5791,5801,5807,5813,5821,5827,5839,5843,5849,5851,5857,5861,5867,5869,5879,5881,5897,5903,5923,5927,5939,5953,5981,5987,6007,6011,6029,6037,6043,6047,6053,6067,6073,6079,6089,6091,6101,6113,6121,6131,6133,6143,6151,6163,6173,6197,6199,6203,6211,6217,6221,6229,6247,6257,6263,6269,6271,6277,6287,6299,6301,6311,6317,6323,6329,6337,6343,6353,6359,6361,6367,6373,6379,6389,6397,6421,6427,6449,6451,6469,6473,6481,6491,6521,6529,6547,6551,6553,6563,6569,6571,6577,6581,6599,6607,6619,6637,6653,6659,6661,6673,6679,6689,6691,6701,6703,6709,6719,6733,6737,6761,6763,6779,6781,6791,6793,6803,6823,6827,6829,6833,6841,6857,6863,6869,6871,6883,6899,6907,6911,6917,6947,6949,6959,6961,6967,6971,6977,6983,6991,6997,7001,7013,7019,7027,7039,7043,7057,7069,7079,7103,7109,7121,7127,7129,7151,7159,7177,7187,7193,72077211,7213,7219,7229,7237,7243,7247,7253,7283,7297,7307,7309,7321,7331,7333,7349,7351,7369,7393,7411,7417,7433,7451,7457,7459,7477,7481,7487,7489,7499,7507,7517,7523,7529,7537,7541,7547,7549,7559,7561,7573,7577,7583,7589,7591,7603,7607,7621,7639,7643,7649,7669,7673,7681,7687,7691,7699,7703,7717,7723,7727,7741,7753,7757,7759,7789,7793,7817,7823,7829,7841,7853,7867,7873,7877,7879,7883,7901,7907,7919],
    /** Factorise n. When n=2^(a1)*3^(a2)*5^(a3)*..., this returns the powers [a1,a2,a3,...]
     *
     * @param {Number} n
     * @returns {Array.<Number>} - exponents of the prime factors of n
     */
    factorise: function(n) {
        if(n<=0) {
            return [];
        }
        var factors = [];
        for(var i=0;i<math.primes.length;i++) {
            var acc = 0;
            var p = math.primes[i];
            while(n%p==0) {
                acc += 1;
                n /= p;
            }
            factors.push(acc);
            if(n==1) {
                break;
            }
        }
        return factors;
    },
    /** Sum the elements in the given list
     *
     * @param {Array.<Number>} list
     * @returns {Number}
     */
    sum: function(list) {
        var total = 0;
        var l = list.length;
        if(l==0) {
            return 0;
        }
        for(var i=0;i<l;i++) {
            total = math.add(total,list[i]);
        }
        return total;
    }
};
math.gcf = math.gcd;
var add = math.add, sub = math.sub, mul = math.mul, div = math.div, eq = math.eq, neq = math.neq, negate = math.negate;
/** A list of a vector's components.
 * @typedef vector
 *  @type {Array.<Number>}
 */
/** Vector operations.
 *
 * These operations are very lax about the dimensions of vectors - they stick zeros in when pairs of vectors don't line up exactly
 * @namespace Numbas.vectormath
 */
var vectormath = Numbas.vectormath = {
    /** Negate a vector - negate each of its components
     * @param {vector} v
     * @returns {vector}
     */
    negate: function(v) {
        return v.map(function(x) { return negate(x); });
    },
    /** Add two vectors
     * @param {vector} a
     * @param {vector} b
     * @returns {vector}
     */
    add: function(a,b) {
        if(b.length>a.length)
        {
            var c = b;
            b = a;
            a = c;
        }
        return a.map(function(x,i){ return add(x,b[i]||0) });
    },
    /** Subtract one vector from another
     * @param {vector} a
     * @param {vector} b
     * @returns {vector}
     */
    sub: function(a,b) {
        if(b.length>a.length)
        {
            return b.map(function(x,i){ return sub(a[i]||0,x) });
        }
        else
        {
            return a.map(function(x,i){ return sub(x,b[i]||0) });
        }
    },
    /** Multiply by a scalar
     * @param {Number} k
     * @param {vector} v
     * @returns {vector}
     */
    mul: function(k,v) {
        return v.map(function(x){ return mul(k,x) });
    },
    /** Divide by a scalar
     * @param {vector} v
     * @param {Number} k
     * @returns {vector}
     */
    div: function(v,k) {
        return v.map(function(x){ return div(x,k); });
    },
    /** Vector dot product - each argument can be a vector, or a matrix with one row or one column, which is converted to a vector.
     * @param {vector|matrix} a
     * @param {vector|matrix} b
     * @returns {Number}
     * @throws {Numbas.Error} "vectormaths.dot.matrix too big" if either of `a` or `b` is bigger than `1xN` or `Nx1`.
     */
    dot: function(a,b) {
        //check if A is a matrix object. If it's the right shape, we can use it anyway
        if('rows' in a)
        {
            if(a.rows==1)
                a = a[0];
            else if(a.columns==1)
                a = a.map(function(x){return x[0]});
            else
                throw(new Numbas.Error('vectormath.dot.matrix too big'));
        }
        //Same check for B
        if('rows' in b)
        {
            if(b.rows==1)
                b = b[0];
            else if(b.columns==1)
                b = b.map(function(x){return x[0]});
            else
                throw(new Numbas.Error('vectormath.dot.matrix too big'));
        }
        if(b.length>a.length)
        {
            var c = b;
            b = a;
            a = c;
        }
        return a.reduce(function(s,x,i){ return add(s,mul(x,b[i]||0)) },0);
    },
    /** Vector cross product - each argument can be a vector, or a matrix with one row, which is converted to a vector.
     *
     * @param {vector|matrix} a
     * @param {vector|matrix} b
     * @returns {vector}
     *
     * @throws {Numbas.Error} "vectormaths.cross.matrix too big" if either of `a` or `b` is bigger than `1xN` or `Nx1`.
     * @throws {Numbas.Error} "vectormath.cross.not 3d" if either of the vectors is not 3D.
     */
    cross: function(a,b) {
        //check if A is a matrix object. If it's the right shape, we can use it anyway
        if('rows' in a)
        {
            if(a.rows==1)
                a = a[0];
            else if(a.columns==1)
                a = a.map(function(x){return x[0]});
            else
                throw(new Numbas.Error('vectormath.cross.matrix too big'));
        }
        //Same check for B
        if('rows' in b)
        {
            if(b.rows==1)
                b = b[0];
            else if(b.columns==1)
                b = b.map(function(x){return x[0]});
            else
                throw(new Numbas.Error('vectormath.cross.matrix too big'));
        }
        if(a.length!=3 || b.length!=3)
            throw(new Numbas.Error('vectormath.cross.not 3d'));
        return [
                sub( mul(a[1],b[2]), mul(a[2],b[1]) ),
                sub( mul(a[2],b[0]), mul(a[0],b[2]) ),
                sub( mul(a[0],b[1]), mul(a[1],b[0]) )
                ];
    },
    /** Length of a vector, squared
     * @param {vector} a
     * @returns {Number}
     */
    abs_squared: function(a) {
        return a.reduce(function(s,x){ return s + mul(x,x); },0);
    },
    /** Length of a vector
     * @param {vector} a
     * @returns {Number}
     */
    abs: function(a) {
        return Math.sqrt( a.reduce(function(s,x){ return s + mul(x,x); },0) );
    },
    /** Angle between vectors a and b, in radians, or 0 if either vector has length 0.
     * @param {vector} a
     * @param {vector} b
     * @returns {Number}
     */
    angle: function(a,b) {
        var dot = vectormath.dot(a,b);
        var da = vectormath.abs_squared(a);
        var db = vectormath.abs_squared(b);
        if(da*db==0) {
            return 0;
        }
        var d = Math.sqrt(da*db);
        return math.arccos(dot/d);
    },
    /** Are two vectors equal? True if each pair of corresponding components is equal.
     * @param {vector} a
     * @param {vector} b
     * @returns {Boolean}
     */
    eq: function(a,b) {
        if(b.length>a.length)
        {
            var c = b;
            b = a;
            a = c;
        }
        return a.reduce(function(s,x,i){return s && eq(x,b[i]||0)},true);
    },
    /** Are two vectors unequal?
     * @param {vector} a
     * @param {vector} b
     * @returns {Boolean}
     * @see Numbas.vectormath.eq
     */
    neq: function(a,b) {
        return !vectormath.eq(a,b);
    },
    /** Multiply a vector on the left by a matrix
     * @param {matrix} m
     * @param {vector} v
     * @returns {vector}
     */
    matrixmul: function(m,v) {
        return m.map(function(row){
            return row.reduce(function(s,x,i){ return add(s,mul(x,v[i]||0)); },0);
        });
    },
    /** Multiply a vector on the right by a matrix.
     * The vector is considered as a column vector.
     * @param {vector} v
     * @param {matrix} m
     * @returns {vector}
     */
    vectormatrixmul: function(v,m) {
        var out = [];
        for(var i=0;i<m.columns;i++) {
            out.push(v.reduce(function(s,x,j){ var c = j<m.rows ? (m[j][i]||0) : 0; return add(s,mul(x,c)); },0));
        }
        return out;
    },
    /** Apply given function to each element
     * @param {vector}
     * @param {function}
     * @returns {vector}
     */
    map: function(v,fn) {
        return v.map(fn);
    },
    /** Round each element to given number of decimal places
     * @param {vector}
     * @param {Number} - number of decimal places
     * @returns {vector}
     */
    precround: function(v,dp) {
        return vectormath.map(v,function(n){return math.precround(n,dp);});
    },
    /** Round each element to given number of significant figures
     * @param {vector}
     * @param {Number} - number of decimal places
     * @returns {vector}
     */
    siground: function(v,sf) {
        return vectormath.map(v,function(n){return math.siground(n,sf);});
    },
    /** Transpose of a vector
     * @param {vector} v
     * @returns {matrix}
     */
    transpose: function(v) {
        var matrix = [v.slice()];
        matrix.rows = 1;
        matrix.columns = v.length;
        return matrix;
    },
    /** Convert a vector to a 1-column matrix
     * @param {vector} v
     * @returns {matrix}
     */
    toMatrix: function(v) {
        var m = v.map(function(n){return [n]});
        m.rows = m.length;
        m.columns = 1;
        return m;
    },

    /** Is every component of this vector zero?
     */
    is_zero: function(v) {
        return v.every(function(c){return c==0;});
    }
}
/** A two-dimensional matrix: an array of rows, each of which is an array of numbers.
 * @typedef matrix
 * @type {Array.<Array.<Number>>}
 * @property {Number} rows - The number of rows in the matrix
 * @property {Number} columns - The number of columns in the matrix
 */
/** Matrix operations.
 *
 * These operations are very lax about the dimensions of vectors - they stick zeros in when pairs of matrices don't line up exactly
 * @namespace Numbas.matrixmath
 */
var matrixmath = Numbas.matrixmath = {
    /** Negate a matrix - negate each of its elements */
    negate: function(m) {
        var matrix = [];
        for(var i=0;i<m.rows;i++) {
            matrix.push(m[i].map(function(x){ return negate(x) }));
        }
        matrix.rows = m.rows;
        matrix.columns = m.columns;
        return matrix;
    },
    /** Add two matrices.
     *
     * @param {matrix} a
     * @param {matrix} b
     * @returns {matrix}
     */
    add: function(a,b) {
        var rows = Math.max(a.rows,b.rows);
        var columns = Math.max(a.columns,b.columns);
        var matrix = [];
        for(var i=0;i<rows;i++)
        {
            var row = [];
            matrix.push(row);
            for(var j=0;j<columns;j++)
            {
                row[j] = add(a[i][j]||0,b[i][j]||0);
            }
        }
        matrix.rows = rows;
        matrix.columns = columns;
        return matrix;
    },
    /** Subtract one matrix from another
     *
     * @param {matrix} a
     * @param {matrix} b
     * @returns {matrix}
     */
    sub: function(a,b) {
        var rows = Math.max(a.rows,b.rows);
        var columns = Math.max(a.columns,b.columns);
        var matrix = [];
        for(var i=0;i<rows;i++)
        {
            var row = [];
            matrix.push(row);
            for(var j=0;j<columns;j++)
            {
                row[j] = sub(a[i][j]||0,b[i][j]||0);
            }
        }
        matrix.rows = rows;
        matrix.columns = columns;
        return matrix;
    },
    /** Matrix determinant. Only works up to 3x3 matrices.
     * @param {matrix} m
     * @returns {Number}
     * @throws {Numbas.Error} "matrixmath.abs.too big" if the matrix has more than 3 rows.
     */
    abs: function(m) {
        if(m.rows!=m.columns)
            throw(new Numbas.Error('matrixmath.abs.non-square'));
        //abstraction failure!
        switch(m.rows)
        {
        case 1:
            return m[0][0];
        case 2:
            return sub( mul(m[0][0],m[1][1]), mul(m[0][1],m[1][0]) );
        case 3:
            return add( sub(
                            mul(m[0][0],sub(mul(m[1][1],m[2][2]),mul(m[1][2],m[2][1]))),
                            mul(m[0][1],sub(mul(m[1][0],m[2][2]),mul(m[1][2],m[2][0])))
                        ),
                        mul(m[0][2],sub(mul(m[1][0],m[2][1]),mul(m[1][1],m[2][0])))
                    );
        default:
            throw(new Numbas.Error('matrixmath.abs.too big'));
        }
    },
    /** Multiply a matrix by a scalar
     * @param {Number} k
     * @param {matrix} m
     * @returns {matrix}
     */
    scalarmul: function(k,m) {
        var out = m.map(function(row){ return row.map(function(x){ return mul(k,x); }); });
        out.rows = m.rows;
        out.columns = m.columns;
        return out;
    },
    /** Divide a matrix by a scalar
     * @param {matrix} m
     * @param {Number} k
     * @returns {matrix}
     */
    scalardiv: function(m,k) {
        var out = m.map(function(row){ return row.map(function(x){ return div(x,k); }); });
        out.rows = m.rows;
        out.columns = m.columns;
        return out;
    },
    /** Multiply two matrices
     * @param {matrix} a
     * @param {matrix} b
     * @returns {matrix}
     * @throws {Numbas.Error} "matrixmath.mul.different sizes" if `a` doesn't have as many columns as `b` has rows.
     */
    mul: function(a,b) {
        if(a.columns!=b.rows)
            throw(new Numbas.Error('matrixmath.mul.different sizes'));
        var out = [];
        out.rows = a.rows;
        out.columns = b.columns;
        for(var i=0;i<a.rows;i++)
        {
            var row = [];
            out.push(row);
            for(var j=0;j<b.columns;j++)
            {
                var s = 0;
                for(var k=0;k<a.columns;k++)
                {
                    s = add(s,mul(a[i][k],b[k][j]));
                }
                row.push(s);
            }
        }
        return out;
    },
    /** Are two matrices equal? True if each pair of corresponding elements is equal.
     * @param {matrix} a
     * @param {matrix} b
     * @returns {Boolean}
     */
    eq: function(a,b) {
        var rows = Math.max(a.rows,b.rows);
        var columns = Math.max(a.columns,b.columns);
        for(var i=0;i<rows;i++)
        {
            var rowA = a[i] || [];
            var rowB = b[i] || [];
            for(var j=0;j<columns;j++)
            {
                if(!eq(rowA[j]||0,rowB[j]||0))
                    return false;
            }
        }
        return true;
    },
    /** Are two matrices unequal?
     * @param {matrix} a
     * @param {matrix} b
     * @returns {Boolean}
     * @see Numbas.matrixmath.eq
     */
    neq: function(a,b) {
        return !matrixmath.eq(a,b);
    },
    /** Make an `NxN` identity matrix.
     * @param {Number} n
     * @returns {matrix}
     */
    id: function(n) {
        var out = [];
        out.rows = out.columns = n;
        for(var i=0;i<n;i++)
        {
            var row = [];
            out.push(row);
            for(var j=0;j<n;j++)
                row.push(j==i ? 1 : 0);
        }
        return out;
    },
    /** Matrix transpose
     * @param {matrix}
     * @returns {matrix}
     */
    transpose: function(m) {
        var out = [];
        out.rows = m.columns;
        out.columns = m.rows;
        for(var i=0;i<m.columns;i++)
        {
            var row = [];
            out.push(row);
            for(var j=0;j<m.rows;j++)
            {
                row.push(m[j][i]||0);
            }
        }
        return out;
    },

    /** Sum of every cell
     * @param {matrix}
     * @returns {Number}
     */
    sum_cells: function(m) {
        var t = 0;
        m.forEach(function(row) {
            row.forEach(function(cell) {
                t += cell;
            });
        });
        return t;
    },

    /** Apply given function to each element
     * @param {matrix}
     * @param {function}
     * @returns {matrix}
     */
    map: function(m,fn) {
        var out = m.map(function(row){
            return row.map(fn);
        });
        out.rows = m.rows;
        out.columns = m.columns;
        return out;
    },
    /** Round each element to given number of decimal places
     * @param {matrix}
     * @param {Number} - number of decimal places
     * @returns {matrix}
     */
    precround: function(m,dp) {
        return matrixmath.map(m,function(n){return math.precround(n,dp);});
    },
    /** Round each element to given number of significant figures
     * @param {matrix}
     * @param {Number} - number of decimal places
     * @returns {matrix}
     */
    siground: function(m,sf) {
        return matrixmath.map(m,function(n){return math.siground(n,sf);});
    }
}
/** A set of objects: no item occurs more than once.
 * @typedef set
 * @type Array
 */
/** Set operations.
 *
 * @namespace Numbas.setmath
 */
var setmath = Numbas.setmath = {
    /** Does the set contain the given element?
     * @param {set} set
     * @param element
     * @returns {Boolean}
     */
    contains: function(set,element) {
        for(var i=0,l=set.length;i<l;i++) {
            if(Numbas.util.eq(set[i],element)) {
                return true;
            }
        }
    },
    /** Union of two sets
     * @param {set} a
     * @param {set} b
     * @returns {set}
     */
    union: function(a,b) {
        var out = a.slice();
        for(var i=0,l=b.length;i<l;i++) {
            if(!setmath.contains(a,b[i])) {
                out.push(b[i]);
            }
        }
        return out;
    },
    /** Intersection of two sets
     * @param {set} a
     * @param {set} b
     * @returns {set}
     */
    intersection: function(a,b) {
        return a.filter(function(v) {
            return setmath.contains(b,v);
        });
    },
    /** Are two sets equal? Yes if a,b and (a intersect b) all have the same length
     * @param {set} a
     * @param {set} b
     * @returns {Boolean}
     */
    eq: function(a,b) {
        return a.length==b.length && setmath.intersection(a,b).length==a.length;
    },
    /** Set minus - remove b's elements from a
     * @param {set} a
     * @param {set} b
     * @returns {set}
     */
    minus: function(a,b) {
        return a.filter(function(v){ return !setmath.contains(b,v); });
    },
    /** Size of a set
     * @param {set} set
     * @returns {Number}
     */
    size: function(set) {
        return set.length;
    }
}
});

Numbas.queueScript('mathjax-hooks',['display-base','jme','jme-display'],function() {
    var jme = Numbas.jme;
    Numbas.display.MathJaxQueue = MathJax.Callback.Queue(MathJax.Hub.Register.StartupHook('End',{}));
    MathJax.Hub.Register.MessageHook("Math Processing Error",function(message){
        var elem = message[1];
        var contexts = [];
        while(elem.parentElement) {
            var context = Numbas.display.getLocalisedAttribute(elem,'data-jme-context-description');
            if(context) {
                contexts.splice(0,0,context);
            }
            elem = elem.parentElement;
        }
        var context_description = contexts.join(' ');
        throw(new Numbas.Error(context_description ? 'mathjax.error with context' : 'mathjax.error',{context: context_description, message:message[2].message}));
    });
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
        var TEX = MathJax.InputJax.TeX;
        var currentScope = null;
        TEX.prefilterHooks.Add(function(data) {
            currentScope = $(data.script).parents('.jme-scope').first().data('jme-scope');
        });
        TEX.Definitions.Add({macros: {
            'var': 'JMEvar',
            'simplify': 'JMEsimplify'
        }});
        TEX.Parse.Augment({
            JMEvar: function(name) {
                var settings_string = this.GetBrackets(name);
                var settings = {};
                if(settings_string!==undefined) {
                    settings_string.split(/\s*,\s*/g).forEach(function(v) {
                        var setting = v.trim().toLowerCase();
                        settings[setting] = true;
                    });
                }
                var expr = this.GetArgument(name);
                var scope = currentScope;
                try {
                    var v = jme.evaluate(jme.compile(expr,scope),scope);
                    var tex = jme.display.texify({tok: v},settings);
                }catch(e) {
                    throw(new Numbas.Error('mathjax.math processing error',{message:e.message,expression:expr}));
                }
                var mml = TEX.Parse(tex,this.stack.env).mml();
                this.Push(mml);
            },
            JMEsimplify: function(name) {
                var rules = this.GetBrackets(name);
                if(rules===undefined) {
                    rules = 'all';
                }
                var expr = this.GetArgument(name);
                var scope = currentScope;
                expr = jme.subvars(expr,scope);
                var tex = jme.display.exprToLaTeX(expr,rules,scope);
                var mml = TEX.Parse(tex,this.stack.env).mml();
                this.Push(mml);
            }
        })
    });
});

Numbas.queueScript('part-display',['display-base','util'],function() {
    var display = Numbas.display;
    var extend = Numbas.util.extend;
    var util = Numbas.util;
    /** Display methods for a generic question part
     * @name PartDisplay
     * @memberof Numbas.display
     * @constructor
     * @param {Numbas.parts.Part} p - the associated part object
     */
    display.PartDisplay = function(p)
    {
        var pd = this;
        /** The associated part object
         * @member {Numbas.parts.Part} part
         * @memberof Numbas.display.PartDisplay
         */
        this.part = p;
        /** The question this part belongs to
         * @member {Numbas.Question} question
         * @memberof Numbas.display.PartDisplay
         */
        this.question = p.question;
        /** The student's current score ({@link Numbas.parts.Part#score})
         * @member {observable|Number} score
         * @memberof Numbas.display.PartDisplay
         */
        this.score = Knockout.observable(p.score);
        /** The total marks available for this part ({@link Numbas.parts.Part#marks})
         * @member {observable|Number} marks
         * @memberof Numbas.display.PartDisplay
         */
        this.marks = Knockout.observable(p.marks);
        /** Proportion of available marks awarded to the student - i.e. `score/marks`. Penalties will affect this instead of the raw score, because of things like the steps marking algorithm.
         * @member {observable|Number} credit
         * @memberof Numbas.display.PartDisplay
         */
        this.credit = Knockout.observable(p.credit);
        /** Does this part do any marking?
         * @member {observable|Boolean} doesMarking
         * @see Numbas.parts.Part#doesMarking
         * @memberof Numbas.display.PartDisplay
         */
        this.doesMarking = Knockout.observable(p.doesMarking);
        /** Has the student answered this part?
         * @member {observable|Boolean} answered
         * @memberof Numbas.display.PartDisplay
         */
        this.answered = Knockout.observable(p.answered);
        /** Has the student changed their answer since the last submission?
         * @member {observable|Boolean} isDirty
         * @memberof Numbas.display.PartDisplay
         */
        this.isDirty = Knockout.observable(false);
        /** Warnings based on the student's answer
         * @member {observable|Array.<Object.<String>>} warnings
         * @memberof Numbas.display.PartDisplay
         */
        this.warnings = Knockout.observableArray([]);
        /** Are the warnings visible?
         * @member {observable|Boolean} warningsShown
         * @memberof Numbas.display.PartDisplay
         */
        this.warningsShown = Knockout.observable(false);
        /** Show the warnings
         * @member {function} showWarnings
         * @method
         * @memberof Numbas.display.PartDisplay
         */
        this.showWarnings = function() {
            this.warningsShown(true);
        }
        /** Hide the warnings
         * @member {function} hideWarnings
         * @method
         * @memberof Numbas.display.PartDisplay
         */
        this.hideWarnings = function() {
            this.warningsShown(false);
        }
        /** Are the marking feedback messages visible?
         * @member {observable|Boolean} feedbackShown
         * @memberof Numbas.display.PartDisplay
         */
        this.feedbackShown = Knockout.observable(false);
        /** Text for the button to toggle the display of the feedback messages
         * @member {observable|String} toggleFeedbackText
         * @memberof Numbas.display.PartDisplay
         */
        this.toggleFeedbackText = Knockout.computed(function() {
            return R(this.feedbackShown() ? 'question.score feedback.hide' : 'question.score feedback.show');
        },this);
        /** Feedback messages
         * @member {observable|String[]} feedbackMessages
         * @memberof Numbas.display.PartDisplay
         */
        this.feedbackMessages = Knockout.observableArray([]);
        /** Are there other parts in line with this one? (Used to decide whether to show the submit button and feedback text)
         * True if there's more than one part in the question, or this is a step.
         * @member {observable|Boolean} isNotOnlyPart
         * @memberof Numbas.display.PartDisplay
         */
        this.isNotOnlyPart = Knockout.computed(function() {
            return this.question.display.numParts()>1 || this.part.isStep;
        },this);
        /** Have the steps ever been shown? ({@link Numbas.parts.Part#stepsShown})
         * @member {observable|Boolean} stepsShown
         * @memberof Numbas.display.PartDisplay
         */
        this.stepsShown = Knockout.observable(p.stepsShown);
        /** Are the steps currently open? ({@link Numbas.parts.Part#stepsOpen})
         * @member {observable|Boolean} stepsOpen
         * @memberof Numbas.display.PartDisplay
         */
        this.stepsOpen = Knockout.observable(p.stepsOpen);
        /** Have the correct answers been revealed?
         * @member {observable|Boolean} revealed
         * @memberof Numbas.display.PartDisplay
         */
        this.revealed = Knockout.observable(false);
        /** Show the "submit part" button?
         * @member {observable|Boolean} showSubmitPart
         * @memberof Numbas.display.PartDisplay
         */
        this.showSubmitPart = Knockout.computed(function() {
            return this.doesMarking() && !this.revealed();
        },this);
        /** Text to describe the state of the steps penalty
         * @member {observable|String} stepsPenaltyMessage
         * @memberof Numbas.display.PartDisplay
         */
        this.stepsPenaltyMessage = Knockout.computed(function() {
            if(this.stepsOpen()) {
                return R('question.hide steps no penalty');
            } else if(this.part.settings.stepsPenalty==0 || this.revealed()) {
                return R('question.show steps no penalty');
            } else if(this.stepsShown()) {
                return R('question.show steps already penalised');
            } else {
                return R('question.show steps penalty',{count:this.part.settings.stepsPenalty});
            }
        },this);
        /** Should the correct answer be shown? True if revealed and {@link Numbas.parts.Part#settings.showCorrectAnswer}) is true
         * @member {observable|Boolean} showCorrectAnswer
         * @memberof Numbas.display.PartDisplay
         */
        this.showCorrectAnswer = Knockout.computed(function() {
            return p.settings.showCorrectAnswer && pd.revealed();
        });
        var feedback_settings = Numbas.util.copyobj(p.question.exam.settings);
        feedback_settings.showFeedbackIcon = p.settings.showFeedbackIcon;
        if(p.parentPart && p.parentPart.type=='gapfill' && p.parentPart.settings.sortAnswers) {
            feedback_settings.showFeedbackIcon = false;
            feedback_settings.showAnswerState = false;
        }
        /** Display of this parts's current score / answered status
         * @member {observable|Numbas.display.scoreFeedback} scoreFeedback
         * @memberof Numbas.display.PartDisplay
         */
        this.scoreFeedback = display.showScoreFeedback(this, feedback_settings);
        /** Should feedback icons be shown for this part?
         * @member {observable|Boolean} showFeedbackIcon
         * @memberof Numbas.display.PartDisplay
         */
        this.showFeedbackIcon = ko.observable(feedback_settings.showFeedbackIcon);
        /** Show the marks feedback?
         * @member {observable|Boolean} showMarks
         * @memberof Numbas.display.PartDisplay
         */
        this.showMarks = Knockout.computed(function() {
            return this.scoreFeedback.message() && (this.isNotOnlyPart() || this.scoreFeedback.iconClass());
        }, this);
        /** Should the box containing part marks and the submit and feedback buttons be shown?
         * @member {observable|Boolean} showFeedbackBox
         * @memberof Numbas.display.PartDisplay
         */
        this.showFeedbackBox = Knockout.computed(function() {
            return this.doesMarking() && this.showMarks();
        },this);
        /** Should the feedback messages be shown?
         * @member {observable|Boolean} showFeedbackMessages
         * @memberof Numbas.display.PartDisplay
         */
        this.showFeedbackMessages = Knockout.pureComputed(function() {
            var e = p.question.exam;
            return (p.question.display.revealed() || e.settings.showAnswerState) && pd.feedbackMessages().length;            
        },this);

        /** Control functions
         * @member {Object} controls
         * @memberof Numbas.display.PartDisplay
         * @property {function} toggleFeedback - Toggle the display of the marking feedback messages
         * @property {function} submit - Submit the student's answers for marking
         * @property {function} showSteps - Show the steps
         * @property {function} hideSteps - Hide the steps
         */
        this.controls = {
            toggleFeedback: function() {
                pd.feedbackShown(!pd.feedbackShown());
            },
            submit: function() {
                var np = p;
                while(np.isGap)
                    np = np.parentPart;
                np.submit();
                if(!np.answered)
                {
                    Numbas.display.showAlert(R('question.can not submit'));
                }
                Numbas.store.save();
            },
            showSteps: function() {
                p.showSteps();
            },
            hideSteps: function() {
                p.hideSteps();
            }
        }
        /** Event bindings
         * @member {Object} inputEvents
         * @memberof Numbas.display.PartDisplay
         */
        this.inputEvents = {
            keypress: function(context,e) {
                if(e.which==13) {
                    pd.controls.submit();
                }
                else
                    return true;
            }
        }
        var label = p.isStep ? 'step' : p.isGap ? 'gap' : 'part';
        var index = p.isStep || p.isGap ? p.index : util.letterOrdinal(p.index);
        p.xml.setAttribute('jme-context-description',R(label)+' '+index);
    }
    display.PartDisplay.prototype = /** @lends Numbas.display.PartDisplay.prototype */
    {
        /** Show a warning message about this part
         * @param {String} warning
         * @memberof Numbas.display.PartDisplay
         */
        warning: function(warning)
        {
            this.warnings.push({message:warning+''});
        },
        /** Set the list of warnings
         * @param {Array.<String>} warnings
         * @memberof Numbas.display.PartDisplay
         */
        setWarnings: function(warnings) {
            this.warnings(warnings.map(function(warning){return {message: warning+''}}));
        },
        /** Remove all previously displayed warnings
         * @memberof Numbas.display.PartDisplay
         */
        removeWarnings: function()
        {
            this.part.removeWarnings();
        },
        /** Called when the part is displayed (basically when question is changed)
         * @see Numbas.display.QuestionDisplay.show
         * @memberof Numbas.display.PartDisplay
         */
        show: function()
        {
            var p = this.part;
            this.feedbackShown(false);
            this.showScore(this.part.answered,true);
        },
        /** Show/update the student's score and answer status on this part
         * @memberof Numbas.display.PartDisplay
         */
        showScore: function(valid,noUpdate)
        {
            var p = this.part;
            var exam = p.question.exam;
            this.score(p.score);
            this.marks(p.marks);
            this.credit(p.credit);
            if(!noUpdate) {
                this.scoreFeedback.update(true);
            }
            if(valid===undefined)
                valid = this.part.answered;
            this.answered(valid);
            if(this.part.markingFeedback.length && !this.part.question.revealed)
            {
                var messages = [];
                var maxMarks = this.part.marks - (this.part.stepsShown ? this.part.settings.stepsPenalty : 0);
                var t = 0;
                for(var i=0;i<this.part.markingFeedback.length;i++)
                {
                    var action = this.part.markingFeedback[i];
                    var change = action.credit*maxMarks;
                    var credit_change = action.credit;
                    if(action.gap!=undefined) {
                        change *= this.part.gaps[action.gap].marks/this.part.marks;
                        credit_change *= this.part.marks>0 ? this.part.gaps[action.gap].marks/this.part.marks : 1/this.part.gaps.length;
                    }
                    t += change;
                    var message = action.message || '';
                    if(util.isNonemptyHTML(message))
                    {
                        var marks = Math.abs(change);
                        if(change>0)
                            message+='\n\n'+R('feedback.you were awarded',{count:marks});
                        else if(change<0)
                            message+='\n\n'+R('feedback.taken away',{count:marks});
                    }
                    var change_desc = credit_change>0 ? 'positive' : credit_change<0 ? 'negative' : 'neutral';
                    switch(action.reason) {
                        case 'correct':
                            change_desc = 'positive';
                            break;
                        case 'incorrect':
                            change_desc = 'negative';
                            break;
                        case 'invalid':
                            change_desc = 'invalid';
                            break;
                    }
                    var icons = {
                        'positive': 'icon-ok',
                        'negative': 'icon-remove',
                        'neutral': '',
                        'invalid': 'icon-exclamation-sign'
                    }
                    if(util.isNonemptyHTML(message)) {
                        messages.push({credit_change: change_desc, message: message, icon: icons[change_desc]});
                    }
                }
                this.feedbackMessages(messages);
            }
        },
        /** Called when 'show steps' button is pressed, or coming back to a part after steps shown
         * @memberof Numbas.display.PartDisplay
         */
        showSteps: function() {
            this.stepsShown(this.part.stepsShown);
            this.stepsOpen(this.part.stepsOpen);
            for(var i=0;i<this.part.steps.length;i++)
            {
                this.part.steps[i].display.show();
            }
        },
        /** Hide the steps
         * @memberof Numbas.display.PartDisplay
         */
        hideSteps: function()
        {
            this.stepsOpen(this.part.stepsOpen);
        },
        /** Fill the student's last submitted answer into inputs
         * @abstract
         * @memberof Numbas.display.PartDisplay
         */
        restoreAnswer: function()
        {
        },
        /** Show the correct answers to this part
         * @memberof Numbas.display.PartDisplay
         */
        revealAnswer: function()
        {
            this.revealed(true);
            this.removeWarnings();
            this.showScore();
        },
        /** Initialise this part's display
         * @see Numbas.display.QuestionDisplay.init
         * @memberof Numbas.display.PartDisplay
         */
        init: function() {
            this.part.setDirty(false);
            for(var i=0;i<this.part.steps.length;i++) {
                this.part.steps[i].display.init();
            }
        },
        /** Called when the exam ends
         * @memberof Numbas.display.PartDisplay
         */
        end: function() {
            this.restoreAnswer();
            for(var i=0;i<this.part.steps.length;i++) {
                this.part.steps[i].display.end();
            }
        }
    };
});

/*
Copyright 2011-14 Newcastle University
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/** @file {@link Numbas.parts}, {@link Numbas.partConstructors}, {@link Numbas.createPart} and the generic {@link Numbas.parts.Part} object */
Numbas.queueScript('part',['base','jme','jme-variables','util','marking'],function() {
var util = Numbas.util;
var jme = Numbas.jme;
var math = Numbas.math;
var marking = Numbas.marking;

/** Definitions of custom part types
 * @name custom_part_types
 * @type {Object}
 * @memberof Numbas
 */

/** A unique identifier for a {@link Numbas.parts.Part} object, of the form `qXpY[gZ|sZ]`. Numbering starts from zero, and the `gZ` bit is used only when the part is a gap, and `sZ` is used if it's a step.
 * @typedef Numbas.parts.partpath
 * @type {String}
 */
/** Part type constructors
 * These functions aren't called directly - they're the original part constructor objects before they're extended with the generic part methods, kept for reference so their methods can be reused by other parts
 * @see Numbas.partConstructors
 * @namespace Numbas.parts
 * @memberof Numbas
 */
Numbas.parts = {};
/** Associate part type names with their object constructors
 * These constructors are called by {@link Numbas.createPart} - they should be finalised constructors with all the generic part methods implemented.
 * Most often, you do this by extending {@link Numbas.parts.Part}
 * @memberof Numbas
 */
var partConstructors = Numbas.partConstructors = {};
/** Create a question part based on an XML definition.
 * @memberof Numbas
 * @param {Element} xml
 * @param {Numbas.parts.partpath} [path]
 * @param {Numbas.Question} [question]
 * @param {Numbas.parts.Part} [parentPart]
 * @param {Numbas.storage.BlankStorage} [store] - the storage engine to use
 * @returns {Numbas.parts.Part}
 * @throws {Numbas.Error} "part.missing type attribute" if the top node in `xml` doesn't have a "type" attribute.
 */
var createPartFromXML = Numbas.createPartFromXML = function(xml, path, question, parentPart, store) {
    var tryGetAttribute = Numbas.xml.tryGetAttribute;
    var type = tryGetAttribute(null,xml,'.','type',[]);
    if(type==null) {
        throw(new Numbas.Error('part.missing type attribute',{part:util.nicePartName(path)}));
    }
    var part = createPart(type, path, question, parentPart, store);
    part.loadFromXML(xml);
    part.finaliseLoad();
    return part;
}
/** Create a question part based on an XML definition.
 * @memberof Numbas
 * @param {Object} data
 * @param {Numbas.parts.partpath} [path]
 * @param {Numbas.Question} [question]
 * @param {Numbas.parts.Part} [parentPart]
 * @param {Numbas.storage.BlankStorage} [store] - the storage engine to use
 * @returns {Numbas.parts.Part}
 * @throws {Numbas.Error} "part.missing type attribute" if `data` doesn't have a "type" attribute.
 */
var createPartFromJSON = Numbas.createPartFromJSON = function(data, path, question, parentPart, store) {
    if(!data.type) {
        throw(new Numbas.Error('part.missing type attribute',{part:util.nicePartName(path)}));
    }
    var part = createPart(data.type, path, question, parentPart, store);
    part.loadFromJSON(data);
    part.finaliseLoad();
    return part;
}
/** Create a new question part.
 * @see Numbas.partConstructors
 * @param {String} type
 * @param {Numbas.parts.partpath} path
 * @param {Numbas.Question} question
 * @param {Numbas.parts.Part} parentPart
 * @param {Numbas.storage.BlankStorage} [store] - the storage engine to use
 * @returns {Numbas.parts.Part}
 * @throws {Numbas.Error} "part.unknown type" if the given part type is not in {@link Numbas.partConstructors}
 * @memberof Numbas
 */
var createPart = Numbas.createPart = function(type, path, question, parentPart, store)
{
    if(partConstructors[type])
    {
        var cons = partConstructors[type];
        var part = new cons(path, question, parentPart, store);
        part.type = type;
        return part;
    }
    else {
        throw(new Numbas.Error('part.unknown type',{part:util.nicePartName(path),type:type}));
    }
}

/** Base question part object
 * @constructor
 * @memberof Numbas.parts
 * @param {Numbas.parts.partpath} [path='p0']
 * @param {Numbas.Question} question
 * @param {Numbas.parts.Part} parentPart
 * @param {Numbas.storage.BlankStorage} [store]
 * @see Numbas.createPart
 */
var Part = Numbas.parts.Part = function( path, question, parentPart, store)
{
    var p = this;
    this.store = store;
    //remember parent question object
    this.question = question;
    //remember parent part object, so scores can percolate up for steps/gaps
    this.parentPart = parentPart;
    //remember a path for this part, for stuff like marking and warnings
    this.path = path || 'p0';
    if(this.question) {
    this.question.partDictionary[path] = this;
    }
    this.index = parseInt(this.path.match(/\d+$/));
    //initialise settings object
    this.settings = util.copyobj(Part.prototype.settings);
    //initialise gap and step arrays
    this.gaps = [];
    this.steps = [];
    this.isStep = false;
    this.settings.errorCarriedForwardReplacements = [];
    this.errorCarriedForwardBackReferences = {};
    this.markingFeedback = [];
    this.finalised_result = {valid: false, credit: 0, states: []};
    this.warnings = [];
    this.scripts = {};
}
Part.prototype = /** @lends Numbas.parts.Part.prototype */ {
    /** Storage engine
     * @type {Numbas.storage.BlankStorage}
     */
    store: undefined,
    /** XML defining this part
     * @type {Element}
     */
    xml: '',
    /** Load the part's settings from an XML <part> node
     * @param {Element} xml
     */
    loadFromXML: function(xml) {
        this.xml = xml;
        var tryGetAttribute = Numbas.xml.tryGetAttribute;
        tryGetAttribute(this,this.xml,'.',['type','marks']);
        tryGetAttribute(this.settings,this.xml,'.',['minimumMarks','enableMinimumMarks','stepsPenalty','showCorrectAnswer','showFeedbackIcon'],[]);
        //load steps
        var stepNodes = this.xml.selectNodes('steps/part');
        for(var i=0; i<stepNodes.length; i++)
        {
            var step = Numbas.createPartFromXML( stepNodes[i], this.path+'s'+i, this.question, this, this.store);
            this.addStep(step,i);
        }
        // set variable replacements
        var variableReplacementsNode = this.xml.selectSingleNode('adaptivemarking/variablereplacements');
        tryGetAttribute(this.settings,this.xml,variableReplacementsNode,['strategy'],['variableReplacementStrategy'])
        var replacementNodes = variableReplacementsNode.selectNodes('replace');
        this.settings.hasVariableReplacements = replacementNodes.length>0;
        for(var i=0;i<replacementNodes.length;i++) {
            var n = replacementNodes[i];
            var vr = {}
            tryGetAttribute(vr,n,'.',['variable','part','must_go_first']);
            this.addVariableReplacement(vr.variable, vr.part, vr.must_go_first);
        }
        // create the JME marking script for the part
        var markingScriptNode = this.xml.selectSingleNode('markingalgorithm');
        var markingScriptString = Numbas.xml.getTextContent(markingScriptNode).trim();
        var markingScript = {};
        tryGetAttribute(markingScript,this.xml,markingScriptNode,['extend']);
        if(markingScriptString) {
            // extend the base marking algorithm if asked to do so
            var extend_base = markingScript.extend;
            this.setMarkingScript(markingScriptString,extend_base);
        } else {
            this.markingScript = this.baseMarkingScript();
        }
        // custom JavaScript scripts
        var scriptNodes = this.xml.selectNodes('scripts/script');
        for(var i=0;i<scriptNodes.length; i++) {
            var name = scriptNodes[i].getAttribute('name');
            var order = scriptNodes[i].getAttribute('order');
            var script = Numbas.xml.getTextContent(scriptNodes[i]);
            this.setScript(name, order, script);
        }
    },
    /** Load the part's settings from a JSON object
     * @param {Object} data
     */
    loadFromJSON: function(data) {
        var p = this;
        var settings = this.settings;
        var tryLoad = Numbas.json.tryLoad;
        var tryGet = Numbas.json.tryGet;
        tryLoad(data,['marks'],this);
        this.marks = parseFloat(this.marks);
        tryLoad(data,['showCorrectAnswer', 'showFeedbackIcon', 'stepsPenalty','variableReplacementStrategy'],this.settings);
        var variableReplacements = tryGet(data, 'variableReplacements');
        if(variableReplacements) {
            variableReplacements.map(function(vr) {
                p.addVariableReplacement(vr.variable, vr.part, vr.must_go_first);
            });
        }
        if('steps' in data) {
            data.steps.map(function(sd,i) {
                var s = createPartFromJSON(sd, this.path+'s'+i, this.question, this, this.store);
                p.addStep(sd,i);
            });
        }
        var marking = {};
        tryLoad(data, ['customMarkingAlgorithm', 'extendBaseMarkingAlgorithm'], marking);
        if(marking.customMarkingAlgorithm) {
            this.setMarkingScript(marking.customMarkingAlgorithm, marking.extendBaseMarkingAlgorithm);
        } else {
            this.markingScript = this.baseMarkingScript();
        }
        if('scripts' in data) {
            for(var name in data.scripts) {
                var script = data.scripts[name];
                this.setScript(name, script.order, script.script);
            }
        }
    },
    /** Perform any tidying up or processing that needs to happen once the part's definition has been loaded
     */
    finaliseLoad: function() {
        this.applyScripts();
        if(this.customConstructor) {
            this.customConstructor.apply(this);
        }
        if(Numbas.display) {
            this.display = new Numbas.display.PartDisplay(this);
        }
    },
    /** Load saved data about this part from storage
     *  The part is not resubmitted - you must do this afterwards, once any steps or gaps have been resumed.
     */
    resume: function() {
        var part = this;
        if(!this.store) {
            return;
        }
        var pobj = this.store.loadPart(this);
        this.answered = pobj.answered;
        this.stepsShown = pobj.stepsShown;
        this.stepsOpen = pobj.stepsOpen;
        this.steps.forEach(function(s){ s.resume() });
        this.display && this.question.signals.on(['ready','HTMLAttached'], function() {
            part.display.restoreAnswer();
        })
    },
    /** Add a step to this part
     * @param {Numbas.parts.Part} step
     * @param {Number} index - position of the step
     */
    addStep: function(step, index) {
        step.isStep = true;
        this.steps.splice(index,0,step);
        this.stepsMarks += step.marks;
    },
    /** Add a variable replacement for this part's adaptive marking
     * @param {String} variable - the name of the variable to replace
     * @param {String} part - the path of the part to use
     * @param {Boolean} must_go_first - Must the referred part be answered before this part can be marked?
     */
    addVariableReplacement: function(variable, part, must_go_first) {
        var vr = {
            variable: variable.toLowerCase(),
            part: part,
            must_go_first: must_go_first
        };
        this.settings.errorCarriedForwardReplacements.push(vr);
    },
    /** The base marking script for this part.
     * @abstract
     * @returns {Numbas.marking.MarkingScript}
     */
    baseMarkingScript: function() {},
    /** Set this part's JME marking script
     * @param {String} markingScriptString
     * @param {Boolean} extend_base - Does this script extend the built-in script?
     */
    setMarkingScript: function(markingScriptString, extend_base) {
        var p = this;
        var oldMarkingScript = this.baseMarkingScript();
        var algo = this.markingScript = new marking.MarkingScript(markingScriptString, extend_base ? oldMarkingScript : undefined);
        // check that the required notes are present
        var requiredNotes = ['mark','interpreted_answer'];
        requiredNotes.forEach(function(name) {
            if(!(name in algo.notes)) {
                p.error("part.marking.missing required note",{note:name});
            }
        });
    },
    /** Set a custom JavaScript script
     * @param {String} name - the name of the method to override
     * @param {String} order - When should the script run? `'instead'`, `'before'` or `'after'`
     * @param {String} script - the source code of the script
     * @see {Numbas.parts.Part#applyScripts}
     */
    setScript: function(name,order,script) {
        var withEnv = {
            variables: this.question ? this.question.unwrappedVariables : {},
            question: this.question,
            part: this
        };
        if(name=='mark') {
            // hack on a finalised_state for old marking scripts
            script = 'var res = (function() {'+script+'\n}).apply(this); this.answered = true; return res || {states: this.markingFeedback.slice(), valid: true, credit: this.credit};';
        }
        with(withEnv) {
            script = eval('(function(){try{'+script+'\n}catch(e){Numbas.showError(new Numbas.Error(\'part.script.error\',{path:util.nicePartName(this.path),script:name,message:e.message}))}})');
        }
        this.scripts[name] = {script: script, order: order};
    },
    /** The question this part belongs to
     * @type {Numbas.Question}
     */
    question: undefined,
    /** Reference to parent of this part, if this is a gap or a step
     * @type {Numbas.parts.Part}
     */
    parentPart: undefined,
    /** A question-wide unique 'address' for this part.
     * @type {Numbas.parts.partpath}
     */
    path: '',
    /** This part's type, e.g. "jme", "numberentry", ...
     * @type {String}
     */
    type: '',
    /** Maximum marks available for this part
     * @type {Number}
     */
    marks: 0,
    /** Marks available for the steps, if any
     * @type {Number}
     */
    stepsMarks: 0,
    /** Proportion of available marks awarded to the student - i.e. `score/marks`. Penalties will affect this instead of the raw score, because of things like the steps marking algorithm.
     * @type {Number}
     */
    credit: 0,
    /** Student's score on this part
     * @type {Number}
     */
    score: 0,
    /** Messages explaining how marks were awarded
     * @type {Array.<Numbas.parts.feedbackmessage>}
     */
    markingFeedback: [],
    /** The result of the last marking run
     * @type {Numbas.marking.finalised_state}
     */
    finalised_result: {valid: false, credit: 0, states: []},
    /** Warnings shown next to the student's answer
     * @type {Array.<String>}
     */
    warnings: [],
    /** Has the student changed their answer since last submitting?
     * @type {Boolean}
     */
    isDirty: false,
    /** Student's answers as visible on the screen (not necessarily yet submitted)
     * @type {Array.<String>}
     */
    stagedAnswer: undefined,

    /** Has this part been answered?
     * @type {Boolean}
     */
    answered: false,

    /** Child gapfill parts
     * @type {Numbas.parts.Part[]}
     */
    gaps: [],
    /** Child step parts
     * @type {Numbas.parts.Part[]}
     */
    steps: [],
    /** Have the steps been show for this part?
     * @type {Boolean}
     */
    stepsShown: false,
    /** Is the steps display open? (Students can toggle it, but that doesn't affect whether they get the penalty)
     * @type {Boolean}
     */
    stepsOpen: false,
    /** True if this part should be resubmitted because another part it depended on has changed
     * @type {Boolean}
     */
    shouldResubmit: false,
    /** Does this mark do any marking? False for information only parts
     * @type {Boolean}
     */
    doesMarking: true,
    /** Properties set when the part is generated
     * @type {Object}
     * @property {Number} stepsPenalty - Number of marks to deduct when the steps are shown
     * @property {Boolean} enableMinimumMarks - Is there a lower limit on the score the student can be awarded for this part?
     * @property {Number} minimumMarks - Lower limit on the score the student can be awarded for this part
     * @property {Boolean} showCorrectAnswer - Show the correct answer on reveal?
     * @property {Boolean} showFeedbackIcon - Show the tick/cross feedback symbol after this part is submitted?
     * @property {Boolean} hasVariableReplacements - Does this part have any variable replacement rules?
     * @property {String} variableReplacementStrategy - `'originalfirst'` or `'alwaysreplace'`
     */
    settings:
    {
        stepsPenalty: 0,
        enableMinimumMarks: true,
        minimumMarks: 0,
        showCorrectAnswer: true,
        showFeedbackIcon: true,
        hasVariableReplacements: false,
        variableReplacementStrategy: 'originalfirst'
    },

    /** The script to mark this part - assign credit, and give messages and feedback.
     * @type {Numbas.marking.MarkingScript}
     */
    markingScript: null,

    /** Throw an error, with the part's identifier prepended to the message
     * @param {String} message
     * @throws {Numbas.Error}
     */
    error: function(message) {
        message = R.apply(this,arguments);
        var niceName = Numbas.util.capitalise(util.nicePartName(this.path));
        throw(new Numbas.Error('part.error',{path: niceName, message: message}));
    },
    /** The name of the input widget this part uses, if any.
     * @returns {String}
     */
    input_widget: function() {
        return null;
    },
    /** Options for this part's input widget
     * @returns {Object}
     */
    input_options: function() {
        return {};
    },
    applyScripts: function() {
        var part = this;
        this.originalScripts = {};
        for(var name in this.scripts) {
            var script_dict = this.scripts[name];
            var order = script_dict.order;
            var script = script_dict.script;
            switch(name) {
                case 'constructor':
                    this.customConstructor = script;
                    break;
                default:
                    var originalScript = this[name];
                    /** Create a function which runs `script` (instead of the built-in script)
                     * @param {Function} script
                     * @returns {Function}
                     */
                    function instead(script) {
                        return function() {
                            return script.apply(part,arguments);
                        }
                    }
                    /** Create a function which runs `script` before `originalScript`
                     * @param {Function} script
                     * @param {Function} originalScript
                     * @returns {Function}
                     */
                    function before(script,originalScript) {
                        return function() {
                            script.apply(part,arguments);
                            return originalScript.apply(part,arguments);
                        }
                    }
                    /** Create a function which runs `script` after `originalScript`
                     * @param {Function} script
                     * @param {Function} originalScript
                     * @returns {Function}
                     */
                    function after(script,originalScript) {
                        return function() {
                            originalScript.apply(part,arguments);
                            return script.apply(part,arguments);
                        }
                    }
                    switch(order) {
                        case 'instead':
                            this[name] = instead(script);
                            break;
                        case 'before':
                            this[name] = before(script,originalScript);
                            break;
                        case 'after':
                            this[name] = after(script,originalScript);
                            break;
                    }
            }
        }
    },
    /** Associated display object. It is not safe to assume this is always present - in the editor, parts have no display.
     * @type {Numbas.display.PartDisplay}
     */
    display: undefined,
    /** Give the student a warning about this part.
     * @param {String} warning
     * @see Numbas.display.PartDisplay.warning
     */
    giveWarning: function(warning)
    {
        this.warnings.push(warning);
        this.display && this.display.warning(warning);
    },
    /** Set the list of warnings
     * @param {Array.<String>} warnings
     * @see Numbas.display.PartDisplay.warning
     */
    setWarnings: function(warnings) {
        this.warnings = warnings;
        this.display && this.display.setWarnings(warnings);
    },
    /** Remove all warnings
     * @see Numbas.display.PartDisplay.warning
     */
    removeWarnings: function() {
        this.setWarnings([]);
    },
    /** Calculate the student's score based on their submitted answers
     *
     * Calls the parent part's `calculateScore` method at the end.
     */
    calculateScore: function()
    {
        if(this.steps.length && this.stepsShown)
        {
            var oScore = this.score = (this.marks - this.settings.stepsPenalty) * this.credit;     //score for main keypart
            var stepsScore = 0, stepsMarks=0;
            for(var i=0; i<this.steps.length; i++)
            {
                stepsScore += this.steps[i].score;
                stepsMarks += this.steps[i].marks;
            }
            var stepsFraction = Math.max(Math.min(1-this.credit,1),0);    //any credit not earned in main part can be earned back in steps
            this.score += stepsScore;                        //add score from steps to total score
            this.score = Math.min(this.score,this.marks - this.settings.stepsPenalty)    //if too many marks are awarded for steps, it's possible that getting all the steps right leads to a higher score than just getting the part right. Clip the score to avoid this.
            if(this.settings.enableMinimumMarks && this.score<this.settings.minimumMarks) {
                this.score = this.settings.minimumMarks;
                this.credit = this.marks!=0 ? this.settings.minimumMarks/this.marks : 0;
                this.markingComment(R('part.marking.minimum score applied',{score:this.settings.minimumMarks}));
            }
            if(stepsMarks!=0 && stepsScore!=0)
            {
                if(this.credit==1)
                    this.markingComment(R('part.marking.steps no matter'));
                else
                {
                    var change = this.score - oScore;
                    if(this.submitting) {
                        this.markingComment(R('part.marking.steps change',{count:change}));
                    }
                }
            }
        }
        else
        {
            this.score = this.credit * this.marks;
            if(this.settings.enableMinimumMarks && this.score<this.settings.minimumMarks) {
                this.score = this.settings.minimumMarks;
                this.credit = this.marks!=0 ? this.settings.minimumMarks/this.marks : 0;
                this.markingComment(R('part.marking.minimum score applied',{score:this.settings.minimumMarks}));
            }
        }
        if(this.revealed) {
            this.score = 0;
        }
        if(this.parentPart && !this.parentPart.submitting)
            this.parentPart.calculateScore();
        this.display && this.display.showScore(this.answered);
    },
    /** Update the stored answer from the student (called when the student changes their answer, but before submitting)
     * @param {*} answer
     * @see {Numbas.parts.Part.stagedAnswer}
     */
    storeAnswer: function(answer) {
        this.stagedAnswer = answer;
        this.setDirty(true);
        this.display && this.display.removeWarnings();
    },
    /** Call when the student changes their answer, or submits - update {@link Numbas.parts.Part.isDirty}
     * @param {Boolean} dirty
     */
    setDirty: function(dirty) {
        this.isDirty = dirty;
        if(this.display) {
            this.display && this.display.isDirty(dirty);
            if(dirty && this.parentPart && !this.isStep && !this.parentPart.submitting) {
                this.parentPart.setDirty(true);
            }
            this.question && this.question.display && this.question.display.isDirty(this.question.isDirty());
        }
    },
    /** Get a JME scope for this part.
     * If `this.question` is set, use the question's scope. Otherwise, use {@link Numbas.jme.builtinScope}.
     * @returns {Numbas.jme.Scope}
     */
    getScope: function() {
        if(!this.scope) {
            if(this.question) {
                this.scope = this.question.scope;
            } else {
                this.scope = new Numbas.jme.Scope(Numbas.jme.builtinScope);
            }
        }
        return this.scope;
    },
    /** Submit the student's answers to this part - remove warnings. save answer, calculate marks, update scores
     */
    submit: function() {
        this.shouldResubmit = false;
        this.credit = 0;
        this.markingFeedback = [];
        this.finalised_result = {valid: false, credit: 0, states: []};
        this.submitting = true;
        if(this.parentPart && !this.parentPart.submitting) {
            this.parentPart.setDirty(true);
        }
        if(this.stepsShown)
        {
            var stepsMax = this.marks - this.settings.stepsPenalty;
            this.markingComment(
                this.settings.stepsPenalty>0
                    ? R('part.marking.revealed steps with penalty',{count:stepsMax})
                    : R('part.marking.revealed steps no penalty'));
        }
        this.setStudentAnswer();
        if(this.doesMarking) {
            if(this.hasStagedAnswer()) {
                this.display && this.display.removeWarnings();
                this.setDirty(false);
                // save existing feedback
                var existing_feedback = {
                    warnings: this.warnings.slice(),
                    markingFeedback: this.markingFeedback.slice()
                };
                var result;
                var try_replacement;
                try{
                    if(this.settings.variableReplacementStrategy=='originalfirst') {
                        var result_original = this.markAgainstScope(this.getScope(),existing_feedback);
                        result = result_original;
                        var try_replacement = this.settings.hasVariableReplacements && (!result.answered || result.credit<1);
                    }
                    if(this.settings.variableReplacementStrategy=='alwaysreplace' || try_replacement) {
                        try {
                            var scope = this.errorCarriedForwardScope();
                            var result_replacement = this.markAgainstScope(scope,existing_feedback);
                            if(!(result_original) || (result_replacement.answered && result_replacement.credit>result_original.credit)) {
                                result = result_replacement;
                                result.finalised_result.states.splice(0,0,{op: Numbas.marking.FeedbackOps.FEEDBACK, message: R('part.marking.used variable replacements')});
                                result.markingFeedback.splice(0,0,{op: 'comment', message: R('part.marking.used variable replacements')});
                            }
                        } catch(e) {
                            try{
                                this.error(e.message);
                            } catch(pe) {
                                console.error(pe.message);
                            }
                        }
                    }
                    if(!result) {
                        this.setCredit(0,R('part.marking.no result after replacement'));
                        this.answered = true;
                    } else {
                        this.setWarnings(result.warnings);
                        this.markingFeedback = result.markingFeedback;
                        this.finalised_result = result.finalised_result;
                        this.credit = result.credit;
                        this.answered = result.answered;
                    }
                } catch(e) {
                    throw(new Numbas.Error('part.marking.uncaught error',{part:util.nicePartName(this.path),message:e.message}));
                }
            } else {
                this.giveWarning(R('part.marking.not submitted'));
                this.setCredit(0,R('part.marking.did not answer'));;
                this.answered = false;
            }
        }
        if(this.stepsShown) {
            for(var i=0;i<this.steps.length;i++) {
                if(this.steps[i].isDirty) {
                    this.steps[i].submit();
                }
            }
        }
        this.calculateScore();
        this.question && this.question.updateScore();
        if(this.answered)
        {
            if(!(this.parentPart && this.parentPart.type=='gapfill') && this.settings.showFeedbackIcon && this.marks!=0) {
                this.markingComment(
                    R('part.marking.total score',{count:this.score})
                );
            }
            this.display && this.display.showScore(this.answered);
        }
        this.store && this.store.partAnswered(this);
        this.submitting = false;
        if(this.answered && this.question) {
            for(var path in this.errorCarriedForwardBackReferences) {
                var p2 = this.question.getPart(path);
                p2.pleaseResubmit();
            }
        }
    },
    /** Has the student entered an answer to this part?
     * @see Numbas.parts.Part#stagedAnswer
     * @returns {Boolean}
     */
    hasStagedAnswer: function() {
        return !(this.stagedAnswer==undefined);
    },
    /** Called by another part when its marking means that the marking for this part might change (i.e., when this part replaces a variable with the answer from the other part)
     * Sets this part as dirty, and gives a warning explaining why the student must resubmit.
     */
    pleaseResubmit: function() {
        if(!this.shouldResubmit) {
            this.shouldResubmit = true;
            this.setDirty(true);
            this.giveWarning(R('part.marking.resubmit because of variable replacement'));
        }
    },
    /** @typedef {Object} Numbas.parts.feedbackmessage
     * @property {String} op - the kind of feedback
     * @see Numbas.parts.Part#setCredit Numbas.parts.Part#addCredit Numbas.parts.Part#multCredit Numbas.parts.Part#markingComment
     */
    /** @typedef {Object} Numbas.parts.marking_results
     * A dictionary representing the results of marking a student's answer.
     * @property {Array.<String>} warnings - Warning messages.
     * @property {Numbas.marking.finalised_state} finalised_result - sequence of marking operations
     * @property {Array.<Numbas.parts.feedbackmessage>} markingFeedback - Feedback messages to show to student, produced from `finalised_result`.
     * @property {Number} credit - Proportion of the available marks to award to the student.
     * @property {Boolean} answered - True if the student's answer could be marked. False if the answer was invalid - the student should change their answer and resubmit.
     */
    /** Calculate the correct answer in the given scope, and mark the student's answer
     * @param {Numbas.jme.Scope} scope - scope in which to calculate the correct answer
     * @param {Object.<Array.<String>>} feedback - dictionary of existing `warnings` and `markingFeedback` lists, to add to - copies of these are returned with any additional feedback appended
     * @returns {Numbas.parts.marking_results}
     */
    markAgainstScope: function(scope,feedback) {
        this.setWarnings(feedback.warnings.slice());
        this.markingFeedback = feedback.markingFeedback.slice();
        var finalised_result = {states: [], valid: false, credit: 0};
        try {
            finalised_result = this.mark(scope);
        } catch(e) {
            this.giveWarning(e.message);
        }
        return {
            warnings: this.warnings.slice(),
            markingFeedback: this.markingFeedback.slice(),
            finalised_result: finalised_result,
            credit: this.credit,
            answered: this.answered
        }
    },
    /** Replace variables with student's answers to previous parts
     * @returns {Numbas.jme.Scope}
     */
    errorCarriedForwardScope: function() {
        // dictionary of variables to replace
        var replace = this.settings.errorCarriedForwardReplacements;
        var replaced = [];
        if(!this.question) {
            return this.getScope();
        }
        // fill scope with new values of those variables
        var new_variables = {}
        for(var i=0;i<replace.length;i++) {
            var vr = replace[i];
            var p2 = this.question.getPart(vr.part);
            if(p2.answered) {
                new_variables[vr.variable] = p2.studentAnswerAsJME();
                replaced.push(vr.variable);
            } else if(vr.must_go_first) {
                throw(new Numbas.Error("part.marking.variable replacement part not answered",{part:util.nicePartName(vr.part)}));
            }
        }
        for(var i=0;i<replace.length;i++) {
            var p2 = this.question.getPart(replace[i].part);
            p2.errorCarriedForwardBackReferences[this.path] = true;
        }
        var scope = new Numbas.jme.Scope([this.question.scope,{variables: new_variables}])
        // find dependent variables which need to be recomputed
        var todo = Numbas.jme.variables.variableDependants(this.question.variablesTodo,replaced);
        for(var name in todo) {
            if(name in new_variables) {
                delete todo[name];
            } else {
                scope.deleteVariable(name);
            }
        }
        // compute those variables
        var nv = Numbas.jme.variables.makeVariables(todo,scope);
        scope = new Numbas.jme.Scope([scope,{variables:nv.variables}]);
        return scope;
    },
    /** Compute the correct answer, based on the given scope.
     * Anything to do with marking that depends on the scope should be in this method, and calling it with a new scope should update all the settings used by the marking algorithm.
     * @param {Numbas.jme.Scope} scope
     * @abstract
     */
    getCorrectAnswer: function(scope) {},
    /** Save an answer entered by the student, for use in marking.
     * @abstract
     */
    setStudentAnswer: function() {},
    /** Get the student's answer as it was entered as a JME data type, to be used in the marking script.
     * @abstract
     * @returns {Numbas.jme.token}
     */
    rawStudentAnswerAsJME: function() {
    },
    /** Get the student's answer as a JME data type, to be used in error-carried-forward calculations
     * @abstract
     * @returns {Numbas.jme.token}
     */
    studentAnswerAsJME: function() {
        return this.interpretedStudentAnswer;
    },
    /** Function which marks the student's answer: run `this.settings.markingScript`, which sets the credit for the student's answer to a number between 0 and 1 and produces a list of feedback messages and warnings.
     * If the question has been answered in a way that can be marked, `this.answered` should be set to `true`.
     * @see Numbas.parts.Part#markingScript
     * @see Numbas.parts.Part#answered
     * @param {Numbas.jme.Scope} scope
     * @returns {Numbas.marking.finalised_state}
     */
    mark: function(scope) {
        var studentAnswer = this.rawStudentAnswerAsJME();
        if(studentAnswer==undefined) {
            this.setCredit(0,R('part.marking.nothing entered'));
            return;
        }
        var result = this.mark_answer(studentAnswer,scope);
        var finalised_result = marking.finalise_state(result.states.mark)
        this.apply_feedback(finalised_result);
        this.interpretedStudentAnswer = result.values['interpreted_answer'];
        return finalised_result;
    },
    /** Apply a finalised list of feedback states to this part.
     * @param {Numbas.marking.feedback_item[]} feedback
     * @see Numbas.marking.finalise_state
     */
    apply_feedback: function(feedback) {
        var valid = feedback.valid;
        var part = this;
        var end = false;
        var states = feedback.states.slice();
        var i=0;
        var lifts = [];
        var scale = 1;
        while(i<states.length) {
            var state = states[i];
            var FeedbackOps = Numbas.marking.FeedbackOps;
            switch(state.op) {
                case FeedbackOps.SET_CREDIT:
                    part.setCredit(scale*state.credit, state.message, state.reason);
                    break;
                case FeedbackOps.MULTIPLY_CREDIT:
                    part.multCredit(scale*state.factor, state.message);
                    break;
                case FeedbackOps.ADD_CREDIT:
                    part.addCredit(scale*state.credit, state.message);
                    break;
                case FeedbackOps.SUB_CREDIT:
                    part.subCredit(scale*state.credit, state.message);
                    break;
                case FeedbackOps.WARNING:
                    part.giveWarning(state.message);
                    break;
                case FeedbackOps.FEEDBACK:
                    part.markingComment(state.message);
                    break;
                case FeedbackOps.END:
                    if(lifts.length) {
                        while(i+1<states.length && states[i+1].op!="end_lift") {
                            i += 1;
                        }
                    } else {
                        end = true;
                        if(state.invalid) {
                            valid = false;
                        }
                    }
                    break;
                case "start_lift":
                    lifts.push({credit: this.credit,scale:scale});
                    this.credit = 0;
                    scale = state.scale;
                    break;
                case 'end_lift':
                    var last_lift = lifts.pop();
                    var lift_credit = this.credit;
                    this.credit = last_lift.credit;
                    this.addCredit(lift_credit*last_lift.scale);
                    scale = last_lift.scale;
                    break;
            }
            i += 1;
            if(end) {
                break;
            }
        }
        part.answered = valid;
    },
    marking_parameters: function(studentAnswer) {
        studentAnswer = jme.makeSafe(studentAnswer);
        return {
            path: jme.wrapValue(this.path),
            question_definitions: jme.wrapValue(this.question ? this.question.local_definitions : {}),
            studentAnswer: studentAnswer,
            settings: jme.wrapValue(this.settings),
            marks: new jme.types.TNum(this.marks),
            partType: new jme.types.TString(this.type),
            gaps: jme.wrapValue(this.gaps.map(function(g){return g.marking_parameters(g.rawStudentAnswerAsJME())})),
            steps: jme.wrapValue(this.steps.map(function(s){return s.marking_parameters(s.rawStudentAnswerAsJME())}))
        };
    },
    /** Run the marking script against the given answer.
     * This does NOT apply the feedback and credit to the part object, it just returns it.
     * @param {Numbas.jme.token} studentAnswer
     * @param {Numbas.jme.Scope} scope
     * @see Numbas.parts.Part#mark
     * @returns {Numbas.marking.marking_script_result}
     */
    mark_answer: function(studentAnswer,scope) {
        try {
            this.getCorrectAnswer(scope);
            var result = this.markingScript.evaluate(
                scope,
                this.marking_parameters(studentAnswer)
            );
        } catch(e) {
            throw(new Numbas.Error("part.marking.error in marking script",{message:e.message}));
        }
        if(result.state_errors.mark) {
            throw(result.state_errors.mark);
        }
        return result;
    },
    /** Set the `credit` to an absolute value
     * @param {Number} credit
     * @param {String} message - message to show in feedback to explain this action
     * @param {String} reason - why was the credit set to this value? If given, either 'correct' or 'incorrect'.
     */
    setCredit: function(credit,message,reason)
    {
        var oCredit = this.credit;
        this.credit = credit;
        this.markingFeedback.push({
            op: 'set_credit',
            credit: this.credit - oCredit,
            message: message,
            reason: reason
        });
    },
    /** Add an absolute value to `credit`
     * @param {Number} credit - amount to add
     * @param {String} message - message to show in feedback to explain this action
     */
    addCredit: function(credit,message)
    {
        this.credit += credit;
        this.markingFeedback.push({
            op: 'add_credit',
            credit: credit,
            message: message
        });
    },
    /** Subtract an absolute value from `credit`
     * @param {Number} credit - amount to subtract
     * @param {String} message - message to show in feedback to explain this action
     */
    subCredit: function(credit,message)
    {
        this.credit -= credit;
        this.markingFeedback.push({
            op: 'sub_credit',
            credit: credit,
            message: message
        });
    },
    /** Multiply `credit` by the given amount - use to apply penalties
     * @param {Number} factor
     * @param {String} message - message to show in feedback to explain this action
     */
    multCredit: function(factor,message)
    {
        var oCredit = this.credit
        this.credit *= factor;
        this.markingFeedback.push({
            op: 'multiply_credit',
            credit: this.credit - oCredit,
            factor: factor,
            message: message
        });
    },
    /** Add a comment to the marking feedback
     * @param {String} message
     */
    markingComment: function(message)
    {
        this.markingFeedback.push({
            op: 'feedback',
            message: message
        });
    },
    /** Show the steps, as a result of the student asking to show them.
     * If the answers have not been revealed, we should apply the steps penalty.
     *
     * @param {Boolean} dontStore - don't tell the storage that this is happening - use when loading from storage to avoid callback loops
     */
    showSteps: function(dontStore)
    {
        this.openSteps();
        if(this.revealed) {
            return;
        }
        this.stepsShown = true;
        if(!this.revealed) {
            if(this.answered) {
                this.submit();
            } else {
                this.calculateScore();
                this.question && this.question.updateScore();
            }
        } else {
            this.calculateScore();
        }
        this.display && this.display.showSteps();
        if(!dontStore) {
            this.store && this.store.stepsShown(this);
        }
    },
    /** Open the steps, either because the student asked or the answers to the question are being revealed. This doesn't affect the steps penalty.
     */
    openSteps: function() {
        this.stepsOpen = true;
        this.display && this.display.showSteps();
    },
    /** Close the steps box. This doesn't affect the steps penalty.
     */
    hideSteps: function()
    {
        this.stepsOpen = false;
        this.display && this.display.hideSteps();
        this.store && this.store.stepsHidden(this);
    },
    /** Reveal the correct answer to this part
     * @param {Boolean} dontStore - don't tell the storage that this is happening - use when loading from storage to avoid callback loops
     */
    revealAnswer: function(dontStore)
    {
        this.display && this.display.revealAnswer();
        this.revealed = true;
        this.setDirty(false);
        //this.setCredit(0);
        if(this.steps.length>0) {
            this.openSteps();
            for(var i=0; i<this.steps.length; i++ )
            {
                this.steps[i].revealAnswer(dontStore);
            }
        }
    }
};
});

Numbas.queueScript('display/parts/custom',['display-base','part-display','util','jme'],function() {
    var display = Numbas.display;
    var extend = Numbas.util.extend;
    /** Display code for a {@link Numbas.parts.CustomPart}
     * @augments Numbas.display.PartDisplay
     * @constructor
     * @name CustomPartDisplay
     * @memberof Numbas.display
     */
    display.CustomPartDisplay = function() {
        var p = this.part;
        /** The type of input widget to use for this part.
         * @member {observable|string} input_widget
         * @memberof Numbas.display.CustomPartDisplay
         */
        this.input_widget = p.input_widget();
        /** Options for the input widget.
         * @member {observable|Object} input_options
         * @memberof Numbas.display.CustomPartDisplay
         */
        this.input_options = p.input_options();
        /** The student's current answer (not necessarily submitted)
         * @member {observable|string} studentAnswer
         * @memberof Numbas.display.CustomPartDisplay
         */
        this.studentAnswer = ko.observable({valid: false, value: this.part.studentAnswer});
        this.correctAnswer = ko.observable({valid: true, value: this.input_options.correctAnswer});
        ko.computed(function() {
            var answer = this.studentAnswer();
            if(Numbas.util.objects_equal(answer.value, p.stagedAnswer) || !answer.valid && p.stagedAnswer===undefined) {
                return;
            }
            if(answer.valid) {
                p.storeAnswer(answer.value);
            } else {
                p.storeAnswer(undefined);
            }
            if(answer.warnings) {
                answer.warnings.forEach(function(warning){ p.giveWarning(warning); });
            }
        },this);
    };
    display.CustomPartDisplay.prototype = {
        restoreAnswer: function() {
            this.studentAnswer({valid: this.part.studentAnswer!==undefined, value: this.part.studentAnswer});
        }
    };
    display.CustomPartDisplay = extend(display.PartDisplay,display.CustomPartDisplay,true);
});
/*
Copyright 2011-15 Newcastle University
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/** @file The {@link Numbas.parts.} object */
Numbas.queueScript('parts/custom_part_type',['base','jme','jme-variables','util','part','marking'],function() {
var util = Numbas.util;
var jme = Numbas.jme;
var math = Numbas.math;
var types = Numbas.jme.types;
var Part = Numbas.parts.Part;
/** Custom part - a part type defined in {@link Numbas.custom_part_types}
 * @constructor
 * @memberof Numbas.parts
 * @augments Numbas.parts.Part
 */
var CustomPart = Numbas.parts.CustomPart = function(path, question, parentPart, loading) {
    this.raw_settings = {};
    this.resolved_input_options = {};
}
CustomPart.prototype = /** @lends Numbas.parts.CustomPart.prototype */ {
    is_custom_part_type: true,
    getDefinition: function() {
        this.definition = Numbas.custom_part_types[this.type];
        return this.definition;
    },
    baseMarkingScript: function() {
        var definition = this.getDefinition();
        return new Numbas.marking.MarkingScript(definition.marking_script);
    },
    loadFromXML: function(xml) {
        var p = this;
        var raw_settings = this.raw_settings;
        this.getDefinition();
        var tryGetAttribute = Numbas.xml.tryGetAttribute;
        var settingNodes = xml.selectNodes('settings/setting');
        settingNodes.forEach(function(settingNode) {
            var name = settingNode.getAttribute('name');
            var value = settingNode.getAttribute('value');
            raw_settings[name] = JSON.parse(value);
        });
    },
    loadFromJSON: function(data) {
        var definition = this.getDefinition();
        var tryLoad = Numbas.json.tryLoad;
        var raw_settings = this.raw_settings;
        definition.settings.forEach(function(sdef) {
            tryLoad(data.settings,sdef.name,raw_settings);
        });
    },
    marking_parameters: function(studentAnswer) {
        var o = Part.prototype.marking_parameters.apply(this,[studentAnswer]);
        o.input_options = jme.wrapValue(this.input_options());
        return o;
    },
    resume: function() {
        if(!this.store) {
            return;
        }
        var pobj = this.store.loadPart(this);
        this.stagedAnswer = pobj.studentAnswer;
    },
    finaliseLoad: function() {
        var p = this;
        var settings = this.settings;
        var raw_settings = this.raw_settings;
        var scope = this.getScope();
        this.definition.settings.forEach(function(s) {
            var name = s.name;
            var value = raw_settings[name];
            if(!p.setting_evaluators[s.input_type]) {
                p.error('part.custom.unrecognised input type',{input_type:s.input_type});
            }
            try {
                settings[name] = p.setting_evaluators[s.input_type].call(p, s, value);
            } catch(e) {
                p.error('part.custom.error evaluating setting',{setting: name, error: e.message});
            }
        });
        var settings_scope = new jme.Scope([scope,{variables:{settings:new jme.types.TDict(settings)}}]);
        var raw_input_options = this.definition.input_options;
        ['correctAnswer','hint'].forEach(function(option) {
            if(raw_input_options[option]===undefined) {
                p.error('part.custom.input option missing',{option:option});
            }
        })
        function evaluate_input_option(option) {
            if(typeof(option)=='string') {
                return jme.unwrapValue(settings_scope.evaluate(option));
            } else {
                if(option.static) {
                    return option.value;
                } else {
                    return jme.unwrapValue(settings_scope.evaluate(option.value));
                }
            }
        }
        for(var option in raw_input_options) {
            try {
                p.resolved_input_options[option] = evaluate_input_option(raw_input_options[option]);
            } catch(e) {
                p.error('part.custom.error evaluating input option',{option:option,error:e.message});
            }
        }
        try {
            this.getCorrectAnswer(this.getScope());
        } catch(e) {
            this.error(e.message);
        }
        if(Numbas.display) {
            this.display = new Numbas.display.CustomPartDisplay(this);
        }
    },
    getCorrectAnswer: function(scope) {
        var settings = this.settings;
        this.correctAnswer = scope.evaluate(this.definition.input_options.correctAnswer, {settings: this.settings});
    },
    setStudentAnswer: function() {
        this.studentAnswer = this.stagedAnswer;
    },
    input_widget: function() {
        return this.definition.input_widget;
    },
    input_options: function() {
        return this.resolved_input_options;
    },
    rawStudentAnswerAsJME: function() {
        if(this.studentAnswer===undefined) {
            return new types.TNothing();
        }
        return this.student_answer_jme_types[this.input_widget()](this.studentAnswer, this.input_options());
    },
    student_answer_jme_types: {
        'string': function(answer) {
            return new types.TString(answer);
        },
        'number': function(answer) {
            return new types.TNum(answer);
        },
        'jme': function(answer) {
            return new types.TExpression(answer);
        },
        'matrix': function(answer,options) {
            if(options.parseCells) {
                return new types.TMatrix(answer);
            } else {
                return jme.wrapValue(answer);
            }
        },
        'radios': function(answer) {
            return new types.TNum(answer);
        },
        'checkboxes': function(answer) {
            return new types.TList(answer.map(function(ticked){ return new types.TBool(ticked) }));
        },
        'dropdown': function(answer) {
            return new types.TNum(answer);
        }
    },
    setting_evaluators: {
        'string': function(def, value) {
            var scope = this.getScope();
            if(def.subvars) {
                value = jme.subvars(value, scope, true);
            }
            return new jme.types.TString(value);
        },
        'mathematical_expression': function(def, value) {
            var scope = this.getScope();
            if(!value.trim()) {
                throw(new Numbas.Error("part.custom.empty setting"));
            }
            if(def.subvars) {
                value = jme.subvars(value, scope);
            }
            var result = new jme.types.TExpression(value);
            return result;
        },
        'checkbox': function(def, value) {
            return new jme.types.TBool(value);
        },
        'dropdown': function(def, value) {
            return new jme.types.TString(value);
        },
        'code': function(def, value) {
            var scope = this.getScope();
            if(!value.trim()) {
                throw(new Numbas.Error('part.custom.empty setting'));
            }
            if(def.evaluate) {
                return scope.evaluate(value);
            } else {
                return new jme.types.TString(value);
            }
        },
        'percent': function(def, value) {
            return new jme.types.TNum(value/100);
        },
        'html': function(def, value) {
            var scope = this.getScope();
            if(def.subvars) {
                value = jme.contentsubvars(value, scope);
            }
            return new jme.types.TString(value);
        },
        'list_of_strings': function(def, value) {
            var scope = this.getScope();
            return new jme.types.TList(value.map(function(s){
                if(def.subvars) {
                    s = jme.subvars(s, scope);
                }
                return new jme.types.TString(s)
            }));
        },
        'choose_several': function(def, value) {
            return new jme.wrapValue(value);
        }
    }
};
['resume','finaliseLoad','loadFromXML','loadFromJSON'].forEach(function(method) {
    CustomPart.prototype[method] = util.extend(Part.prototype[method], CustomPart.prototype[method]);
});
CustomPart = Numbas.parts.CustomPart = util.extend(Part,CustomPart);
});

Numbas.queueScript('display/parts/extension',['display-base','part-display','util'],function() {
    var display = Numbas.display;
    var extend = Numbas.util.extend;
    /** Display code for a {@link Numbas.parts.ExtensionPart}
     * @augments Numbas.display.PartDisplay
     * @constructor
     * @name ExtensionPartDisplay
     * @memberof Numbas.display
     */
    display.ExtensionPartDisplay= function() {};
    display.ExtensionPartDisplay= extend(display.PartDisplay,display.ExtensionPartDisplay,true);
});
/*
Copyright 2011-15 Newcastle University
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/** @file The {@link Numbas.parts.} object */
Numbas.queueScript('parts/extension',['base','util','part'],function() {
var util = Numbas.util;
var Part = Numbas.parts.Part;
/** Extension part - validation and marking should be filled in by an extension, or custom javascript code belonging to the question.
 * @constructor
 * @memberof Numbas.parts
 * @augments Numbas.parts.Part
 */
var ExtensionPart = Numbas.parts.ExtensionPart = function(path, question, parentPart)
{
}
ExtensionPart.prototype = /** @lends Numbas.parts.ExtensionPart.prototype */ {
    loadFromXML: function() {},
    loadFromJSON: function() {},
    finaliseLoad: function() {
        if(Numbas.display) {
    this.display = new Numbas.display.ExtensionPartDisplay(this);
        }
    },
    validate: function() {
        return false;
    },
    hasStagedAnswer: function() {
        return true;
    },
    doesMarking: true,
    mark: function() {
        this.markingComment(R('part.extension.not implemented',{name:'mark'}));
    },
    /** Return suspend data for this part so it can be restored when resuming the exam - must be implemented by an extension or the question.
     * @ returns {object}
     */
    createSuspendData: function() {
        return {};
    },
    /** Get the suspend data created in a previous session for this part, if it exists.
     * @ param {object} data
     */
    loadSuspendData: function(data) {
        if(!this.store) {
            return;
        }
        var pobj = this.store.loadExtensionPart(this);
        if(pobj) {
            return pobj.extension_data;
        }
    }
};
['finaliseLoad','loadFromXML','loadFromJSON'].forEach(function(method) {
    ExtensionPart.prototype[method] = util.extend(Part.prototype[method],ExtensionPart.prototype[method]);
});
Numbas.partConstructors['extension'] = util.extend(Part,ExtensionPart);
});
Numbas.queueScript('display/parts/gapfill',['display-base','part-display','util'],function() {
    var display = Numbas.display;
    var extend = Numbas.util.extend;
    /** Display code for a {@link Numbas.parts.GapFillPart}
     * @augments Numbas.display.PartDisplay
     * @constructor
     * @name GapFillPartDisplay
     * @memberof Numbas.display
     */
    display.GapFillPartDisplay = function()
    {
    }
    display.GapFillPartDisplay.prototype =
    {
        show: function()
        {
            for(var i=0;i<this.part.gaps.length; i++)
                this.part.gaps[i].display.show();
        },
        restoreAnswer: function()
        {
            for(var i=0;i<this.part.gaps.length; i++)
                this.part.gaps[i].display.restoreAnswer();
        },
        revealAnswer: function()
        {
        },
        init: function() {
            for(var i=0;i<this.part.gaps.length; i++)
                this.part.gaps[i].display.init();
        },
        end: function() {
            for(var i=0;i<this.part.gaps.length; i++)
                this.part.gaps[i].display.end();
        }
    };
    display.GapFillPartDisplay = extend(display.PartDisplay,display.GapFillPartDisplay,true);
});
/*
Copyright 2011-15 Newcastle University
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/** @file The {@link Numbas.parts.GapFillPart} object */
Numbas.queueScript('parts/gapfill',['base','jme','jme-variables','util','part','marking_scripts'],function() {
var util = Numbas.util;
var jme = Numbas.jme;
var math = Numbas.math;
var Part = Numbas.parts.Part;
/** Gap-fill part: text with multiple input areas, each of which is its own sub-part, known as a 'gap'.
 * @constructor
 * @memberof Numbas.parts
 * @augments Numbas.parts.Part
 */
var GapFillPart = Numbas.parts.GapFillPart = function(path, question, parentPart)
{
    util.copyinto(GapFillPart.prototype.settings,this.settings);
}
GapFillPart.prototype = /** @lends Numbas.parts.GapFillPart.prototype */
{
    /** Properties set when the part is generated.
     *
     * Extends {@link Numbas.parts.Part#settings}
     * @property {Boolean} sortAnswers - Should the student's answers to the gaps be put in ascending order before marking?
     */
    settings: {
        sortAnswers: false
    },

    loadFromXML: function(xml) {
        var gapXML = xml.selectNodes('gaps/part');
        var settings = this.settings;
        var tryGetAttribute = Numbas.xml.tryGetAttribute;
        this.marks = 0;
        tryGetAttribute(settings,xml,'marking',['sortanswers'],['sortAnswers']);
        for( var i=0 ; i<gapXML.length; i++ ) {
            var gap = Numbas.createPartFromXML(gapXML[i], this.path+'g'+i, this.question, this, this.store);
            this.addGap(gap,i);
        }
    },
    loadFromJSON: function(data) {
        var p = this;
        var settings = this.settings;
        var tryLoad = Numbas.json.tryLoad;
        tryLoad(data,['sortAnswers'],settings);
        if('gaps' in data) {
            data.gaps.forEach(function(gd,i) {
                var gap = Numbas.createPartFromJSON(gd, p.path+'g'+i, p.question, p, p.store);
                p.addGap(gap, i)
            });
        }
    },
    finaliseLoad: function() {
        if(Numbas.display) {
            this.display = new Numbas.display.GapFillPartDisplay(this);
        }
    },
    /** Add a gap to this part
     * @param {Numbas.parts.Part} gap
     * @param {Number} index - the position of the gap
     */
    addGap: function(gap, index) {
        gap.isGap = true;
        this.marks += gap.marks;
        this.gaps.splice(index,0,gap);
    },
    resume: function() {
        var p = this;
        this.gaps.forEach(function(g){
            g.resume();
            p.answered = p.answered || g.answered;
        });
    },
    /** Included so the "no answer entered" error isn't triggered for the whole gap-fill part.
     */
    stagedAnswer: 'something',
    /** The script to mark this part - assign credit, and give messages and feedback.
     * @returns {Numbas.marking.MarkingScript}
     */
    baseMarkingScript: function() { return Numbas.marking_scripts.gapfill; },
    /** Reveal the answers to all of the child gaps
     * Extends {@link Numbas.parts.Part.revealAnswer}
     */
    revealAnswer: function(dontStore)
    {
        for(var i=0; i<this.gaps.length; i++)
            this.gaps[i].revealAnswer(dontStore);
    },
    /** Get the student's answer as it was entered as a JME data type, to be used in the custom marking algorithm
     * @abstract
     * @returns {Numbas.jme.token}
     */
    rawStudentAnswerAsJME: function() {
        if(this.gaps.some(function(g){ return g.rawStudentAnswerAsJME()===undefined; })) {
            return undefined;
        }
        return new Numbas.jme.types.TList(this.gaps.map(function(g){return g.rawStudentAnswerAsJME()}));
    },
    storeAnswer: function(answer) {
        this.gaps.forEach(function(g,i) {
            g.storeAnswer(answer[i]);
        })
    },
    setStudentAnswer: function() {
        this.studentAnswer = this.gaps.map(function(g) {
            g.setStudentAnswer();
            return g.studentAnswer;
        });
    },
    /** Get the student's answer as a JME data type, to be used in error-carried-forward calculations
     * @abstract
     * @returns {Numbas.jme.token}
     */
    studentAnswerAsJME: function() {
        return new Numbas.jme.types.TList(this.gaps.map(function(g){return g.studentAnswerAsJME()}));
    }
};
['loadFromXML','resume','finaliseLoad','loadFromJSON','storeAnswer'].forEach(function(method) {
    GapFillPart.prototype[method] = util.extend(Part.prototype[method], GapFillPart.prototype[method]);
});
['revealAnswer'].forEach(function(method) {
    GapFillPart.prototype[method] = util.extend(GapFillPart.prototype[method], Part.prototype[method]);
});
Numbas.partConstructors['gapfill'] = util.extend(Part,GapFillPart);
});

Numbas.queueScript('display/parts/information',['display-base','part-display','util'],function() {
    var display = Numbas.display;
    var extend = Numbas.util.extend;
    /** Display code for a {@link Numbas.parts.InformationPart}
     * @augments Numbas.display.PartDisplay
     * @constructor
     * @name InformationPartDisplay
     * @memberof Numbas.display
     */
    display.InformationPartDisplay = function() {};
    display.InformationPartDisplay = extend(display.PartDisplay,display.InformationPartDisplay,true);
});
/*
Copyright 2011-15 Newcastle University
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/** @file The {@link Numbas.parts.} object */
Numbas.queueScript('parts/information',['base','jme','jme-variables','util','part'],function() {
var util = Numbas.util;
var jme = Numbas.jme;
var math = Numbas.math;
var Part = Numbas.parts.Part;
/** Information only part - no input, no marking, just display some content to the student.
 * @constructor
 * @memberof Numbas.parts
 * @augments Numbas.parts.Part
 */
var InformationPart = Numbas.parts.InformationPart = function(path, question, parentPart, loading)
{
}
InformationPart.prototype = /** @lends Numbas.parts.InformationOnlyPart.prototype */ {
    loadFromXML: function() {
    },
    loadFromJSON: function() {
    },
    finaliseLoad: function() {
        this.answered = true;
        this.isDirty = false;
        if(Numbas.display) {
            this.display = new Numbas.display.InformationPartDisplay(this);
        }
    },
    /** This part is always valid
     * @returns {Boolean} true
     */
    validate: function() {
        this.answered = true;
        return true;
    },
    /** This part is never dirty
     */
    setDirty: function() {
        this.isDirty = false;
    },
    hasStagedAnswer: function() {
        return true;
    },
    doesMarking: false
};
['finaliseLoad','loadFromXML','loadFromJSON'].forEach(function(method) {
    InformationPart.prototype[method] = util.extend(Part.prototype[method], InformationPart.prototype[method]);
});
Numbas.partConstructors['information'] = util.extend(Part,InformationPart);
});
Numbas.queueScript('display/parts/jme',['display-base','part-display','util','jme-display','jme'],function() {
    var display = Numbas.display;
    var extend = Numbas.util.extend;
    /** Display code for a {@link Numbas.parts.JMEPart}
     * @constructor
     * @augments Numbas.display.PartDisplay
     * @name JMEPartDisplay
     * @memberof Numbas.display
     */
    display.JMEPartDisplay = function()
    {
        var p = this.part;
        /** The student's current answer (not necessarily submitted)
         * @member {observable|JME} studentAnswer
         * @memberof Numbas.display.JMEPartDisplay
         */
        this.studentAnswer = Knockout.observable('');
        /** The correct answer
         * @member {observable|JME} correctAnswer
         * @memberof Numbas.display.JMEPartDisplay
         */
        this.correctAnswer = p.settings.correctAnswer;
        /** Should the LaTeX rendering of the student's answer be shown?
         * @member {boolean} showPreview
         * @memberof Numbas.display.JMEPartDisplay
         */
        this.showPreview = p.settings.showPreview;
        /** The correct answer, in LaTeX form
         * @member {observable|TeX} correctAnswerLaTeX
         * @memberof Numbas.display.JMEPartDisplay
         */
        this.correctAnswerLaTeX = Numbas.jme.display.exprToLaTeX(this.correctAnswer,p.settings.answerSimplification,p.question.scope);
        ko.computed(function() {
            p.storeAnswer(this.studentAnswer());
        },this);
        /** The student's answer, in LaTeX form
         * @member {observable|TeX} studentAnswerLaTeX
         * @memberof Numbas.display.JMEPartDisplay
         */
        this.studentAnswerLaTeX = Knockout.computed(function() {
            var studentAnswer = this.studentAnswer();
            if(studentAnswer=='')
                return '';
            this.removeWarnings();
            try {
                var tex = Numbas.jme.display.exprToLaTeX(studentAnswer,'',p.question.scope);
                if(tex===undefined)
                    throw(new Numbas.Error('display.part.jme.error making maths'));
            }
            catch(e) {
                p.giveWarning(e.message);
                return '';
            }
            if(p.settings.checkVariableNames) {
                var tree = Numbas.jme.compile(studentAnswer,p.question.scope);
                var usedvars = Numbas.jme.findvars(tree);
                var failExpectedVariableNames = false;
                var unexpectedVariableName;
                for(var i=0;i<usedvars.length;i++) {
                    if(!p.settings.expectedVariableNames.contains(usedvars[i])) {
                        failExpectedVariableNames = true;
                        unexpectedVariableName = usedvars[i];
                        break;
                    }
                }
                if( failExpectedVariableNames ) {
                    var suggestedNames = unexpectedVariableName.split(Numbas.jme.re.re_short_name);
                    if(suggestedNames.length>3) {
                        var suggestion = [];
                        for(var i=1;i<suggestedNames.length;i+=2) {
                            suggestion.push(suggestedNames[i]);
                        }
                        suggestion = suggestion.join('*');
                        p.giveWarning(R('part.jme.unexpected variable name suggestion',{name:unexpectedVariableName,suggestion:suggestion}));
                    }
                    else
                        p.giveWarning(R('part.jme.unexpected variable name', {name:unexpectedVariableName}));
                }
            }
            return tex;
        },this).extend({throttle:100});
        /** Does the input box have focus?
         * @member {observable|boolean} inputHasFocus
         * @memberof Numbas.display.JMEPartDisplay
         */
        this.inputHasFocus = Knockout.observable(false);
        /** Give the input box focus
         * @member {function} focusInput
         * @method
         * @memberof Numbas.display.JMEPartDisplay
         */
        this.focusInput = function() {
            this.inputHasFocus(true);
        }
    }
    display.JMEPartDisplay.prototype =
    {
        restoreAnswer: function()
        {
            this.studentAnswer(this.part.studentAnswer);
        }
    };
    display.JMEPartDisplay = extend(display.PartDisplay,display.JMEPartDisplay,true);
})
/*
Copyright 2011-15 Newcastle University
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/** @file The {@link Numbas.parts.JMEPart} object */
Numbas.queueScript('parts/jme',['base','jme','jme-variables','util','part','marking_scripts'],function() {
var util = Numbas.util;
var jme = Numbas.jme;
var math = Numbas.math;
var nicePartName = util.nicePartName;
var Part = Numbas.parts.Part;
/** Judged Mathematical Expression
 *
 * Student enters a string representing a mathematical expression, eg. `x^2+x+1`, and it is compared with the correct answer by evaluating over a range of values.
 * @constructor
 * @memberof Numbas.parts
 * @augments Numbas.parts.Part
 */
var JMEPart = Numbas.parts.JMEPart = function(path, question, parentPart)
{
    var settings = this.settings;
    util.copyinto(JMEPart.prototype.settings,settings);
    settings.mustHave = [];
    settings.notAllowed = [];
    settings.expectedVariableNames = [];
}
JMEPart.prototype = /** @lends Numbas.JMEPart.prototype */
{
    loadFromXML: function(xml) {
        var settings = this.settings;
        var tryGetAttribute = Numbas.xml.tryGetAttribute;
        //parse correct answer from XML
        answerNode = xml.selectSingleNode('answer/correctanswer');
        if(!answerNode) {
            this.error('part.jme.answer missing');
        }
        tryGetAttribute(settings,xml,'answer/correctanswer','simplification','answerSimplificationString');
        settings.correctAnswerString = Numbas.xml.getTextContent(answerNode).trim();
        //get checking type, accuracy, checking range
        var parametersPath = 'answer';
        tryGetAttribute(settings,xml,parametersPath+'/checking',['type','accuracy','failurerate'],['checkingType','checkingAccuracy','failureRate']);
        tryGetAttribute(settings,xml,parametersPath+'/checking/range',['start','end','points'],['vsetRangeStart','vsetRangeEnd','vsetRangePoints']);
        //max length and min length
        tryGetAttribute(settings,xml,parametersPath+'/maxlength',['length','partialcredit'],['maxLength','maxLengthPC']);
        var messageNode = xml.selectSingleNode('answer/maxlength/message');
        if(messageNode)
        {
            settings.maxLengthMessage = $.xsl.transform(Numbas.xml.templates.question,messageNode).string;
            if($(settings.maxLengthMessage).text() == '')
                settings.maxLengthMessage = R('part.jme.answer too long');
        }
        tryGetAttribute(settings,xml,parametersPath+'/minlength',['length','partialcredit'],['minLength','minLengthPC']);
        var messageNode = xml.selectSingleNode('answer/minlength/message');
        if(messageNode)
        {
            settings.minLengthMessage = $.xsl.transform(Numbas.xml.templates.question,messageNode).string;
            if($(settings.minLengthMessage).text() == '')
                settings.minLengthMessage = R('part.jme.answer too short');
        }
        //get list of 'must have' strings
        var mustHaveNode = xml.selectSingleNode('answer/musthave');
        if(mustHaveNode)
        {
            var mustHaves = mustHaveNode.selectNodes('string');
            for(var i=0; i<mustHaves.length; i++)
            {
                settings.mustHave.push(Numbas.xml.getTextContent(mustHaves[i]));
            }
            //partial credit for failing must-have test and whether to show strings which must be present to student when warning message displayed
            tryGetAttribute(settings,xml,mustHaveNode,['partialcredit','showstrings'],['mustHavePC','mustHaveShowStrings']);
            //warning message to display when a must-have is missing
            var messageNode = mustHaveNode.selectSingleNode('message');
            if(messageNode)
                settings.mustHaveMessage = $.xsl.transform(Numbas.xml.templates.question,messageNode).string;
        }
        //get list of 'not allowed' strings
        var notAllowedNode = xml.selectSingleNode('answer/notallowed');
        if(notAllowedNode)
        {
            var notAlloweds = notAllowedNode.selectNodes('string');
            for(var i=0; i<notAlloweds.length; i++)
            {
                settings.notAllowed.push(Numbas.xml.getTextContent(notAlloweds[i]));
            }
            //partial credit for failing not-allowed test
            tryGetAttribute(settings,xml,notAllowedNode,['partialcredit','showstrings'],['notAllowedPC','notAllowedShowStrings']);
            var messageNode = notAllowedNode.selectSingleNode('message');
            if(messageNode)
                settings.notAllowedMessage = $.xsl.transform(Numbas.xml.templates.question,messageNode).string;
        }
        tryGetAttribute(settings,xml,parametersPath,['checkVariableNames','showPreview']);
        var expectedVariableNamesNode = xml.selectSingleNode('answer/expectedvariablenames');
        if(expectedVariableNamesNode)
        {
            var nameNodes = expectedVariableNamesNode.selectNodes('string');
            for(var i=0; i<nameNodes.length; i++)
                settings.expectedVariableNames.push(Numbas.xml.getTextContent(nameNodes[i]).toLowerCase().trim());
        }
    },
    loadFromJSON: function(data) {
        var settings = this.settings;
        var tryLoad = Numbas.json.tryLoad;
        tryLoad(data, ['answer', 'answerSimplification'], settings, ['correctAnswerString', 'answerSimplificationString']);
        tryLoad(data, ['checkingType', 'checkingAccuracy', 'failureRate'], settings, ['checkingType', 'checkingAccuracy', 'failureRate']);
        tryLoad(data.maxlength, ['length', 'partialCredit', 'message'], settings, ['maxLength', 'maxLengthPC', 'maxLengthMessage']);
        tryLoad(data.minlength, ['length', 'partialCredit', 'message'], settings, ['minLength', 'minLengthPC', 'minLengthMessage']);
        tryLoad(data.musthave, ['strings', 'showStrings', 'partialCredit', 'message'], settings, ['mustHave', 'mustHaveShowStrings', 'mustHavePC', 'mustHaveMessage']);
        tryLoad(data.notallowed, ['strings', 'showStrings', 'partialCredit', 'message'], settings, ['notAllowed', 'notAllowedShowStrings', 'notAllowedPC', 'notAllowedMessage']);
        tryLoad(data, ['checkVariableNames', 'expectedVariableNames', 'showPreview'], settings);
    },
    resume: function() {
        if(!this.store) {
            return;
        }
        var pobj = this.store.loadPart(this);
        this.stagedAnswer = pobj.studentAnswer;
    },
    finaliseLoad: function() {
        this.stagedAnswer = '';
        this.getCorrectAnswer(this.getScope());
        if(Numbas.display) {
            this.display = new Numbas.display.JMEPartDisplay(this);
        }
    },
    /** Student's last submitted answer
     * @type {String}
     */
    studentAnswer: '',
    /** The script to mark this part - assign credit, and give messages and feedback.
     * @returns {Numbas.marking.MarkingScript}
     */
    baseMarkingScript: function() { return Numbas.marking_scripts.jme; },
    /** Properties set when the part is generated.
     *
     * Extends {@link Numbas.parts.Part#settings}
     * @property {JME} correctAnswerString - the definition of the correct answer, without variables substituted into it.
     * @property {String} correctAnswer - An expression representing the correct answer to the question. The student's answer should evaluate to the same value as this.
     * @property {String} answerSimplificationString - string from the XML defining which answer simplification rules to use
     * @property {Array.<String>} answerSimplification - names of simplification rules (see {@link Numbas.jme.display.Rule}) to use on the correct answer
     * @property {String} checkingType - method to compare answers. See {@link Numbas.jme.checkingFunctions}
     * @property {Number} checkingAccuracy - accuracy threshold for checking. Exact definition depends on the checking type.
     * @property {Number} failureRate - comparison failures allowed before we decide answers are different
     * @property {Number} vsetRangeStart - lower bound on range of points to pick values from for variables in the answer expression
     * @property {Number} vsetRangeEnd - upper bound on range of points to pick values from for variables in the answer expression
     * @property {Number} vsetRangePoints - number of points to compare answers on
     * @property {Number} maxLength - maximum length, in characters, of the student's answer. Note that the student's answer is cleaned up before checking length, so extra space or brackets aren't counted
     * @property {Number} maxLengthPC - partial credit if the student's answer is too long
     * @property {String} maxLengthMessage - Message to add to marking feedback if the student's answer is too long
     * @property {Number} minLength - minimum length, in characters, of the student's answer. Note that the student's answer is cleaned up before checking length, so extra space or brackets aren't counted
     * @property {Number} minLengthPC - partial credit if the student's answer is too short
     * @property {String} minLengthMessage - message to add to the marking feedback if the student's answer is too short
     * @property {Array.<String>} mustHave - strings which must be present in the student's answer
     * @property {Number} mustHavePC - partial credit to award if any must-have string is missing
     * @property {String} mustHaveMessage - message to add to the marking feedback if the student's answer is missing a must-have string.
     * @property {Boolean} mustHaveShowStrings - tell the students which strings must be included in the marking feedback, if they're missing a must-have?
     * @property {Array.<String>} notAllowed - strings which must not be present in the student's answer
     * @property {Number} notAllowedPC - partial credit to award if any not-allowed string is present
     * @property {String} notAllowedMessage - message to add to the marking feedback if the student's answer contains a not-allowed string.
     * @property {Boolean} notAllowedShowStrings - tell the students which strings must not be included in the marking feedback, if they've used a not-allowed string?
     */
    settings:
    {
        correctAnswerString: '',
        correctAnswer: '',
        answerSimplificationString: '',
        answerSimplification: ['basic','unitFactor','unitPower','unitDenominator','zeroFactor','zeroTerm','zeroPower','collectNumbers','zeroBase','constantsFirst','sqrtProduct','sqrtDivision','sqrtSquare','otherNumbers'],
        checkingType: 'RelDiff',
        checkingAccuracy: 0,
        failureRate: 1,
        vsetRangeStart: 0,
        vsetRangeEnd: 1,
        vsetRangePoints: 1,
        maxLength: 0,
        maxLengthPC: 0,
        maxLengthMessage: 'Your answer is too long',
        minLength: 0,
        minLengthPC: 0,
        minLengthMessage: 'Your answer is too short',
        mustHave: [],
        mustHavePC: 0,
        mustHaveMessage: '',
        mustHaveShowStrings: false,
        notAllowed: [],
        notAllowedPC: 0,
        notAllowedMessage: '',
        notAllowedShowStrings: false
    },
    /** The name of the input widget this part uses, if any.
     * @returns {String}
     */
    input_widget: function() {
        return 'jme';
    },
    /** Options for this part's input widget
     * @returns {Object}
     */
    input_options: function() {
        return {
            showPreview: this.settings.showPreview,
            returnString: true
        };
    },
    /** Compute the correct answer, based on the given scope
     */
    getCorrectAnswer: function(scope) {
        var settings = this.settings;
        settings.answerSimplification = Numbas.jme.collectRuleset(settings.answerSimplificationString,scope.allRulesets());
        var expr = jme.subvars(settings.correctAnswerString,scope);
        settings.correctAnswer = jme.display.simplifyExpression(
            expr,
            settings.answerSimplification,
            scope
        );
        if(settings.correctAnswer == '' && this.marks>0) {
            this.error('part.jme.answer missing');
        }
        this.markingScope = new jme.Scope(this.getScope());
        this.markingScope.variables = {};
    },
    /** Save a copy of the student's answer as entered on the page, for use in marking.
     */
    setStudentAnswer: function() {
        this.studentAnswer = this.stagedAnswer;
    },
    /** Get the student's answer as it was entered as a JME data type, to be used in the custom marking algorithm
     * @abstract
     * @returns {Numbas.jme.token}
     */
    rawStudentAnswerAsJME: function() {
        return new Numbas.jme.types.TString(this.studentAnswer);
    }
};
['resume','finaliseLoad','loadFromXML','loadFromJSON'].forEach(function(method) {
    JMEPart.prototype[method] = util.extend(Part.prototype[method], JMEPart.prototype[method]);
});
Numbas.partConstructors['jme'] = util.extend(Part,JMEPart);
});

Numbas.queueScript('display/parts/matrix',['display-base','part-display','util','jme','jme-display'],function() {
    var display = Numbas.display;
    var extend = Numbas.util.extend;
    var util = Numbas.util;
    /** Display code for a {@link Numbas.parts.MatrixEntryPart}
     * @augments Numbas.display.PartDisplay
     * @constructor
     * @name MatrixEntryPartDisplay
     * @memberof Numbas.display
     */
    display.MatrixEntryPartDisplay = function()
    {
        var p = this.part;
        /** The student's current (not necessarily submitted) answer
         * @member {observable|string} studentAnswer
         * @memberof Numbas.display.MatrixEntryPartDisplay
         */
        this.studentAnswer = Knockout.observable(p.studentAnswer);
        /** The correct answer
         * @member {observable|number} correctAnswer
         * @memberof Numbas.display.MatrixEntryPartDisplay
         */
        var correctInput = p.settings.correctAnswer.map(function(row) {
            return row.map(function(c) {
                if(p.settings.allowFractions) {
                    return c;
                }
                return Numbas.math.niceNumber(c,{precisionType: p.settings.precisionType, precision: p.settings.precision, style: p.settings.correctAnswerStyle});
            });
        });
        correctInput.rows = p.settings.correctAnswer.rows;
        correctInput.columns = p.settings.correctAnswer.columns;

        this.correctAnswer = Knockout.observable(correctInput);
        this.correctAnswerLaTeX = Knockout.computed(function() {
            var correctAnswer = this.correctAnswer();
            var m = new Numbas.jme.types.TMatrix(correctAnswer);
            return Numbas.jme.display.texify({tok:m},{fractionnumbers: p.settings.correctAnswerFractions});
        },this);
        this.studentAnswerRows = Knockout.observable(p.settings.numRows);
        this.studentAnswerColumns = Knockout.observable(p.settings.numColumns);
        this.allowResize = Knockout.observable(p.settings.allowResize);
        Knockout.computed(function() {
            var stagedAnswer = p.stagedAnswer || {rows:null, columns: null, matrix: null};
            var oldRows = stagedAnswer.rows;
            var oldColumns = stagedAnswer.columns;
            var oldMatrix = stagedAnswer.matrix;
            var newRows = this.studentAnswerRows();
            var newColumns = this.studentAnswerColumns();
            var newMatrix = this.studentAnswer();
            if(newRows != oldRows || newColumns != oldColumns || !util.arraysEqual(oldMatrix,newMatrix)) {
                var m = this.studentAnswer();
                m.rows = this.studentAnswerRows();
                m.columns = this.studentAnswerColumns();
                p.storeAnswer(m);
            }
        },this);
        /** Show a LaTeX rendering of the answer?
         * @member {boolean} showPreview
         * @memberof Numbas.display.MatrixEntryPartDisplay
         */
        this.showPreview = false;
        /** TeX version of student's answer
         * @member {observable|TeX} studentAnswerLaTeX
         * @memberof Numbas.display.MatrixEntryPartDisplay
         */
        this.studentAnswerLaTeX = Knockout.computed(function() {
            return 'student answer latex';
        },this);
    }
    display.MatrixEntryPartDisplay.prototype =
    {
        restoreAnswer: function()
        {
            var studentAnswer = this.part.studentAnswer;
            this.studentAnswerRows(studentAnswer.length || 1);
            this.studentAnswerColumns(studentAnswer.length ? studentAnswer[0].length : 1);
            this.studentAnswer(studentAnswer);
        }
    };
    display.MatrixEntryPartDisplay = extend(display.PartDisplay,display.MatrixEntryPartDisplay,true);
});

/*
Copyright 2011-15 Newcastle University
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/** @file The {@link Numbas.parts.MatrixEntryPart} object */
Numbas.queueScript('parts/matrixentry',['base','jme','jme-variables','util','part','marking_scripts'],function() {
var util = Numbas.util;
var jme = Numbas.jme;
var math = Numbas.math;
var Part = Numbas.parts.Part;
/** Matrix entry part - student enters a matrix of numbers
 * @constructor
 * @memberof Numbas.parts
 * @augments Numbas.parts.Part
 */
var MatrixEntryPart = Numbas.parts.MatrixEntryPart = function(xml, path, question, parentPart, loading) {
    var settings = this.settings;
    util.copyinto(MatrixEntryPart.prototype.settings,settings);
}
MatrixEntryPart.prototype = /** @lends Numbas.parts.MatrixEntryPart.prototype */
{
    loadFromXML: function(xml) {
        var settings = this.settings;
        var tryGetAttribute = Numbas.xml.tryGetAttribute;
        tryGetAttribute(settings,xml,'answer',['correctanswer'],['correctAnswerString'],{string:true});
        tryGetAttribute(settings,xml,'answer',['correctanswerfractions','rows','columns','allowresize','tolerance','markpercell','allowfractions'],['correctAnswerFractions','numRows','numColumns','allowResize','tolerance','markPerCell','allowFractions']);
        tryGetAttribute(settings,xml,'answer/precision',['type','partialcredit','strict'],['precisionType','precisionPC','strictPrecision']);
        tryGetAttribute(settings,xml,'answer/precision','precision','precisionString',{'string':true});
        var messageNode = xml.selectSingleNode('answer/precision/message');
        if(messageNode) {
            settings.precisionMessage = $.xsl.transform(Numbas.xml.templates.question,messageNode).string;
        }
    },
    loadFromJSON: function(data) {
        var settings = this.settings;
        var tryLoad = Numbas.json.tryLoad;
        tryLoad(data,['correctAnswer', 'correctAnswerFractions', 'numRows', 'numColumns', 'allowResize', 'tolerance', 'markPerCell', 'allowFractions'], settings, ['correctAnswerString', 'correctAnswerFractions', 'numRows', 'numColumns', 'allowResize', 'tolerance', 'markPerCell', 'allowFractions']);
        tryLoad(data,['precisionType', 'precision', 'precisionPartialCredit', 'precisionMessage', 'strictPrecision'], settings, ['precisionType', 'precisionString', 'precisionPC', 'precisionMessage', 'strictPrecision']);
        settings.precisionPC /= 100;
    },
    resume: function() {
        if(!this.store) {
            return;
        }
        var pobj = this.store.loadPart(this);
        if(pobj.studentAnswer!==undefined) {
            this.stagedAnswer = pobj.studentAnswer.matrix;
            this.stagedAnswer.rows = pobj.studentAnswer.rows;
            this.stagedAnswer.columns = pobj.studentAnswer.columns;
        }
    },
    finaliseLoad: function() {
        var settings = this.settings;
        var scope = this.getScope();
        var numRows = jme.subvars(settings.numRows, scope);
        settings.numRows = scope.evaluate(numRows).value;
        var numColumns = jme.subvars(settings.numColumns, scope);
        settings.numColumns = scope.evaluate(numColumns).value;
        var tolerance = jme.subvars(settings.tolerance, scope);
        settings.tolerance = scope.evaluate(tolerance).value;
        settings.tolerance = Math.max(settings.tolerance,0.00000000001);
        if(settings.precisionType!='none') {
            settings.allowFractions = false;
        }
        this.studentAnswer = [];
        for(var i=0;i<this.settings.numRows;i++) {
            var row = [];
            for(var j=0;j<this.settings.numColumns;j++) {
                row.push('');
            }
            this.studentAnswer.push(row);
        }
        this.getCorrectAnswer(scope);
        if(!settings.allowResize && (settings.correctAnswer.rows!=settings.numRows || settings.correctAnswer.columns != settings.numColumns)) {
            var correctSize = settings.correctAnswer.rows+'×'+settings.correctAnswer.columns;
            var answerSize = settings.numRows+'×'+settings.numColumns;
            throw(new Numbas.Error('part.matrix.size mismatch',{correct_dimensions:correctSize,input_dimensions:answerSize}));
        }
        if(Numbas.display) {
            this.display = new Numbas.display.MatrixEntryPartDisplay(this);
        }
    },
    /** The student's last submitted answer */
    studentAnswer: '',
    /** The script to mark this part - assign credit, and give messages and feedback.
     * @returns {Numbas.marking.MarkingScript}
     */
    baseMarkingScript: function() { return Numbas.marking_scripts.matrixentry; },
    /** Properties set when part is generated
     * Extends {@link Numbas.parts.Part#settings}
     * @property {matrix} correctAnswer - the correct answer to the part
     * @property {JME} numRows - default number of rows in the student's answer
     * @property {JME} numColumns - default number of columns in the student's answer
     * @property {Boolean} allowResize - allow the student to change the dimensions of their answer?
     * @property {JME} tolerance - allowed margin of error in each cell (if student's answer is within +/- `tolerance` of the correct answer (after rounding to , mark it as correct
     * @property {Boolean} markPerCell - should the student gain marks for each correct cell (true), or only if they get every cell right (false)?
     * @property {Boolean} allowFractions - can the student enter a fraction as their answer for a cell?
     * @property {String} precisionType - type of precision restriction to apply: `none`, `dp` - decimal places, or `sigfig` - significant figures
     * @property {Number} precision - how many decimal places or significant figures to require
     * @property {Number} precisionPC - partial credit to award if the answer is between `minvalue` and `maxvalue` but not given to the required precision
     * @property {String} precisionMessage - message to display in the marking feedback if their answer was not given to the required precision
     * @property {Boolean} strictPrecision - must the student give exactly the required precision? If false, omitting trailing zeros is allowed.
     */
    settings: {
        correctAnswer: null,
        correctAnswerFractions: false,
        numRows: '3',
        numColumns: '3',
        allowResize: true,
        tolerance: '0',
        markPerCell: false,
        allowFractions: false,
        precisionType: 'none',    //'none', 'dp' or 'sigfig'
        precisionString: '0',
        precision: 0,
        precisionPC: 0,
        precisionMessage: R('You have not given your answer to the correct precision.'),
        strictPrecision: true
    },
    /** The name of the input widget this part uses, if any.
     * @returns {String}
     */
    input_widget: function() {
        return 'matrix';
    },
    /** Options for this part's input widget
     * @returns {Object}
     */
    input_options: function() {
        return {
            allowFractions: this.settings.allowFractions,
            allowedNotationStyles: ['plain','en','si-en'],
            allowResize: this.settings.allowResize,
            numRows: this.settings.numRows,
            numColumns: this.settings.numColumns,
            parseCells: false
        };
    },
    /** Compute the correct answer, based on the given scope
     */
    getCorrectAnswer: function(scope) {
        var settings = this.settings;
        var correctAnswer = jme.subvars(settings.correctAnswerString,scope);
        correctAnswer = jme.evaluate(correctAnswer,scope);
        if(correctAnswer && correctAnswer.type=='matrix') {
            settings.correctAnswer = correctAnswer.value;
        } else if(correctAnswer && correctAnswer.type=='vector') {
            settings.correctAnswer = Numbas.vectormath.toMatrix(correctAnswer.value);
        } else {
            this.error('part.setting not present',{property:'correct answer'});
        }
        settings.precision = jme.subvars(settings.precisionString, scope);
        settings.precision = jme.evaluate(settings.precision,scope).value;
    },
    /** Save a copy of the student's answer as entered on the page, for use in marking.
     */
    setStudentAnswer: function() {
        if(this.stagedAnswer !== undefined) {
            var m = this.stagedAnswer;
            this.studentAnswerRows = m.length;
            this.studentAnswerColumns = this.studentAnswerRows>0 ? m[0].length : 0;
        } else {
            this.studentAnswerRows = 0;
            this.studentAnswerColumns = 0;
        }
        this.studentAnswer = this.stagedAnswer;
    },
    /** Get the student's answer as it was entered as a JME data type, to be used in the marking script
     * @abstract
     * @returns {Numbas.jme.token}
     */
    rawStudentAnswerAsJME: function() {
        return jme.wrapValue(this.studentAnswer);
    }
};
['resume','finaliseLoad','loadFromXML','loadFromJSON'].forEach(function(method) {
    MatrixEntryPart.prototype[method] = util.extend(Part.prototype[method], MatrixEntryPart.prototype[method]);
});
Numbas.partConstructors['matrix'] = util.extend(Part,MatrixEntryPart);
});

Numbas.queueScript('display/parts/multipleresponse',['display-base','part-display','util'],function() {
    var display = Numbas.display;
    var extend = Numbas.util.extend;
    var util = Numbas.util;
    /** Display code for a {@link Numbas.parts.MultipleResponsePart}
     * @augments Numbas.display.PartDisplay
     * @constructor
     * @name MultipleResponsePartDisplay
     * @memberof Numbas.display
     */
    display.MultipleResponsePartDisplay = function()
    {
        var p = this.part;
        function makeTicker(answer,choice) {
            var obs = ko.observable(p.ticks[answer][choice]);
            ko.computed(function() {
                p.storeTick({answer:answer, choice:choice, ticked:obs()});
            },p);
            return obs;
        }
        function makeRadioTicker(choice) {
            var obs = Knockout.observable(null);
            for(var i=0;i<p.numAnswers;i++) {
                if(p.ticks[i][choice])
                    obs(i);
            }
            Knockout.computed(function() {
                var answer = parseInt(obs());
                p.storeTick({answer:answer, choice:choice, ticked: true});
            },p);
            return obs;
        }
        function makeCheckboxTicker(answer,choice) {
            var obs = ko.observable(p.ticks[answer][choice]);
            ko.computed(function() {
                p.storeTick({answer:answer, choice:choice, ticked:obs()});
            });
            return obs;
        }
        this.layout = util.copyarray(p.layout);
        this.showCellAnswerState = ko.observable(p.settings.showCellAnswerState);
        this.displayColumns = ko.observable(p.settings.displayColumns);
        switch(p.type) {
        case '1_n_2':
            /** Index of student's current answer choice (not necessarily submitted)
             * @member {observable|number} studentAnswer
             * @memberof Numbas.display.MultipleResponsePartDisplay
             */
            this.studentAnswer = Knockout.observable(null);
            for(var i=0;i<p.numAnswers;i++) {
                if(p.ticks[i][0])
                    this.studentAnswer(i);
            }
            var oldAnswer = null;
            Knockout.computed(function() {
                if(this.studentAnswer()==='') {
                    oldAnswer = null;
                    p.storeTick({answer:null, choice: 0});
                }
                var i = parseInt(this.studentAnswer());
                if(i!==oldAnswer && !isNaN(i)) {
                    p.storeTick({answer:i, choice:0});
                    oldAnswer = i;
                }
            },this);
            var max = 0, maxi = -1;
            for(var i=0;i<p.numAnswers;i++) {
                if(p.settings.matrix[i][0]>max || maxi==-1) {
                    max = p.settings.matrix[i][0];
                    maxi = i;
                }
            }
            /** Index of the answer which gains the most marks
             * @member {observable|number} correctAnswer
             * @memberof Numbas.display.MultipleResponsePartDisplay
             */
            this.correctAnswer = Knockout.observable(maxi+'');
            break;
        case 'm_n_2':
            /** For each choice, has the student selected it?
             *
             * For m_n_2 parts, this is a list of booleans. For m_n_x radiogroup parts, it's a list of indices. For m_n_x checkbox parts, it's a 2d array of booleans.
             * @member {observable|boolean[]|number[]|Array.Array.<boolean>} ticks
             * @memberof Numbas.display.MultipleResponsePartDisplay
             */
            this.ticks = [];
            /** For each choice, should it be selected to get the most marks?
             *
             * For m_n_2 parts, this is a list of booleans. For m_n_x radiogroup parts, it's a list of indices. For m_n_x checkbox parts, it's a 2d array of booleans.
             * @member {observable|boolean[]|number[]|Array.Array.<boolean>} ticks
             * @memberof Numbas.display.MultipleResponsePartDisplay
             */
            this.correctTicks = [];
            for(var i=0; i<p.numAnswers; i++) {
                this.ticks[i] = makeTicker(i,0);
                this.correctTicks[i] = p.settings.matrix[i][0]>0;
            }
            if(p.settings.warningType!='none') {
                Knockout.computed(function() {
                    this.removeWarnings();
                    var ticked = 0;
                    this.ticks.map(function(tick) {
                        ticked += tick() ? 1 : 0;
                    });
                    if(ticked<p.settings.minAnswers || ticked>p.settings.maxAnswers) {
                        p.giveWarning(R('part.mcq.wrong number of choices'));
                    };
                },this);
            }
            break;
        case 'm_n_x':
            switch(p.settings.displayType) {
            case 'radiogroup':
                this.ticks = [];
                this.correctTicks = [];
                for(var i=0; i<p.numChoices; i++) {
                    this.ticks.push(makeRadioTicker(i));
                    var maxj=-1,max=0;
                    for(var j=0;j<p.numAnswers; j++) {
                        if(maxj==-1 || p.settings.matrix[j][i]>max) {
                            maxj = j;
                            max = p.settings.matrix[j][i];
                        }
                    }
                    this.correctTicks.push(maxj);
                }
                break;
            case 'checkbox':
                this.ticks = [];
                this.correctTicks = [];
                for(var i=0; i<p.numAnswers; i++) {
                    var row = [];
                    this.ticks.push(row);
                    var correctRow = [];
                    this.correctTicks.push(correctRow);
                    for(var j=0; j<p.numChoices; j++) {
                        row.push(makeCheckboxTicker(i,j));
                        correctRow.push(p.settings.matrix[i][j]>0);
                    }
                }
                if(p.settings.warningType!='none') {
                    Knockout.computed(function() {
                        this.removeWarnings();
                        var ticked = 0;
                        this.ticks.map(function(row) {
                            row.map(function(tick) {
                                ticked += tick() ? 1 : 0;
                            });
                        });
                        if(ticked<p.settings.minAnswers || ticked>p.settings.maxAnswers) {
                            p.giveWarning(R('part.mcq.wrong number of choices'));
                        };
                    },this);
                }
                break;
            }
            break;
        }
    }
    display.MultipleResponsePartDisplay.prototype =
    {
        restoreAnswer: function()
        {
            var part = this.part;
            switch(part.type) {
            case '1_n_2':
                this.studentAnswer(null);
                for(var i=0;i<part.numAnswers; i++) {
                    if(part.ticks[i][0])
                        this.studentAnswer(i+'');
                }
                break;
            case 'm_n_2':
                for(var i=0; i<part.numAnswers; i++) {
                    this.ticks[i](part.ticks[i][0]);
                }
                break;
            case 'm_n_x':
                switch(part.settings.displayType) {
                case 'radiogroup':
                    for(var i=0; i<part.numAnswers; i++) {
                        for(var j=0; j<part.numChoices; j++) {
                            if(part.ticks[i][j]) {
                                this.ticks[j](i+'');
                            }
                        }
                    }
                    break;
                case 'checkbox':
                    for(var i=0; i<part.numAnswers; i++) {
                        for(var j=0; j<part.numChoices; j++) {
                            this.ticks[i][j](part.ticks[i][j]);
                        }
                    }
                    break;
                }
                break;
            }
        }
    };
    display.MultipleResponsePartDisplay = extend(display.PartDisplay,display.MultipleResponsePartDisplay,true);
});

/*
Copyright 2011-15 Newcastle University
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/** @file The {@link Numbas.parts.MultipleResponsePart} object */
Numbas.queueScript('parts/multipleresponse',['base','jme','jme-variables','util','part','marking_scripts'],function() {
var util = Numbas.util;
var jme = Numbas.jme;
var math = Numbas.math;
var Part = Numbas.parts.Part;
/** Multiple choice part - either pick one from a list, pick several from a list, or match choices with answers (2d grid, either pick one from each row or tick several from each row)
 *
 * Types:
 * * `1_n_2`: pick one from a list. Represented as N answers, 1 choice
 * * `m_n_2`: pick several from a list. Represented as N answers, 1 choice
 * * `m_n_x`: match choices (rows) with answers (columns). Represented as N answers, X choices.
 *
 * @constructor
 * @augments Numbas.parts.Part
 * @memberof Numbas.parts
 */
var MultipleResponsePart = Numbas.parts.MultipleResponsePart = function(path, question, parentPart)
{
    var p = this;
    var settings = this.settings;
    util.copyinto(MultipleResponsePart.prototype.settings,settings);
}
MultipleResponsePart.prototype = /** @lends Numbas.parts.MultipleResponsePart.prototype */
{
    loadFromXML: function(xml) {
        var settings = this.settings;
        var tryGetAttribute = Numbas.xml.tryGetAttribute;
        var scope = this.getScope();
        //get number of answers and answer order setting
        if(this.type == '1_n_2' || this.type == 'm_n_2') {
            // the XML for these parts lists the options in the <choices> tag, but it makes more sense to list them as answers
            // so swap "answers" and "choices"
            // this all stems from an extremely bad design decision made very early on
            this.flipped = true;
        } else {
            this.flipped = false;
        }
        //work out marks available
        tryGetAttribute(settings,xml,'.','showCellAnswerState');
        tryGetAttribute(settings,xml,'marking/maxmarks','enabled','maxMarksEnabled');
        if(this.type=='1_n_2') {
            settings.maxMarksEnabled = false;
        }
        if(settings.maxMarksEnabled) {
            tryGetAttribute(this,xml,'marking/maxmarks','value','marks');
        } else {
            tryGetAttribute(this,xml,'.','marks');
        }
        //get minimum marks setting
        tryGetAttribute(settings,xml,'marking/minmarks','enabled','minMarksEnabled');
        if(this.type=='1_n_2') {
            settings.minMarksEnabled = false;
        }
        if(settings.minMarksEnabled) {
            tryGetAttribute(settings,xml,'marking/minmarks','value','minimumMarks');
        }
        //get restrictions on number of choices
        var choicesNode = xml.selectSingleNode('choices');
        if(!choicesNode) {
            this.error('part.mcq.choices missing');
        }
        tryGetAttribute(settings,null,choicesNode,['minimumexpected','maximumexpected','shuffle','displayType','displayColumns'],['minAnswersString','maxAnswersString','shuffleChoices']);
        var choiceNodes = choicesNode.selectNodes('choice');
        var answersNode, answerNodes;
        if(this.type == '1_n_2' || this.type == 'm_n_2') {
            // the XML for these parts lists the options in the <choices> tag, but it makes more sense to list them as answers
            // so swap "answers" and "choices"
            // this all stems from an extremely bad design decision made very early on
            this.numAnswers = choiceNodes.length;
            this.numChoices = 1;
            answersNode = choicesNode;
            choicesNode = null;
        } else {
            this.numChoices = choiceNodes.length;
            answersNode = xml.selectSingleNode('answers');
            if(answersNode) {
                tryGetAttribute(settings,null,answersNode,'shuffle','shuffleAnswers');
                answerNodes = answersNode.selectNodes('answer');
                this.numAnswers = answerNodes.length;
            }
        }
        var def;
        function loadDef(def,scope,topNode,nodeName) {
            var values = jme.evaluate(def,scope);
            if(values.type!='list') {
                p.error('part.mcq.options def not a list',{properties: nodeName});
            }
            var numValues = values.value.length;
            values.value.map(function(value) {
                var node = xml.ownerDocument.createElement(nodeName);
                var content = xml.ownerDocument.createElement('content');
                var span = xml.ownerDocument.createElement('span');
                content.appendChild(span);
                node.appendChild(content);
                topNode.appendChild(node);
                switch(value.type) {
                case 'string':
                case 'number':
                    var d = document.createElement('d');
                    d.innerHTML = value.type == 'string' ? value.value : Numbas.math.niceNumber(value.value);
                    var newNode;
                    try {
                        newNode = xml.ownerDocument.importNode(d,true);
                    } catch(e) {
                        d = Numbas.xml.dp.parseFromString('<d>'+value.value.replace(/&(?!amp;)/g,'&amp;')+'</d>','text/xml').documentElement;
                        newNode = xml.ownerDocument.importNode(d,true);
                    }
                    while(newNode.childNodes.length) {
                        span.appendChild(newNode.childNodes[0]);
                    }
                    break;
                case 'html':
                    var selection = $(value.value);
                    for(var i=0;i<selection.length;i++) {
                        try {
                            span.appendChild(xml.ownerDocument.importNode(selection[i],true));
                        } catch(e) {
                            var d = Numbas.xml.dp.parseFromString('<d>'+selection[i].outerHTML+'</d>','text/xml').documentElement;
                            var newNode = xml.ownerDocument.importNode(d,true);
                            while(newNode.childNodes.length) {
                                span.appendChild(newNode.childNodes[0]);
                            }
                        }
                    }
                    break;
                default:
                    span.appendChild(xml.ownerDocument.createTextNode(value));
                }
            });
            return numValues;
        }
        if(def = answersNode.getAttribute('def')) {
            settings.answersDef = def;
            var nodeName = this.flipped ? 'choice' : 'answer';
            loadDef(settings.answersDef,scope,answersNode,nodeName);
            answerNodes = answersNode.selectNodes(nodeName);
            this.numAnswers = answerNodes.length;
        }
        if(choicesNode && (def = choicesNode.getAttribute('def'))) {
            settings.choicesDef = def;
            loadDef(settings.choicesDef,scope,choicesNode,'choice');
            choiceNodes = choicesNode.selectNodes('choice');
            this.numChoices = choiceNodes.length;
        }
        //get warning type and message for wrong number of choices
        warningNode = xml.selectSingleNode('marking/warning');
        if(warningNode) {
            tryGetAttribute(settings,null,warningNode,'type','warningType');
        }
        if(this.type=='m_n_x') {
            var layoutNode = xml.selectSingleNode('layout');
            tryGetAttribute(settings,null,layoutNode,['type','expression'],['layoutType','layoutExpression']);
        }
        //fill marks matrix
        var def;
        var markingMatrixNode = xml.selectSingleNode('marking/matrix');
        var markingMatrixString = markingMatrixNode.getAttribute('def');
        var useMarkingString = settings.answersDef || settings.choicesDef || (typeof markingMatrixString == "string");
        if(useMarkingString) {
            settings.markingMatrixString = markingMatrixString;
            if(!settings.markingMatrixString) {
                this.error('part.mcq.marking matrix string empty')
            }
        } else {
            var matrixNodes = xml.selectNodes('marking/matrix/mark');
            var markingMatrixArray = settings.markingMatrixArray = [];
            for( i=0; i<this.numAnswers; i++ ) {
                markingMatrixArray.push([]);
            }
            for( i=0; i<matrixNodes.length; i++ ) {
                var cell = {value: ""};
                tryGetAttribute(cell,null, matrixNodes[i], ['answerIndex', 'choiceIndex', 'value']);
                if(this.flipped) {
                    // possible answers are recorded as choices in the multiple choice types.
                    // switch the indices round, so we don't have to worry about this again
                    cell.answerIndex = cell.choiceIndex;
                    cell.choiceIndex = 0;
                }
                markingMatrixArray[cell.answerIndex][cell.choiceIndex] = cell.value;
            }
        }
        var distractors = [];
        for( i=0; i<this.numAnswers; i++ ) {
            var row = [];
            for(var j=0;j<this.numChoices;j++) {
                row.push('');
            }
            distractors.push(row);
        }
        var distractorNodes = xml.selectNodes('marking/distractors/distractor');
        for( i=0; i<distractorNodes.length; i++ )
        {
            var cell = {message: ""};
            tryGetAttribute(cell,null, distractorNodes[i], ['answerIndex', 'choiceIndex']);
            cell.message = $.xsl.transform(Numbas.xml.templates.question,distractorNodes[i]).string;
            cell.message = jme.contentsubvars(cell.message,scope);
            if(this.type == '1_n_2' || this.type == 'm_n_2') {
                // possible answers are recorded as choices in the multiple choice types.
                // switch the indices round, so we don't have to worry about this again
                cell.answerIndex = cell.choiceIndex;
                cell.choiceIndex = 0;
            }
            distractors[cell.answerIndex][cell.choiceIndex] = util.isNonemptyHTML(cell.message) ? cell.message : '';
        }
        settings.distractors = distractors;
    },
    loadFromJSON: function(data) {
        var settings = this.settings;
        var tryLoad = Numbas.json.tryLoad;
        var scope = this.getScope();
        //get number of answers and answer order setting
        if(this.type == '1_n_2' || this.type == 'm_n_2') {
            this.flipped = true;
        } else {
            this.flipped = false;
        }
        tryLoad(data, ['maxMarks'], this, ['marks']);
        tryLoad(data, ['minMarks'], settings, ['minimumMarks']);
        tryLoad(data, ['minAnswers', 'maxAnswers', 'shuffleChoices', 'shuffleAnswers', 'displayType','displayColumns'], settings, ['minAnswersString', 'maxAnswersString', 'shuffleChoices', 'shuffleAnswers', 'displayType','displayColumns']);
        tryLoad(data, ['warningType'], settings);
        tryLoad(data.layout, ['type', 'expression'], settings, ['layoutType', 'layoutExpression']);
        if('choices' in data) {
            if(typeof(data.choices)=='string') {
                choices = jme.evaluate(data.choices, scope);
                if(settings.choices.type!='list') {
                    this.error('part.mcq.options def not a list',{properties: 'choice'});
                }
                settings.choices = jme.unwrapValue(choices);
            } else {
                settings.choices = data.choices;
            }
            this.numChoices = settings.choices.length;
        }
        if('answers' in data) {
            if(typeof(data.answers)=='string') {
                answers = jme.evaluate(data.answers, scope);
                if(settings.answers.type!='list') {
                    this.error('part.mcq.options def not a list',{properties: 'answer'});
                }
                settings.answers = jme.unwrapValue(answers);
            } else {
                settings.answers = data.answers;
            }
            this.numAnswers = settings.answers.length;
        }
        if(this.flipped) {
            this.numAnswers = 1;
        }
        if(typeof(data.matrix)=='string') {
            settings.markingMatrixString = data.matrix;
        } else {
            settings.markingMatrixArray = data.matrix.map(function(row){return typeof(row)=='object' ? row : [row]});
            if(!this.flipped) {
                var m = settings.markingMatrixArray;
                m.rows = this.numChoices;
                m.columns = this.numAnswers;
                settings.markingMatrixArray = Numbas.matrixmath.transpose(settings.markingMatrixArray);
            }
        }
        if(this.flipped) {
            this.numAnswers = this.numChoices;
            this.numChoices = 1;
            this.answers = this.choices;
            this.choices = null;
        }
        tryLoad(data, ['distractors'], settings);
        if(settings.distractors && (this.type=='1_n_2' || this.type=='m_n_2')) {
            settings.distractors = settings.distractors.map(function(d){return [d]});
        }
        if(!settings.distractors) {
            settings.distractors = [];
            for(var i=0;i<this.numAnswers; i++) {
                var row = [];
                for(var j=0;j<this.numChoices; j++) {
                    row.push('');
                }
                settings.distractors.push(row);
            }
        }
    },
    resume: function() {
        if(!this.store) {
            return;
        }
        var pobj = this.store.loadPart(this);
        this.shuffleChoices = pobj.shuffleChoices;
        this.shuffleAnswers = pobj.shuffleAnswers;
        this.ticks = pobj.studentAnswer;
        this.stagedAnswer = [];
        for( i=0; i<this.numAnswers; i++ ) {
            this.stagedAnswer.push([]);
            for( var j=0; j<this.numChoices; j++ ) {
                this.stagedAnswer[i].push(pobj.studentAnswer[i][j] || false);
            }
        }
    },
    finaliseLoad: function() {
        var settings = this.settings;
        var scope = this.getScope();
        //get number of answers and answer order setting
        if(this.type == '1_n_2' || this.type == 'm_n_2') {
            settings.shuffleAnswers = settings.shuffleChoices;
            settings.shuffleChoices = false;
        }
        this.shuffleChoices = [];
        if(settings.shuffleChoices) {
            this.shuffleChoices = math.deal(this.numChoices);
        } else {
            this.shuffleChoices = math.range(this.numChoices);
        }
        this.shuffleAnswers = [];
        if(settings.shuffleAnswers) {
            this.shuffleAnswers = math.deal(this.numAnswers);
        } else {
            this.shuffleAnswers = math.range(this.numAnswers);
        }
        this.marks = util.parseNumber(this.marks) || 0;
        settings.minimumMarks = util.parseNumber(settings.minimumMarks) || 0;
        var minAnswers = jme.subvars(settings.minAnswersString, scope);
        minAnswers = jme.evaluate(minAnswers, scope);
        if(minAnswers && minAnswers.type=='number') {
            settings.minAnswers = minAnswers.value;
        } else {
            this.error('part.setting not present',{property: 'minimum answers'});
        }
        var maxAnswers = jme.subvars(settings.maxAnswersString, scope);
        maxAnswers = jme.evaluate(maxAnswers, scope);
        if(maxAnswers && maxAnswers.type=='number') {
            settings.maxAnswers = maxAnswers.value;
        } else {
            this.error('part.setting not present',{property: 'maximum answers'});
        }
        // fill layout matrix
        var layout = this.layout = [];
        if(this.type=='m_n_x') {
            if(settings.layoutType=='expression') {
                // expression can either give a 2d array (list of lists) or a matrix
                // note that the list goes [row][column], unlike all the other properties of this part object, which go [column][row], i.e. they're indexed by answer then choice
                // it's easier for question authors to go [row][column] because that's how they're displayed, but it's too late to change the internals of the part to match that now
                // I have only myself to thank for this - CP
                var layoutMatrix = jme.unwrapValue(jme.evaluate(settings.layoutExpression,scope));
                var layoutFunction = function(row,column) { return layoutMatrix[row][column]; };
            } else {
                var layoutFunction = MultipleResponsePart.layoutTypes[settings.layoutType];
            }
            for(var i=0;i<this.numAnswers;i++) {
                var row = [];
                for(var j=0;j<this.numChoices;j++) {
                    row.push(layoutFunction(j,i));
                }
                layout.push(row);
            }
        } else {
            for(var i=0;i<this.numAnswers;i++) {
                var row = [];
                for(var j=0;j<this.numChoices;j++) {
                    row.push(true);
                }
                layout.push(row);
            }
        }
        if(this.type=='1_n_2') {
            settings.maxAnswers = 1;
        } else if(settings.maxAnswers==0) {
            settings.maxAnswers = this.numAnswers * this.numChoices;
        }
        this.getCorrectAnswer(scope);
        if(this.marks == 0) {    //if marks not set explicitly
            var matrix = this.settings.matrix;
            var flat = [];
            switch(this.type)
            {
            case '1_n_2':
                for(var i=0;i<matrix.length;i++) {
                    flat.push(matrix[i][0]);
                }
                break;
            case 'm_n_2':
                for(var i=0;i<matrix.length;i++) {
                    flat.push(matrix[i][0]);
                }
                break;
            case 'm_n_x':
                if(settings.displayType=='radiogroup') {
                    for(var i=0;i<this.numChoices;i++)
                    {
                        var row = [];
                        for(var j=0;j<this.numAnswers;j++)
                        {
                            row.push(matrix[j][i]);
                        }
                        row.sort(function(a,b){return a>b ? 1 : a<b ? -1 : 0});
                        flat.push(row[row.length-1]);
                    }
                } else {
                    for(var i=0;i<matrix.length;i++) {
                        flat = flat.concat(matrix[i]);
                    }
                }
                break;
            }
            flat.sort(function(a,b){return a>b ? 1 : a<b ? -1 : 0});
            for(var i=flat.length-1; i>=0 && flat.length-1-i<settings.maxAnswers && flat[i]>0;i--) {
                this.marks+=flat[i];
            }
        }
        //ticks array - which answers/choices are selected?
        this.ticks = [];
        this.stagedAnswer = [];
        for( i=0; i<this.numAnswers; i++ ) {
            this.ticks.push([]);
            this.stagedAnswer.push([]);
            for( var j=0; j<this.numChoices; j++ ) {
                this.ticks[i].push(false);
                this.stagedAnswer[i].push(false);
            }
        }
        if(Numbas.display) {
            this.display = new Numbas.display.MultipleResponsePartDisplay(this);
        }
    },
    /** Student's last submitted answer/choice selections
     * @type {Array.<Array.<Boolean>>}
     */
    ticks: [],
    /** The script to mark this part - assign credit, and give messages and feedback.
     * @returns {Numbas.marking.MarkingScript}
     */
    baseMarkingScript: function() { return Numbas.marking_scripts.multipleresponse; },
    /** Number of choices - used by `m_n_x` parts
     * @type {Number}
     */
    numChoices: 0,
    /** Number of answers
     * @type {Number}
     */
    numAnswers: 0,
    /** Have choice and answers been swapped (because of the weird settings for 1_n_2 and m_n_2 parts)
     * @type {Boolean}
     */
    flipped: false,
    /** Properties set when the part is generated
     * Extends {@link Numbas.parts.Part#settings}
     * @property {Boolean} maxMarksEnabled - is there a maximum number of marks the student can get?
     * @property {String} minAnswersString - minimum number of responses the student must select, without variables substituted in.
     * @property {String} maxAnswersString - maximum number of responses the student must select, without variables substituted in.
     * @property {Number} minAnswers - minimum number of responses the student must select. Generated from `minAnswersString`.
     * @property {Number} maxAnswers - maximum number of responses the student must select. Generated from `maxAnswersString`.
     * @property {String} shuffleChoices - should the order of choices be randomised?
     * @property {String} shuffleAnswers - should the order of answers be randomised?
     * @property {Array.<Array.<Number>>} matrix - marks for each answer/choice pair. Arranged as `matrix[answer][choice]`
     * @property {String} displayType - how to display the response selectors. Can be `radiogroup`, `checkbox` or `dropdownlist`.
     * @property {Number} displayColumns - how many columns to use to display the choices
     * @property {String} warningType - what to do if the student picks the wrong number of responses? Either `none` (do nothing), `prevent` (don't let the student submit), or `warn` (show a warning but let them submit)
     * @property {String} layoutType - The kind of layout to use. See {@link Numbas.parts.MultipleResponsePart.layoutTypes}
     * @property {JME} layoutExpression - Expression giving a 2d array or matrix describing the layout when `layoutType` is `'expression'`.
     */
    settings:
    {
        maxMarksEnabled: false,        //is there a maximum number of marks the student can get?
        minAnswersString: '0',                //minimum number of responses student must select
        maxAnswersString: '0',                //maximum ditto
        minAnswers: 0,                //minimum number of responses student must select
        maxAnswers: 0,                //maximum ditto
        shuffleChoices: false,
        shuffleAnswers: false,
        matrix: [],                    //marks matrix
        displayType: '',            //how to display the responses? can be: radiogroup, dropdownlist, buttonimage, checkbox, choicecontent
        warningType: '',                //what to do if wrong number of responses
        layoutType: 'all',
        layoutExpression: ''
    },
    /** The name of the input widget this part uses, if any.
     * @returns {String}
     */
    input_widget: function() {
        switch(this.type) {
            case '1_n_2':
                switch(this.settings.displayType) {
                    case 'radiogroup':
                        return 'radios'	;
                    case 'dropdownlist':
                        return 'dropdown';
                }
            case 'm_n_2':
                return 'checkboxes';
            case 'm_n_x':
                return 'm_n_x';
        }
    },
    /** Options for this part's input widget
     * @returns {Object}
     */
    input_options: function() {
        return {
            choices: this.settings.choices,
            answers: this.settings.answers,
            answerAsArray: true
        };
    },
    /** Compute the correct answer, based on the given scope
     */
    getCorrectAnswer: function(scope) {
        var settings = this.settings;
        var matrix = [];
        if(settings.markingMatrixString) {
            matrix = jme.evaluate(settings.markingMatrixString,scope);
            switch(matrix.type) {
            case 'list':
                var numLists = 0;
                var numNumbers = 0;
                for(var i=0;i<matrix.value.length;i++) {
                    switch(matrix.value[i].type) {
                    case 'list':
                        numLists++;
                        break;
                    case 'number':
                        numNumbers++;
                        break;
                    default:
                        this.error('part.mcq.matrix wrong type',{type: matrix.value[i].type});
                    }
                }
                if(numLists == matrix.value.length) {
                    matrix = matrix.value.map(function(row){    //convert TNums to javascript numbers
                        return row.value.map(function(e){return e.value;});
                    });
                } else if(numNumbers == matrix.value.length) {
                    matrix = matrix.value.map(function(e) {
                        return [e.value];
                    });
                } else {
                    this.error('part.mcq.matrix mix of numbers and lists');
                }
                matrix.rows = matrix.length;
                matrix.columns = matrix[0].length;
                break;
            case 'matrix':
                matrix = matrix.value;
                break;
            default:
                this.error('part.mcq.matrix not a list');
            }
            if(this.flipped) {
                matrix = Numbas.matrixmath.transpose(matrix);
            }
            if(matrix.length!=this.numChoices) {
                this.error('part.mcq.matrix wrong size');
            }
            // take into account shuffling;
            for(var i=0;i<this.numChoices;i++) {
                if(matrix[i].length!=this.numAnswers) {
                    this.error('part.mcq.matrix wrong size');
                }
            }
            matrix = Numbas.matrixmath.transpose(matrix);
        } else {
            for(var i=0;i<this.numAnswers;i++) {
                var row = [];
                matrix.push(row);
                for(var j=0;j<this.numChoices;j++) {
                    var value = settings.markingMatrixArray[i][j];
                    if(util.isFloat(value)) {
                        value = parseFloat(value);
                    } else {
                        if(value == ''){
                          this.error('part.mcq.matrix cell empty',{part:this.path,row:i,column:j});
                        }
                        try {
                          value = jme.evaluate(value,scope).value;
                        } catch(e) {
                          this.error('part.mcq.matrix jme error',{part:this.path,row:i,column:j,error:e.message});
                        }
                        if(!util.isFloat(value)) {
                          this.error('part.mcq.matrix not a number',{part:this.path,row:i,column:j});
                        }
                        value = parseFloat(value);
                    }
                    row[j] = value;
                }
            }
        }
        for(var i=0;i<matrix.length;i++) {
            var l = matrix[i].length;
            for(var j=0;j<l;j++) {
                if(!this.layout[i][j]) {
                    matrix[i][j] = 0;
                }
            }
        }
        switch(this.type) {
        case '1_n_2':
            var max = 0, maxi = null;
            for(var i=0;i<this.numAnswers;i++) {
                if(matrix[i][0]>max || maxi===null) {
                    max = matrix[i][0];
                    maxi = i;
                }
            }
            var best = [];
            for(var i=0;i<this.numAnswers;i++) {
                best.push([i==maxi]);
            }
            settings.maxMatrix = best;
            break;
        case 'm_n_2':
            settings.maxMatrix = matrix.map(function(r){ return [r[0]>0]; });
            break;
        case 'm_n_x':
            settings.maxMatrix = matrix.map(function(r){ return r.map(function(c){return c>0; }) });
            break;
        }
        settings.matrix = matrix;
    },
    /** Store the student's choices */
    storeTick: function(answer)
    {
        this.setDirty(true);
        this.display && this.display.removeWarnings();
        //get choice and answer
        //in MR1_n_2 and MRm_n_2 parts, only the choiceindex matters
        var answerIndex = answer.answer;
        var choiceIndex = answer.choice;
        switch(this.settings.displayType)
        {
        case 'radiogroup':                            //for radiogroup parts, only one answer can be selected.
        case 'dropdownlist':
            for(var i=0; i<this.numAnswers; i++)
            {
                this.stagedAnswer[i][choiceIndex] = i===answerIndex;
            }
            break;
        default:
            this.stagedAnswer[answerIndex][choiceIndex] = answer.ticked;
        }
    },
    /** Save a copy of the student's answer as entered on the page, for use in marking.
     */
    setStudentAnswer: function() {
        this.ticks = util.copyarray(this.stagedAnswer,true);
    },
    /** Get the student's answer as it was entered as a JME data type, to be used in the custom marking algorithm
     * @abstract
     * @returns {Numbas.jme.token}
     */
    rawStudentAnswerAsJME: function() {
        return Numbas.jme.wrapValue(this.ticks);
    },
    /** Get the student's answer as a JME data type, to be used in error-carried-forward calculations
     * @abstract
     * @returns {Numbas.jme.token}
     */
    studentAnswerAsJME: function() {
        switch(this.type) {
            case '1_n_2':
                for(var i=0;i<this.numAnswers;i++) {
                    if(this.ticks[i][0]) {
                        return new jme.types.TNum(i);
                    }
                }
                break;
            case 'm_n_2':
                var o = [];
                for(var i=0;i<this.numAnswers;i++) {
                    o.push(new jme.types.TBool(this.ticks[i][0]));
                }
                return new jme.types.TList(o);
            case 'm_n_x':
                switch(this.settings.displayType) {
                    case 'radiogroup':
                        var o = [];
                        for(var choice=0;choice<this.numChoices;choice++) {
                            for(var answer=0;answer<this.numAnswers;answer++) {
                                if(this.ticks[choice][answer]) {
                                    o.push(new jme.types.TNum(answer));
                                    break;
                                }
                            }
                        }
                        return new jme.types.TList(o);
                    case 'checkbox':
                        return Numbas.jme.wrapValue(this.ticks);
                }
        }
    },
    /** Reveal the correct answers, and any distractor messages for the student's choices
     * Extends {@link Numbas.parts.Part.revealAnswer}
     */
    revealAnswer: function()
    {
        var row,message;
        for(var i=0;i<this.numAnswers;i++)
        {
            for(var j=0;j<this.numChoices;j++)
            {
                if((row = this.settings.distractors[i]) && (message=row[j]))
                {
                    this.markingComment(message);
                }
            }
        }
    }
};
['resume','finaliseLoad','loadFromXML','loadFromJSON'].forEach(function(method) {
    MultipleResponsePart.prototype[method] = util.extend(Part.prototype[method],MultipleResponsePart.prototype[method]);
});
['revealAnswer'].forEach(function(method) {
    MultipleResponsePart.prototype[method] = util.extend(MultipleResponsePart.prototype[method], Part.prototype[method]);
});

/** Layouts for multiple response types
 * @type {Object.<function>}
 */
Numbas.parts.MultipleResponsePart.layoutTypes = {
    all: function(row,column) { return true; },
    lowertriangle: function(row,column) { return row>=column; },
    strictlowertriangle: function(row,column) { return row>column; },
    uppertriangle: function(row,column) { return row<=column; },
    strictuppertriangle: function(row,column) { return row<column; }
};
Numbas.partConstructors['1_n_2'] = util.extend(Part,MultipleResponsePart);
Numbas.partConstructors['m_n_2'] = util.extend(Part,MultipleResponsePart);
Numbas.partConstructors['m_n_x'] = util.extend(Part,MultipleResponsePart);
});

Numbas.queueScript('display/parts/numberentry',['display-base','part-display','util'],function() {
    var display = Numbas.display;
    var extend = Numbas.util.extend;
    var util = Numbas.util;
    /** Display code for a {@link Numbas.parts.NumberEntryPart}
     * @augments Numbas.display.PartDisplay
     * @constructor
     * @name NumberEntryPartDisplay
     * @memberof Numbas.display
     */
    display.NumberEntryPartDisplay = function()
    {
        var p = this.part;
        /** The student's current (not necessarily submitted) answer
         * @member {observable|string} studentAnswer
         * @memberof Numbas.display.NumberEntryPartDisplay
         */
        this.studentAnswer = Knockout.observable(p.studentAnswer);
        /** The correct answer
         * @member {observable|number} correctAnswer
         * @memberof Numbas.display.NumberEntryPartDisplay
         */
        this.correctAnswer = Knockout.observable(p.settings.displayAnswer);
        ko.computed(function() {
            p.storeAnswer(this.studentAnswer());
        },this);
        /** Cleaned-up version of student answer (remove commas and trim whitespace)
         *
         * Also check for validity and give warnings
         * @member {observable|string} cleanStudentAnswer
         * @memberof Numbas.display.NumberEntryPartDisplay
         */
        this.cleanStudentAnswer = Knockout.computed(function() {
            var studentAnswer = p.cleanAnswer(this.studentAnswer());
            this.removeWarnings();
            if(studentAnswer=='')
                return '';
            if(p.settings.integerAnswer) {
                var dp = Numbas.math.countDP(studentAnswer);
                if(dp>0)
                    p.giveWarning(R('part.numberentry.answer not integer'));
            }
            if(!util.isNumber(studentAnswer,p.settings.allowFractions,p.settings.notationStyles,true)) {
                p.giveWarning(R('part.numberentry.answer not integer or decimal'));
                return '';
            }
            var n = util.parseNumber(studentAnswer,p.settings.allowFractions,p.settings.notationStyles,true);
            return n+'';
        },this);
        /** Show a LaTeX rendering of the answer?
         * @member {boolean} showPreview
         * @memberof Numbas.display.NumberEntryPartDisplay
         */
        this.showPreview = false;
        /** TeX version of student's answer
         * @member {observable|TeX} studentAnswerLaTeX
         * @memberof Numbas.display.NumberEntryPartDisplay
         */
        this.studentAnswerLaTeX = Knockout.computed(function() {
            return this.cleanStudentAnswer();
        },this);
        /** Does the input box have focus?
         * @member {observable|boolean} inputHasFocus
         * @memberof Numbas.display.NumberEntryPartDisplay
         */
        this.inputHasFocus = Knockout.observable(false);
        /** Give the input box focus
         * @member {function} focusInput
         * @method
         * @memberof Numbas.display.NumberEntryPartDisplay
         */
        this.focusInput = function() {
            this.inputHasFocus(true);
        }
        /** Some text describing what precision the student should round their answer to
         * @member {observable|string} precisionHint
         * @memberof Numbas.display.NumberEntryPartDisplay
         */
        this.precisionHint = Knockout.computed(function() {
            if(this.part.settings.precisionType=='none') {
                if(this.part.settings.mustBeReduced) {
                    return R('part.numberentry.give your answer as a reduced fraction');
                } else {
                    return '';
                }
            } else {
                var precision = this.part.settings.precision;
                var precisionType = R('part.numberentry.precision type.'+this.part.settings.precisionType,{count:precision});
                if (precision === 0) {
                  return R('part.numberentry.give your answer to precision_0',{count: precision,precisionType: precisionType});
                } else {
                  return R('part.numberentry.give your answer to precision',{count: precision,precisionType: precisionType});
                }
            }
        },this);
        /** Show the precision restriction hint?
         * @member {observable|string} showPrecisionHint
         * @memberof Numbas.display.NumberEntryPartDisplay
         */
        this.showPrecisionHint = Knockout.computed(function() {
            return this.part.settings.showPrecisionHint && this.precisionHint();
        },this);
    }
    display.NumberEntryPartDisplay.prototype =
    {
        restoreAnswer: function()
        {
            this.studentAnswer(this.part.studentAnswer);
        }
    };
    display.NumberEntryPartDisplay = extend(display.PartDisplay,display.NumberEntryPartDisplay,true);
});

/*
Copyright 2011-15 Newcastle University
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/** @file The {@link Numbas.parts.NumberEntryPart} object */
Numbas.queueScript('parts/numberentry',['base','jme','jme-variables','util','part','marking_scripts'],function() {
var util = Numbas.util;
var jme = Numbas.jme;
var math = Numbas.math;
var Part = Numbas.parts.Part;
/** Number entry part - student's answer must be within given range, and written to required precision.
 * @constructor
 * @memberof Numbas.parts
 * @augments Numbas.parts.Part
 */
var NumberEntryPart = Numbas.parts.NumberEntryPart = function(xml, path, question, parentPart, loading)
{
    var settings = this.settings;
    util.copyinto(NumberEntryPart.prototype.settings,settings);
}
NumberEntryPart.prototype = /** @lends Numbas.parts.NumberEntryPart.prototype */
{
    loadFromXML: function(xml) {
        var settings = this.settings;
        var tryGetAttribute = Numbas.xml.tryGetAttribute;
        tryGetAttribute(settings,xml,'answer',['minvalue','maxvalue'],['minvalueString','maxvalueString'],{string:true});
        tryGetAttribute(settings,xml,'answer',['correctanswerfraction','correctanswerstyle','allowfractions'],['correctAnswerFraction','correctAnswerStyle','allowFractions']);
        tryGetAttribute(settings,xml,'answer',['mustbereduced','mustbereducedpc'],['mustBeReduced','mustBeReducedPC']);
        var answerNode = xml.selectSingleNode('answer');
        var notationStyles = answerNode.getAttribute('notationstyles');
        if(notationStyles) {
            settings.notationStyles = notationStyles.split(',');
        }
        tryGetAttribute(settings,xml,'answer/precision',['type','partialcredit','strict','showprecisionhint'],['precisionType','precisionPC','strictPrecision','showPrecisionHint']);
        tryGetAttribute(settings,xml,'answer/precision','precision','precisionString',{'string':true});
        var messageNode = xml.selectSingleNode('answer/precision/message');
        if(messageNode) {
            settings.precisionMessage = $.xsl.transform(Numbas.xml.templates.question,messageNode).string;
        }
    },
    loadFromJSON: function(data) {
        var settings = this.settings;
        var tryLoad = Numbas.json.tryLoad;
        tryLoad(data, ['minValue', 'maxValue'], settings, ['minvalueString', 'maxvalueString']);
        tryLoad(data, ['correctAnswerFraction', 'correctAnswerStyle', 'allowFractions'], settings);
        tryLoad(data, ['mustBeReduced', 'mustBeReducedPC'], settings);
        tryLoad(data, ['notationStyles'], settings);
        tryLoad(data, ['precisionPartialCredit', 'strictPrecision', 'showPrecisionHint', 'precision', 'precisionType', 'precisionMessage'], settings, ['precisionPC', 'strictPrecision', 'showPrecisionHint', 'precisionString', 'precisionType', 'precisionMessage']);
        settings.precisionPC /= 100;
    },
    finaliseLoad: function() {
        var settings = this.settings;
        if(settings.precisionType!='none') {
            settings.allowFractions = false;
        }
        try {
            this.getCorrectAnswer(this.getScope());
        } catch(e) {
            this.error(e.message);
        }
        this.stagedAnswer = '';
        if(Numbas.display) {
            this.display = new Numbas.display.NumberEntryPartDisplay(this);
        }
    },
    resume: function() {
        if(!this.store) {
            return;
        }
        var pobj = this.store.loadPart(this);
        this.stagedAnswer = pobj.studentAnswer+'';
    },
    /** The student's last submitted answer */
    studentAnswer: '',
    /** The script to mark this part - assign credit, and give messages and feedback.
     * @returns {Numbas.marking.MarkingScript}
     */
    baseMarkingScript: function() { return Numbas.marking_scripts.numberentry; },
    /** Properties set when the part is generated
     * Extends {@link Numbas.parts.Part#settings}
     * @property {Number} minvalueString - definition of minimum value, before variables are substituted in
     * @property {Number} minvalue - minimum value marked correct
     * @property {Number} maxvalueString - definition of maximum value, before variables are substituted in
     * @property {Number} maxvalue - maximum value marked correct
     * @property {Number} correctAnswerFraction - display the correct answer as a fraction?
     * @property {Boolean} allowFractions - can the student enter a fraction as their answer?
     * @property {Array.<String>} notationStyles - styles of notation to allow, other than `<digits>.<digits>`. See {@link Numbas.util.re_decimal}.
     * @property {Number} displayAnswer - representative correct answer to display when revealing answers
     * @property {String} precisionType - type of precision restriction to apply: `none`, `dp` - decimal places, or `sigfig` - significant figures
     * @property {Number} precisionString - definition of precision setting, before variables are substituted in
     * @property {Boolean} strictPrecision - must the student give exactly the required precision? If false, omitting trailing zeros is allowed.
     * @property {Number} precision - how many decimal places or significant figures to require
     * @property {Number} precisionPC - partial credit to award if the answer is between `minvalue` and `maxvalue` but not given to the required precision
     * @property {String} precisionMessage - message to display in the marking feedback if their answer was not given to the required precision
     * @property {Boolean} mustBeReduced - should the student enter a fraction in lowest terms
     * @property {Number} mustBeReducedPC - partial credit to award if the answer is not a reduced fraction
     */
    settings:
    {
        minvalueString: '0',
        maxvalueString: '0',
        minvalue: 0,
        maxvalue: 0,
        correctAnswerFraction: false,
        allowFractions: false,
        notationStyles: ['plain','en','si-en'],
        displayAnswer: 0,
        precisionType: 'none',
        precisionString: '0',
        strictPrecision: false,
        precision: 0,
        precisionPC: 0,
        mustBeReduced: false,
        mustBeReducedPC: 0,
        precisionMessage: R('You have not given your answer to the correct precision.'),
        showPrecisionHint: true
    },
    /** The name of the input widget this part uses, if any.
     * @returns {String}
     */
    input_widget: function() {
        return 'string';
    },
    /** Options for this part's input widget
     * @returns {Object}
     */
    input_options: function() {
        return {
            allowFractions: this.settings.allowFractions,
            allowedNotationStyles: this.settings.notationStyles
        };
    },
    /** Compute the correct answer, based on the given scope
     */
    getCorrectAnswer: function(scope) {
        var settings = this.settings;
        var precision = jme.subvars(settings.precisionString, scope);
        settings.precision = scope.evaluate(precision).value;
        if(settings.precisionType=='sigfig' && settings.precision<=0) {
            throw(new Numbas.Error('part.numberentry.zero sig fig'));
        }
        if(settings.precisionType=='dp' && settings.precision<0) {
            throw(new Numbas.Error('part.numberentry.negative decimal places'));
        }
        var minvalue = jme.subvars(settings.minvalueString,scope);
        minvalue = scope.evaluate(minvalue);
        if(minvalue && minvalue.type=='number') {
            minvalue = minvalue.value;
        } else {
            throw(new Numbas.Error('part.setting not present',{property:R('minimum value')}));
        }
        var maxvalue = jme.subvars(settings.maxvalueString,scope);
        maxvalue = scope.evaluate(maxvalue);
        if(maxvalue && maxvalue.type=='number') {
            maxvalue = maxvalue.value;
        } else {
            throw(new Numbas.Error('part.setting not present',{property:R('maximum value')}));
        }
        var displayAnswer = (minvalue + maxvalue)/2;
        if(settings.correctAnswerFraction) {
            var diff = Math.abs(maxvalue-minvalue)/2;
            var accuracy = Math.max(15,Math.ceil(-Math.log(diff)));
            settings.displayAnswer = jme.display.jmeRationalNumber(displayAnswer,{accuracy:accuracy});
        } else {
            settings.displayAnswer = math.niceNumber(displayAnswer,{precisionType: settings.precisionType, precision:settings.precision, style: settings.correctAnswerStyle});
        }
        var fudge = 0.00000000001;
        settings.minvalue = minvalue - fudge;
        settings.maxvalue = maxvalue + fudge;
    },
    /** Tidy up the student's answer - at the moment, just remove space.
     * You could override this to do more substantial filtering of the student's answer.
     * @param {String} answer
     * @returns {String}
     */
    cleanAnswer: function(answer) {
        answer = answer.toString().trim();
        return answer;
    },
    /** Save a copy of the student's answer as entered on the page, for use in marking.
     */
    setStudentAnswer: function() {
        this.studentAnswer = this.cleanAnswer(this.stagedAnswer);
    },
    /** Get the student's answer as it was entered as a JME data type, to be used in the custom marking algorithm
     * @abstract
     * @returns {Numbas.jme.token}
     */
    rawStudentAnswerAsJME: function() {
        return new Numbas.jme.types.TString(this.studentAnswer);
    }
};
['loadFromXML','loadFromJSON','resume','finaliseLoad'].forEach(function(method) {
    NumberEntryPart.prototype[method] = util.extend(Part.prototype[method], NumberEntryPart.prototype[method]);
});
Numbas.partConstructors['numberentry'] = util.extend(Part,NumberEntryPart);
});

Numbas.queueScript('display/parts/patternmatch',['display-base','part-display','util'],function() {
    var display = Numbas.display;
    var extend = Numbas.util.extend;
    /** Display code for a {@link Numbas.parts.PatternMatchPart}
     * @augments Numbas.display.PartDisplay
     * @constructor
     * @name PatternMatchPartDisplay
     * @memberof Numbas.display
     */
    display.PatternMatchPartDisplay = function()
    {
        var p = this.part;
        /** The student's current answer (not necessarily submitted)
         * @member {observable|string} studentAnswer
         * @memberof Numbas.display.PatternMatchPartDisplay
         */
        this.studentAnswer = Knockout.observable(this.part.studentAnswer);
        /** The correct answer regular expression
         * @member {observable|RegExp} correctAnswer
         * @memberof Numbas.display.PatternMatchPartDisplay
         */
        this.correctAnswer = Knockout.observable(p.settings.correctAnswer);
        /** A representative correct answer to display when answers are revealed
         * @member {observable|string} displayAnswer
         * @memberof Numbas.display.PatternMatchPartDisplay
         */
        this.displayAnswer = Knockout.observable(p.settings.displayAnswer);
        ko.computed(function() {
            p.storeAnswer(this.studentAnswer());
        },this);
    }
    display.PatternMatchPartDisplay.prototype =
    {
        restoreAnswer: function()
        {
            this.studentAnswer(this.part.studentAnswer);
        }
    };
    display.PatternMatchPartDisplay = extend(display.PartDisplay,display.PatternMatchPartDisplay,true);
});
/*
Copyright 2011-15 Newcastle University
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
/** @file The {@link Numbas.parts.PatternMatchPart} object */
Numbas.queueScript('parts/patternmatch',['base','jme','jme-variables','util','part','marking_scripts'],function() {
var util = Numbas.util;
var jme = Numbas.jme;
var math = Numbas.math;
var Part = Numbas.parts.Part;
/** Text-entry part - student's answer must match the given regular expression
 * @constructor
 * @memberof Numbas.parts
 * @augments Numbas.parts.Part
 */
var PatternMatchPart = Numbas.parts.PatternMatchPart = function(xml, path, question, parentPart, loading) {
    var settings = this.settings;
    util.copyinto(PatternMatchPart.prototype.settings,settings);
}
PatternMatchPart.prototype = /** @lends Numbas.PatternMatchPart.prototype */ {
    loadFromXML: function(xml) {
        var settings = this.settings;
        var tryGetAttribute = Numbas.xml.tryGetAttribute;
        settings.correctAnswerString = $.trim(Numbas.xml.getTextContent(xml.selectSingleNode('correctanswer')));
        tryGetAttribute(settings,xml,'correctanswer',['mode'],['matchMode']);
        var displayAnswerNode = xml.selectSingleNode('displayanswer');
        if(!displayAnswerNode)
            this.error('part.patternmatch.display answer missing');
        settings.displayAnswerString = $.trim(Numbas.xml.getTextContent(displayAnswerNode));
        tryGetAttribute(settings,xml,'case',['sensitive','partialCredit'],'caseSensitive');
    },
    loadFromJSON: function(data) {
        var settings = this.settings;
        var tryLoad = Numbas.json.tryLoad;
        tryLoad(data, ['answer', 'displayAnswer'], settings, ['correctAnswerString', 'displayAnswerString']);
        tryLoad(data, ['caseSensitive', 'partialCredit'], settings);
    },
    finaliseLoad: function() {
        this.getCorrectAnswer(this.getScope());
        if(Numbas.display) {
            this.display = new Numbas.display.PatternMatchPartDisplay(this);
        }
    },
    resume: function() {
        if(!this.store) {
            return;
        }
        var pobj = this.store.loadPart(this);
        this.stagedAnswer = pobj.studentAnswer;
    },
    /** The student's last submitted answer
     * @type {String}
     */
    studentAnswer: '',
    /** The script to mark this part - assign credit, and give messages and feedback.
     * @returns {Numbas.marking.MarkingScript}
     */
    baseMarkingScript: function() { return Numbas.marking_scripts.patternmatch; },
    /** Properties set when the part is generated.
     * Extends {@link Numbas.parts.Part#settings}
     * @property {String} correctAnswerString - the definition of the correct answer, without variables substituted in.
     * @property {RegExp} correctAnswer - regular expression pattern to match correct answers
     * @property {String} displayAnswerString - the definition of the display answer, without variables substituted in.
     * @property {String} displayAnswer - a representative correct answer to display when answers are revealed
     * @property {Boolean} caseSensitive - does case matter?
     * @property {Number} partialCredit - partial credit to award if the student's answer matches, apart from case, and `caseSensitive` is `true`.
     * @property {String} matchMode - Either "regex", for a regular expression, or "exact", for an exact match.
     */
    settings: {
    correctAnswerString: '.*',
    correctAnswer: /.*/,
    displayAnswerString: '',
    displayAnswer: '',
    caseSensitive: false,
    partialCredit: 0,
    matchMode: 'regex'
    },
    /** The name of the input widget this part uses, if any.
     * @returns {String}
     */
    input_widget: function() {
        return 'string';
    },
    /** Options for this part's input widget
     * @returns {Object}
     */
    input_options: function() {
        return {
            allowEmpty: false
        }
    },
    /** Compute the correct answer, based on the given scope
     */
    getCorrectAnswer: function(scope) {
        var settings = this.settings;
        settings.correctAnswer = jme.subvars(settings.correctAnswerString, scope, true);
        switch(this.settings.matchMode) {
            case 'regex':
                settings.correctAnswer = '^'+settings.correctAnswer+'$';
                break;
        }
        settings.displayAnswer = jme.subvars(settings.displayAnswerString,scope, true);
    },
    /** Save a copy of the student's answer as entered on the page, for use in marking.
     */
    setStudentAnswer: function() {
        this.studentAnswer = this.stagedAnswer;
    },
    /** Get the student's answer as it was entered as a JME data type, to be used in the custom marking algorithm
     * @abstract
     * @returns {Numbas.jme.token}
     */
    rawStudentAnswerAsJME: function() {
        return new Numbas.jme.types.TString(this.studentAnswer);
    },
};
['finaliseLoad','resume','loadFromXML','loadFromJSON'].forEach(function(method) {
    PatternMatchPart.prototype[method] = util.extend(Part.prototype[method], PatternMatchPart.prototype[method]);
});
Numbas.partConstructors['patternmatch'] = util.extend(Part,PatternMatchPart);
});

Numbas.queueScript('question-display',['display-base','jme-variables','xml','schedule','jme'],function() {
    var display = Numbas.display;
    /** Display properties of a question object
     * @name QuestionDisplay
     * @memberof Numbas.display
     * @constructor
     * @param {Numbas.Question} q - the associated question object
     */
    display.QuestionDisplay = function(q)
    {
        this.question = q;
        var exam = q.exam;
        /** Has the advice been shown?
         * @member {observable|Boolean} adviceDisplayed
         * @memberof Numbas.display.QuestionDisplay
         */
        this.adviceDisplayed = Knockout.observable(false);
        /** Get the {@link Numbas.display.PartDisplay} object for the given path.
         * @param {Numbas.parts.partpath} path
         * @returns {Numbas.display.PartDisplay}
         * @method getPart
         * @memberof Numbas.display.QuestionDisplay
         */
        this.getPart = function(path) {
            return q.getPart(path).display;
        }
        /** Text for the "submit all answers" button
         * @member {observable|String} submitMessage
         * @memberof Numbas.display.QuestionDisplay
         */
        this.submitMessage = Knockout.observable('');
        /** The name to display for this question - in default locale, it's "Question {N}"
         * @member {observable|String} displayName
         * @memberof Numbas.display.QuestionDisplay
         */
        this.displayName = Knockout.observable(R('question.header',{'number':q.number+1}));
        /** Has the student looked at this question? ({@link Numbas.Question#visited})
         * @member {observable|Boolean} visited
         * @memberof Numbas.display.QuestionDisplay
         */
        this.visited = Knockout.observable(q.visited);

        this.isCurrentQuestion = ko.computed(function() {
            return exam.display.currentQuestionNumber()==q.number;
        },this);

        /** Is this question visible in the list?
         * @member {observable|Boolean} visible
         * @memberof Numbas.display.QuestionDisplay
         */
        this.visible = Knockout.computed(function() {
            var q = this.question;
            var currentQuestionNumber = exam.display.currentQuestionNumber();
            return (q.number==currentQuestionNumber
                || exam.settings.navigateBrowse                                                 // is browse navigation enabled?
                || this.visited()                            // if not, we can still move backwards to questions already seen if reverse navigation is enabled
                || (currentQuestionNumber!==null && q.number>currentQuestionNumber && exam.display.questions()[q.number-1].visited())    // or you can always move to the next question
            )
        },this);
        /** Number of parts in this question
         * @member {observable|Number} numParts
         * @memberof Numbas.display.QuestionDisplay
         */
        this.numParts = Knockout.observable(q.parts.length);
        /** Student's current score ({@link Numbas.Question#score})
         * @member {observable|Number} score
         * @memberof Numbas.display.QuestionDisplay
         */
        this.score = Knockout.observable(q.score);
        /** Total marks available for this question ({@link Numbas.Question#marks})
         * @member {observable|Number} marks
         * @memberof Numbas.display.QuestionDisplay
         */
        this.marks = Knockout.observable(q.marks);
        /** Proportion of available marks awarded to the student
         * @member {observable|Number} credit
         * @memberof Numbas.display.QuestionDisplay
         */
        this.credit = Knockout.computed(function() {
            return this.score()/this.marks();
        },this);
        /** Does this question do any marking?
         * @member {observable|Boolean} doesMarking
         * @memberof Numbas.display.QuestionDisplay
         */
        this.doesMarking = Knockout.computed(function() {
            return this.marks()>0
        },this);
        /** Has this question been answered? ({@link Numbas.Question#answered})
         * @member {observable|Boolean} answered
         * @memberof Numbas.display.QuestionDisplay
         */
        this.answered = Knockout.observable(q.answered);
        /** Have the correct answers been revealed? ({@link Numbas.Question#revealed})
         * @member {observable|Boolean} revealed
         * @memberof Numbas.display.QuestionDisplay
         */
        this.revealed = Knockout.observable(q.revealed);
        /** Have any of this question's parts been answered?
         * @member {observable|Boolean} anyAnswered
         * @memberof Numbas.display.QuestionDisplay
         */
        this.anyAnswered = Knockout.observable(false);
        /** Has the student changed any of their answers since submitting?
         * @member {observable|Boolean} isDirty
         * @memberof Numbas.display.QuestionDisplay
         */
        this.isDirty = Knockout.observable(false);
        /** Is the student able to reveal the correct answers?
         * @member {observable|Boolean} canReveal
         * @memberof Numbas.display.QuestionDisplay
         */
        this.canReveal = Knockout.computed(function() {
            return exam.settings.allowRevealAnswer && !this.revealed();
        },this);
        /** Score feedback string
         * @member {{update: function, message: observable|String}} scoreFeedback
         * @memberof Numbas.display.QuestionDisplay
         */
        this.scoreFeedback = display.showScoreFeedback(this,q.exam.settings);
        /** Show this question in review mode
         * @member {function} review
         * @method
         * @memberof Numbas.display.QuestionDisplay
         */
        this.review = function() {
            exam.reviewQuestion(q.number);
        }
    }
    display.QuestionDisplay.prototype = /** @lends Numbas.display.QuestionDisplay.prototype */
    {
        /** The associated question object
         * @type {Numbas.Question}
         * @memberof Numbas.display.QuestionDisplay
         */
        question: undefined,            //reference back to the main question object
        /** HTML representing the question
         * @type {Element}
         * @memberof Numbas.display.QuestionDisplay
         */
        html: '',                        //HTML for displaying question
        /** Make the HTML to display the question
         * @memberof Numbas.display.QuestionDisplay
         */
        makeHTML: function() {
            var q = this.question;
            var qd = this;
            var html = this.html = $($.xsl.transform(Numbas.xml.templates.question, q.xml).string);
            html.addClass('jme-scope').data('jme-scope',q.scope);
            html.attr('data-jme-context-description',R('question.header',{number:q.number+1}));
            html.find('table').wrap('<div class="table-responsive">');    // wrap tables so they have a scrollbar when they overflow
            $('#questionDisplay').append(html);
            qd.css = document.createElement('style');
            qd.css.setAttribute('type','text/css');
            if(qd.css.styleSheet) {
                qd.css.styleSheet.cssText = q.preamble.css;
            } else {
                qd.css.appendChild(document.createTextNode(q.preamble.css));
            }
            Numbas.schedule.add(function()
            {
                html.each(function(e) {
                    Numbas.jme.variables.DOMcontentsubvars(this,q.scope);
                })
                // trigger a signal that the question HTML is attached
                // DEPRECATED: use question.onHTMLAttached(fn) instead
                $('body').trigger('question-html-attached',q,qd);
                $('body').unbind('question-html-attached');
                // make mathjax process the question text (render the maths)
                Numbas.display.typeset(qd.html,qd.postTypesetF);
                q.signals.trigger('HTMLAttached');
            });
        },
        /** Show the question
         * @memberof Numbas.display.QuestionDisplay
         */
        show: function()
        {
            var q = this.question;
            var qd = this;
            var exam = q.exam;
            this.html.append(this.css);
            this.visited(q.visited);
            //update the question menu - highlight this question, etc.
            exam.display.updateQuestionMenu();
            switch(exam.mode) {
            case 'normal':
                this.submitMessage( R(q.parts.length<=1 ? 'control.submit answer' : 'control.submit all parts') );
                break;
            case 'review':
                break;
            }
            //show parts
            this.postTypesetF = function(){};
            for(var i=0;i<q.parts.length;i++)
            {
                q.parts[i].display.show();
            }
            //display advice if appropriate
            this.showAdvice();
            //show correct answers if appropriate
            this.revealAnswer();
            //display score if appropriate
            this.showScore(true);
            //scroll back to top of page
            scroll(0,0);
            // make mathjax process the question text (render the maths)
            Numbas.display.typeset(this.html,this.postTypesetF);
        },
        /** Called when the student leaves the question
         * @memberof Numbas.display.QuestionDisplay
         */
        leave: function() {
            $(this.css).remove();
        },
        /** Show this question's advice
         * @memberof Numbas.display.QuestionDisplay
         */
        showAdvice: function( fromButton )
        {
            this.adviceDisplayed(this.question.adviceDisplayed);
        },
        /** Reveal the answers to this question
         * @memberof Numbas.display.QuestionDisplay
         */
        revealAnswer: function()
        {
            this.revealed(this.question.revealed);
            if(!this.question.revealed)
                return;
            scroll(0,0);
        },
        /** Display question score and answer state
         * @memberof Numbas.display.QuestionDisplay
         */
        showScore: function(noUpdate)
        {
            var q = this.question;
            var exam = q.exam;
            this.score(q.score);
            this.marks(q.marks);
            this.answered(q.answered);
            if(!noUpdate) {
                this.scoreFeedback.update(true);
            }
            var anyAnswered = false;
            for(var i=0;i<q.parts.length;i++)
            {
                anyAnswered = anyAnswered || (q.parts[i].doesMarking && q.parts[i].answered);
            }
            this.anyAnswered(anyAnswered);
        },
        /** Scroll to the first part submission error
         * @memberof Numbas.display.QuestionDisplay
         */
        scrollToError: function() {
            scrollTo($('.warning-icon:visible:first'));
        },
        /** Initialise this question's display
         * @memberof Numbas.display.QuestionDisplay
         */
        init: function() {
            var q = this.question;
            for(var i=0;i<q.parts.length;i++)
            {
                q.parts[i].display.init();
            }
            this.numParts(q.parts.length);
        },
        /** Called when the exam ends
         * @memberof Numbas.display.QuestionDisplay
         */
        end: function() {
            var q = this.question;
            for(var i=0;i<q.parts.length;i++)
            {
                q.parts[i].display.end();
            }
        }
    };
    function scrollTo(el)
    {
        if(!(el).length)
            return;
        var docTop = $(window).scrollTop();
        var docBottom = docTop + $(window).height();
        var elemTop = $(el).offset().top;
        if((elemTop-docTop < 50) || (elemTop>docBottom-50))
            $('html,body').animate({scrollTop: $(el).offset().top-50 });
    }
})

/*
Copyright 2011-14 Newcastle University
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/** @file The {@link Numbas.Question} object */
Numbas.queueScript('standard_parts',['parts/jme','parts/patternmatch','parts/numberentry','parts/matrixentry','parts/multipleresponse','parts/gapfill','parts/information','parts/extension'],function() {});
Numbas.queueScript('question',['base','schedule','jme','jme-variables','util','part','standard_parts'],function() {
var util = Numbas.util;
var jme = Numbas.jme;
var math = Numbas.math;
/** Create a {@link Numbas.Question} object from an XML definition
 * @memberof Numbas
 * @param {Element} xml
 * @param {Number} number - the number of the question in the exam
 * @param {Numbas.Exam} [exam] - the exam this question belongs to
 * @param {Numbas.QuestionGroup} [group] - the group this question belongs to
 * @param {Numbas.jme.Scope} [scope] - the global JME scope
 * @param {Numbas.storage.BlankStorage} [store] - the storage engine to use
 * @returns Numbas.Question
 */
var createQuestionFromXML = Numbas.createQuestionFromXML = function(xml, number, exam, group, gscope, store) {
    try {
        var q = new Question(number, exam, group, gscope, store);
        q.loadFromXML(xml);
        q.finaliseLoad();
    } catch(e) {
        throw(new Numbas.Error('question.error creating question',{number: number, message: e.message}));
    }
    return q;
}
/** Create a {@link Numbas.Question} object from a JSON object
 * @memberof Numbas
 * @param {Object} data
 * @param {Number} number - the number of the question in the exam
 * @param {Numbas.Exam} [exam] - the exam this question belongs to
 * @param {Numbas.QuestionGroup} [group] - the group this question belongs to
 * @param {Numbas.jme.Scope} [scope] - the global JME scope
 * @param {Numbas.storage.BlankStorage} [store] - the storage engine to use
 * @returns Numbas.Question
 */
var createQuestionFromJSON = Numbas.createQuestionFromJSON = function(data, number, exam, group, gscope, store) {
    try {
        var q = new Question(number, exam, group, gscope, store);
        q.loadFromJSON(data);
        q.finaliseLoad();
    } catch(e) {
        throw(new Numbas.Error('question.error creating question',{number: number, message: e.message}));
    }
    return q;
}
/** Keeps track of all info to do with an instance of a single question
 *
 * @constructor
 * @memberof Numbas
 * @param {Number} number - index of this question in the exam (starting at 0)
 * @param {Numbas.Exam} [exam] - parent exam
 * @param {Numbas.QuestionGroup} [group] - group this question belongs to
 * @param {Numbas.jme.Scope} [gscope=Numbas.jme.builtinScope] - global JME scope
 * @param {Numbas.storage.BlankStorage} [store] - the storage engine to use
 */
var Question = Numbas.Question = function( number, exam, group, gscope, store)
{
    var q = this;
    q.store = store;
    q.signals = new Numbas.schedule.SignalBox(function(e) {
        e.message = R('question.error',{'number':q.number+1,message:e.message});
        throw(e);
    });
    q.exam = exam;
    q.group = group;
    q.adviceThreshold = q.exam ? q.exam.adviceGlobalThreshold : 0;
    q.number = number;
    gscope = gscope || (exam && exam.scope) || Numbas.jme.builtinScope;
    q.scope = new jme.Scope(gscope);
    q.scope.question = q;
    q.preamble = {
        'js': '',
        'css': ''
    };
    q.functionsTodo = [];
    q.variablesTodo = {};
    q.rulesets = {};
    q.variablesTest = {
        condition: '',
        maxRuns: 10
    };
    q.parts = [];
    q.partDictionary = {};
}

/** The question preamble has been loaded but not run yet- this happens before any variables, functions, rulesets or parts are generated.
 * @event Numbas.Question#preambleLoaded
 * @see Numbas.Question#event:preambleRun
 */
/** The question preamble has been run.
 * @event Numbas.Question#preambleRun
 */
/** The question's function definitions have been loaded, but the corresponding {@link Numbas.jme.funcObj} objects have not been added to the scope yet.
 * @event Numbas.Question#functionsLoaded
 * @see Numbas.Question#event:functionsMade
 */
/** The question's functions have been made and added to the question's scope.
 * @event Numbas.Question#functionsMade
 */
/** The question's ruleset  definitions have been loaded, but the {@link Numbas.jme.rules.Ruleset} objects have not been added to the scope yet.
 * @event Numbas.Question#rulesetsLoaded
 * @see Numbas.Question#event:rulesetsMade
 */
/** The question's rulesets have been made and added to the question's scope.
 * @event Numbas.Question#rulesetsMade
 */
/** Trigger this when you're ready to evaluate the question's variables. In an exam context, the {@link Numbas.Exam} object triggers this event.
 * If the question has been created standalone, this event must be triggered in order for the question to finish loading.
 * @event Numbas.Question#generateVariables
 */
/** The variable definitions have been loaded, but their values have not been generated yet.
 * @event Numbas.Question#variableDefinitionsLoaded
 * @see Numbas.Question#event:variablesSet
 * @see Numbas.Question#event:variablesGenerated
 */
/** The parts of the question have been generated.
 * If resuming an attempt, the parts have not yet been restored to the saved state.
 * @event Numbas.Question#partsGenerated
 * @see Numbas.Question#event:partsResumed
 */
/** Triggered when resuming a saved attempt: the question's parts have been restored to the saved state.
 * @event Numbas.Question#partsResumed
 */
/** The variables have been evaluated, but {@link Numbas.Question.unwrappedVariables} has not been set yet.
 * @event Numbas.Question#variablesSet
 */
/** The variables have been generated and added to the scope, and are ready to use.
 * @event Numbas.Question#variablesGenerated
 */
/** The question is fully loaded and ready to use.
 * @event Numbas.Question#ready
 */
/** The question's HTML has been generated and attached to the page.
 * @event Numbas.Question#HTMLAttached
 */

Question.prototype = /** @lends Numbas.Question.prototype */
{
    /** Signals produced while loading this question.
     * @type {Numbas.schedule.SignalBox} 
     * */
    signals: undefined,

    /** Storage engine
     * @type {Numbas.storage.BlankStorage}
     */
    store: undefined,
    /** Load the question's settings from an XML <question> node
     * @param {Element} xml
     * @fires Numbas.Question#preambleLoaded
     * @fires Numbas.Question#functionsLoaded
     * @fires Numbas.Question#rulesetsLoaded
     * @fires Numbas.Question#variableDefinitionsLoaded
     * @fires Numbas.Question#partsGenerated
     * @listens Numbas.Question#event:variablesGenerated
     */
    loadFromXML: function(xml) {
        var q = this;
        var tryGetAttribute = Numbas.xml.tryGetAttribute;
        q.xml = xml;
        q.originalXML = q.xml;
        //get question's name
        tryGetAttribute(q,q.xml,'.','name');
        var preambleNodes = q.xml.selectNodes('preambles/preamble');
        for(var i = 0; i<preambleNodes.length; i++) {
            var lang = preambleNodes[i].getAttribute('language');
            q.preamble[lang] = Numbas.xml.getTextContent(preambleNodes[i]);
        }
        q.signals.trigger('preambleLoaded');
        q.functionsTodo = Numbas.xml.loadFunctions(q.xml,q.scope);
        q.signals.trigger('functionsLoaded');
        //make rulesets
        var rulesetNodes = q.xml.selectNodes('rulesets/set');
        q.rulesets = {};
        for(var i=0; i<rulesetNodes.length; i++) {
            var name = rulesetNodes[i].getAttribute('name');
            var set = [];
            //get new rule definitions
            defNodes = rulesetNodes[i].selectNodes('ruledef');
            for( var j=0; j<defNodes.length; j++ ) {
                var pattern = defNodes[j].getAttribute('pattern');
                var result = defNodes[j].getAttribute('result');
                var conditions = [];
                var conditionNodes = defNodes[j].selectNodes('conditions/condition');
                for(var k=0; k<conditionNodes.length; k++) {
                    conditions.push(Numbas.xml.getTextContent(conditionNodes[k]));
                }
                var rule = new Numbas.jme.display.Rule(pattern,conditions,result);
                set.push(rule);
            }
            //get included sets
            var includeNodes = rulesetNodes[i].selectNodes('include');
            for(var j=0; j<includeNodes.length; j++) {
                set.push(includeNodes[j].getAttribute('name'));
            }
            q.rulesets[name] = set;
        }
        q.signals.trigger('rulesetsLoaded');
        q.variablesTodo = Numbas.xml.loadVariables(q.xml,q.scope);
        tryGetAttribute(q.variablesTest,q.xml,'variables',['condition','maxRuns'],[]);
        q.signals.trigger('variableDefinitionsLoaded');
        q.signals.on('variablesGenerated',function() {
            var doc = Sarissa.getDomDocument();
            doc.appendChild(q.originalXML.cloneNode(true));    //get a fresh copy of the original XML, to sub variables into
            q.xml = doc.selectSingleNode('question');
            q.xml.setAttribute('number',q.number);
        });
        q.signals.on('variablesGenerated', function() {
            //load parts
            var partNodes = q.xml.selectNodes('parts/part');
            for(var j = 0; j<partNodes.length; j++) {
                var part = Numbas.createPartFromXML(partNodes[j], 'p'+j,q,null, q.store);
                q.addPart(part,j);
            }
            q.signals.trigger('partsGenerated');
        });
    },
    /** Load the question's settings from a JSON object
     * @param {Object} data
     * @fires Numbas.Question#preambleLoaded
     * @fires Numbas.Question#functionsLoaded
     * @fires Numbas.Question#rulesetsLoaded
     * @fires Numbas.Question#variableDefinitionsLoaded
     * @fires Numbas.Question#partsGenerated
     * @listens Numbas.Question#event:variablesGenerated
     */
    loadFromJSON: function(data) {
        var q = this;
        var tryLoad = Numbas.json.tryLoad;
        var tryGet = Numbas.json.tryGet;
        tryLoad(data,'name',q);
        var preambles = tryGet(data,'preamble');
        if(preambles) {
            Object.keys(preambles).forEach(function(key) {
                q.preamble[key] = preambles[key];
            });
        }
        q.signals.trigger('preambleLoaded');
        var functions = tryGet(data,'functions');
        if(functions) {
            q.functionsTodo = Object.keys(functions).map(function(name) {
                var fd = functions[name];
                return {
                    name: name,
                    definition: fd.definition,
                    language: fd.language,
                    outtype: fd.type,
                    parameters: fd.parameters.map(function(p){ return {name:p[0], type: p[1]}})
                };
            });
        }
        q.signals.trigger('functionsLoaded');
        var rulesets = tryGet(data,'rulesets');
        if(rulesets) {
            Object.keys(rulesets).forEach(function(name) {
                q.rulesets[name] = rulesets[name];
            });
        }
        q.signals.trigger('rulesetsLoaded');
        var variables = tryGet(data,'variables');
        if(variables) {
            Object.keys(variables).map(function(name) {
                var vd = variables[name];
                try {
                    var tree = Numbas.jme.compile(vd.definition);
                } catch(e) {
                    throw(new Numbas.Error('variable.error in variable definition',{name:name}));
                }
                var vars = Numbas.jme.findvars(tree);
                q.variablesTodo[name] = {
                    tree: tree,
                    vars: vars
                }
            });
        }
        var variablesTest = tryGet(data,'variablesTest');
        if(variablesTest) {
            tryLoad(variablesTest,['condition','maxRuns'],q.variablesTest);
        }
        q.signals.trigger('variableDefinitionsLoaded');
        q.signals.on('variablesGenerated', function() {
            var parts = tryGet(data,'parts');
            if(parts) {
                parts.forEach(function(pd,i) {
                    var p = Numbas.createPartFromJSON(pd, 'p'+i, q, q.store);
                    q.addPart(p,i);
                });
                q.signals.trigger('partsGenerated');
            }
        });
    },
    /** Add a part to the question
     * @param {Numbas.parts.Part} part
     * @param {Number} index
     */
    addPart: function(part, index) {
        this.parts.splice(index, 0, part);
        this.marks += part.marks;
    },
    /** Perform any tidying up or processing that needs to happen once the question's definition has been loaded
     * @fires Numbas.Question#functionsMade
     * @fires Numbas.Question#rulesetsMade
     * @fires Numbas.Question#variablesSet
     * @fires Numbas.Question#variablesGenerated
     * @fires Numbas.Question#ready
     * @listens Numbas.Question#event:preambleLoaded
     * @listens Numbas.Question#event:functionsLoaded
     * @listens Numbas.Question#event:rulesetsLoaded
     * @listens Numbas.Question#event:generateVariables
     * @listens Numbas.Question#event:functionsMade
     * @listens Numbas.Question#event:rulesetsMade
     * @listens Numbas.Question#event:variableDefinitionsLoaded
     * @listens Numbas.Question#event:variablesSet
     * @listens Numbas.Question#event:variablesGenerated
     * @listens Numbas.Question#event:partsGenerated
     * @listens Numbas.Question#event:ready
     * @listens Numbas.Question#event:HTMLAttached
     */
    finaliseLoad: function() {
        var q = this;
        q.signals.on('preambleLoaded', function() {
            q.runPreamble();
        });
        q.signals.on('functionsLoaded', function() {
            q.scope.functions = Numbas.jme.variables.makeFunctions(q.functionsTodo,q.scope,{question:q});
            q.signals.trigger('functionsMade');
        });
        q.signals.on('rulesetsLoaded',function() {
            Numbas.jme.variables.makeRulesets(q.rulesets,q.scope);
            q.signals.trigger('rulesetsMade');
        });
        q.signals.on(['generateVariables','functionsMade','rulesetsMade', 'variableDefinitionsLoaded'], function() {
            var conditionSatisfied = false;
            var condition = jme.compile(q.variablesTest.condition);
            var runs = 0;
            var scope;
            while(runs<q.variablesTest.maxRuns && !conditionSatisfied) {
                runs += 1;
                scope = new jme.Scope([q.scope]);
                var result = jme.variables.makeVariables(q.variablesTodo,scope,condition);
                conditionSatisfied = result.conditionSatisfied;
            }
            if(!conditionSatisfied) {
                throw(new Numbas.Error('jme.variables.question took too many runs to generate variables'));
            } else {
                q.scope = scope;
            }
            q.signals.trigger('variablesSet');
        });
        q.signals.on('variablesSet',function() {
            q.scope = new jme.Scope([q.scope]);
            q.scope.flatten();
            q.local_definitions = {
                variables: Object.keys(q.variablesTodo),
                functions: Object.keys(q.functionsTodo),
                rulesets: Object.keys(q.rulesets)
            };
            q.unwrappedVariables = {};
            var all_variables = q.scope.allVariables()
            for(var name in all_variables) {
                q.unwrappedVariables[name] = Numbas.jme.unwrapValue(all_variables[name]);
            }
            q.signals.trigger('variablesGenerated');
        });
        q.signals.on('variablesGenerated',function() {
            q.name = jme.contentsubvars(q.name,q.scope);
        });
        if(Numbas.display) {
            q.display = new Numbas.display.QuestionDisplay(q);
        }
        q.signals.on(['variablesGenerated','partsGenerated'], function() {
            //initialise display - get question HTML, make menu item, etc.
            q.display && q.display.makeHTML();
        });
        q.signals.on(['variablesGenerated','partsGenerated'], function() {
            q.signals.trigger('ready');
        });
        q.signals.on('ready',function() {
            q.updateScore();
        });
        q.signals.on(['variablesGenerated','partsGenerated','HTMLAttached'], function() {
            q.display && q.display.showScore();
        });
    },
    generateVariables: function() {
        this.signals.trigger('generateVariables');
    },
    /** Load saved data about this question from storage
     * @fires Numbas.Question#variablesSet
     * @fires Numbas.Question#partsResumed
     * @listens Numbas.Question#event:partsGenerated
     * @listens Numbas.Question#event:ready
     */
    resume: function() {
        if(!this.store) {
            return;
        }
        var q = this;
        // check the suspend data was for this question - if the test is updated and the question set changes, this won't be the case!
        var qobj = this.store.loadQuestion(q);
        if(qobj.name && qobj.name!=q.name) {
            throw(new Numbas.Error('question.loaded name mismatch'));
        }
        for(var x in qobj.variables) {
            q.scope.setVariable(x,qobj.variables[x]);
        }
        q.signals.trigger('variablesSet');
        q.signals.on('partsGenerated', function() {
            q.parts.forEach(function(part) {
                if(loading) {
                    part.resume();
                }
            });
            q.signals.on('ready',function() {
                q.parts.forEach(function(part) {
                    part.steps.forEach(function(step) {
                        if(step.answered) {
                            step.submit();
                        }
                    });
                    if(part.answered) {
                        part.submit();
                    }
                });
            });
            q.signals.trigger('partsResumed');
        });
        q.signals.on('partsResumed',function() {
            q.adviceDisplayed = qobj.adviceDisplayed;
            q.answered = qobj.answered;
            q.revealed = qobj.revealed;
            q.submitted = qobj.submitted;
            q.visited = qobj.visited;
            q.score = qobj.score;
            if(q.revealed) {
                q.revealAnswer(true);
            } else if(q.adviceDisplayed) {
                q.getAdvice(true);
            }
            q.updateScore();
        });
    },
    /** XML definition of this question
     * @type {Element}
     */
    xml: null,
    /** Position of this question in the exam
     * @type {Number}
     */
    number: -1,
    /** Name - shouldn't be shown to students
     * @type {String}
     */
    name: '',
    /** The JME scope for this question. Contains variables, functions and rulesets defined in this question
     * @type {Numbas.jme.Scope}
     */
    scope: null,
    /** Maximum marks available for this question
     * @type {Number}
     */
    marks: 0,
    /** Student's score on this question
     * @type {Number}
     */
    score: 0,
    /** Has this question been seen by the student? For determining if you can jump back to this question, when {@link Numbas.Question.navigateBrowse} is disabled.
     * @type {Boolean}
     */
    visited: false,
    /** Has this question been answered satisfactorily?
     * @type {Boolean}
     */
    answered: false,
    /** Number of times this question has been submitted.
     * @type {Number}
     */
    submitted: 0,
    /** Has the advice been displayed?
     * @type {Boolean}
     */
    adviceDisplayed: false,
    /** Have the correct answers been revealed?
     * @type {Boolean}
     */
    revealed: false,
    /** Parts belonging to this question, in the order they're displayed.
     * @type {Numbas.parts.Part}
     */
    parts: [],
    /** Dictionary mapping part addresses (of the form `qXpY[gZ]`) to {@link Numbas.parts.Part} objects.
     * @type {Object.<Numbas.parts.Part>}
     */
    partDictionary: {},
    /** Associated display object
     * @type {Numbas.display.QuestionDisplay}
     */
    display: undefined,
    /** Callbacks to run when various events happen
     * @property {Array.<function>} HTMLAttached - Run when the question's HTML has been attached to the page.
     * @property {Array.<function>} variablesGenerated - Run when the question's variables have been generated.
     * @type {Object.<Array.<function>>}
     */
    callbacks: {
    },
    /** Leave this question - called when moving to another question, or showing an info page.
     * @see Numbas.display.QuestionDisplay.leave
     */
    leave: function() {
    this.display && this.display.leave();
    },
    /** Execute the question's JavaScript preamble - should happen as soon as the configuration has been loaded from XML, before variables are generated. 
     * @fires Numbas.Question#preambleRun
     */
    runPreamble: function() {
        with({
            question: this
        }) {
            var js = '(function() {'+this.preamble.js+'\n})()';
            try{
                eval(js);
            } catch(e) {
                var errorName = e.name=='SyntaxError' ? 'question.preamble.syntax error' : 'question.preamble.error';
                throw(new Numbas.Error(errorName,{'number':this.number+1,message:e.message}));
            }
        }
        this.signals.trigger('preambleRun');
    },
    /** Get the part object corresponding to a path
     * @param {Numbas.parts.partpath} path
     * @returns {Numbas.parts.Part}
     */
    getPart: function(path)
    {
        return this.partDictionary[path];
    },
    /** Show the question's advice
     * @param {Boolean} dontStore - Don't tell the storage that the advice has been shown - use when loading from storage!
     */
    getAdvice: function(dontStore)
    {
        this.adviceDisplayed = true;
    this.display && this.display.showAdvice(true);
        if(this.store && !dontStore) {
            this.store.adviceDisplayed(this);
        }
    },
    /** Reveal the correct answers to the student
     * @param {Boolean} dontStore - Don't tell the storage that the advice has been shown - use when loading from storage!
     */
    revealAnswer: function(dontStore)
    {
        this.revealed = true;
        //display advice if allowed
        this.getAdvice(dontStore);
        //part-specific reveal code. Might want to do some logging in future?
        for(var i=0; i<this.parts.length; i++) {
            this.parts[i].revealAnswer(dontStore);
        }
        if(this.display) {
            //display revealed answers
            this.display.end();
            this.display.revealAnswer();
            this.display.showScore();
        }
        if(this.store && !dontStore) {
            this.store.answerRevealed(this);
        }
        this.exam && this.exam.updateScore();
    },
    /** Validate the student's answers to the question. True if all parts are either answered or have no marks available.
     * @returns {Boolean}
     */
    validate: function()
    {
        var success = true;
        for(var i=0; i<this.parts.length; i++)
        {
            success = success && (this.parts[i].answered || this.parts[i].marks==0);
        }
        return success;
    },
    /** Has anything been changed since the last submission? If any part has `isDirty` set to true, return true.
     * @returns {Boolean}
     */
    isDirty: function()
    {
        if(this.revealed) {
            return false;
        }
        for(var i=0;i<this.parts.length; i++) {
            if(this.parts[i].isDirty)
                return true;
        }
        return false;
    },
    /** Show a warning and return true if the question is dirty.
     * @see Numbas.Question#isDirty
     * @returns {Boolean}
     */
    leavingDirtyQuestion: function() {
        if(this.answered && this.isDirty()) {
        Numbas.display && Numbas.display.showAlert(R('question.unsubmitted changes',{count:this.parts.length}));
            return true;
        }
    },
    /** Calculate the student's total score for this questoin - adds up all part scores
     */
    calculateScore: function()
    {
        var tmpScore=0;
        for(var i=0; i<this.parts.length; i++)
        {
            tmpScore += this.parts[i].score;
        }
        this.score = tmpScore;
        this.answered = this.validate();
    },
    /** Submit every part in the question */
    submit: function()
    {
        //submit every part
        for(var i=0; i<this.parts.length; i++)
        {
            this.parts[i].submit();
        }
        //validate every part
        //displays warning messages if appropriate,
        //and returns false if any part is not completed sufficiently
        this.answered = this.validate();
        //keep track of how many times question successfully submitted
        if(this.answered)
            this.submitted += 1;
        //display message about success or failure
        if(! this.answered ) {
            if(this.display) {
                Numbas.display.showAlert(R('question.can not submit'));
                this.display.scrollToError();
            }
        }
        this.updateScore();
        if(this.exam && this.exam.adviceType == 'threshold' && 100*this.score/this.marks < this.adviceThreshold ) {
            this.getAdvice();
        }
        this.store && this.store.questionSubmitted(this);
    },
    /** Recalculate the student's score, update the display, and notify storage. */
    updateScore: function()
    {
        //calculate score - if warning is uiPrevent then score is 0
        this.calculateScore('uwNone');
        //update total exam score
        this.exam && this.exam.updateScore();
    //display score - ticks and crosses etc.
        this.display && this.display.showScore();
        //notify storage
        this.store && this.store.saveQuestion(this);
    },
    /** Add a callback function to run when the question's HTML is attached to the page
     *
     * @param {function} fn
     * @deprecated Use {@link Numbas.Question#signals} instead.
     * @listens Numbas.Question#event:HTMLAttached
     */
    onHTMLAttached: function(fn) {
        this.signals.on('HTMLAttached',fn);
    },
    /** Add a callback function to run when the question's variables are generated (but before the HTML is attached)
     *
     * @param {function} fn
     * @deprecated Use {@link Numbas.Question#signals} instead.
     * @listens Numbas.Question#event:variablesGenerated
     */
    onVariablesGenerated: function(fn) {
        this.signals.on('variablesGenerated',fn);
    }
};
});

Numbas.queueScript('sarissa',[],function(module) {
/*
 * ====================================================================
 * About Sarissa: http://dev.abiss.gr/sarissa
 * ====================================================================
 * Sarissa is an ECMAScript library acting as a cross-browser wrapper for native XML APIs.
 * The library supports Gecko based browsers like Mozilla and Firefox,
 * Internet Explorer (5.5+ with MSXML3.0+), Konqueror, Safari and Opera
 * @version 0.9.9.5
 * @author: Copyright 2004-2008 Emmanouil Batsis, mailto: mbatsis at users full stop sourceforge full stop net
 * ====================================================================
 * Licence
 * ====================================================================
 * Sarissa is free software distributed under the GNU GPL version 2 (see <a href="gpl.txt">gpl.txt</a>) or higher,
 * GNU LGPL version 2.1 (see <a href="lgpl.txt">lgpl.txt</a>) or higher and Apache Software License 2.0 or higher
 * (see <a href="asl.txt">asl.txt</a>). This means you can choose one of the three and use that if you like. If
 * you make modifications under the ASL, i would appreciate it if you submitted those.
 * In case your copy of Sarissa does not include the license texts, you may find
 * them online in various formats at <a href="http://www.gnu.org">http://www.gnu.org</a> and
 * <a href="http://www.apache.org">http://www.apache.org</a>.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
 * KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE
 * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
/**
 * <p>Sarissa is a utility class. Provides "static" methods for DOMDocument,
 * DOM Node serialization to XML strings and other utility goodies.</p>
 * @constructor
 * @static
 */
function Sarissa(){}
Sarissa.VERSION = "0.9.9.5";
Sarissa.PARSED_OK = "Document contains no parsing errors";
Sarissa.PARSED_EMPTY = "Document is empty";
Sarissa.PARSED_UNKNOWN_ERROR = "Not well-formed or other error";
Sarissa.IS_ENABLED_TRANSFORM_NODE = false;
Sarissa.REMOTE_CALL_FLAG = "gr.abiss.sarissa.REMOTE_CALL_FLAG";
/** @private */
Sarissa._lastUniqueSuffix = 0;
/** @private */
Sarissa._getUniqueSuffix = function(){
    return Sarissa._lastUniqueSuffix++;
};
/** @private */
Sarissa._SARISSA_IEPREFIX4XSLPARAM = "";
/** @private */
Sarissa._SARISSA_HAS_DOM_IMPLEMENTATION = document.implementation && true;
/** @private */
Sarissa._SARISSA_HAS_DOM_CREATE_DOCUMENT = Sarissa._SARISSA_HAS_DOM_IMPLEMENTATION && document.implementation.createDocument;
/** @private */
Sarissa._SARISSA_HAS_DOM_FEATURE = Sarissa._SARISSA_HAS_DOM_IMPLEMENTATION && document.implementation.hasFeature;
/** @private */
Sarissa._SARISSA_IS_MOZ = Sarissa._SARISSA_HAS_DOM_CREATE_DOCUMENT && Sarissa._SARISSA_HAS_DOM_FEATURE;
/** @private */
Sarissa._SARISSA_IS_SAFARI = navigator.userAgent.toLowerCase().indexOf("safari") != -1 || navigator.userAgent.toLowerCase().indexOf("konqueror") != -1;
/** @private */
Sarissa._SARISSA_IS_SAFARI_OLD = Sarissa._SARISSA_IS_SAFARI && (parseInt((navigator.userAgent.match(/AppleWebKit\/(\d+)/)||{})[1], 10) < 420);
/** @private */
Sarissa._SARISSA_IS_IE = (document.all && window.ActiveXObject && navigator.userAgent.toLowerCase().indexOf("msie") > -1  && navigator.userAgent.toLowerCase().indexOf("opera") == -1) || (!window.ActiveXObject && "ActiveXObject" in window);
/** @private */
Sarissa._SARISSA_IS_OPERA = navigator.userAgent.toLowerCase().indexOf("opera") != -1;
if(!window.Node || !Node.ELEMENT_NODE){
    Node = {ELEMENT_NODE: 1, ATTRIBUTE_NODE: 2, TEXT_NODE: 3, CDATA_SECTION_NODE: 4, ENTITY_REFERENCE_NODE: 5,  ENTITY_NODE: 6, PROCESSING_INSTRUCTION_NODE: 7, COMMENT_NODE: 8, DOCUMENT_NODE: 9, DOCUMENT_TYPE_NODE: 10, DOCUMENT_FRAGMENT_NODE: 11, NOTATION_NODE: 12};
}
//This breaks for(x in o) loops in the old Safari
if(Sarissa._SARISSA_IS_SAFARI_OLD){
    HTMLHtmlElement = document.createElement("html").constructor;
    Node = HTMLElement = {};
    HTMLElement.prototype = HTMLHtmlElement.__proto__.__proto__;
    HTMLDocument = Document = document.constructor;
    var x = new DOMParser();
    XMLDocument = x.constructor;
    Element = x.parseFromString("<Single />", "text/xml").documentElement.constructor;
    x = null;
}
if(typeof XMLDocument == "undefined" && typeof Document !="undefined"){ XMLDocument = Document; }
// IE initialization
if(Sarissa._SARISSA_IS_IE){
    // for XSLT parameter names, prefix needed by IE
    Sarissa._SARISSA_IEPREFIX4XSLPARAM = "xsl:";
    // used to store the most recent ProgID available out of the above
    var _SARISSA_DOM_PROGID = "";
    var _SARISSA_XMLHTTP_PROGID = "";
    var _SARISSA_DOM_XMLWRITER = "";
    /**
     * Called when the sarissa.js file is parsed, to pick most recent
     * ProgIDs for IE, then gets destroyed.
     * @memberOf Sarissa
     * @private
     * @param idList an array of MSXML PROGIDs from which the most recent will be picked for a given object
     * @param enabledList an array of arrays where each array has two items; the index of the PROGID for which a certain feature is enabled
     */
    Sarissa.pickRecentProgID = function (idList){
        // found progID flag
        var bFound = false, e;
        var o2Store;
        for(var i=0; i < idList.length && !bFound; i++){
            try{
                var oDoc = new ActiveXObject(idList[i]);
                o2Store = idList[i];
                bFound = true;
            }catch (objException){
                // trap; try next progID
                e = objException;
            }
        }
        if (!bFound) {
            throw "Could not retrieve a valid progID of Class: " + idList[idList.length-1]+". (original exception: "+e+")";
        }
        idList = null;
        return o2Store;
    };
    // pick best available MSXML progIDs
    _SARISSA_DOM_PROGID = null;
    _SARISSA_THREADEDDOM_PROGID = null;
    _SARISSA_XSLTEMPLATE_PROGID = null;
    _SARISSA_XMLHTTP_PROGID = null;
    // commenting the condition out; we need to redefine XMLHttpRequest
    // anyway as IE7 hardcodes it to MSXML3.0 causing version problems
    // between different activex controls
    //if(!window.XMLHttpRequest){
    /**
     * Emulate XMLHttpRequest
     * @constructor
     */
    XMLHttpRequest = function() {
        if(!_SARISSA_XMLHTTP_PROGID){
            _SARISSA_XMLHTTP_PROGID = Sarissa.pickRecentProgID(["Msxml2.XMLHTTP.6.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP"]);
        }
        return new ActiveXObject(_SARISSA_XMLHTTP_PROGID);
    };
    //}
    // we dont need this anymore
    //============================================
    // Factory methods (IE)
    //============================================
    // see non-IE version
    Sarissa.getDomDocument = function(sUri, sName){
        if(!_SARISSA_DOM_PROGID){
    try{
        _SARISSA_DOM_PROGID = Sarissa.pickRecentProgID(["Msxml2.DOMDocument.6.0", "Msxml2.DOMDocument.3.0", "MSXML2.DOMDocument", "MSXML.DOMDocument", "Microsoft.XMLDOM"]);
    }catch(e){
        _SARISSA_DOM_PROGID = "noActiveX";
    }
        }
        // Not sure how far IE can carry this but try to do something useful when ActiveX is disabled
        var oDoc = _SARISSA_DOM_PROGID == "noActiveX" ? document.createElement("xml") : new ActiveXObject(_SARISSA_DOM_PROGID);
        // set validation off, make sure older IEs dont choke (no time or IEs to test ;-)
        try{
    oDoc.validateOnParse = false;
    oDoc.resolveExternals = "false";
    oDoc.setProperty("ProhibitDTD", false);
        }catch(e){}
        // if a root tag name was provided, we need to load it in the DOM object
        if (sName){
            // create an artifical namespace prefix
            // or reuse existing prefix if applicable
            var prefix = "";
            if(sUri){
                if(sName.indexOf(":") > 1){
                    prefix = sName.substring(0, sName.indexOf(":"));
                    sName = sName.substring(sName.indexOf(":")+1);
                }else{
                    prefix = "a" + Sarissa._getUniqueSuffix();
                }
            }
            // use namespaces if a namespace URI exists
            if(sUri){
                oDoc.loadXML('<' + prefix+':'+sName + " xmlns:" + prefix + "=\"" + sUri + "\"" + " />");
            } else {
                oDoc.loadXML('<' + sName + " />");
            }
        }
        return oDoc;
    };
    // see non-IE version
    Sarissa.getParseErrorText = function (oDoc) {
        var parseErrorText = Sarissa.PARSED_OK;
        if(oDoc && oDoc.parseError && oDoc.parseError.errorCode && oDoc.parseError.errorCode != 0){
            parseErrorText = "XML Parsing Error: " + oDoc.parseError.reason +
                "\nLocation: " + oDoc.parseError.url +
                "\nLine Number " + oDoc.parseError.line + ", Column " +
                oDoc.parseError.linepos +
                ":\n" + oDoc.parseError.srcText +
                "\n";
            for(var i = 0;  i < oDoc.parseError.linepos;i++){
                parseErrorText += "-";
            }
            parseErrorText +=  "^\n";
        }
        else if(oDoc.documentElement === null){
            parseErrorText = Sarissa.PARSED_EMPTY;
        }
        return parseErrorText;
    };
    // see non-IE version
    Sarissa.setXpathNamespaces = function(oDoc, sNsSet) {
        oDoc.setProperty("SelectionLanguage", "XPath");
        oDoc.setProperty("SelectionNamespaces", sNsSet);
    };
    /**
     * A class that reuses the same XSLT stylesheet for multiple transforms.
     * @constructor
     */
    XSLTProcessor = function(){
        if(!_SARISSA_XSLTEMPLATE_PROGID){
            _SARISSA_XSLTEMPLATE_PROGID = Sarissa.pickRecentProgID(["Msxml2.XSLTemplate.6.0", "MSXML2.XSLTemplate.3.0"]);
        }
        this.template = new ActiveXObject(_SARISSA_XSLTEMPLATE_PROGID);
        this.processor = null;
    };
    /**
     * Imports the given XSLT DOM and compiles it to a reusable transform
     * <b>Note:</b> If the stylesheet was loaded from a URL and contains xsl:import or xsl:include elements,it will be reloaded to resolve those
     * @param {DOMDocument} xslDoc The XSLT DOMDocument to import
     */
    XSLTProcessor.prototype.importStylesheet = function(xslDoc){
        if(!_SARISSA_THREADEDDOM_PROGID){
            _SARISSA_THREADEDDOM_PROGID = Sarissa.pickRecentProgID(["MSXML2.FreeThreadedDOMDocument.6.0", "MSXML2.FreeThreadedDOMDocument.3.0"]);
        }
        xslDoc.setProperty("SelectionLanguage", "XPath");
        xslDoc.setProperty("SelectionNamespaces", "xmlns:xsl='http://www.w3.org/1999/XSL/Transform'");
        // convert stylesheet to free threaded
        var converted = new ActiveXObject(_SARISSA_THREADEDDOM_PROGID);
        // make included/imported stylesheets work if exist and xsl was originally loaded from url
        try{
            converted.resolveExternals = true;
            converted.setProperty("AllowDocumentFunction", true);
            converted.setProperty("AllowXsltScript", true);
        }
        catch(e){
            // Ignore. "AllowDocumentFunction" and "AllowXsltScript" is only supported in MSXML 3.0 SP4+ and 3.0 SP8+ respectively.
        }
        if(xslDoc.url && xslDoc.selectSingleNode("//xsl:*[local-name() = 'import' or local-name() = 'include']") != null){
            converted.async = false;
            converted.load(xslDoc.url);
        }
        else {
            converted.loadXML(xslDoc.xml);
        }
        converted.setProperty("SelectionNamespaces", "xmlns:xsl='http://www.w3.org/1999/XSL/Transform'");
        var output = converted.selectSingleNode("//xsl:output");
        //this.outputMethod = output ? output.getAttribute("method") : "html";
        if(output) {
            this.outputMethod = output.getAttribute("method");
        }
        else {
            delete this.outputMethod;
        }
        this.template.stylesheet = converted;
        this.processor = this.template.createProcessor();
        // for getParameter and clearParameters
        this.paramsSet = [];
    };
    /**
     * Transform the given XML DOM and return the transformation result as a new DOM document
     * @param {DOMDocument} sourceDoc The XML DOMDocument to transform
     * @return {DOMDocument} The transformation result as a DOM Document
     */
    XSLTProcessor.prototype.transformToDocument = function(sourceDoc){
        // fix for bug 1549749
        var outDoc;
        if(_SARISSA_THREADEDDOM_PROGID){
            this.processor.input=sourceDoc;
            outDoc=new ActiveXObject(_SARISSA_DOM_PROGID);
            this.processor.output=outDoc;
            this.processor.transform();
            return outDoc;
        }
        else{
            if(!_SARISSA_DOM_XMLWRITER){
                _SARISSA_DOM_XMLWRITER = Sarissa.pickRecentProgID(["Msxml2.MXXMLWriter.6.0", "Msxml2.MXXMLWriter.3.0", "MSXML2.MXXMLWriter", "MSXML.MXXMLWriter", "Microsoft.XMLDOM"]);
            }
            this.processor.input = sourceDoc;
            outDoc = new ActiveXObject(_SARISSA_DOM_XMLWRITER);
            this.processor.output = outDoc;
            this.processor.transform();
            var oDoc = new ActiveXObject(_SARISSA_DOM_PROGID);
            oDoc.loadXML(outDoc.output+"");
            return oDoc;
        }
    };
    /**
     * Transform the given XML DOM and return the transformation result as a new DOM fragment.
     * <b>Note</b>: The xsl:output method must match the nature of the owner document (XML/HTML).
     * @param {DOMDocument} sourceDoc The XML DOMDocument to transform
     * @param {DOMDocument} ownerDoc The owner of the result fragment
     * @return {DOMDocument} The transformation result as a DOM Document
     */
    XSLTProcessor.prototype.transformToFragment = function (sourceDoc, ownerDoc) {
        this.processor.input = sourceDoc;
        this.processor.transform();
        var s = this.processor.output;
        var f = ownerDoc.createDocumentFragment();
        var container;
        if (this.outputMethod == 'text') {
            f.appendChild(ownerDoc.createTextNode(s));
        } else if (ownerDoc.body && ownerDoc.body.innerHTML) {
            container = ownerDoc.createElement('div');
            container.innerHTML = s;
            while (container.hasChildNodes()) {
                f.appendChild(container.firstChild);
            }
        }
        else {
            var oDoc = new ActiveXObject(_SARISSA_DOM_PROGID);
            if (s.substring(0, 5) == '<?xml') {
                s = s.substring(s.indexOf('?>') + 2);
            }
            var xml = ''.concat('<my>', s, '</my>');
            oDoc.loadXML(xml);
            container = oDoc.documentElement;
            while (container.hasChildNodes()) {
                f.appendChild(container.firstChild);
            }
        }
        return f;
    };
    /**
     * Set global XSLT parameter of the imported stylesheet. This method should
     * only be used <strong>after</strong> the importStylesheet method for the
     * context XSLTProcessor instance.
     * @param {String} nsURI The parameter namespace URI
     * @param {String} name The parameter base name
     * @param {String} value The new parameter value
     */
     XSLTProcessor.prototype.setParameter = function(nsURI, name, value){
         // make value a zero length string if null to allow clearing
         value = value ? value : "";
         // nsURI is optional but cannot be null
         if(nsURI){
             this.processor.addParameter(name, value, nsURI);
         }else{
             this.processor.addParameter(name, value);
         }
         // update updated params for getParameter
         nsURI = "" + (nsURI || "");
         if(!this.paramsSet[nsURI]){
             this.paramsSet[nsURI] = [];
         }
         this.paramsSet[nsURI][name] = value;
     };
    /**
     * Gets a parameter if previously set by setParameter. Returns null
     * otherwise
     * @param {String} name The parameter base name
     * @param {String} value The new parameter value
     * @return {String} The parameter value if reviously set by setParameter, null otherwise
     */
    XSLTProcessor.prototype.getParameter = function(nsURI, name){
        nsURI = "" + (nsURI || "");
        if(this.paramsSet[nsURI] && this.paramsSet[nsURI][name]){
            return this.paramsSet[nsURI][name];
        }else{
            return null;
        }
    };
    /**
     * Clear parameters (set them to default values as defined in the stylesheet itself)
     */
    XSLTProcessor.prototype.clearParameters = function(){
        for(var nsURI in this.paramsSet){
            for(var name in this.paramsSet[nsURI]){
                if(nsURI!=""){
                    this.processor.addParameter(name, "", nsURI);
                }else{
                    this.processor.addParameter(name, "");
                }
            }
        }
        this.paramsSet = [];
    };
}else{ /* end IE initialization, try to deal with real browsers now ;-) */
    if(Sarissa._SARISSA_HAS_DOM_CREATE_DOCUMENT){
        /**
         * <p>Ensures the document was loaded correctly, otherwise sets the
         * parseError to -1 to indicate something went wrong. Internal use</p>
         * @private
         */
        Sarissa.__handleLoad__ = function(oDoc){
            Sarissa.__setReadyState__(oDoc, 4);
        };
        /**
        * <p>Attached by an event handler to the load event. Internal use.</p>
        * @private
        */
        _sarissa_XMLDocument_onload = function(){
            Sarissa.__handleLoad__(this);
        };
        /**
         * <p>Sets the readyState property of the given DOM Document object.
         * Internal use.</p>
         * @memberOf Sarissa
         * @private
         * @param oDoc the DOM Document object to fire the
         *          readystatechange event
         * @param iReadyState the number to change the readystate property to
         */
        Sarissa.__setReadyState__ = function(oDoc, iReadyState){
            oDoc.readyState = iReadyState;
            oDoc.readystate = iReadyState;
            if (oDoc.onreadystatechange != null && typeof oDoc.onreadystatechange == "function") {
                oDoc.onreadystatechange();
            }
        };
        Sarissa.getDomDocument = function(sUri, sName){
            var oDoc = document.implementation.createDocument(sUri?sUri:null, sName?sName:null, null);
            if(!oDoc.onreadystatechange){
                /**
                * <p>Emulate IE's onreadystatechange attribute</p>
                */
                oDoc.onreadystatechange = null;
            }
            if(!oDoc.readyState){
                /**
                * <p>Emulates IE's readyState property, which always gives an integer from 0 to 4:</p>
                * <ul><li>1 == LOADING,</li>
                * <li>2 == LOADED,</li>
                * <li>3 == INTERACTIVE,</li>
                * <li>4 == COMPLETED</li></ul>
                */
                oDoc.readyState = 0;
            }
            oDoc.addEventListener("load", _sarissa_XMLDocument_onload, false);
            return oDoc;
        };
        if(window.XMLDocument){
            // do nothing
        }// TODO: check if the new document has content before trying to copynodes, check  for error handling in DOM 3 LS
        else if(Sarissa._SARISSA_HAS_DOM_FEATURE && window.Document && !Document.prototype.load && document.implementation.hasFeature('LS', '3.0')){
        //Opera 9 may get the XPath branch which gives creates XMLDocument, therefore it doesn't reach here which is good
            /**
            * <p>Factory method to obtain a new DOM Document object</p>
            * @memberOf Sarissa
            * @param {String} sUri the namespace of the root node (if any)
            * @param {String} sUri the local name of the root node (if any)
            * @returns {DOMDOcument} a new DOM Document
            */
            Sarissa.getDomDocument = function(sUri, sName){
                var oDoc = document.implementation.createDocument(sUri?sUri:null, sName?sName:null, null);
                return oDoc;
            };
        }
        else {
            Sarissa.getDomDocument = function(sUri, sName){
                var oDoc = document.implementation.createDocument(sUri?sUri:null, sName?sName:null, null);
                // looks like safari does not create the root element for some unknown reason
                if(oDoc && (sUri || sName) && !oDoc.documentElement){
                    oDoc.appendChild(oDoc.createElementNS(sUri, sName));
                }
                return oDoc;
            };
        }
    }//if(Sarissa._SARISSA_HAS_DOM_CREATE_DOCUMENT)
}
//==========================================
// Common stuff
//==========================================
if(Sarissa._SARISSA_IS_IE || !window.DOMParser){
    if(Sarissa._SARISSA_IS_SAFARI){
        /**
         * DOMParser is a utility class, used to construct DOMDocuments from XML strings
         * @constructor
         */
        DOMParser = function() { };
        /**
        * Construct a new DOM Document from the given XMLstring
        * @param {String} sXml the given XML string
        * @param {String} contentType the content type of the document the given string represents (one of text/xml, application/xml, application/xhtml+xml).
        * @return {DOMDocument} a new DOM Document from the given XML string
        */
        DOMParser.prototype.parseFromString = function(sXml, contentType){
            var xmlhttp = new XMLHttpRequest();
            xmlhttp.open("GET", "data:text/xml;charset=utf-8," + encodeURIComponent(sXml), false);
            xmlhttp.send(null);
            return xmlhttp.responseXML;
        };
    }else if(Sarissa.getDomDocument && Sarissa.getDomDocument() && Sarissa.getDomDocument(null, "bar").xml){
        DOMParser = function() { };
        DOMParser.prototype.parseFromString = function(sXml, contentType){
            var doc = Sarissa.getDomDocument();
            try{
    doc.validateOnParse = false;
    doc.setProperty("ProhibitDTD", false);
            }catch(e){}
            doc.loadXML(sXml);
            return doc;
        };
    }
}
if((typeof(document.importNode) == "undefined") && Sarissa._SARISSA_IS_IE){
    try{
        /**
        * Implementation of importNode for the context window document in IE.
        * If <code>oNode</code> is a TextNode, <code>bChildren</code> is ignored.
        * @param {DOMNode} oNode the Node to import
        * @param {boolean} bChildren whether to include the children of oNode
        * @returns the imported node for further use
        */
        document.importNode = function(oNode, bChildren){
            var tmp;
            if (oNode.nodeName=='#text') {
                return document.createTextNode(oNode.data);
            }
            else {
                if(oNode.nodeName == "tbody" || oNode.nodeName == "tr"){
                    tmp = document.createElement("table");
                }
                else if(oNode.nodeName == "td"){
                    tmp = document.createElement("tr");
                }
                else if(oNode.nodeName == "option"){
                    tmp = document.createElement("select");
                }
                else{
                    tmp = document.createElement("div");
                }
                if(bChildren){
                    tmp.innerHTML = oNode.xml ? oNode.xml : oNode.outerHTML;
                }else{
                    tmp.innerHTML = oNode.xml ? oNode.cloneNode(false).xml : oNode.cloneNode(false).outerHTML;
                }
                return tmp.getElementsByTagName("*")[0];
            }
        };
    }catch(e){ }
}
if(!Sarissa.getParseErrorText){
    /**
     * <p>Returns a human readable description of the parsing error. Usefull
     * for debugging. Tip: append the returned error string in a &lt;pre&gt;
     * element if you want to render it.</p>
     * <p>Many thanks to Christian Stocker for the initial patch.</p>
     * @memberOf Sarissa
     * @param {DOMDocument} oDoc The target DOM document
     * @returns {String} The parsing error description of the target Document in
     *          human readable form (preformated text)
     */
    Sarissa.getParseErrorText = function (oDoc){
        var parseErrorText = Sarissa.PARSED_OK;
        if((!oDoc) || (!oDoc.documentElement)){
            parseErrorText = Sarissa.PARSED_EMPTY;
        } else if(oDoc.documentElement.tagName == "parsererror"){
            parseErrorText = oDoc.documentElement.firstChild.data;
            parseErrorText += "\n" +  oDoc.documentElement.firstChild.nextSibling.firstChild.data;
        } else if(oDoc.getElementsByTagName("parsererror").length > 0){
            var parsererror = oDoc.getElementsByTagName("parsererror")[0];
            parseErrorText = Sarissa.getText(parsererror, true)+"\n";
        } else if(oDoc.parseError && oDoc.parseError.errorCode != 0){
            parseErrorText = Sarissa.PARSED_UNKNOWN_ERROR;
        }
        return parseErrorText;
    };
}
/**
 * Get a string with the concatenated values of all string nodes under the given node
 * @param {DOMNode} oNode the given DOM node
 * @param {boolean} deep whether to recursively scan the children nodes of the given node for text as well. Default is <code>false</code>
 * @memberOf Sarissa
 */
Sarissa.getText = function(oNode, deep){
    var s = "";
    var nodes = oNode.childNodes;
    // opera fix, finds no child text node for attributes so we use .value
    if (oNode.nodeType == Node.ATTRIBUTE_NODE && nodes.length == 0) {
        return oNode.value;
    }
    // END opera fix
    for(var i=0; i < nodes.length; i++){
        var node = nodes[i];
        var nodeType = node.nodeType;
        if(nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE){
            s += node.data;
        } else if(deep === true && (nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE || nodeType == Node.DOCUMENT_FRAGMENT_NODE)){
            s += Sarissa.getText(node, true);
        }
    }
    return s;
};
if(Sarissa._SARISSA_IS_IE || !window.XMLSerializer && Sarissa.getDomDocument && Sarissa.getDomDocument("","foo", null).xml){
    /**
     * Utility class to serialize DOM Node objects to XML strings
     * @constructor
     */
    XMLSerializer = function(){};
    /**
     * Serialize the given DOM Node to an XML string
     * @param {DOMNode} oNode the DOM Node to serialize
     */
    XMLSerializer.prototype.serializeToString = function(oNode) {
        return oNode.xml;
    };
}
/**
 * Strips tags from the given markup string. If the given string is
 * <code>undefined</code>, <code>null</code> or empty, it is returned as is.
 * @memberOf Sarissa
 * @param {String} s the string to strip the tags from
 */
Sarissa.stripTags = function (s) {
    return s?s.replace(/<[^>]+>/g,""):s;
};
/**
 * <p>Deletes all child nodes of the given node</p>
 * @memberOf Sarissa
 * @param {DOMNode} oNode the Node to empty
 */
Sarissa.clearChildNodes = function(oNode) {
    // need to check for firstChild due to opera 8 bug with hasChildNodes
    while(oNode.firstChild) {
        oNode.removeChild(oNode.firstChild);
    }
};
/**
 * <p> Copies the childNodes of nodeFrom to nodeTo</p>
 * <p> <b>Note:</b> The second object's original content is deleted before
 * the copy operation, unless you supply a true third parameter</p>
 * @memberOf Sarissa
 * @param {DOMNode} nodeFrom the Node to copy the childNodes from
 * @param {DOMNode} nodeTo the Node to copy the childNodes to
 * @param {boolean} bPreserveExisting whether to preserve the original content of nodeTo, default is false
 */
Sarissa.copyChildNodes = function(nodeFrom, nodeTo, bPreserveExisting) {
    if(Sarissa._SARISSA_IS_SAFARI && nodeTo.nodeType == Node.DOCUMENT_NODE){ // SAFARI_OLD ??
    nodeTo = nodeTo.documentElement; //Apparently there's a bug in safari where you can't appendChild to a document node
    }
    if((!nodeFrom) || (!nodeTo)){
        throw "Both source and destination nodes must be provided";
    }
    if(!bPreserveExisting){
        Sarissa.clearChildNodes(nodeTo);
    }
    var ownerDoc = nodeTo.nodeType == Node.DOCUMENT_NODE ? nodeTo : nodeTo.ownerDocument;
    var nodes = nodeFrom.childNodes;
    var i;
    if(typeof(ownerDoc.importNode) != "undefined")  {
        for(i=0;i < nodes.length;i++) {
            nodeTo.appendChild(ownerDoc.importNode(nodes[i], true));
        }
    } else {
        for(i=0;i < nodes.length;i++) {
            nodeTo.appendChild(nodes[i].cloneNode(true));
        }
    }
};
/**
 * <p> Moves the childNodes of nodeFrom to nodeTo</p>
 * <p> <b>Note:</b> The second object's original content is deleted before
 * the move operation, unless you supply a true third parameter</p>
 * @memberOf Sarissa
 * @param {DOMNode} nodeFrom the Node to copy the childNodes from
 * @param {DOMNode} nodeTo the Node to copy the childNodes to
 * @param {boolean} bPreserveExisting whether to preserve the original content of nodeTo, default is
 */
Sarissa.moveChildNodes = function(nodeFrom, nodeTo, bPreserveExisting) {
    if((!nodeFrom) || (!nodeTo)){
        throw "Both source and destination nodes must be provided";
    }
    if(!bPreserveExisting){
        Sarissa.clearChildNodes(nodeTo);
    }
    var nodes = nodeFrom.childNodes;
    // if within the same doc, just move, else copy and delete
    if(nodeFrom.ownerDocument == nodeTo.ownerDocument){
        while(nodeFrom.firstChild){
            nodeTo.appendChild(nodeFrom.firstChild);
        }
    } else {
        var ownerDoc = nodeTo.nodeType == Node.DOCUMENT_NODE ? nodeTo : nodeTo.ownerDocument;
        var i;
        if(typeof(ownerDoc.importNode) != "undefined") {
           for(i=0;i < nodes.length;i++) {
               nodeTo.appendChild(ownerDoc.importNode(nodes[i], true));
           }
        }else{
           for(i=0;i < nodes.length;i++) {
               nodeTo.appendChild(nodes[i].cloneNode(true));
           }
        }
        Sarissa.clearChildNodes(nodeFrom);
    }
};
/**
 * <p>Serialize any <strong>non</strong> DOM object to an XML string. All properties are serialized using the property name
 * as the XML element name. Array elements are rendered as <code>array-item</code> elements,
 * using their index/key as the value of the <code>key</code> attribute.</p>
 * @memberOf Sarissa
 * @param {Object} anyObject the object to serialize
 * @param {String} objectName a name for that object, to be used as the root element name
 * @param {String} indentSpace Optional, the indentation space to use, default is an empty
 *        string. A single space character is added in any recursive call.
 * @param {noolean} skipEscape Optional, whether to skip escaping characters that map to the
 *        five predefined XML entities. Default is <code>false</code>.
 * @return {String} the XML serialization of the given object as a string
 */
Sarissa.xmlize = function(anyObject, objectName, indentSpace, skipEscape){
    indentSpace = indentSpace?indentSpace:'';
    var s = indentSpace  + '<' + objectName + '>';
    var isLeaf = false;
    if(!(anyObject instanceof Object) || anyObject instanceof Number || anyObject instanceof String || anyObject instanceof Boolean || anyObject instanceof Date){
        s += (skipEscape ? Sarissa.escape(anyObject) : anyObject);
        isLeaf = true;
    }else{
        s += "\n";
        var isArrayItem = anyObject instanceof Array;
        for(var name in anyObject){
    // do not xmlize functions
    if (anyObject[name] instanceof Function){
        continue;
    }
            s += Sarissa.xmlize(anyObject[name], (isArrayItem?"array-item key=\""+name+"\"":name), indentSpace + " ");
        }
        s += indentSpace;
    }
    return (s += (objectName.indexOf(' ')!=-1?"</array-item>\n":"</" + objectName + ">\n"));
};
/**
 * Escape the given string chacters that correspond to the five predefined XML entities
 * @memberOf Sarissa
 * @param {String} sXml the string to escape
 */
Sarissa.escape = function(sXml){
    return sXml.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
};
/**
 * Unescape the given string. This turns the occurences of the predefined XML
 * entities to become the characters they represent correspond to the five predefined XML entities
 * @memberOf Sarissa
 * @param  {String}sXml the string to unescape
 */
Sarissa.unescape = function(sXml){
    return sXml.replace(/&apos;/g,"'").replace(/&quot;/g,"\"").replace(/&gt;/g,">").replace(/&lt;/g,"<").replace(/&amp;/g,"&");
};
/** @private */
Sarissa.updateCursor = function(oTargetElement, sValue) {
    if(oTargetElement && oTargetElement.style && oTargetElement.style.cursor != undefined ){
        oTargetElement.style.cursor = sValue;
    }
};
/**
 * Asynchronously update an element with response of a GET request on the given URL.  Passing a configured XSLT
 * processor will result in transforming and updating oNode before using it to update oTargetElement.
 * You can also pass a callback function to be executed when the update is finished. The function will be called as
 * <code>functionName(oNode, oTargetElement);</code>
 * @memberOf Sarissa
 * @param {String} sFromUrl the URL to make the request to
 * @param {DOMElement} oTargetElement the element to update
 * @param {XSLTProcessor} xsltproc (optional) the transformer to use on the returned
 *                  content before updating the target element with it
 * @param {Function} callback (optional) a Function object to execute once the update is finished successfuly, called as <code>callback(sFromUrl, oTargetElement)</code>.
 *        In case an exception is thrown during execution, the callback is called as called as <code>callback(sFromUrl, oTargetElement, oException)</code>
 * @param {boolean} skipCache (optional) whether to skip any cache
 */
Sarissa.updateContentFromURI = function(sFromUrl, oTargetElement, xsltproc, callback, skipCache) {
    try{
        Sarissa.updateCursor(oTargetElement, "wait");
        var xmlhttp = new XMLHttpRequest();
        xmlhttp.open("GET", sFromUrl, true);
        xmlhttp.onreadystatechange = function() {
            if (xmlhttp.readyState == 4) {
    try{
        var oDomDoc = xmlhttp.responseXML;
    if(oDomDoc && Sarissa.getParseErrorText(oDomDoc) == Sarissa.PARSED_OK){
                        Sarissa.updateContentFromNode(xmlhttp.responseXML, oTargetElement, xsltproc);
                if(callback){
    callback(sFromUrl, oTargetElement);
                        }
    }
    else{
        throw Sarissa.getParseErrorText(oDomDoc);
    }
    }
    catch(e){
        if(callback){
    callback(sFromUrl, oTargetElement, e);
                    }
                    else{
    throw e;
                    }
    }
            }
        };
        if (skipCache) {
             var oldage = "Sat, 1 Jan 2000 00:00:00 GMT";
             xmlhttp.setRequestHeader("If-Modified-Since", oldage);
        }
        xmlhttp.send("");
    }
    catch(e){
        Sarissa.updateCursor(oTargetElement, "auto");
        if(callback){
    callback(sFromUrl, oTargetElement, e);
        }
        else{
    throw e;
        }
    }
};
/**
 * Update an element's content with the given DOM node. Passing a configured XSLT
 * processor will result in transforming and updating oNode before using it to update oTargetElement.
 * You can also pass a callback function to be executed when the update is finished. The function will be called as
 * <code>functionName(oNode, oTargetElement);</code>
 * @memberOf Sarissa
 * @param {DOMNode} oNode the URL to make the request to
 * @param {DOMElement} oTargetElement the element to update
 * @param {XSLTProcessor} xsltproc (optional) the transformer to use on the given
 *                  DOM node before updating the target element with it
 */
Sarissa.updateContentFromNode = function(oNode, oTargetElement, xsltproc) {
    try {
        Sarissa.updateCursor(oTargetElement, "wait");
        Sarissa.clearChildNodes(oTargetElement);
        // check for parsing errors
        var ownerDoc = oNode.nodeType == Node.DOCUMENT_NODE?oNode:oNode.ownerDocument;
        if(ownerDoc.parseError && ownerDoc.parseError.errorCode != 0) {
            var pre = document.createElement("pre");
            pre.appendChild(document.createTextNode(Sarissa.getParseErrorText(ownerDoc)));
            oTargetElement.appendChild(pre);
        }
        else {
            // transform if appropriate
            if(xsltproc) {
                oNode = xsltproc.transformToDocument(oNode);
            }
            // be smart, maybe the user wants to display the source instead
            if(oTargetElement.tagName.toLowerCase() == "textarea" || oTargetElement.tagName.toLowerCase() == "input") {
                oTargetElement.value = new XMLSerializer().serializeToString(oNode);
            }
            else {
                // ok that was not smart; it was paranoid. Keep up the good work by trying to use DOM instead of innerHTML
                try{
                    oTargetElement.appendChild(oTargetElement.ownerDocument.importNode(oNode, true));
                }
                catch(e){
                    oTargetElement.innerHTML = new XMLSerializer().serializeToString(oNode);
                }
            }
        }
    }
    catch(e) {
    throw e;
    }
    finally{
        Sarissa.updateCursor(oTargetElement, "auto");
    }
};
/**
 * Creates an HTTP URL query string from the given HTML form data
 * @memberOf Sarissa
 * @param {HTMLFormElement} oForm the form to construct the query string from
 */
Sarissa.formToQueryString = function(oForm){
    var qs = "";
    for(var i = 0;i < oForm.elements.length;i++) {
        var oField = oForm.elements[i];
        var sFieldName = oField.getAttribute("name") ? oField.getAttribute("name") : oField.getAttribute("id");
        // ensure we got a proper name/id and that the field is not disabled
        if(sFieldName &&
            ((!oField.disabled) || oField.type == "hidden")) {
            switch(oField.type) {
                case "hidden":
                case "text":
                case "textarea":
                case "password":
                    qs += sFieldName + "=" + encodeURIComponent(oField.value) + "&";
                    break;
                case "select-one":
                    qs += sFieldName + "=" + encodeURIComponent(oField.options[oField.selectedIndex].value) + "&";
                    break;
                case "select-multiple":
                    for (var j = 0; j < oField.length; j++) {
                        var optElem = oField.options[j];
                        if (optElem.selected === true) {
                            qs += sFieldName + "[]" + "=" + encodeURIComponent(optElem.value) + "&";
                        }
                     }
                     break;
                case "checkbox":
                case "radio":
                    if(oField.checked) {
                        qs += sFieldName + "=" + encodeURIComponent(oField.value) + "&";
                    }
                    break;
            }
        }
    }
    // return after removing last '&'
    return qs.substr(0, qs.length - 1);
};
/**
 * Asynchronously update an element with response of an XMLHttpRequest-based emulation of a form submission. <p>The form <code>action</code> and
 * <code>method</code> attributess will be followed. Passing a configured XSLT processor will result in
 * transforming and updating the server response before using it to update the target element.
 * You can also pass a callback function to be executed when the update is finished. The function will be called as
 * <code>functionName(oNode, oTargetElement);</code></p>
 * <p>Here is an example of using this in a form element:</p>
 * <pre name="code" class="xml">
 * &lt;div id="targetId"&gt; this content will be updated&lt;/div&gt;
 * &lt;form action="/my/form/handler" method="post"
 *     onbeforesubmit="return Sarissa.updateContentFromForm(this, document.getElementById('targetId'));"&gt;<pre>
 * <p>If JavaScript is supported, the form will not be submitted. Instead, Sarissa will
 * scan the form and make an appropriate AJAX request, also adding a parameter
 * to signal to the server that this is an AJAX call. The parameter is
 * constructed as <code>Sarissa.REMOTE_CALL_FLAG = "=true"</code> so you can change the name in your webpage
 * simply by assigning another value to Sarissa.REMOTE_CALL_FLAG. If JavaScript is not supported
 * the form will be submitted normally.
 * @memberOf Sarissa
 * @param {HTMLFormElement} oForm the form submition to emulate
 * @param {DOMElement} oTargetElement the element to update
 * @param {XSLTProcessor} xsltproc (optional) the transformer to use on the returned
 *                  content before updating the target element with it
 * @param {Function} callback (optional) a Function object to execute once the update is finished successfuly, called as <code>callback(oNode, oTargetElement)</code>.
 *        In case an exception occurs during excecution and a callback function was provided, the exception is cought and the callback is called as
 *        <code>callback(oForm, oTargetElement, exception)</code>
 */
Sarissa.updateContentFromForm = function(oForm, oTargetElement, xsltproc, callback) {
    try{
    Sarissa.updateCursor(oTargetElement, "wait");
        // build parameters from form fields
        var params = Sarissa.formToQueryString(oForm) + "&" + Sarissa.REMOTE_CALL_FLAG + "=true";
        var xmlhttp = new XMLHttpRequest();
        var bUseGet = oForm.getAttribute("method") && oForm.getAttribute("method").toLowerCase() == "get";
        if(bUseGet) {
            xmlhttp.open("GET", oForm.getAttribute("action")+"?"+params, true);
        }
        else{
            xmlhttp.open('POST', oForm.getAttribute("action"), true);
            xmlhttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
            xmlhttp.setRequestHeader("Content-length", params.length);
            xmlhttp.setRequestHeader("Connection", "close");
        }
        xmlhttp.onreadystatechange = function() {
    try{
                if (xmlhttp.readyState == 4) {
    var oDomDoc = xmlhttp.responseXML;
    if(oDomDoc && Sarissa.getParseErrorText(oDomDoc) == Sarissa.PARSED_OK){
                        Sarissa.updateContentFromNode(xmlhttp.responseXML, oTargetElement, xsltproc);
                if(callback){
    callback(oForm, oTargetElement);
                        }
    }
    else{
        throw Sarissa.getParseErrorText(oDomDoc);
    }
                }
    }
    catch(e){
        if(callback){
            callback(oForm, oTargetElement, e);
        }
        else{
            throw e;
        }
    }
        };
        xmlhttp.send(bUseGet?"":params);
    }
    catch(e){
        Sarissa.updateCursor(oTargetElement, "auto");
        if(callback){
    callback(oForm, oTargetElement, e);
        }
        else{
    throw e;
        }
    }
    return false;
};
/**
 * Get the name of a function created like:
 * <pre>function functionName(){}</pre>
 * If a name is not found, attach the function to
 * the window object with a new name and return that
 * @param {Function} oFunc the function object
 */
Sarissa.getFunctionName = function(oFunc){
    if(!oFunc || (typeof oFunc != 'function' )){
        throw "The value of parameter 'oFunc' must be a function";
    }
    if(oFunc.name) {
        return oFunc.name;
    }
    // try to parse the function name from the defintion
    var sFunc = oFunc.toString();
    alert("sFunc: "+sFunc);
    var name = sFunc.substring(sFunc.indexOf('function') + 8 , sFunc.indexOf('('));
    if(!name || name.length == 0 || name == " "){
        // attach to window object under a new name
        name = "SarissaAnonymous" + Sarissa._getUniqueSuffix();
        window[name] = oFunc;
    }
    return name;
};
/**
 *
 */
Sarissa.setRemoteJsonCallback = function(url, callback, callbackParam) {
    if(!callbackParam){
        callbackParam = "callback";
    }
    var callbackFunctionName = Sarissa.getFunctionName(callback);
    //alert("callbackFunctionName: '" + callbackFunctionName+"', length: "+callbackFunctionName.length);
    var id = "sarissa_json_script_id_" + Sarissa._getUniqueSuffix();
    var oHead = document.getElementsByTagName("head")[0];
    var scriptTag = document.createElement('script');
    scriptTag.type = 'text/javascript';
    scriptTag.id = id;
    scriptTag.onload = function(){
        // cleanUp
        // document.removeChild(scriptTag);
    };
    if(url.indexOf("?") != -1){
        url += ("&" + callbackParam + "=" + callbackFunctionName);
    }
    else{
        url += ("?" + callbackParam + "=" + callbackFunctionName);
    }
    scriptTag.src = url;
    oHead.appendChild(scriptTag);
    return id;
};
//   EOF
module.exports.Sarissa = Sarissa;
});
Numbas.queueScript('sarissa_ieemu_xpath',['sarissa'],function() {
/**
 * ====================================================================
 * About
 * ====================================================================
 * Sarissa cross browser XML library - IE XPath Emulation
 * @version 0.9.9.5
 * @author: Copyright 2004-2007 Emmanouil Batsis, mailto: mbatsis at users full stop sourceforge full stop net
 *
 * This script emulates Internet Explorer's selectNodes and selectSingleNode
 * for Mozilla. Associating namespace prefixes with URIs for your XPath queries
 * is easy with IE's setProperty.
 * USers may also map a namespace prefix to a default (unprefixed) namespace in the
 * source document with Sarissa.setXpathNamespaces
 *
 * ====================================================================
 * Licence
 * ====================================================================
 * Sarissa is free software distributed under the GNU GPL version 2 (see <a href="gpl.txt">gpl.txt</a>) or higher,
 * GNU LGPL version 2.1 (see <a href="lgpl.txt">lgpl.txt</a>) or higher and Apache Software License 2.0 or higher
 * (see <a href="asl.txt">asl.txt</a>). This means you can choose one of the three and use that if you like. If
 * you make modifications under the ASL, i would appreciate it if you submitted those.
 * In case your copy of Sarissa does not include the license texts, you may find
 * them online in various formats at <a href="http://www.gnu.org">http://www.gnu.org</a> and
 * <a href="http://www.apache.org">http://www.apache.org</a>.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
 * KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE
 * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
if(Sarissa._SARISSA_HAS_DOM_FEATURE && document.implementation.hasFeature("XPath", "3.0")){
    /**
     * <p>SarissaNodeList behaves as a NodeList but is only used as a result to <code>selectNodes</code>,
     * so it also has some properties IEs proprietery object features.</p>
     * @private
     * @constructor
     * @argument i the (initial) list size
     */
    SarissaNodeList = function (i){
        this.length = i;
    };
    /**
     * <p>Set an Array as the prototype object</p>
     * @private
     */
    SarissaNodeList.prototype = [];
    /**
     * <p>Inherit the Array constructor </p>
     * @private
     */
    SarissaNodeList.prototype.constructor = Array;
    /**
     * <p>Returns the node at the specified index or null if the given index
     * is greater than the list size or less than zero </p>
     * <p><b>Note</b> that in ECMAScript you can also use the square-bracket
     * array notation instead of calling <code>item</code>
     * @argument i the index of the member to return
     * @returns the member corresponding to the given index
     * @private
     */
    SarissaNodeList.prototype.item = function(i) {
        return (i < 0 || i >= this.length)?null:this[i];
    };
    /**
     * <p>Emulate IE's expr property
     * (Here the SarissaNodeList object is given as the result of selectNodes).</p>
     * @returns the XPath expression passed to selectNodes that resulted in
     *          this SarissaNodeList
     * @private
     */
    SarissaNodeList.prototype.expr = "";
    /** dummy, used to accept IE's stuff without throwing errors */
    if(window.XMLDocument && (!XMLDocument.prototype.setProperty)){
        XMLDocument.prototype.setProperty  = function(x,y){};
    }
    /**
    * <p>Programmatically control namespace URI/prefix mappings for XPath
    * queries.</p>
    * <p>This method comes especially handy when used to apply XPath queries
    * on XML documents with a default namespace, as there is no other way
    * of mapping that to a prefix.</p>
    * <p>Using no namespace prefix in DOM Level 3 XPath queries, implies you
    * are looking for elements in the null namespace. If you need to look
    * for nodes in the default namespace, you need to map a prefix to it
    * first like:</p>
    * <pre>Sarissa.setXpathNamespaces(oDoc, "xmlns:myprefix'http://mynsURI'");</pre>
    * <p><b>Note 1 </b>: Use this method only if the source document features
    * a default namespace (without a prefix), otherwise just use IE's setProperty
    * (moz will rezolve non-default namespaces by itself). You will need to map that
    * namespace to a prefix for queries to work.</p>
    * <p><b>Note 2 </b>: This method calls IE's setProperty method to set the
    * appropriate namespace-prefix mappings, so you dont have to do that.</p>
    * @param oDoc The target XMLDocument to set the namespace mappings for.
    * @param sNsSet A whilespace-seperated list of namespace declarations as
    *            those would appear in an XML document. E.g.:
    *            <code>&quot;xmlns:xhtml=&apos;http://www.w3.org/1999/xhtml&apos;
    * xmlns:&apos;http://www.w3.org/1999/XSL/Transform&apos;&quot;</code>
    * @throws An error if the format of the given namespace declarations is bad.
    */
    Sarissa.setXpathNamespaces = function(oDoc, sNsSet) {
        //oDoc._sarissa_setXpathNamespaces(sNsSet);
        oDoc._sarissa_useCustomResolver = true;
        var namespaces = sNsSet.indexOf(" ")>-1?sNsSet.split(" "):[sNsSet];
        oDoc._sarissa_xpathNamespaces = [];
        for(var i=0;i < namespaces.length;i++){
            var ns = namespaces[i];
            var colonPos = ns.indexOf(":");
            var assignPos = ns.indexOf("=");
            if(colonPos > 0 && assignPos > colonPos+1){
                var prefix = ns.substring(colonPos+1, assignPos);
                var uri = ns.substring(assignPos+2, ns.length-1);
                oDoc._sarissa_xpathNamespaces[prefix] = uri;
            }else{
                throw "Bad format on namespace declaration(s) given";
            }
        }
    };
    /**
    * @private Flag to control whether a custom namespace resolver should
    *          be used, set to true by Sarissa.setXpathNamespaces
    */
    XMLDocument.prototype._sarissa_useCustomResolver = false;
    /** @private */
    XMLDocument.prototype._sarissa_xpathNamespaces = [];
    /**
    * <p>Extends the XMLDocument to emulate IE's selectNodes.</p>
    * @argument sExpr the XPath expression to use
    * @argument contextNode this is for internal use only by the same
    *           method when called on Elements
    * @returns the result of the XPath search as a SarissaNodeList
    * @throws An error if no namespace URI is found for the given prefix.
    */
    XMLDocument.prototype.selectNodes = function(sExpr, contextNode, returnSingle){
        var nsDoc = this;
        var nsresolver;
        if(this._sarissa_useCustomResolver){
            nsresolver = function(prefix){
                var s = nsDoc._sarissa_xpathNamespaces[prefix];
                if(s){
                    return s;
                }
                else {
                    throw "No namespace URI found for prefix: '" + prefix+"'";
                }
            };
        }
        else{
            nsresolver = this.createNSResolver(this.documentElement);
        }
        var result = null;
        if(!returnSingle){
            var oResult = this.evaluate(sExpr,
                (contextNode?contextNode:this),
                nsresolver,
                XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
            var nodeList = new SarissaNodeList(oResult.snapshotLength);
            nodeList.expr = sExpr;
            for(var i=0;i<nodeList.length;i++){
                nodeList[i] = oResult.snapshotItem(i);
            }
            result = nodeList;
        }
        else {
            result = this.evaluate(sExpr,
                (contextNode?contextNode:this),
                nsresolver,
                XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
        }
        return result;
    };
    /**
    * <p>Extends the Element to emulate IE's selectNodes</p>
    * @argument sExpr the XPath expression to use
    * @returns the result of the XPath search as an (Sarissa)NodeList
    * @throws An
    *             error if invoked on an HTML Element as this is only be
    *             available to XML Elements.
    */
    Element.prototype.selectNodes = function(sExpr){
        var doc = this.ownerDocument;
        if(doc.selectNodes){
            return doc.selectNodes(sExpr, this);
        }
        else{
            throw "Method selectNodes is only supported by XML Elements";
        }
    };
    /**
    * <p>Extends the XMLDocument to emulate IE's selectSingleNode.</p>
    * @argument sExpr the XPath expression to use
    * @argument contextNode this is for internal use only by the same
    *           method when called on Elements
    * @returns the result of the XPath search as an (Sarissa)NodeList
    */
    XMLDocument.prototype.selectSingleNode = function(sExpr, contextNode){
        var ctx = contextNode?contextNode:null;
        return this.selectNodes(sExpr, ctx, true);
    };
    /**
    * <p>Extends the Element to emulate IE's selectSingleNode.</p>
    * @argument sExpr the XPath expression to use
    * @returns the result of the XPath search as an (Sarissa)NodeList
    * @throws An error if invoked on an HTML Element as this is only be
    *             available to XML Elements.
    */
    Element.prototype.selectSingleNode = function(sExpr){
        var doc = this.ownerDocument;
        if(doc.selectSingleNode){
            return doc.selectSingleNode(sExpr, this);
        }
        else{
            throw "Method selectNodes is only supported by XML Elements";
        }
    };
    Sarissa.IS_ENABLED_SELECT_NODES = true;
}
});
/*
Copyright 2011-14 Newcastle University
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/** @file Provides {@link Numbas.schedule} */
Numbas.queueScript('schedule',['base'],function() {
/** Schedule functions to be called. The scheduler can put tiny timeouts in between function calls so the browser doesn't become unresponsive. It also updates the loading bar.
 * @namespace Numbas.schedule
 */
var schedule = Numbas.schedule = /** @lends Numbas.schedule */ {
    /** Functions to call
     * @type {function[]}
     */
    calls: [],
    /** Bits of queue that have been picked up while a task performs sub-tasks
     * @type {Array.<Array.<function>>} */
    lifts: [],
    /** Number of tasks completed
     * @type {Number}
     */
    completed: 0,
    /** Total number of tasks ever scheduled
     * @type {Number}
     */
    total: 0,
    /** Should the scheduler stop running tasks?
     * Don't use this directly - use {@link Numbas.schedule.halt}
     * @type {Boolean}
     */
    halted:false,
    /** Error which caused the scheduler to halt
     * @type {Error}
     */
    halt_error: null,
    /** Prevent the scheduler from running any more tasks, and save the error message which caused this.
     * @param {Error} error
     * @see Numbas.schedule.halted
     * @see Numbas.schedule.halt_error
     */
    halt: function(error) {
        Numbas.display && Numbas.display.die(error);
        schedule.halted = true;
        schedule.halt_error = error;
    },
    /** @typedef {Object} Numbas.schedule.task_object
     * @property {function} task - The function to execute.
     * @property {function} error - A callback, used if an error is raised.
     */
    /** Add a task to the queue
     * @param {function|Numbas.schedule.task_object} fn - the function to run, or a dictionary `{task: fn, error: fn}`, where `error` is a callback if an error is caused
     * @param {Object} that - what `this` should be when the function is called
     */
    add: function(fn,that)
    {
        if(schedule.halted)
            return;
        var args = [],l=arguments.length;
        for(var i=2;i<l;i++)
        {
            args[i-2]=arguments[i];
        }
        if(typeof(fn)=='function') {
            fn = {task: fn};
        }
        var task = function()
        {
            try {
                fn.task.apply(that,args);
            } catch(e) {
                if(fn.error) {
                    fn.error(e);
                } else {
                    throw(e);
                }
            }
        };
        schedule.calls.push(task);
        setTimeout(schedule.pop,0);
        schedule.total++;
    },
    /** Pop the first task off the queue and run it.
     *
     * If there's an error, the scheduler halts and shows the error.
     */
    pop: function()
    {
        var calls = schedule.calls;
        if(!calls.length || schedule.halted){return;}
        var task = calls.shift();
        schedule.lift();
        try {
            task();
        }
        catch(e) {
            schedule.halt(e);
        }
        schedule.drop();
        schedule.completed++;
        Numbas.display && Numbas.display.showLoadProgress();
    },
    /** 'pick up' the current queue and put stuff in front. Called before running a task, so it can queue things which must be done before the rest of the queue is called */
    lift: function()
    {
        schedule.lifts.push(schedule.calls);
        schedule.calls=new Array();
    },
    /** Put the last lifted queue back on the end of the real queue */
    drop: function()
    {
        schedule.calls = schedule.calls.concat(schedule.lifts.pop());
    },
};

/** Coordinates Promises corresponding to different stages in the loading process.
 * @constructor
 * @memberof Numbas.schedule
 */
var SignalBox = schedule.SignalBox = function() {
    this.callbacks = {};
}
SignalBox.prototype = { /** @lends Numbas.schedule.SignalBox.prototype */
    /** @typedef Numbas.schedule.callback
     * @type {Object}
     * @property {Promise} Promise
     * @property {function} resolve - the promise's `resolve` function
     * @property {function} reject - the promise's `reject` function
     * @property {Boolean} resolved - has the promise been resolved?
     */

    /** Dictionary of registered callbacks.
     * @type {Object.<Numbas.schedule.callback>}
     * @private
     */
    callbacks: {},

    /** Get a callback object for the event with the hiven name.
     * If the callback hasn't been accessed before, it's created.
     * @param {String} name
     * @returns {Numbas.schedule.callback}
     */
    getCallback: function(name) {
        if(this.callbacks[name]) {
            return this.callbacks[name];
        }
        var deferred = this.callbacks[name] = {};
        deferred.promise = new Promise(function(resolve,reject) {
            deferred.resolve = resolve;
            deferred.reject = reject;
        });
        deferred.promise.catch(function(e) {
            deferred.reject(e);
        });
        return deferred;
    },

    /** Once the given event(s) have resolved, run the given callback function. Returns a Promise, so can be used without a callback.
     * @param {String|Array.<String>} events - the name of an event, or a list of event names
     * @param {function} [fn] - a callback function to run
     * @returns {Promise} Resolves when all of the events have resolved, or rejects if the signal box is in an error state.
     */
    on: function(events, fn) {
        var sb = this;
        if(sb.error) {
            return Promise.reject(sb.error);
        }
        if(typeof(events)=='string') {
            events = [events];
        }
        var promises = [];
        var callbacks = events.map(function(name) {
            var callback = sb.getCallback(name);
            promises.push(callback.promise);
            return callback;
        });
        var promise = Promise.all(promises);
        if(fn) {
            promise = promise.then(function() {
                return new Promise(function(resolve,reject) {
                    try {
                        if(schedule.halted) {
                            reject(schedule.halt_error)
                        }
                        var result = fn();
                        resolve(result);
                    } catch(e) {
                        reject(e);
                    }
                });
            }).catch(function(e){
                sb.error = e;
                for(var x in sb.callbacks) {
                    sb.callbacks[x].reject(e);
                }
                return Promise.reject(e);
            });
        }
        return promise;
    },

    /** Notify the signal box that the event with the given name has happened.
     * @param {String} name
     */
    trigger: function(name) {
        var callback = this.getCallback(name);
        if(this.error) {
            callback.reject(error);
        }
        callback.resolved = true;
        callback.resolve();
    }
}
});

/*
Copyright 2011-14 Newcastle University
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/** @file Provides a storage API {@link Numbas.storage.SCORMStorage} which interfaces with SCORM */
Numbas.queueScript('scorm-storage',['base','util','SCORM_API_wrapper','storage'],function() {
var scorm = Numbas.storage.scorm = {};
/** SCORM storage object - controls saving and loading of data from the LMS
 * @constructor
 * @memberof Numbas.storage
 * @augments Numbas.storage.BlankStorage
 */
var SCORMStorage = scorm.SCORMStorage = function()
{
    if(pipwerks.SCORM.init()){
       Numbas.storage.lmsConnected = true;
    }
    else
    {
        var errorCode = pipwerks.SCORM.debug.getCode();
        if(errorCode) {
            throw(new Numbas.Error(R('scorm.error initialising',{message: pipwerks.SCORM.debug.getInfo(errorCode)})));
        }
        //if the pretend LMS extension is loaded, we can start that up
        if(Numbas.storage.PretendLMS)
        {
            if(!Numbas.storage.lms)
            {
                Numbas.storage.lms = new Numbas.storage.PretendLMS();
            }
            window.API_1484_11 = Numbas.storage.lms.API;
            pipwerks.SCORM.init();
        }
        //otherwise return a blank storage object which does nothing
        else
        {
            return new Numbas.storage.BlankStorage();
        }
    }
    this.getEntry();
    //get all question-objective indices
    this.questionIndices = {};
    var numObjectives = parseInt(this.get('objectives._count'),10);
    for(var i=0;i<numObjectives;i++)
    {
        var id = this.get('objectives.'+i+'.id');
        this.questionIndices[id]=i;
    }
    //get part-interaction indices
    this.partIndices = {};
    var numInteractions = parseInt(this.get('interactions._count'),10);
    for(var i=0;i<numInteractions;i++)
    {
        var id = this.get('interactions.'+i+'.id');
        this.partIndices[id]=i;
    }
};
SCORMStorage.prototype = /** @lends Numbas.storage.SCORMStorage.prototype */ {
    /** Mode the session started in:
     *
     * * `ab-initio` - starting a new attempt
     * * `resume` - loaded attempt in progress
     */
    mode: 'ab-initio',
    /** Indicates whether a true SCORM connection to an LMS exists */
    lmsConnected: false,
    /** reference to the {@link Numbas.Exam} object for the current exam */
    exam: undefined,            //reference to the main exam object
    /** Dictionary mapping question ids (of the form `qN`) to `cmi.objective` indices */
    questionIndices:{},        //associate question ids with objective indices
    /** Dictionary mapping {@link Numbas.parts.partpath} ids to `cmi.interaction` indices */
    partIndices:{},            //associate part ids with interaction indices
    /** The last `cmi.suspend_data` object
     * @type {Numbas.storage.exam_suspend_data}
     */
    suspendData: undefined,    //save the suspend data so we don't have to keep fetching it off the server
    /** Save SCORM data - call the SCORM commit method to make sure the data model is saved to the server */
    save: function()
    {
        var exam = this.exam;
        function trySave() {
            exam.display.saving(true);
            var saved = pipwerks.SCORM.save();
            if(!saved) {
                Numbas.display.showAlert(R('scorm.failed save'),function(){
                    setTimeout(trySave,1);
                });
            }
            else
                exam.display.saving(false);
        }
        trySave();
    },
    /** Set a SCORM data model element.
     * @param {String} key - element name. This is prepended with `cmi.`
     * @param {String} value - element value
     * @returns {Boolean} - did the call succeed?
     */
    set: function(key,value)
    {
        //Numbas.debug("set "+key+" := "+value,true);
        var val = pipwerks.SCORM.set('cmi.'+key,value);
        //Numbas.debug(pipwerks.SCORM.debug.getCode(),true);
        return val;
    },
    /** Get a SCORM data model element
     * @param {String} key - element name. This is prepended with `cmi.`
     * @returns {String} - the value of the element
     */
    get: function(key)
    {
        var val = pipwerks.SCORM.get('cmi.'+key);
        //Numbas.debug("get "+key+" = "+val,true);
        //Numbas.debug(pipwerks.SCORM.debug.getCode(),true);
        return val;
    },
    /** Make an id string corresponding to a question, of the form `qN`, where `N` is the question's number
     * @param {Numbas.Question} question
     * @returns {String}
     */
    getQuestionId: function(question)
    {
        return 'q'+question.number;
    },
    /** Make an id string corresponding to a part, of the form `qNpXgYsZ`
     * @param {Numbas.parts.Part} part
     * @returns {String}
     */
    getPartId: function(part)
    {
        return this.getQuestionId(part.question)+part.path;
    },
    /** Load student's name and ID
     */
    get_student_name: function() {
        this.exam.student_name = this.get('learner_name');
        this.exam.student_id = this.get('learner_id');
    },
    /** Initialise the SCORM data model and this storage object.
     * @param {Numbas.Exam} exam
     */
    init: function(exam)
    {
        this.exam = exam;
        this.get_student_name();
        var set = this.set;
        this.set('completion_status','incomplete');
        this.set('exit','suspend');
        this.set('progress_measure',0);
        this.set('session_time','PT0H0M0S');
        this.set('success_status','unknown');
        this.set('score.scaled',0);
        this.set('score.raw',0);
        this.set('score.min',0);
        this.set('score.max',exam.mark);
        this.questionIndices = {};
        this.partIndices = {};
        for(var i=0; i<exam.settings.numQuestions; i++)
        {
            this.initQuestion(exam.questionList[i]);
        }
        this.setSuspendData();
    },
    /** Initialise a question - make an objective for it, and initialise all its parts.
     * @param {Numbas.Question} q
     */
    initQuestion: function(q)
    {
        var id = this.getQuestionId(q);
        var index = this.get('objectives._count');
        this.questionIndices[id] = index;
        var prepath = 'objectives.'+index+'.';
        this.set(prepath+'id', id);
        this.set(prepath+'score.min',0);
        this.set(prepath+'score.max',q.marks);
        this.set(prepath+'score.raw',q.score || 0);
        this.set(prepath+'success_status','unknown');
        this.set(prepath+'completion_status','not attempted');
        this.set(prepath+'progress_measure',0);
        this.set(prepath+'description',q.name);
        for(var i=0; i<q.parts.length;i++)
        {
            this.initPart(q.parts[i]);
        }
    },
    getPartStorage: function(p) {
        if(p.is_custom_part_type) {
            return scorm.partTypeStorage['custom'];
        } else {
            return scorm.partTypeStorage[p.type];
        }
    },
    /** Initialise a part - make an interaction for it, and set up correct responses.
     * @param {Numbas.parts.Part} part
     */
    initPart: function(p)
    {
        var id = this.getPartId(p);
        var index = this.get('interactions._count');
        this.partIndices[id] = index;
        var prepath = 'interactions.'+index+'.';
        this.set(prepath+'id',id);
        this.set(prepath+'objectives.0.id',this.getQuestionId(p.question));
        this.set(prepath+'weighting',p.marks);
        this.set(prepath+'result',0);
        this.set(prepath+'description',p.type);
        var typeStorage = this.getPartStorage(p);
        if(typeStorage) {
            this.set(prepath+'type', typeStorage.interaction_type(p));
            var correct_answer = typeStorage.correct_answer(p);
            if(correct_answer!==undefined) {
                this.set(prepath+'correct_responses.0.pattern', correct_answer);
            }
        }
        if(p.type=='gapfill') {
            for(var i=0;i<p.gaps.length;i++) {
                this.initPart(p.gaps[i]);
            }
        }
        for(var i=0;i<p.steps.length;i++) {
            this.initPart(p.steps[i]);
        }
    },
    /** Save all the other stuff that doesn't fit into the standard SCORM data model using the `cmi.suspend_data` string.
     */
    setSuspendData: function()
    {
        var exam = this.exam;
        if(exam.loading)
            return;
        var eobj =
        {
            timeRemaining: exam.timeRemaining || 0,
            timeSpent: exam.timeSpent || 0,
            duration: exam.settings.duration || 0,
            questionSubsets: exam.question_groups.map(function(g){ return g.questionSubset }),
            start: exam.start-0,
            stop: exam.stop ? exam.stop-0 : null
        };
        eobj.questions = [];
        for(var i=0;i<exam.settings.numQuestions;i++)
        {
            eobj.questions.push(this.questionSuspendData(exam.questionList[i]));
        }
        this.set('suspend_data',JSON.stringify(eobj));
        this.setSessionTime();
        this.suspendData = eobj;
    },
    /** Create suspend data object for a question
     * @param {Numbas.Question} question
     * @returns {Numbas.storage.question_suspend_data}
     * @see Numbas.storage.SCORMStorage#setSuspendData
     */
    questionSuspendData: function(question)
    {
        var qobj =
        {
            name: question.name,
            visited: question.visited,
            answered: question.answered,
            submitted: question.submitted,
            adviceDisplayed: question.adviceDisplayed,
            revealed: question.revealed
        };
        qobj.variables = {};
        var all_variables = question.scope.allVariables();
        for(var name in all_variables)
        {
            qobj.variables[name] = Numbas.jme.display.treeToJME({tok: all_variables[name]},{niceNumber:false, wrapexpressions: true});
        }
        qobj.parts = [];
        for(var i=0;i<question.parts.length;i++)
        {
            qobj.parts.push(this.partSuspendData(question.parts[i]));
        }
        return qobj;
    },
    /** Create suspend data object for a part
     * @param {Numbas.parts.Part} part
     * @returns {Numbas.storage.part_suspend_data}
     * @see Numbas.storage.SCORMStorage#setSuspendData
     */
    partSuspendData: function(part)
    {
        var pobj = {
            answered: part.answered,
            stepsShown: part.stepsShown,
            stepsOpen: part.stepsOpen
        };
        var typeStorage = this.getPartStorage(part);
        if(typeStorage) {
            var data = typeStorage.suspend_data(part, this);
            if(data) {
                pobj = Numbas.util.extend_object(pobj,data);
            }
        }
        pobj.steps = [];
        for(var i=0;i<part.steps.length;i++)
        {
            pobj.steps.push(this.partSuspendData(part.steps[i]));
        }
        return pobj;
    },
    /** Get the suspend data from the SCORM data model
     * @returns {Numbas.storage.exam_suspend_data}
     */
    getSuspendData: function()
    {
        try {
            if(!this.suspendData)
            {
                var suspend_data = this.get('suspend_data');
                if(suspend_data.length)
                    this.suspendData = JSON.parse(suspend_data);
            }
            if(!this.suspendData) {
                throw(new Numbas.Error('scorm.no exam suspend data'));
            }
        } catch(e) {
            throw(new Numbas.Error('scorm.error loading suspend data',{message: e.message}));
        }
        return this.suspendData;
    },
    /** Get suspended exam info
     * @param {Numbas.Exam} exam
     * @returns {Numbas.storage.exam_suspend_data}
     */
    load: function(exam)
    {
        this.exam = exam;
        this.get_student_name();
        var eobj = this.getSuspendData();
        this.set('exit','suspend');
        var currentQuestion = this.get('location');
        if(currentQuestion.length)
            currentQuestion=parseInt(currentQuestion,10);
        else
            currentQuestion=undefined;
        var score = parseInt(this.get('score.raw'),10);
        return {
            timeRemaining: eobj.timeRemaining || 0,
            timeSpent: eobj.timeSpent || 0,
            duration: eobj.duration || 0 ,
            questionSubsets: eobj.questionSubsets,
            start: eobj.start,
            stop: eobj.stop,
            score: score,
            currentQuestion: currentQuestion
        };
    },
    /** Get suspended info for a question
     * @param {Numbas.Question} question
     * @returns {Numbas.storage.question_suspend_data}
     */
    loadQuestion: function(question)
    {
        try {
            var eobj = this.getSuspendData();
            var qobj = eobj.questions[question.number];
            if(!qobj) {
                throw(new Numbas.Error('scorm.no question suspend data'));
            }
            var id = this.getQuestionId(question);
            var index = this.questionIndices[id];
            var variables = {};
            for(var name in qobj.variables)
            {
                variables[name] = question.scope.evaluate(qobj.variables[name]);
            }
            return {
                    name: qobj.name,
                    score: parseInt(this.get('objectives.'+index+'.score.raw') || 0,10),
                    visited: qobj.visited,
                    answered: qobj.answered,
                    submitted: qobj.submitted,
                    adviceDisplayed: qobj.adviceDisplayed,
                    revealed: qobj.revealed,
                    variables: variables
            };
        } catch(e) {
            throw(new Numbas.Error('scorm.error loading question',{'number':question.number,message:e.message}));
        }
    },
    /** Get suspended info for a part
     * @param {Numbas.parts.Part} part
     * @returns {Numbas.storage.part_suspend_data}
     */
    loadPart: function(part)
    {
        try {
            var eobj = this.getSuspendData();
            var pobj = eobj.questions[part.question.number];
            var re = /(p|g|s)(\d+)/g;
            while(m = re.exec(part.path))
            {
                var i = parseInt(m[2]);
                switch(m[1])
                {
                case 'p':
                    pobj = pobj.parts[i];
                    break;
                case 'g':
                    pobj = pobj.gaps[i];
                    break;
                case 's':
                    pobj = pobj.steps[i];
                    break;
                }
            }
            if(!pobj) {
                throw(new Numbas.Error('scorm.no part suspend data'));
            }
            var id = this.getPartId( part );
            var index = this.partIndices[id];
            var sc = this;
            function get(key) { return sc.get('interactions.'+index+'.'+key); };
            pobj.answer = get('learner_response');
            var typeStorage = this.getPartStorage(part);
            if(typeStorage) {
                var studentAnswer = typeStorage.load(part, pobj);
                if(studentAnswer!==undefined) {
                    pobj.studentAnswer = studentAnswer;
                }
            }
            return pobj;
        } catch(e) {
            throw(new Numbas.Error('scorm.error loading part',{part:Numbas.util.nicePartName(part.path),message:e.message}));
        }
    },
    /** Record duration of the current session
     */
    setSessionTime: function()
    {
        var timeSpent = new Date(this.exam.timeSpent*1000);
        var sessionTime = 'PT'+timeSpent.getHours()+'H'+timeSpent.getMinutes()+'M'+timeSpent.getSeconds()+'S';
        this.set('session_time',sessionTime);
    },
    /** Call this when the exam is started (when {@link Numbas.Exam#begin} runs, not when the page loads) */
    start: function()
    {
        this.set('completion_status','incomplete');
    },
    /** Call this when the exam is paused ({@link Numbas.Exam#pause}) */
    pause: function()
    {
        this.setSuspendData();
    },
    /** Call this when the exam is resumed ({@link Numbas.Exam#resume}) */
    resume: function() {},
    /** Call this when the exam ends ({@link Numbas.Exam#end}) */
    end: function()
    {
        this.setSessionTime();
        this.setSuspendData();
        this.set('success_status',this.exam.passed ? 'passed' : 'failed');
        this.set('completion_status','completed');
        pipwerks.SCORM.quit();
    },
    /** Get the student's ID
     * @returns {String}
     */
    getStudentID: function() {
        var id = this.get('learner_id');
        return id || null;
    },
    /** Get entry state: `ab-initio`, or `resume`
     * @returns {String}
     */
    getEntry: function()
    {
        return this.get('entry');
    },
    /** Get viewing mode:
     *
     * * `browse` - see exam info, not questions
     * * `normal` - sit exam
     * * `review` - look at completed exam
     * @returns {String}
     */
    getMode: function()
    {
        return this.get('mode');
    },
    /** Call this when the student moves to a different question
     * @param {Numbas.Question} question
     */
    changeQuestion: function(question)
    {
        this.set('location',question.number);    //set bookmark
        this.setSuspendData();    //because currentQuestion.visited has changed
    },
    /** Call this when a part is answered
     * @param {Numbas.parts.Part} part
     */
    partAnswered: function(part)
    {
        var id = this.getPartId(part);
        var index = this.partIndices[id];
        var prepath = 'interactions.'+index+'.';
        this.set(prepath+'result',part.score);
        if(part.answered) {
            var typeStorage = this.getPartStorage(part);
            if(typeStorage) {
                var answer = typeStorage.student_answer(part,this);
                this.set(prepath+'learner_response', answer+'');
            }
        } else {
            this.set(prepath+'learner_response', '');
        }
        this.setSuspendData();
    },
    /** Save exam-level details (just score at the mo)
     * @param {Numbas.Exam} exam
     */
    saveExam: function(exam)
    {
        if(exam.loading)
            return;
        //update total exam score and so on
        this.set('score.raw',exam.score);
        this.set('score.scaled',(exam.mark > 0 ? exam.score/exam.mark : 0) || 0);
    },
    /** Save details about a question - save score and success status
     * @param {Numbas.Question} question
     */
    saveQuestion: function(question)
    {
        if(question.exam.loading)
            return;
        var id = this.getQuestionId(question);
        if(!(id in this.questionIndices))
            return;
        var index = this.questionIndices[id];
        var prepath = 'objectives.'+index+'.';
        this.set(prepath+'score.raw',question.score);
        this.set(prepath+'score.scaled',(question.marks > 0 ? question.score/question.marks : 0) || 0);
        this.set(prepath+'success_status', question.score==question.marks ? 'passed' : 'failed' );
        this.set(prepath+'completion_status', question.answered ? 'completed' : 'incomplete' );
    },
    /** Record that a question has been submitted
     * @param {Numbas.Question} question
     */
    questionSubmitted: function(question)
    {
        this.save();
    },
    /** Record that the student displayed question advice
     * @param {Numbas.Question} question
     */
    adviceDisplayed: function(question)
    {
        this.setSuspendData();
    },
    /** Record that the student revealed the answers to a question
     * @param {Numbas.Question} question
     */
    answerRevealed: function(question)
    {
        this.setSuspendData();
        this.save();
    },
    /** Record that the student showed the steps for a part
     * @param {Numbas.parts.Part} part
     */
    stepsShown: function(part)
    {
        this.setSuspendData();
        this.save();
    },
    /** Record that the student hid the steps for a part
     * @param {Numbas.parts.Part} part
     */
    stepsHidden: function(part)
    {
        this.setSuspendData();
        this.save();
    }
};
scorm.partTypeStorage = {
    'information': {
        interaction_type: function() {return 'other';},
        correct_answer: function() {},
        student_answer: function() {},
        suspend_data: function() {},
        load: function() {}
    },
    'extension': {
        interaction_type: function() {return 'other';},
        correct_answer: function() {},
        student_answer: function() {},
        suspend_data: function(part) {
            return {extension_data: part.createSuspendData()};
        },
        load: function() {}
    },
    '1_n_2': {
        interaction_type: function() {return 'choice';},
        correct_answer: function(part) {
            for(var i=0;i<part.numAnswers;i++) {
                if(part.settings.maxMatrix[i][0]) {
                    return i+'';
                }
            }
        },
        student_answer: function(part) {
            var choices = [];
            for(var i=0;i<part.numAnswers;i++) {
                if(part.ticks[i][0]) {
                    return i+'';
                }
            }
        },
        suspend_data: function(part) {
            return {shuffleAnswers: Numbas.math.inverse(part.shuffleAnswers)};
        },
        load: function(part, data) {
            var ticks = [];
            var tick = parseInt(data.answer,10);
            for(var i=0;i<part.numAnswers;i++) {
                ticks.push([i==tick]);
            }
            return ticks;
        }
    },
    'm_n_2': {
        interaction_type: function(part) {return 'choice';},
        correct_answer: function(part) {
            var good_choices = [];
            for(var i=0;i<part.numAnswers;i++) {
                if(part.settings.maxMatrix[i][0]) {
                    good_choices.push(i);
                }
            }
            return good_choices.join('[,]');
        },
        student_answer: function(part) {
            var choices = [];
            for(var i=0;i<part.numAnswers;i++) {
                if(part.ticks[i][0]) {
                    choices.push(i);
                }
            }
            return choices.join('[,]');
        },
        suspend_data: function(part) {
            return {shuffleAnswers: Numbas.math.inverse(part.shuffleAnswers)};
        },
        load: function(part, data) {
            var ticks = [];
            for(var i=0;i<part.numAnswers;i++) {
                ticks.push([false]);
            }
            data.answer.split('[,]').forEach(function(tickstr) {
                var tick = parseInt(tickstr,10);
                if(!isNaN(tick)) {
                    ticks[tick][0] = true;
                }
            });
            return ticks;
        }
    },
    'm_n_x': {
        interaction_type: function(part) {return 'matching';},
        correct_answer: function(part) {
            var good_choices = [];
            for(var i=0;i<part.settings.maxMatrix.length;i++) {
                for(var j=0;j<part.settings.maxMatrix[i].length;j++) {
                    if(part.settings.maxMatrix[i][j]) {
                        good_choices.push(i+'[.]'+j);
                    }
                }
            }
            return good_choices.join('[,]');
        },
        student_answer: function(part) {
            var choices = [];
            for(var i=0;i<part.numAnswers;i++) {
                for( var j=0;j<part.numChoices;j++ ) {
                    if(part.ticks[i][j]) {
                        choices.push(i+'[.]'+j);
                    }
                }
            }
            return choices.join('[,]');
        },
        suspend_data: function(part) {
            return {
                shuffleAnswers: Numbas.math.inverse(part.shuffleAnswers),
                shuffleChoices: Numbas.math.inverse(part.shuffleChoices)
            };
        },
        load: function(part, data) {
            var ticks = [];
            for(var i=0;i<part.numAnswers;i++) {
                var row = [];
                ticks.push(row);
                for(var j=0;j<part.numChoices;j++) {
                    row.push(false);
                }
            }
            var tick_re=/(\d+)\[\.\](\d+)/;
            var bits = data.answer.split('[,]');
            for(var i=0;i<bits.length;i++) {
                var m = bits[i].match(tick_re);
                if(m) {
                    var x = parseInt(m[1],10);
                    var y = parseInt(m[2],10);
                    ticks[x][y] = true;
                }
            }
            return ticks;
        }
    },
    'numberentry': {
        interaction_type: function(part) {return 'fill-in';},
        correct_answer: function(part) {
            return Numbas.math.niceNumber(part.settings.minvalue)+'[:]'+Numbas.math.niceNumber(part.settings.maxvalue);
        },
        student_answer: function(part) {
            return part.studentAnswer;
        },
        suspend_data: function() {},
        load: function(part, data) { return data.answer || ''; }
    },
    'matrix': {
        interaction_type: function(part) {return 'fill-in';},
        correct_answer: function(part) {
            return '{case_matters=false}'+JSON.stringify(part.settings.correctAnswer);
        },
        student_answer: function(part) {
            return JSON.stringify({
                rows: part.studentAnswerRows,
                columns: part.studentAnswerColumns,
                matrix: part.studentAnswer
            });
        },
        suspend_data: function() {},
        load: function(part, data) {
            if(data.answer) {
                return JSON.parse(data.answer);
            }
        }
    },
    'patternmatch': {
        interaction_type: function(part) {return 'fill-in';},
        correct_answer: function(part) {
            return '{case_matters='+part.settings.caseSensitive+'}'+part.settings.correctAnswer;
        },
        student_answer: function(part) { return part.studentAnswer; },
        suspend_data: function() {},
        load: function(part, data) { return data.answer || ''; }
    },
    'jme': {
        interaction_type: function(part) {return 'fill-in';},
        correct_answer: function(part) {
            return '{case_matters=false}'+part.settings.correctAnswer;
        },
        student_answer: function(part) { return part.studentAnswer; },
        suspend_data: function() {},
        load: function(part, data) { return data.answer || ''; }
    },
    'gapfill': {
        interaction_type: function(part) {return 'other';},
        correct_answer: function(part) {},
        student_answer: function(part) {},
        suspend_data: function(part, store) {
            var gapSuspendData = part.gaps.map(function(gap) {
                return store.partSuspendData(gap);
            });
            return {gaps: gapSuspendData};
        },
        load: function(part) {}
    },
    'custom': {
        interaction_type: function(part) {
            var widget = part.input_widget();
            var storage = scorm.inputWidgetStorage[widget];
            if(storage) {
                return storage.interaction_type(part);
            } else {
                return 'other';
            }
        },
        correct_answer: function(part) {
            var widget = part.input_widget();
            var storage = scorm.inputWidgetStorage[widget];
            if(storage) {
                return storage.correct_answer(part);
            }
        },
        student_answer: function(part) {
            var widget = part.input_widget();
            var storage = scorm.inputWidgetStorage[widget];
            if(storage) {
                return storage.student_answer(part);
            }
        },
        suspend_data: function() {},
        load: function(part, data) {
            var widget = part.input_widget();
            var storage = scorm.inputWidgetStorage[widget];
            if(storage) {
                return storage.load(part,data);
            }
      }
    }
};
scorm.inputWidgetStorage = {
    'string': {
        interaction_type: function(part) { return 'fill-in'; },
        correct_answer: function(part) { return part.input_options().correctAnswer; },
        student_answer: function(part) { return part.studentAnswer; },
        load: function(part, data) { return data.answer; }
    },
    'number': {
        interaction_type: function(part) { return 'fill-in'; },
        correct_answer: function(part) { return Numbas.math.niceNumber(part.input_options().correctAnswer); },
        student_answer: function(part) { return Numbas.math.niceNumber(part.studentAnswer); },
        load: function(part, data) { return Numbas.util.parseNumber(data.answer, part.input_options().allowFractions, part.input_options().allowedNotationStyles); }
    },
    'jme': {
        interaction_type: function(part) { return 'fill-in'; },
        correct_answer: function(part) { return Numbas.jme.display.treeToJME(part.input_options().correctAnswer); },
        student_answer: function(part) { return Numbas.jme.display.treeToJME(part.studentAnswer); },
        load: function(part, data) { return Numbas.jme.compile(data.answer); }
    },
    'matrix': {
        interaction_type: function(part) { return 'fill-in'; },
        correct_answer: function(part) { return JSON.stringify(part.input_options().correctAnswer); },
        student_answer: function(part) { return JSON.stringify(part.studentAnswer); },
        load: function(part, data) {
            try {
                var m = JSON.parse(data.answer);
                m.rows = m.length;
                m.columns = m.length>0 ? m[0].length : 0;
                return m;
            } catch(e) {
                return undefined;
            }
        }
    },
    'radios': {
        interaction_type: function(part) { return 'choice'; },
        correct_answer: function(part) { return part.input_options().correctAnswer+''; },
        student_answer: function(part) { return part.studentAnswer+''; },
        load: function(part, data) { return parseInt(data.answer,10); }
    },
    'checkboxes': {
        interaction_type: function(part) { return 'choice'; },
        correct_answer: function(part) {
            var good_choices = [];
            part.input_options().correctAnswer.forEach(function(c,i) {
                if(c) {
                    good_choices.push(i);
                }
            });
            return good_choices.join('[,]');
        },
        student_answer: function(part) {
            var ticked = [];
            part.studentAnswer.forEach(function(c,i) {
                if(c) {
                    ticked.push(i);
                }
            });
            return ticked.join('[,]');
        },
        load: function(part, data) {
            var ticked = part.input_options().choices.map(function(c){ return false; });
            data.answer.split('[,]').forEach(function(c){ var i = parseInt(c,10); ticked[i] = true; });
            return ticked;
        }
    },
    'dropdown': {
        interaction_type: function(part) { return 'choice'; },
        correct_answer: function(part) { return part.input_options().correctAnswer+''; },
        student_answer: function(part) { return part.studentAnswer+''; },
        load: function(part, data) { return parseInt(data.answer,10); }
    }
}
});

﻿Numbas.queueScript('seedrandom',[],function(module) {
// seedrandom.js version 2.0.
// Author: David Bau 4/2/2011
//
// Defines a method Math.seedrandom() that, when called, substitutes
// an explicitly seeded RC4-based algorithm for Math.random().  Also
// supports automatic seeding from local or network sources of entropy.
//
// Usage:
//
//   <script src=http://davidbau.com/encode/seedrandom-min.js></script>
//
//   Math.seedrandom('yipee'); Sets Math.random to a function that is
//                             initialized using the given explicit seed.
//
//   Math.seedrandom();        Sets Math.random to a function that is
//                             seeded using the current time, dom state,
//                             and other accumulated local entropy.
//                             The generated seed string is returned.
//
//   Math.seedrandom('yowza', true);
//                             Seeds using the given explicit seed mixed
//                             together with accumulated entropy.
//
//   <script src="http://bit.ly/srandom-512"></script>
//                             Seeds using physical random bits downloaded
//                             from random.org.
//
//   <script src="https://jsonlib.appspot.com/urandom?callback=Math.seedrandom">
//   </script>                 Seeds using urandom bits from call.jsonlib.com,
//                             which is faster than random.org.
//
// Examples:
//
//   Math.seedrandom("hello");            // Use "hello" as the seed.
//   document.write(Math.random());       // Always 0.5463663768140734
//   document.write(Math.random());       // Always 0.43973793770592234
//   var rng1 = Math.random;              // Remember the current prng.
//
//   var autoseed = Math.seedrandom();    // New prng with an automatic seed.
//   document.write(Math.random());       // Pretty much unpredictable.
//
//   Math.random = rng1;                  // Continue "hello" prng sequence.
//   document.write(Math.random());       // Always 0.554769432473455
//
//   Math.seedrandom(autoseed);           // Restart at the previous seed.
//   document.write(Math.random());       // Repeat the 'unpredictable' value.
//
// Notes:
//
// Each time seedrandom('arg') is called, entropy from the passed seed
// is accumulated in a pool to help generate future seeds for the
// zero-argument form of Math.seedrandom, so entropy can be injected over
// time by calling seedrandom with explicit data repeatedly.
//
// On speed - This javascript implementation of Math.random() is about
// 3-10x slower than the built-in Math.random() because it is not native
// code, but this is typically fast enough anyway.  Seeding is more expensive,
// especially if you use auto-seeding.  Some details (timings on Chrome 4):
//
// Our Math.random()            - avg less than 0.002 milliseconds per call
// seedrandom('explicit')       - avg less than 0.5 milliseconds per call
// seedrandom('explicit', true) - avg less than 2 milliseconds per call
// seedrandom()                 - avg about 38 milliseconds per call
//
// LICENSE (BSD):
//
// Copyright 2010 David Bau, all rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//   1. Redistributions of source code must retain the above copyright
//      notice, this list of conditions and the following disclaimer.
//
//   2. Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
//
//   3. Neither the name of this module nor the names of its contributors may
//      be used to endorse or promote products derived from this software
//      without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
/**
 * All code is in an anonymous closure to keep the global namespace clean.
 *
 * @param {number=} overflow
 * @param {number=} startdenom
 */
(function (pool, math, width, chunks, significance, overflow, startdenom) {
//
// seedrandom()
// This is the seedrandom function described above.
//
math['seedrandom'] = function seedrandom(seed, use_entropy) {
  var key = [];
  var arc4;
  // Flatten the seed string or build one from local entropy if needed.
  seed = mixkey(flatten(
    use_entropy ? [seed, pool] :
    arguments.length ? seed :
    [new Date().getTime(), pool, window], 3), key);
  // Use the seed to initialize an ARC4 generator.
  arc4 = new ARC4(key);
  // Mix the randomness into accumulated entropy.
  mixkey(arc4.S, pool);
  // Override Math.random
  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.
  math['random'] = function random() {  // Closure to return a random double:
    var n = arc4.g(chunks);             // Start with a numerator n < 2 ^ 48
    var d = startdenom;                 //   and denominator d = 2 ^ 48.
    var x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };
  // Return the seed that was used
  return seed;
};
//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
/** @constructor */
function ARC4(key) {
  var t, u, me = this, keylen = key.length;
  var i = 0, j = me.i = me.j = me.m = 0;
  me.S = [];
  me.c = [];
  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }
  // Set up S using the standard key scheduling algorithm.
  while (i < width) { me.S[i] = i++; }
  for (i = 0; i < width; i++) {
    t = me.S[i];
    j = lowbits(j + t + key[i % keylen]);
    u = me.S[j];
    me.S[i] = u;
    me.S[j] = t;
  }
  // The "g" method returns the next (count) outputs as one number.
  me.g = function getnext(count) {
    var s = me.S;
    var i = lowbits(me.i + 1); var t = s[i];
    var j = lowbits(me.j + t); var u = s[j];
    s[i] = u;
    s[j] = t;
    var r = s[lowbits(t + u)];
    while (--count) {
      i = lowbits(i + 1); t = s[i];
      j = lowbits(j + t); u = s[j];
      s[i] = u;
      s[j] = t;
      r = r * width + s[lowbits(t + u)];
    }
    me.i = i;
    me.j = j;
    return r;
  };
  // For robust unpredictability discard an initial batch of values.
  // See http://www.rsa.com/rsalabs/node.asp?id=2009
  me.g(width);
}
//
// flatten()
// Converts an object tree to nested arrays of strings.
//
/** @param {Object=} result
  * @param {string=} prop
  * @param {string=} typ */
function flatten(obj, depth, result, prop, typ) {
  result = [];
  typ = typeof(obj);
  if (depth && typ == 'object') {
    for (prop in obj) {
      if (prop.indexOf('S') < 5) {    // Avoid FF3 bug (local/sessionStorage)
        try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
      }
    }
  }
  return (result.length ? result : obj + (typ != 'string' ? '\0' : ''));
}
//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
/** @param {number=} smear
  * @param {number=} j */
function mixkey(seed, key, smear, j) {
  seed += '';                         // Ensure the seed is a string
  smear = 0;
  for (j = 0; j < seed.length; j++) {
    key[lowbits(j)] =
      lowbits((smear ^= key[lowbits(j)] * 19) + seed.charCodeAt(j));
  }
  seed = '';
  for (j in key) { seed += String.fromCharCode(key[j]); }
  return seed;
}
//
// lowbits()
// A quick "n mod width" for width a power of 2.
//
function lowbits(n) { return n & (width - 1); }
//
// The following constants are related to IEEE 754 limits.
//
startdenom = math.pow(width, chunks);
significance = math.pow(2, significance);
overflow = significance * 2;
//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to intefere with determinstic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);
// End anonymous scope, and pass initial values.
})(
  [],   // pool: entropy pool starts empty
  Math, // math: package containing random, pow, and seedrandom
  256,  // width: each RC4 output is 0 <= x < 256
  6,    // chunks: at least six RC4 outputs for each double
  52    // significance: there are 52 significant digits in a double
);
});
﻿/*
Copyright 2011-14 Newcastle University
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/** @file Start the exam */
// 'base' gives the third-party libraries on which Numbas depends
Numbas.queueScript('base',['jquery','localisation','seedrandom','knockout','sarissa','es6-promise'],function() {
});
Numbas.queueScript('start-exam',['base','exam','settings'],function() {
    for(var name in Numbas.custom_part_types) {
        Numbas.partConstructors[name] = Numbas.parts.CustomPart;
    };
    /**
     * Initialise the exam:
     *
     * - Connect to the LMS, which might have saved student answers
     * - Load the exam XML and the XSL templates
     * - create and initialise the exam object
     * - display the frontpage
     *
     * This function is called when all the other scripts have been loaded and executed.
     * It uses the scheduling system to make sure the browser isn't locked up when the exam is being initialised
     * @memberof Numbas
     * @method
     */
    var init = Numbas.init = function()
    {
    $(document).ready(function() {
        var seed = Math.seedrandom(new Date().getTime());
        var job = Numbas.schedule.add;
        job(Numbas.xml.loadXMLDocs);                //load in all the XML and XSLT files
        job(Numbas.display.localisePage);
        job(function()
        {
            var store = Numbas.store = new Numbas.storage.scorm.SCORMStorage();    //The storage object manages communication between the LMS and the exam
            var exam = Numbas.exam = new Numbas.Exam(store);                    //create the exam object, and load in everything from the XML
            exam.seed = Numbas.util.hashCode(seed);
            var entry = store.getEntry();
            if(store.getMode() == 'review')
                entry = 'review';
            switch(entry)
            {
            case 'ab-initio':
                job(exam.init,exam);
                exam.signals.on('ready', function() {
                    job(function() {
                            Numbas.display.init();
                    });
                    job(function() {
                        if(exam.settings.showFrontPage)
                        {
                            exam.display.showInfoPage('frontpage');
                        }
                        else
                        {
                            exam.begin();
                        }
                    });
                })
                break;
            case 'resume':
            case 'review':
                job(exam.load,exam);
                exam.signals.on('ready', function() {
                    job(Numbas.display.init);
                    job(function() {
                        if(entry == 'review')
                        {
                            job(exam.end,exam,false);
                        }
                        else if(exam.currentQuestion !== undefined)
                        {
                            job(exam.display.showInfoPage,exam.display,'suspend');
                        }
                        else
                        {
                            job(exam.display.showInfoPage,exam.display,'frontpage');
                        }
                    });
                });
                break;
            }
        });
    });
    }
});

/*
Copyright 2011-14 Newcastle University
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
Numbas.queueScript('storage',['base'],function() {
/** @namespace Numbas.storage */
/** @typedef exam_suspend_data
 * @memberof Numbas.storage
 * @property {Number} timeRemaining - Seconds until the end of the exam ({@link Numbas.Exam#timeRemaining})
 * @property {Number} duration - Length of the exam, in seconds ({@link Numbas.Exam#settings})
 * @property {Array.<Array.<Number>>} questionSubsets - The sets of questions in each question group ({@link Numbas.Exam#question_groups})
 * @property {Date} start - The time the exam was started ({@link Numbas.Exam#start})
 * @property {Number} score - The student's current score ({@link Numbas.exam#score})
 * @property {Number} currentQuestion - The index of the current question ({@link Numbas.Exam#currentQuestionNumber})
 */
/** @typedef question_suspend_data
 * @memberof Numbas.storage
 * @property {String} name - The name of the question ({@link Numbas.Question#name})
 * @property {Number} score - The student's score for this question ({@link Numbas.Question#score})
 * @property {Boolean} visited - Has the student visited this question yet? ({@link Numbas.Question#visited})
 * @property {Boolean} answered - Has the student answered this question? ({@link Numbas.Question#answered})
 * @property {Boolean} adviceDisplayed - Has the advice been displayed? ({@link Numbas.Question#adviceDisplayed})
 * @property {Boolean} revealed - Have the correct answers been revealed? ({@link Numbas.Question#revealed})
 * @property {Object.<JME>} variables - A dictionary of the values of the question variables. ({@link Numbas.Question#scope})
 * @see Numbas.storage.SCORMStorage#loadQuestion
 */
/** @typedef part_suspend_data
 * @memberof Numbas.storage
 * @property {String} answer - student's answer to the part, as encoded for saving
 * @property {Boolean} answered - has the student answered this part? ({@link Numbas.parts.Part#answered})
 * @property {Boolean} stepsShown - have the steps been shown? ({@link Numbas.parts.Part#stepsShown})
 * @property {Boolean} stepsOpen - are the steps currently visible? ({@link Numbas.parts.Part#stepsOpen})
 * @property {Array.<Numbas.storage.part_suspend_data>} gaps - data for gaps, if this is a gapfill part
 * @property {Array.<Numbas.storage.part_suspend_data>} steps - data for steps, if this part has steps
 * @property {String} studentAnswer - student's answer, for {@link Numbas.parts.JMEPart}, {@link Numbas.parts.NumberEntryPart} or {@link Numbas.parts.PatternMatchPart} parts
 * @property {Array.<Number>} shuffleChoices - order of choices, if this is a {@link Numbas.parts.MultipleResponsePart}
 * @property {Array.<Number>} shuffleAnswers - order of answers, if this is a {@link Numbas.parts.MultipleResponsePart}
 * @property {Array.<Array.<Number>>} ticks - student's choices, for {@link Numbas.parts.MultipleResponsePart} parts
 */
/** The active storage object ({@link Numbas.storage}) to be used by the exam */
Numbas.store = null;
Numbas.storage = {};
/** A blank storage object which does nothing.
 *
 * Any real storage object needs to implement all of this object's methods.
 * @memberof Numbas.storage
 * @constructor
 */
Numbas.storage.BlankStorage = function() {}
Numbas.storage.BlankStorage.prototype = /** @lends Numbas.storage.BlankStorage.prototype */ {
    /** Initialise the SCORM data model and this storage object.
     * @param {Numbas.Exam} exam
     */
    init: function(exam) {},
    /** Get suspended exam info
     * @param {Numbas.Exam} exam
     * @returns {Numbas.storage.exam_suspend_data}
     */
    load: function() {},
    /** Save SCORM data - call the SCORM commit method to make sure the data model is saved to the server/backing store */
    save: function() {
    },
    /** Get suspended info for a question
     * @param {Numbas.Question} question
     * @returns {Numbas.storage.question_suspend_data}
     */
    loadQuestion: function(questionNumber) {},
    /** Get suspended info for a part
     * @param {Numbas.parts.Part} part
     * @returns {Numbas.storage.part_suspend_data}
     */
    loadPart: function(part) {},
    /** Load a {@link Numbas.parts.JMEPart}
     * @param {Numbas.parts.Part} part
     * @returns {Numbas.storage.part_suspend_data}
     */
    loadJMEPart: function(part) {},
    /** Load a {@link Numbas.parts.PatternMatchPart}
     * @param {Numbas.parts.Part} part
     * @returns {Numbas.storage.part_suspend_data}
     */
    loadPatternMatchPart: function(part) {},
    /** Load a {@link Numbas.parts.NumberEntryPart}
     * @param {Numbas.parts.Part} part
     * @returns {Numbas.storage.part_suspend_data}
     */
    loadNumberEntryPart: function(part) {},
    /** Load a {@link Numbas.parts.MatrixEntryPart}
     * @param {Numbas.parts.Part} part
     * @returns {Numbas.storage.part_suspend_data}
     */
    loadMatrixEntryPart: function(part) {},
    /** Load a {@link Numbas.parts.MultipleResponsePart}
     * @param {Numbas.parts.Part} part
     * @returns {Numbas.storage.part_suspend_data}
     */
    loadMultipleResponsePart: function(part) {},
    /** Load a {@link Numbas.parts.ExtensionPart}
     * @param {Numbas.parts.Part} part
     * @returns {Numbas.storage.part_suspend_data}
     */
    loadExtensionPart: function(part) {},
    /** Call this when the exam is started (when {@link Numbas.Exam#begin} runs, not when the page loads) */
    start: function() {},
    /** Call this when the exam is paused ({@link Numbas.Exam#pause}) */
    pause: function() {},
    /** Call this when the exam is resumed ({@link Numbas.Exam#resume}) */
    resume: function() {},
    /** Call this when the exam ends ({@link Numbas.Exam#end}) */
    end: function() {},
    /** Get the student's ID
     * @returns {String}
     */
    getStudentID: function() {
        return '';
    },
    /** Get entry state: `ab-initio`, or `resume`
     * @returns {String}
     */
    getEntry: function() {
        return 'ab-initio';
    },
    /** Get viewing mode:
     *
     * * `browse` - see exam info, not questions
     * * `normal` - sit exam
     * * `review` - look at completed exam
     * @returns {String}
     */
    getMode: function() {},
    /** Call this when the student moves to a different question
     * @param {Numbas.Question} question
     */
    changeQuestion: function(question) {},
    /** Call this when a part is answered
     * @param {Numbas.parts.Part} part
     */
    partAnswered: function(part) {},
    /** Save exam-level details (just score at the mo)
     * @param {Numbas.Exam} exam
     */
    saveExam: function(exam) {},
    /* Save details about a question - save score and success status
     * @param {Numbas.Question} question
     */
    saveQuestion: function(question) {},
    /** Record that a question has been submitted
     * @param {Numbas.Question} question
     */
    questionSubmitted: function(question) {},
    /** Rcord that the student displayed question advice
     * @param {Numbas.Question} question
     */
    adviceDisplayed: function(question) {},
    /** Record that the student revealed the answers to a question
     * @param {Numbas.Question} question
     */
    answerRevealed: function(question) {},
    /** Record that the student showed the steps for a part
     * @param {Numbas.parts.Part} part
     */
    stepsShown: function(part) {},
    /** Record that the student hid the steps for a part
     * @param {Numbas.parts.Part} part
     */
    stepsHidden: function(part) {}
};
});

/*
Copyright 2011-14 Newcastle University
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/** @file A few functions to do with time and date, and also performance timing. Provides {@link Numbas.timing}. */
Numbas.queueScript('timing',['base'],function() {
/** @namespace Numbas.timing */
var timing = Numbas.timing = /** @lends Numbas.timing */ {
    /** Get the current date as a string in the user's locale
     * @returns {String}
     */
    displayDate: function()
    {
        return (new Date()).toLocaleDateString();
    },
    /** Convert a number of seconds to a string in `HH:MM:SS` format
     * @param {Number} time
     * @returns {String}
     */
    secsToDisplayTime: function( time )
    {
        if(time<0)
            return '-'+Numbas.timing.secsToDisplayTime(-time);
        var hours = 0;
        var minutes = 0;
        var seconds = 0;
        var remainder = time % 3600;
        hours = ( time - remainder ) / 3600;
        time = remainder;
        if (time>59)
        {
            remainder = time % 60;
            minutes = ( time - remainder ) / 60;
        }
        else
        {
            minutes = 0;
        }
        seconds = Math.floor(remainder);
        if( minutes<=9 )
        {
            minutes = "0" + minutes;
        }
        if( seconds<=9 )
        {
            seconds = "0" + seconds;
        }
        displayTime = hours + ":" + minutes + ":" + seconds;
        return displayTime;
    },
    /** A queue of timers
     * @type {Date[]}
     */
    timers: [],
    /** Timing messages - how long did each timer take?
     * @type {Array.<String>}
     */
    messages: [],
    start: function()
    {
        timing.timers.push(new Date());
    },
    /** End the top timer on the queue
     * @param {String} label - a description of the timer
     */
    end: function(label)
    {
        var s='';
        for(var i=0;i<timing.timers.length;i++){s+='   ';}
        s+=(new Date())-timing.timers.pop();
        s+=' '+label;
        timing.messages.push(s);
        if(!timing.timers.length){timing.show();}
    },
    /** Show all timing messages through {@link Numbas.debug}*/
    show: function()
    {
        for(var x in timing.accs)
        {
            Numbas.debug(timing.accs[x].total+' '+x,true);
        }
        timing.accs = {};
        for(var i=0;i<timing.messages.length;i++)
        {
            Numbas.debug(timing.messages[i],true);
        }
        timing.messages = [];
    },
    /** Stress test a function by running it a lot of times and seeing how long it takes
     * @param {function} f
     * @param {Number} times
     */
    stress: function(f,times)
    {
        timing.start();
        for(var i=0;i<times;i++)
        {
            f();
        }
        timing.end();
    },
    /** Timing accumulators
     * @see Numbas.timing.startacc
     */
    accs: {},
    /** Accumulators are for counting time spent in functions which don't take long to evaluate, but are called repeatedly.
     *
     * Call this with the function's name when you start the function, and {@link Numbas.timing.endacc} with the same name just before returning a value.
     *
     * It copes with recursion automatically, so you don't need to worry about double counting
     * @param {String} name
     */
    startacc: function(name)
    {
        if(timing.accs[name]==undefined)
        {
            timing.accs[name] = {
                total: 0,
                go: 0
            }
        }
        var acc = timing.accs[name];
        acc.go+=1;
        if(acc.go>1) { return; }
        acc.start = new Date();
    },
    /** Stop accumulating runtime for a function
     * @param {String} name
     * @see Numbas.timing.startacc
     */
    endacc: function(name)
    {
        var acc = timing.accs[name];
        if(!acc)
            throw(new Numbas.Error('timing.no accumulator',{name:name}));
        acc.go -= 1;
        if(acc.go==0)
        {
            var end = new Date();
            acc.total += (end - acc.start);
        }
    }
};
});
/*
Copyright 2011-14 Newcastle University
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/** @file Convenience functions, extensions to javascript built-ins, etc. Provides {@link Numbas.util}. Includes es5-shim.js */
Numbas.queueScript('util',['base','math'],function() {
/** @namespace Numbas.util */
var util = Numbas.util = /** @lends Numbas.util */ {
    /** Derive type B from A (class inheritance, really)
     *
     * B's prototype supercedes A's.
     * @param {function} a - the constructor for the parent class
     * @param {function} b - a constructor to be called after `a`'s constructor is done.
     * @returns {function} a constructor for the derived class
     */
    extend: function(a,b,extendMethods)
    {
        var c = function()
        {
            a.apply(this,arguments);
            b.apply(this,arguments);
        };
        var x;
        for(x in a.prototype)
        {
            c.prototype[x]=a.prototype[x];
        }
        for(x in b.prototype)
        {
            c.prototype[x]=b.prototype[x];
        }
        if(extendMethods)
        {
            for(x in a.prototype)
            {
                if(typeof(a.prototype[x])=='function' && b.prototype[x])
                    c.prototype[x]=Numbas.util.extend(a.prototype[x],b.prototype[x]);
            }
        }
        return c;
    },
    /** Extend `destination` with all the properties from subsequent arguments.
     * `undefined` values are not copied over.
     * Replacement for jQuery.extend. Modified from https://stackoverflow.com/a/11197343
     * Object.assign doesn't behave the same way - it copies over `undefined`.
     * @param {Object} destination
     * @param {Object} others*
     * @returns {Object}
     */
    extend_object: function(destination) {
        for(var i=1; i<arguments.length; i++) {
            for(var key in arguments[i]) {
                if(arguments[i].hasOwnProperty(key) && arguments[i][key]!==undefined) {
                    destination[key] = arguments[i][key];
                }
            }
        }
        return destination;
    },
    /** Clone an array, with array elements copied too.
     * Array.splice() will create a copy of an array, but the elements are the same objects, which can cause fruity bugs.
     * This function clones the array elements as well, so there should be no side-effects when operating on the cloned array.
     * @param {Array} arr
     * @param {Boolean} deep - if true, do a deep copy of each element
     * @see Numbas.util.copyobj
     * @returns {Array}
     */
    copyarray: function(arr,deep)
    {
        arr = arr.slice();
        if(deep)
        {
            for(var i=0;i<arr.length;i++)
            {
                arr[i]=util.copyobj(arr[i],deep);
            }
        }
        return arr;
    },
    /** Clone an object.
     * @param {Object} obj
     * @param {Boolean} deep - if true, each property is cloned as well (recursively) so there should be no side-effects when operating on the cloned object.
     * @returns {Object}
     */
    copyobj: function(obj,deep)
    {
        switch(typeof(obj))
        {
        case 'object':
            if(obj===null)
                return obj;
            if(obj.length!==undefined)
            {
                return util.copyarray(obj,deep);
            }
            else
            {
                var newobj={};
                for(var x in obj)
                {
                    if(deep)
                        newobj[x] = util.copyobj(obj[x],deep);
                    else
                        newobj[x]=obj[x];
                }
                return newobj;
            }
        default:
            return obj;
        }
    },
    /** Shallow copy an object into an already existing object
     * (add all src's properties to dest)
     * @param {Object} src
     * @param {Object} dest
     */
    copyinto: function(src,dest)
    {
        for(var x in src)
        {
            if(dest[x]===undefined)
                dest[x]=src[x]
        }
    },
    /** Generic equality test on {@link Numbas.jme.token}s
     * @param {Numbas.jme.token} a
     * @param {Numbas.jme.token} b
     * @see Numbas.util.equalityTests
     * @returns {Boolean}
     */
    eq: function(a,b) {
        if(a.type != b.type)
            return false;
        if(a.type in util.equalityTests) {
            return util.equalityTests[a.type](a,b);
        } else {
            throw(new Numbas.Error('util.equality not defined for type',{type:a.type}));
        }
    },

    /** Functions to decide if two tokens of the same type are equal.
     * Dictionary mapping token type name to function.
     * @see Numbas.util.eq
     */
    equalityTests: {
        'nothing': function(a,b) {
            return true;
        },
        'number': function(a,b) {
            return Numbas.math.eq(a.value,b.value);
        },
        'vector': function(a,b) {
            return Numbas.vectormath.eq(a.value,b.value);
        },
        'matrix': function(a,b) {
            return Numbas.matrixmath.eq(a.value,b.value);
        },
        'list': function(a,b) {
            return a.value.length==b.value.length && a.value.filter(function(ae,i){return !util.eq(ae,b.value[i])}).length==0;
        },
        'set': function(a,b) {
            return Numbas.setmath.eq(a.value,b.value);
        },
        'range': function(a,b) {
            return a.value[0]==b.value[0] && a.value[1]==b.value[1] && a.value[2]==b.value[2];
        },
        'name': function(a,b) {
            return a.name.toLowerCase() == b.name.toLowerCase();
        },
        'string': function(a,b) {
            return a.value==b.value;
        },
        'boolean': function(a,b) {
            return a.value==b.value;
        }
    },
    /** Generic inequality test on {@link Numbas.jme.token}s
     * @param {Numbas.jme.token} a
     * @param {Numbas.jme.token} b
     * @returns {Boolean}
     * @see Numbas.util.eq
     */
    neq: function(a,b) {
        return !util.eq(a,b);
    },
    objects_equal: function(a,b) {
        if(typeof(a)!=typeof(b)) {
            return false;
        }
        if(typeof(a)=='object') {
            if(a===null || b===null) {
                return a===b;
            }
            if(Array.isArray(a) && Array.isArray(b)) {
                return util.arraysEqual(a,b);
            } else {
                return Object.keys(a).every(function(k){ return util.objects_equal(a[k],b[k]) }) && Object.keys(b).every(function(k){ return a.hasOwnProperty(k); });
            }
        }
        return a==b;
    },
    /** Are two arrays equal? True if their elements are all equal
     * @param {Array} a
     * @param {Array} b
     * @returns {Boolean}
     */
    arraysEqual: function(a,b) {
        if(!Array.isArray(a) || !Array.isArray(b)) {
            return false;
        }
        if(a.length!=b.length) {
            return false;
        }
        var l = a.length;
        for(var i=0;i<l;i++) {
            if(Array.isArray(a[i])) {
                if(!Array.isArray(b[i])) {
                    return false;
                } else if(!util.arraysEqual(a[i],b[i])) {
                    return false;
                }
            } else {
                if(!util.objects_equal(a[i],b[i])) {
                    return false;
                }
            }
        }
        return true;
    },
    /** Filter out values in `exclude` from `list`
     * @param {Numbas.jme.types.TList} list
     * @param {Numbas.jme.types.TList} exclude
     * @returns {Array}
     */
    except: function(list,exclude) {
        return list.filter(function(l) {
            for(var i=0;i<exclude.length;i++) {
                if(util.eq(l,exclude[i]))
                    return false;
            }
            return true;
        });
    },
    /** Return a copy of the input list with duplicates removed
     * @param {Array} list
     * @returns {Array}
     * @see Numbas.util.eq
     */
    distinct: function(list) {
        if(list.length==0) {
            return [];
        }
        var out = [list[0]];
        for(var i=1;i<list.length;i++) {
            var got = false;
            for(var j=0;j<out.length;j++) {
                if(util.eq(list[i],out[j])) {
                    got = true;
                    break;
                }
            }
            if(!got) {
                out.push(list[i]);
            }
        }
        return out;
    },
    /** Is value in the list?
     * @param {Array} list
     * @param {Numbas.jme.token} value
     * @returns {Boolean}
     */
    contains: function(list,value) {
        for(var i=0;i<list.length;i++) {
            if(util.eq(value,list[i])) {
                return true;
            }
        }
        return false;
    },
    /** Test if parameter is an integer
     * @param {Object} i
     * @returns {Boolean}
     */
    isInt: function(i)
    {
        return parseInt(i,10)==i;
    },
    /** Test if parameter is a float
     * @param {Object} f
     * @returns {Boolean}
     */
    isFloat: function(f)
    {
        return parseFloat(f)==f;
    },
    /** Test if parameter is a fraction
     * @param {String} s
     * @returns {Boolean}
     */
    isFraction: function(s) {
        s = s.toString().trim();
        return util.re_fraction.test(s);
    },
    /** Is `n`a number? i.e. `!isNaN(n)`, or is `n` "infinity", or if `allowFractions` is true, is `n` a fraction?
     *
     * If `styles` is given, try to put the number in standard form if it matches any of the given styles.
     * @param {Number|String} n
     * @param {Boolean} allowFractions
     * @param {String|Array.<String>} styles - styles of notation to allow.
     * @param {Boolean} strictStyle - if false or not given, strings which do not match any of the allowed styles but are valid JavaScript number literals will be allowed. If true, these strings will return false.
     * @see Numbas.util.cleanNumber
     * @returns {Boolean}
     */
    isNumber: function(n,allowFractions,styles,strictStyle) {
        if(n===undefined || n===null) {
            return false;
        }
        if(allowFractions && util.re_fraction.test(n)) {
            return true;
        }
        n = util.cleanNumber(n,styles,strictStyle);
        if(!isNaN(n)) {
            return true;
        }
        if(/-?infinity/i.test(n)) {
            return true;
        } else {
            return false;
        }
    },
    /** Wrap a list index so -1 maps to length-1
     * @param {Number} n
     * @param {Number} size
     * @returns {Number}
     */
    wrapListIndex: function(n,size) {
        if(n<0) {
            n += size;
        }
        return n;
    },
    /** Test if parameter is a boolean - that is: a boolean literal, or any of the strings 'false','true','yes','no', case-insensitive.
     * @param {Object} b
     * @returns {Boolean}
     */
    isBool: function(b)
    {
        if(b==null) { return false; }
        if(typeof(b)=='boolean') { return true; }
        b = b.toString().toLowerCase();
        return b=='false' || b=='true' || b=='yes' || b=='no';
    },
    /** Parse a string as HTML, and return true only if it contains non-whitespace text
     * @param {String} html
     * @returns {Boolean}
     */
    isNonemptyHTML: function(html) {
        var d = document.createElement('div');
        d.innerHTML = html;
        return $(d).text().trim().length>0;
    },
    /** Parse parameter as a boolean. The boolean value `true` and the strings 'true' and 'yes' are parsed as the value `true`, everything else is `false`.
     * @param {Object} b
     * @returns {Boolean}
     */
    parseBool: function(b)
    {
        if(!b)
            return false;
        b = b.toString().toLowerCase();
        return( b=='true' || b=='yes' );
    },
    /** Regular expression recognising a fraction */
    re_fraction: /^\s*(-?)\s*(\d+)\s*\/\s*(\d+)\s*/,
    /** Create a function `(integer,decimal) -> string` which formats a number according to the given punctuation.
     * @param {String} thousands - the string used to separate powers of 1000
     * @param {String} decimal_mark - the decimal mark character
     * @param {Boolean} separate_decimal=false - should the `thousands` separator be used to separate negative powers of 1000 (that is, groups of 3 digits after the decimal point)?
     * @returns {function}
     */
    standardNumberFormatter: function(thousands, decimal_mark, separate_decimal) {
        return function(integer,decimal) {
            var s = util.separateThousands(integer,thousands);
            if(decimal) {
                var o = '';
                if(separate_decimal) {
                    for(var i=0;i<decimal.length;i+=3) {
                        o += (o ? thousands : '')+decimal.slice(i,i+3);
                    }
                } else {
                    o = decimal;
                }
                s += decimal_mark+o;
            }
            return s;
        }
    },

    /** Try to match a string representing a number in any of the given styles at the start of the given string, and return both the matched text and a JavaScript number literal equivalent.
     *
     * @param {String} s - the string potentially representing a number.
     * @param {String|String[]} styles - styles of notation to allow, e.g. `['en','si-en']`
     * @param {Boolean} [strictStyle] - if false or not given, strings which do not match any of the allowed styles but are valid JavaScript number literals will be allowed. If true, these strings will return 'NaN'.
     * @param {Boolean} [mustMatchAll] - if true, then the string must contain only the matched number.
     * @returns {Object|null} - `{matched, cleaned}` or `null`
     *
     * @see Numbas.util.numberNotationStyles
     */
    matchNotationStyle: function(s,styles,strictStyle,mustMatchAll) {
        var pos = 0;
        s = s.toString();
        var match_neg = /^\s*(-)?\s*/.exec(s);
        var minus = match_neg[1] || '';
        pos += match_neg[0].length;

        var matched = false;
        var cleaned = s;
        var bestpos = pos;
        if(styles!==undefined) {
            if(typeof styles=='string') {
                styles = [styles];
            }
            for(var i=0,l=styles.length;i<l;i++) {
                var style = util.numberNotationStyles[styles[i]];
                if(!style) {
                    continue;
                }
                var re = style.re;
                var m;
                if(re && (m=re.exec(s.slice(pos))) && (!mustMatchAll || s.slice(pos+m[0].length).trim()=='')) {
                    matched = true;
                    var integer = m[1].replace(/\D/g,'');
                    var mcleaned;
                    if(m[2]) {
                        var decimal = m[2].replace(/\D/g,'');
                        mcleaned = minus + integer + '.' + decimal
                    } else {
                        mcleaned = minus + integer;
                    }
                    var mpos = pos + m[0].length;
                    if(mpos > bestpos) {
                        bestpos = mpos;
                        cleaned = mcleaned;
                    }
                }
            }
        }
        pos = bestpos;
        if(strictStyle && !matched) {
            cleaned = 'NaN';
        }
        return {
            matched: matched ? s.slice(0,pos) : '',
            cleaned: cleaned
        }
    },

    /** Clean a string potentially representing a number.
     * Remove space, and then try to identify a notation style.
     *
     * If `styles` is given, `s` will be tested against the given styles. If it matches, the string will be rewritten using the matched integer and decimal parts, with punctuation removed and the decimal point changed to a dot.
     *
     * @param {String} s - the string potentially representing a number.
     * @param {String|String[]} styles - styles of notation to allow, e.g. `['en','si-en']`
     * @param {Boolean} [strictStyle] - if false or not given, strings which do not match any of the allowed styles but are valid JavaScript number literals will be allowed. If true, these strings will return 'NaN'.
     * @returns {String}
     *
     * @see Numbas.util.numberNotationStyles
     */
    cleanNumber: function(s,styles,strictStyle) {
        var result = util.matchNotationStyle(s,styles,strictStyle,true);
        return result.cleaned;
    },
    /** Parse a number - either parseFloat, or parse a fraction.
     * @param {String} s
     * @param {Boolean} allowFractions - are fractions of the form `a/b` (`a` and `b` integers without punctuation) allowed?
     * @param {String|String[]} styles - styles of notation to allow.
     * @param {Boolean} strictStyle - if false or not given, strings which do not match any of the allowed styles but are valid JavaScript number literals will be allowed. If true, these strings will return NaN.
     * @see Numbas.util.cleanNumber
     * @returns {Number}
     */
    parseNumber: function(s,allowFractions,styles,strictStyle) {
        var cleaned_s = util.cleanNumber(s,styles,strictStyle);
        var m;
        if(util.isFloat(cleaned_s)) {
            return parseFloat(cleaned_s);
        } else if(s.toLowerCase()=='infinity') {
            return Infinity;
        } else if(s.toLowerCase()=='-infinity') {
            return -Infinity;
        } else if(allowFractions && (m = util.parseFraction(s))) {
            return m.numerator/m.denominator;
        } else {
            return NaN;
        }
    },
    /** A fraction
     * @typedef {Object} fraction
     * @property {Number} numerator
     * @property {Number} denominator
     */
    /** Parse a string representing an integer or fraction
     * @param {String} s
     * @see Numbas.util.re_fraction
     * @returns {fraction}
     */
    parseFraction: function(s) {
        if(util.isInt(s)){
            return {numerator:parseInt(s), denominator:1};
        }
        var m = util.re_fraction.exec(s);
        if(!m) {
            return;
        }
        var n = parseInt(m[2]);
        n = m[1] ? -n : n;
        var d = parseInt(m[3]);
        return {numerator:n, denominator:d};
    },
    /** Pad string `s` on the left with a character `p` until it is `n` characters long.
     * @param {String} s
     * @param {Number} n
     * @param {String} p
     * @returns {String}
     */
    lpad: function(s,n,p)
    {
        s=s.toString();
        p=(p+'').slice(0,1);
        while(s.length<n) { s=p+s; }
        return s;
    },
    /** Pad string `s` on the right with a character `p` until it is `n` characters long.
     * @param {String} s
     * @param {Number} n
     * @param {String} p
     * @returns {String}
     */
    rpad: function(s,n,p)
    {
        s=s.toString();
        p=(p+'').slice(0,1);
        while(s.length<n) { s=s+p; }
        return s;
    },
    /** Replace occurences of `%s` with the extra arguments of the function
     * @example formatString('hello %s %s','Mr.','Perfect') => 'hello Mr. Perfect'
     * @param {String} str
     * @param {...String} value - string to substitute
     * @returns {String}
     */
    formatString: function(str)
    {
        var i=0;
        for(var i=1;i<arguments.length;i++)
        {
            str=str.replace(/%s/,arguments[i]);
        }
        return str;
    },
    /** String representation of a time, in the format HH:MM:SS
     * @param {Date} t
     * @returns {String}
     */
    formatTime: function(t) {
        var h = t.getHours();
        var m = t.getMinutes();
        var s = t.getSeconds();
        var lpad = util.lpad;
        return t.toDateString() + ' ' + lpad(h,2,'0')+':'+lpad(m,2,'0')+':'+lpad(s,2,'0');
    },
    /** Format an amount of currency
     * @example currency(5.3,'£','p') => £5.30
     * @param {Number} n
     * @param {String} prefix - symbol to use in front of currency if abs(n) >= 1
     * @param {String} suffix - symbol to use after currency if abs(n) <= 1
     */
    currency: function(n,prefix,suffix) {
        if(n<0)
            return '-'+util.currency(-n,prefix,suffix);
        else if(n==0) {
            return prefix+'0';
        }
        // convert n to a whole number of pence, as a string
        var s = Numbas.math.niceNumber(100*n,{precisionType:'dp',precision:0});
        if(n >= 0.995) {
            if(n%1 < 0.005) {
                return prefix+Numbas.math.niceNumber(Math.floor(n));
            } else if(n%1 >= 0.995) {
                return prefix+Numbas.math.niceNumber(Math.ceil(n));
            }
            s = s.replace(/(..)$/,'.$1');   // put a dot before the last two digits, representing the pence
            return prefix + s
        } else {
            return s + suffix;
        }
    },
    /* Write a number with every three digits separated by the given separator character
     * @example separateThousands(1234567.1234,',') => '1,234,567.1234'
     * @param {Number} n
     * @param {String} separator
     * @returns {String}
     */
    separateThousands: function(n,separator) {
        if(n<0) {
            return '-'+util.separateThousands(-n,separator);
        }
        var s = Numbas.math.niceNumber(n);
        var bits = s.split('.');
        var whole = bits[0];
        var frac = bits[1];
        var over = whole.length%3;
        var out = whole.slice(0,over);
        var i = over;
        while(i<whole.length) {
            out += (out ? separator: '')+whole.slice(i,i+3);
            i += 3;
        }
        if(frac>0) {
            out += '.'+(frac+'');
        }
        return out;
    },
    /** Get rid of the % on the end of percentages and parse as float, then divide by 100
     * @example unPercent('50%') => 0.5
     * @example unPercent('50') => 0.5
     * @param {String} s
     * @returns {Number}
     */
    unPercent: function(s)
    {
        return (util.parseNumber(s.replace(/%/,''))/100);
    },
    /** Pluralise a word
     *
     * If `n` is not unity, return `plural`, else return `singular`
     * @param {Number} n
     * @param {String} singular - string to return if `n` is +1 or -1
     * @param {String} plural - string to returns if `n` is not +1 or -1
     * @returns {String}
     */
    pluralise: function(n,singular,plural)
    {
        n = Numbas.math.precround(n,10);
        if(n==-1 || n==1)
            return singular;
        else
            return plural;
    },
    /** Make the first letter in the string a capital
     * @param {String} str
     * @returns {String}
     */
    capitalise: function(str) {
        return str.replace(/^[a-z]/,function(c){return c.toUpperCase()});
    },
    /** Split a string up according to brackets
     *
     * Strips out nested brackets
     * @example splitbrackets('a{{b}}c','{','}') => ['a','b','c']
     * @param {String} t - string to split
     * @param {String} lb - left bracket string
     * @param {String} rb - right bracket string
     * @returns {Array.<String>} - alternating strings in brackets and strings outside: odd-numbered indices are inside brackets.
     */
    splitbrackets: function(str,lb,rb)
    {
        var length = str.length;
        var lb_length = lb.length;
        var rb_length = rb.length;
        var out = [];    // bits to return
        var end = 0;    // end of the last pair of bracket
        for(var i=0;i<length;i++) {
            // if last character wasn't an escape
            if(i==0 || str.charAt(i-1)!='\\') {
                // if cursor is at a left bracket
                if(str.slice(i,i+lb_length)==lb) {
                    var j = i+lb_length;
                    var depth = 1;
                    var shortened = str.slice();    // this will store the contents of the brackets, with nested brackets removed
                    var acc = 0;    // number of characters removed in shortened text
                    // scan along until matching right bracket found
                    while(j<length && depth>0) {
                        if(j==0 || str.charAt(j-1)!='\\') {
                            if(str.slice(j,j+lb_length)==lb) {
                                // remove this bracket from shortened
                                shortened = shortened.slice(0,j-acc)+shortened.slice(j+lb_length-acc);
                                acc += lb_length;
                                // add 1 to depth
                                depth += 1;
                                j += lb_length;
                            } else if(str.slice(j,j+rb_length)==rb) {
                                // remove this bracket from shortened
                                shortened = shortened.slice(0,j-acc)+shortened.slice(j+rb_length-acc);
                                acc += rb_length;
                                // subtract 1 from depth
                                depth -= 1;
                                j += rb_length;
                            } else {
                                j += 1;
                            }
                        } else {
                            j += 1;
                        }
                    }
                    // if matching right bracket found
                    if(depth==0) {
                        // output plain text found before bracket
                        out.push(str.slice(end,i));
                        // output contents of bracket
                        out.push(shortened.slice(i+lb_length,j-acc));
                        // remember the position of the end of the bracket
                        end = j;
                        i = j-1;
                    }
                }
            }
        }
        // output the remaining plain text
        out.push(str.slice(end));
        return out;
    },
    /** Because XML doesn't like having ampersands hanging about, replace them with escape codes
     * @param {String} str - XML string
     * @returns {String}
     */
    escapeHTML: function(str)
    {
        return str
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;")
        ;
    },
    /** Create a comparison function which sorts objects by a particular property
     * @param {Array.<String>|String} prop - name of the property (or list of names of properties) to sort by
     * @returns {function}
     */
    sortBy: function(props) {
        if(typeof props=='string') {
            props = [props];
        }
        var l = props.length;
        return function(a,b) {
            for(var i=0;i<l;i++) {
                var prop = props[i];
                if(a[prop]>b[prop])
                    return 1;
                else if(a[prop]<b[prop])
                    return -1;
            }
            return 0;
        }
    },
    /** Hash a string into a string of digits
     *
     * From {@link http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/}
     */
    hashCode: function(str){
        var hash = 0, i, c;
        if (str.length == 0) return hash;
        for (i = 0; i < str.length; i++) {
            c = str.charCodeAt(i);
            hash = ((hash<<5)-hash)+c;
        }
        if(hash<0)
            return '0'+(-hash);
        else
            return '1'+hash;
    },
    /** Cartesian product of one or more lists
     * @param {Array} lists - list of arrays
     * @returns {Array}
     */
    product: function(lists) {
        if(!Array.isArray(lists)) {
            throw(new Numbas.Error("util.product.non list"));
        }
        var indexes = lists.map(function(){return 0});
        var zero = false;
        var nonArray = false;
        var lengths = lists.map(function(l){
            if(!Array.isArray(l)) {
                nonArray = true;
            }
            if(l.length==0) {
                zero = true;
            }
            return l.length
        });
        if(nonArray) {
            throw(new Numbas.Error("util.product.non list"));
        }
        if(zero) {
            return [];
        }
        var end = lists.length-1;
        var out = [];
        while(indexes[0]!=lengths[0]) {
            out.push(indexes.map(function(i,n){return lists[n][i]}));
            var k = end;
            indexes[k] += 1;
            while(k>0 && indexes[k]==lengths[k]) {
                indexes[k] = 0;
                k -= 1;
                indexes[k] += 1;
            }
        }
        return out;
    },

    /** Cartesian product of list, repeated n times
     * @param {Array} l
     * @param {Number} n
     * @returns {Array}
     */
    cartesian_power: function(l,n) {
        var o = [[]];
        for(var i=0;i<n;i++) {
            var no = [];
            o.forEach(function(ol) {
                l.forEach(function(x) {
                    var nl = ol.slice();
                    nl.push(x);
                    no.push(nl);
                })
            });
            o = no;
        }
        return o;
    },

    /** Zip lists together: given lists [a,b,c,...], [x,y,z,...], return [[a,x],[b,y],[c,z], ...]
     * @param {Array} lists - list of arrays
     * @returns {Array}
     */
    zip: function(lists) {
        var out = [];
        if(lists.length==0) {
            return out;
        }
        for(var i=0;true;i++) {
            var z = [];
            for(var j=0;j<lists.length;j++) {
                if(i<lists[j].length) {
                    z.push(lists[j][i]);
                } else {
                    return out;
                }
            }
            out.push(z);
        }
    },
    /** All combinations of r items from given array, without replacement
     * @param {Array} list
     * @param {Number} r
     */
    combinations: function(list,r) {
        var indexes = [];
        for(var i=0;i<r;i++) {
            indexes.push(i);
        }
        var length = list.length;
        var end = r-1;
        var out = [];
        var steps = 0;
        while(steps<1000 && indexes[0]<length+1-r) {
            steps += 1;
            out.push(indexes.map(function(i){return list[i]; }));
            indexes[end] += 1;
            if(indexes[end]==length) {
                var k = end;
                while(k>=0 && indexes[k]==length+1-r+k) {
                    k -= 1;
                    indexes[k] += 1;
                }
                for(k=k+1;k<r;k++) {
                    indexes[k] = indexes[k-1]+1;
                }
            }
        }
        return out;
    },
    /** All combinations of r items from given array, with replacement
     * @param {Array} list
     * @param {Number} r
     */
    combinations_with_replacement: function(list,r) {
        var indexes = [];
        for(var i=0;i<r;i++) {
            indexes.push(0);
        }
        var length = list.length;
        var end = r-1;
        var out = [];
        while(indexes[0]<length) {
            out.push(indexes.map(function(i){return list[i]; }));
            indexes[end] += 1;
            if(indexes[end]==length) {
                var k = end;
                while(k>=0 && indexes[k]==length) {
                    k -= 1;
                    indexes[k] += 1;
                }
                for(k=k+1;k<r;k++) {
                    indexes[k] = indexes[k-1];
                }
            }
        }
        return out;
    },
    /** All permutations of all choices of r elements from list
     *
     * Inspired by the algorithm in Python's itertools library
     * @param {Array} list - elements to choose and permute
     * @param {Number} r - number of elements to choose
     */
    permutations: function(list,r) {
        var n = list.length;
        if(r===undefined) {
            r = n;
        }
        if(r>n) {
            throw(new Numbas.Error('util.permutations.r bigger than n'));
        }
        var indices = [];
        var cycles = [];
        for(var i=0;i<n;i++) {
            indices.push(i);
        }
        for(var i=n;i>=n-r+1;i--) {
            cycles.push(i);
        }
        var out = [indices.slice(0,r).map(function(v){return list[v]})];
        while(n) {
            for(var i=r-1;i>=0;i--) {
                cycles[i] -= 1
                if(cycles[i]==0) {
                    indices.push(indices.splice(i,1)[0]);
                    cycles[i] = n-i
                } else {
                    var j = cycles[i];
                    var t = indices[i];
                    indices[i] = indices[n-j];
                    indices[n-j] = t;
                    out.push(indices.slice(0,r).map(function(v){return list[v]}));
                    break;
                }
            }
            if(i==-1) {
                return out;
            }
        }
    },
    /** Get the letter format of an ordinal
     * e.g. the Nth element in the sequence a,b,c,...z,aa,ab,..,az,ba,...
     * @param {Number} n
     * @returns {String}
     */
    letterOrdinal: function(n) {
        var alphabet = 'abcdefghijklmnopqrstuvwxyz';
        var b = alphabet.length;
        if(n==0) {
            return alphabet[0];
        }
        var s = '';
        while(n>0) {
            if(s) {
                n -= 1;
            }
            var m = n%b;
            s = alphabet[m]+s;
            n = (n-m)/b;
        }
        return s;
    },
    /** Get a human-sensible name of a part, given its path
     * @param {String} path
     * @returns {String}
     */
    nicePartName: function(path) {
        var re_path = /^p(\d+)(?:g(\d+)|s(\d+))?$/;
        var m = re_path.exec(path);
        var s = R('part')+' '+util.letterOrdinal(m[1]);
        if(m[2]) {
            s += ' '+R('gap')+' '+m[2];
        }
        if(m[3]) {
            s += ' '+R('step')+' '+m[3];
        }
        return s;
    }
};
/** Different styles of writing a decimal
 *
 * Objects of the form `{re,format}`, where `re` is a regex recognising numbers in this style, and `format(integer,decimal)` renders the number in this style.
 *
 * Each regex matches the integer part in group 1, and the decimal part in group 2 - it should be safe to remove all non-digit characters in these and preserve meaning.
 * @see {@link https://en.wikipedia.org/wiki/Decimal_mark#Examples_of_use|Examples of decimal mark use on Wikipedia}
 * @memberof Numbas.util
 */
var numberNotationStyles = util.numberNotationStyles = {
    // Plain English style - no thousands separator, dot for decimal point
    'plain': {
        re: /^([0-9]+)(\x2E[0-9]+)?/,
        format: function(integer,decimal) {
            if(decimal) {
                return integer+'.'+decimal;
            } else {
                return integer;
            }
        }
    },
    // English style - commas separate thousands, dot for decimal point
    'en': {
        re: /^(\d{1,3}(?:,\d{3})*)(\x2E\d+)?/,
        format: util.standardNumberFormatter(',','.')
    },
    // English SI style - spaces separate thousands, dot for decimal point
    'si-en': {
        re: /^(\d{1,3}(?: +\d{3})*)(\x2E(?:\d{3} )*\d{1,3})?/,
        format: util.standardNumberFormatter(' ','.',true)
    },
    // French SI style - spaces separate thousands, comma for decimal point
    'si-fr': {
        re: /^(\d{1,3}(?: +\d{3})*)(,(?:\d{3} )*\d{1,3})?/,
        format: util.standardNumberFormatter(' ',',',true)
    },
    // Continental European style - dots separate thousands, comma for decimal point
    'eu': {
        re: /^(\d{1,3}(?:\x2E\d{3})*)(,\d+)?/,
        format: util.standardNumberFormatter('.',',')
    },
    // Plain French style - no thousands separator, comma for decimal point
    'plain-eu': {
        re: /^([0-9]+)(,[0-9]+)?/,
        format: function(integer,decimal) {
            if(decimal) {
                return integer+','+decimal;
            } else {
                return integer;
            }
        }
    },
    // Swiss style - apostrophes separate thousands, dot for decimal point
    'ch': {
        re: /^(\d{1,3}(?:'\d{3})*)(\x2E\d+)?/,
        format: util.standardNumberFormatter('\'','.')
    },
    // Indian style - commas separate groups, dot for decimal point. The rightmost group is three digits, other groups are two digits.
    'in': {
        re: /^((?:\d{1,2}(?:,\d{2})*,\d{3})|\d{1,3})(\x2E\d+)?/,
        format: function(integer,decimal) {
            integer = integer+'';
            if(integer.length>3) {
                var over = (integer.length-3)%2
                var out = integer.slice(0,over);
                var i = over;
                while(i<integer.length-3) {
                    out += (out ? ',' : '')+integer.slice(i,i+2);
                    i += 2;
                }
                integer = out+','+integer.slice(i);
            }
            if(decimal) {
                return integer+'.'+decimal;
            } else {
                return integer;
            }
        }
    }
}
var endDelimiters = {
    '$': /[^\\]\$/,
    '\\(': /[^\\]\\\)/,
    '$$': /[^\\]\$\$/,
    '\\[': /[^\\]\\\]/
}
var re_startMaths = /(^|[^\\])(?:\$\$|\$)|\\\(|\\\[|\\begin\{(\w+)\}/;
/** Split a string up by TeX delimiters (`$`, `\[`, `\]`)
 *
 * `bits.re_end` stores the delimiter if the returned array has unfinished maths at the end
 * @param {String} txt - string to split up
 * @param {RegExp} re_end - If tex is split across several strings (e.g. text nodes with <br> in the middle), this can be used to give the end delimiter for unfinished maths
 * @returns {Array.<String>} bits - stuff outside TeX, left delimiter, TeX, right delimiter, stuff outside TeX, ...
 * @example contentsplitbrackets('hello $x+y$ and \[this\] etc') => ['hello ','$','x+y','$',' and ','\[','this','\]']
 * @memberof Numbas.util
 * @method
 */
var contentsplitbrackets = util.contentsplitbrackets = function(txt,re_end) {
    var i = 0;
    var m;
    var startDelimiter='', endDelimiter='';
    var startText = '';
    var start='', end='';
    var startChop, endChop;
    var re_end;
    var bits = [];
    while(txt.length) {
        if(!re_end) {
            m = re_startMaths.exec(txt);
            if(!m) {     // if no maths delimiters, we're done
                bits.push(txt);
                txt = '';
                break;
            }
            startDelimiter = m[0];
            var start = m.index;
            startChop = start+startDelimiter.length;
            startText = txt.slice(0,start);
            if(m[1]) {
                startText += m[1];
                startDelimiter = startDelimiter.slice(m[1].length);
            }
            txt = txt.slice(startChop);
            if(startDelimiter.match(/^\\begin/m)) {    //if this is an environment, construct a regexp to find the corresponding \end{} command.
                var environment = m[1];
                re_end = new RegExp('[^\\\\]\\\\end\\{'+environment+'\\}');    // don't ask if this copes with nested environments
            }
            else if(startDelimiter.match(/^(?:.|[\r\n])\$/m)) {
                re_end = endDelimiters[startDelimiter.slice(1)];
            } else {
                re_end = endDelimiters[startDelimiter];    // get the corresponding end delimiter for the matched start delimiter
            }
        }
        m = re_end.exec(txt);
        if(!m) {    // if no ending delimiter, the text contains no valid maths
            bits.push(startText,startDelimiter,txt);
            bits.re_end = re_end;
            txt = '';
            break;
        }
        endDelimiter = m[0].slice(1);
        var end = m.index+1;    // the end delimiter regexp has a "not a backslash" character at the start because JS regexps don't do negative lookbehind
        endChop = end+endDelimiter.length;
        var math = txt.slice(0,end);
        txt = txt.slice(endChop);
        i += startChop+endChop;
        bits.push(startText,startDelimiter,math,endDelimiter);
        re_end = null;
    }
    return bits;
}
//Because indexOf not supported in IE
if(!Array.indexOf)
{
    Array.prototype.indexOf = function(obj){
        for(var i=0; i<this.length; i++){
            if(this[i]==obj){
                return i;
            }
        }
        return -1;
    };
}
//nice short 'string contains' function
if(!String.prototype.contains)
{
    String.prototype.contains = function(it) { return this.indexOf(it) != -1; };
}
if(!Array.prototype.contains)
{
    Array.prototype.contains = function(it) { return this.indexOf(it) != -1; };
}
//merge one array into another, only adding elements which aren't already present
if(!Array.prototype.merge)
{
    Array.prototype.merge = function(arr,sortfn)
    {
        if(this.length==0)
            return arr.slice();
        var out = this.concat(arr);
        if(sortfn)
            out.sort(sortfn);
        else
            out.sort();
        if(sortfn)
        {
            for(var i=1; i<out.length;) {
                if(sortfn(out[i-1],out[i])==0)    //duplicate elements, so remove latest
                    out.splice(i,1);
                else
                    i++;
            }
        }
        else
        {
            for(var i=1;i<out.length;) {
                if(out[i-1]==out[i])
                    out.splice(i,1);
                else
                    i++;
            }
        }
        return out;
    };
}
/* Cross-Browser Split 1.0.1
(c) Steven Levithan <stevenlevithan.com>; MIT License
An ECMA-compliant, uniform cross-browser split method */
var cbSplit;
// avoid running twice, which would break `cbSplit._nativeSplit`'s reference to the native `split`
if (!cbSplit) {
cbSplit = function (str, separator, limit) {
    // if `separator` is not a regex, use the native `split`
    if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
        return cbSplit._nativeSplit.call(str, separator, limit);
    }
    var output = [],
        lastLastIndex = 0,
        flags = (separator.ignoreCase ? "i" : "") +
                (separator.multiline  ? "m" : "") +
                (separator.sticky     ? "y" : ""),
        separator = RegExp(separator.source, flags + "g"), // make `global` and avoid `lastIndex` issues by working with a copy
        separator2, match, lastIndex, lastLength;
    str = str + ""; // type conversion
    if (!cbSplit._compliantExecNpcg) {
        separator2 = RegExp("^" + separator.source + "$(?!\\s)", flags); // doesn't need /g or /y, but they don't hurt
    }
    /* behavior for `limit`: if it's...
    - `undefined`: no limit.
    - `NaN` or zero: return an empty array.
    - a positive number: use `Math.floor(limit)`.
    - a negative number: no limit.
    - other: type-convert, then use the above rules. */
    if (limit === undefined || +limit < 0) {
        limit = Infinity;
    } else {
        limit = Math.floor(+limit);
        if (!limit) {
            return [];
        }
    }
    while (match = separator.exec(str)) {
        lastIndex = match.index + match[0].length; // `separator.lastIndex` is not reliable cross-browser
        if (lastIndex > lastLastIndex) {
            output.push(str.slice(lastLastIndex, match.index));
            // fix browsers whose `exec` methods don't consistently return `undefined` for nonparticipating capturing groups
            if (!cbSplit._compliantExecNpcg && match.length > 1) {
                match[0].replace(separator2, function () {
                    for (var i = 1; i < arguments.length - 2; i++) {
                        if (arguments[i] === undefined) {
                            match[i] = undefined;
                        }
                    }
                });
            }
            if (match.length > 1 && match.index < str.length) {
                Array.prototype.push.apply(output, match.slice(1));
            }
            lastLength = match[0].length;
            lastLastIndex = lastIndex;
            if (output.length >= limit) {
                break;
            }
        }
        if (separator.lastIndex === match.index) {
            separator.lastIndex++; // avoid an infinite loop
        }
    }
    if (lastLastIndex === str.length) {
        if (lastLength || !separator.test("")) {
            output.push("");
        }
    } else {
        output.push(str.slice(lastLastIndex));
    }
    return output.length > limit ? output.slice(0, limit) : output;
};
cbSplit._compliantExecNpcg = /()??/.exec("")[1] === undefined; // NPCG: nonparticipating capturing group
cbSplit._nativeSplit = String.prototype.split;
} // end `if (!cbSplit)`
// for convenience, override the builtin split function with the cross-browser version...
if(!String.prototype.split)
{
    String.prototype.split = function (separator, limit) {
        return cbSplit(this, separator, limit);
    };
}
// es5-shim.min.js 24/09/2012
//
// -- kriskowal Kris Kowal Copyright (C) 2009-2011 MIT License
// -- tlrobinson Tom Robinson Copyright (C) 2009-2010 MIT License (Narwhal Project)
// -- dantman Daniel Friesen Copyright (C) 2010 XXX TODO License or CLA
// -- fschaefer Florian Schäfer Copyright (C) 2010 MIT License
// -- Gozala Irakli Gozalishvili Copyright (C) 2010 MIT License
// -- kitcambridge Kit Cambridge Copyright (C) 2011 MIT License
// -- kossnocorp Sasha Koss XXX TODO License or CLA
// -- bryanforbes Bryan Forbes XXX TODO License or CLA
// -- killdream Quildreen Motta Copyright (C) 2011 MIT Licence
// -- michaelficarra Michael Ficarra Copyright (C) 2011 3-clause BSD License
// -- sharkbrainguy Gerard Paapu Copyright (C) 2011 MIT License
// -- bbqsrc Brendan Molloy (C) 2011 Creative Commons Zero (public domain)
// -- iwyg XXX TODO License or CLA
// -- DomenicDenicola Domenic Denicola Copyright (C) 2011 MIT License
// -- xavierm02 Montillet Xavier Copyright (C) 2011 MIT License
// -- Raynos Jake Verbaten Copyright (C) 2011 MIT Licence
// -- samsonjs Sami Samhuri Copyright (C) 2010 MIT License
// -- rwldrn Rick Waldron Copyright (C) 2011 MIT License
// -- lexer Alexey Zakharov XXX TODO License or CLA
/*!
    Copyright (c) 2009, 280 North Inc. http://280north.com/
    MIT License. http://github.com/280north/narwhal/blob/master/README.md
*/
// Module systems magic dance
(function (definition) {
    // RequireJS
    if (typeof define == "function") {
        define(definition);
    // CommonJS and <script>
    } else {
        definition();
    }
})(function () {
/**
 * Brings an environment as close to ECMAScript 5 compliance
 * as is possible with the facilities of erstwhile engines.
 *
 * Annotated ES5: http://es5.github.com/ (specific links below)
 * ES5 Spec: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
 * Required reading: http://javascriptweblog.wordpress.com/2011/12/05/extending-javascript-natives/
 */
//
// Function
// ========
//
// ES-5 15.3.4.5
// http://es5.github.com/#x15.3.4.5
if (!Function.prototype.bind) {
    Function.prototype.bind = function bind(that) { // .length is 1
        // 1. Let Target be the this value.
        var target = this;
        // 2. If IsCallable(Target) is false, throw a TypeError exception.
        if (typeof target != "function") {
            throw new TypeError("Function.prototype.bind called on incompatible " + target);
        }
        // 3. Let A be a new (possibly empty) internal list of all of the
        //   argument values provided after thisArg (arg1, arg2 etc), in order.
        // XXX slicedArgs will stand in for "A" if used
        var args = slice.call(arguments, 1); // for normal call
        // 4. Let F be a new native ECMAScript object.
        // 11. Set the [[Prototype]] internal property of F to the standard
        //   built-in Function prototype object as specified in 15.3.3.1.
        // 12. Set the [[Call]] internal property of F as described in
        //   15.3.4.5.1.
        // 13. Set the [[Construct]] internal property of F as described in
        //   15.3.4.5.2.
        // 14. Set the [[HasInstance]] internal property of F as described in
        //   15.3.4.5.3.
        var bound = function () {
            if (this instanceof bound) {
                // 15.3.4.5.2 [[Construct]]
                // When the [[Construct]] internal method of a function object,
                // F that was created using the bind function is called with a
                // list of arguments ExtraArgs, the following steps are taken:
                // 1. Let target be the value of F's [[TargetFunction]]
                //   internal property.
                // 2. If target has no [[Construct]] internal method, a
                //   TypeError exception is thrown.
                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Construct]] internal
                //   method of target providing args as the arguments.
                var F = function(){};
                F.prototype = target.prototype;
                var self = new F;
                var result = target.apply(
                    self,
                    args.concat(slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return self;
            } else {
                // 15.3.4.5.1 [[Call]]
                // When the [[Call]] internal method of a function object, F,
                // which was created using the bind function is called with a
                // this value and a list of arguments ExtraArgs, the following
                // steps are taken:
                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 2. Let boundThis be the value of F's [[BoundThis]] internal
                //   property.
                // 3. Let target be the value of F's [[TargetFunction]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Call]] internal method
                //   of target providing boundThis as the this value and
                //   providing args as the arguments.
                // equiv: target.call(this, ...boundArgs, ...args)
                return target.apply(
                    that,
                    args.concat(slice.call(arguments))
                );
            }
        };
        // XXX bound.length is never writable, so don't even try
        //
        // 15. If the [[Class]] internal property of Target is "Function", then
        //     a. Let L be the length property of Target minus the length of A.
        //     b. Set the length own property of F to either 0 or L, whichever is
        //       larger.
        // 16. Else set the length own property of F to 0.
        // 17. Set the attributes of the length own property of F to the values
        //   specified in 15.3.5.1.
        // TODO
        // 18. Set the [[Extensible]] internal property of F to true.
        // TODO
        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
        // 20. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
        //   false.
        // 21. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
        //   and false.
        // TODO
        // NOTE Function objects created using Function.prototype.bind do not
        // have a prototype property or the [[Code]], [[FormalParameters]], and
        // [[Scope]] internal properties.
        // XXX can't delete prototype in pure-js.
        // 22. Return F.
        return bound;
    };
}
// Shortcut to an often accessed properties, in order to avoid multiple
// dereference that costs universally.
// _Please note: Shortcuts are defined after `Function.prototype.bind` as we
// us it in defining shortcuts.
var call = Function.prototype.call;
var prototypeOfArray = Array.prototype;
var prototypeOfObject = Object.prototype;
var slice = prototypeOfArray.slice;
// Having a toString local variable name breaks in Opera so use _toString.
var _toString = call.bind(prototypeOfObject.toString);
var owns = call.bind(prototypeOfObject.hasOwnProperty);
// If JS engine supports accessors creating shortcuts.
var defineGetter;
var defineSetter;
var lookupGetter;
var lookupSetter;
var supportsAccessors;
if ((supportsAccessors = owns(prototypeOfObject, "__defineGetter__"))) {
    defineGetter = call.bind(prototypeOfObject.__defineGetter__);
    defineSetter = call.bind(prototypeOfObject.__defineSetter__);
    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
}
//
// Array
// =====
//
// ES5 15.4.3.2
// http://es5.github.com/#x15.4.3.2
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
if (!Array.isArray) {
    Array.isArray = function isArray(obj) {
        return _toString(obj) == "[object Array]";
    };
}
// The IsCallable() check in the Array functions
// has been replaced with a strict check on the
// internal class of the object to trap cases where
// the provided function was actually a regular
// expression literal, which in V8 and
// JavaScriptCore is a typeof "function".  Only in
// V8 are regular expression literals permitted as
// reduce parameters, so it is desirable in the
// general case for the shim to match the more
// strict and common behavior of rejecting regular
// expressions.
// ES5 15.4.4.18
// http://es5.github.com/#x15.4.4.18
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/forEach
if (!Array.prototype.forEach) {
    Array.prototype.forEach = function forEach(fun /*, thisp*/) {
        var self = toObject(this),
            thisp = arguments[1],
            i = -1,
            length = self.length >>> 0;
        // If no callback function or if callback is not a callable function
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(); // TODO message
        }
        while (++i < length) {
            if (i in self) {
                // Invoke the callback function with call, passing arguments:
                // context, property value, property key, thisArg object context
                fun.call(thisp, self[i], i, self);
            }
        }
    };
}
// ES5 15.4.4.19
// http://es5.github.com/#x15.4.4.19
// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
if (!Array.prototype.map) {
    Array.prototype.map = function map(fun /*, thisp*/) {
        var self = toObject(this),
            length = self.length >>> 0,
            result = Array(length),
            thisp = arguments[1];
        // If no callback function or if callback is not a callable function
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }
        for (var i = 0; i < length; i++) {
            if (i in self)
                result[i] = fun.call(thisp, self[i], i, self);
        }
        return result;
    };
}
// ES5 15.4.4.20
// http://es5.github.com/#x15.4.4.20
// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
if (!Array.prototype.filter) {
    Array.prototype.filter = function filter(fun /*, thisp */) {
        var self = toObject(this),
            length = self.length >>> 0,
            result = [],
            value,
            thisp = arguments[1];
        // If no callback function or if callback is not a callable function
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }
        for (var i = 0; i < length; i++) {
            if (i in self) {
                value = self[i];
                if (fun.call(thisp, value, i, self)) {
                    result.push(value);
                }
            }
        }
        return result;
    };
}
// ES5 15.4.4.16
// http://es5.github.com/#x15.4.4.16
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every
if (!Array.prototype.every) {
    Array.prototype.every = function every(fun /*, thisp */) {
        var self = toObject(this),
            length = self.length >>> 0,
            thisp = arguments[1];
        // If no callback function or if callback is not a callable function
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }
        for (var i = 0; i < length; i++) {
            if (i in self && !fun.call(thisp, self[i], i, self)) {
                return false;
            }
        }
        return true;
    };
}
// ES5 15.4.4.17
// http://es5.github.com/#x15.4.4.17
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some
if (!Array.prototype.some) {
    Array.prototype.some = function some(fun /*, thisp */) {
        var self = toObject(this),
            length = self.length >>> 0,
            thisp = arguments[1];
        // If no callback function or if callback is not a callable function
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }
        for (var i = 0; i < length; i++) {
            if (i in self && fun.call(thisp, self[i], i, self)) {
                return true;
            }
        }
        return false;
    };
}
// ES5 15.4.4.21
// http://es5.github.com/#x15.4.4.21
// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduce
if (!Array.prototype.reduce) {
    Array.prototype.reduce = function reduce(fun /*, initial*/) {
        var self = toObject(this),
            length = self.length >>> 0;
        // If no callback function or if callback is not a callable function
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }
        // no value to return if no initial value and an empty array
        if (!length && arguments.length == 1) {
            throw new TypeError('reduce of empty array with no initial value');
        }
        var i = 0;
        var result;
        if (arguments.length >= 2) {
            result = arguments[1];
        } else {
            do {
                if (i in self) {
                    result = self[i++];
                    break;
                }
                // if array contains no values, no initial value to return
                if (++i >= length) {
                    throw new TypeError('reduce of empty array with no initial value');
                }
            } while (true);
        }
        for (; i < length; i++) {
            if (i in self) {
                result = fun.call(void 0, result, self[i], i, self);
            }
        }
        return result;
    };
}
// ES5 15.4.4.22
// http://es5.github.com/#x15.4.4.22
// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduceRight
if (!Array.prototype.reduceRight) {
    Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {
        var self = toObject(this),
            length = self.length >>> 0;
        // If no callback function or if callback is not a callable function
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }
        // no value to return if no initial value, empty array
        if (!length && arguments.length == 1) {
            throw new TypeError('reduceRight of empty array with no initial value');
        }
        var result, i = length - 1;
        if (arguments.length >= 2) {
            result = arguments[1];
        } else {
            do {
                if (i in self) {
                    result = self[i--];
                    break;
                }
                // if array contains no values, no initial value to return
                if (--i < 0) {
                    throw new TypeError('reduceRight of empty array with no initial value');
                }
            } while (true);
        }
        do {
            if (i in this) {
                result = fun.call(void 0, result, self[i], i, self);
            }
        } while (i--);
        return result;
    };
}
// ES5 15.4.4.14
// http://es5.github.com/#x15.4.4.14
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function indexOf(sought /*, fromIndex */ ) {
        var self = toObject(this),
            length = self.length >>> 0;
        if (!length) {
            return -1;
        }
        var i = 0;
        if (arguments.length > 1) {
            i = toInteger(arguments[1]);
        }
        // handle negative indices
        i = i >= 0 ? i : Math.max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === sought) {
                return i;
            }
        }
        return -1;
    };
}
// ES5 15.4.4.15
// http://es5.github.com/#x15.4.4.15
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf
if (!Array.prototype.lastIndexOf) {
    Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {
        var self = toObject(this),
            length = self.length >>> 0;
        if (!length) {
            return -1;
        }
        var i = length - 1;
        if (arguments.length > 1) {
            i = Math.min(i, toInteger(arguments[1]));
        }
        // handle negative indices
        i = i >= 0 ? i : length - Math.abs(i);
        for (; i >= 0; i--) {
            if (i in self && sought === self[i]) {
                return i;
            }
        }
        return -1;
    };
}
//
// Object
// ======
//
// ES5 15.2.3.2
// http://es5.github.com/#x15.2.3.2
if (!Object.getPrototypeOf) {
    // https://github.com/kriskowal/es5-shim/issues#issue/2
    // http://ejohn.org/blog/objectgetprototypeof/
    // recommended by fschaefer on github
    Object.getPrototypeOf = function getPrototypeOf(object) {
        return object.__proto__ || (
            object.constructor
                ? object.constructor.prototype
                : prototypeOfObject
        );
    };
}
// ES5 15.2.3.3
// http://es5.github.com/#x15.2.3.3
if (!Object.getOwnPropertyDescriptor) {
    var ERR_NON_OBJECT = "Object.getOwnPropertyDescriptor called on a non-object: ";
    Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
        if ((typeof object != "object" && typeof object != "function") || object === null) {
            throw new TypeError(ERR_NON_OBJECT + object);
        }
        // If object does not owns property return undefined immediately.
        if (!owns(object, property)) {
            return;
        }
        // If object has a property then it's for sure both `enumerable` and
        // `configurable`.
        var descriptor =  { enumerable: true, configurable: true };
        // If JS engine supports accessor properties then property may be a
        // getter or setter.
        if (supportsAccessors) {
            // Unfortunately `__lookupGetter__` will return a getter even
            // if object has own non getter property along with a same named
            // inherited getter. To avoid misbehavior we temporary remove
            // `__proto__` so that `__lookupGetter__` will return getter only
            // if it's owned by an object.
            var prototype = object.__proto__;
            object.__proto__ = prototypeOfObject;
            var getter = lookupGetter(object, property);
            var setter = lookupSetter(object, property);
            // Once we have getter and setter we can put values back.
            object.__proto__ = prototype;
            if (getter || setter) {
                if (getter) {
                    descriptor.get = getter;
                }
                if (setter) {
                    descriptor.set = setter;
                }
                // If it was accessor property we're done and return here
                // in order to avoid adding `value` to the descriptor.
                return descriptor;
            }
        }
        // If we got this far we know that object has an own property that is
        // not an accessor so we set it as a value and return descriptor.
        descriptor.value = object[property];
        return descriptor;
    };
}
// ES5 15.2.3.4
// http://es5.github.com/#x15.2.3.4
if (!Object.getOwnPropertyNames) {
    Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
        return Object.keys(object);
    };
}
// ES5 15.2.3.5
// http://es5.github.com/#x15.2.3.5
if (!Object.create) {
    Object.create = function create(prototype, properties) {
        var object;
        if (prototype === null) {
            object = { "__proto__": null };
        } else {
            if (typeof prototype != "object") {
                throw new TypeError("typeof prototype["+(typeof prototype)+"] != 'object'");
            }
            var Type = function () {};
            Type.prototype = prototype;
            object = new Type();
            // IE has no built-in implementation of `Object.getPrototypeOf`
            // neither `__proto__`, but this manually setting `__proto__` will
            // guarantee that `Object.getPrototypeOf` will work as expected with
            // objects created using `Object.create`
            object.__proto__ = prototype;
        }
        if (properties !== void 0) {
            Object.defineProperties(object, properties);
        }
        return object;
    };
}
// ES5 15.2.3.6
// http://es5.github.com/#x15.2.3.6
// Patch for WebKit and IE8 standard mode
// Designed by hax <hax.github.com>
// related issue: https://github.com/kriskowal/es5-shim/issues#issue/5
// IE8 Reference:
//     http://msdn.microsoft.com/en-us/library/dd282900.aspx
//     http://msdn.microsoft.com/en-us/library/dd229916.aspx
// WebKit Bugs:
//     https://bugs.webkit.org/show_bug.cgi?id=36423
function doesDefinePropertyWork(object) {
    try {
        Object.defineProperty(object, "sentinel", {});
        return "sentinel" in object;
    } catch (exception) {
        // returns falsy
    }
}
// check whether defineProperty works if it's given. Otherwise,
// shim partially.
if (Object.defineProperty) {
    var definePropertyWorksOnObject = doesDefinePropertyWork({});
    var definePropertyWorksOnDom = typeof document == "undefined" ||
        doesDefinePropertyWork(document.createElement("div"));
    if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
        var definePropertyFallback = Object.defineProperty;
    }
}
if (!Object.defineProperty || definePropertyFallback) {
    var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";
    var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: "
    var ERR_ACCESSORS_NOT_SUPPORTED = "getters & setters can not be defined " +
                                      "on this javascript engine";
    Object.defineProperty = function defineProperty(object, property, descriptor) {
        if ((typeof object != "object" && typeof object != "function") || object === null) {
            throw new TypeError(ERR_NON_OBJECT_TARGET + object);
        }
        if ((typeof descriptor != "object" && typeof descriptor != "function") || descriptor === null) {
            throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
        }
        // make a valiant attempt to use the real defineProperty
        // for I8's DOM elements.
        if (definePropertyFallback) {
            try {
                return definePropertyFallback.call(Object, object, property, descriptor);
            } catch (exception) {
                // try the shim if the real one doesn't work
            }
        }
        // If it's a data property.
        if (owns(descriptor, "value")) {
            // fail silently if "writable", "enumerable", or "configurable"
            // are requested but not supported
            /*
            // alternate approach:
            if ( // can't implement these features; allow false but not true
                !(owns(descriptor, "writable") ? descriptor.writable : true) ||
                !(owns(descriptor, "enumerable") ? descriptor.enumerable : true) ||
                !(owns(descriptor, "configurable") ? descriptor.configurable : true)
            )
                throw new RangeError(
                    "This implementation of Object.defineProperty does not " +
                    "support configurable, enumerable, or writable."
                );
            */
            if (supportsAccessors && (lookupGetter(object, property) ||
                                      lookupSetter(object, property)))
            {
                // As accessors are supported only on engines implementing
                // `__proto__` we can safely override `__proto__` while defining
                // a property to make sure that we don't hit an inherited
                // accessor.
                var prototype = object.__proto__;
                object.__proto__ = prototypeOfObject;
                // Deleting a property anyway since getter / setter may be
                // defined on object itself.
                delete object[property];
                object[property] = descriptor.value;
                // Setting original `__proto__` back now.
                object.__proto__ = prototype;
            } else {
                object[property] = descriptor.value;
            }
        } else {
            if (!supportsAccessors) {
                throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
            }
            // If we got that far then getters and setters can be defined !!
            if (owns(descriptor, "get")) {
                defineGetter(object, property, descriptor.get);
            }
            if (owns(descriptor, "set")) {
                defineSetter(object, property, descriptor.set);
            }
        }
        return object;
    };
}
// ES5 15.2.3.7
// http://es5.github.com/#x15.2.3.7
if (!Object.defineProperties) {
    Object.defineProperties = function defineProperties(object, properties) {
        for (var property in properties) {
            if (owns(properties, property) && property != "__proto__") {
                Object.defineProperty(object, property, properties[property]);
            }
        }
        return object;
    };
}
// ES5 15.2.3.8
// http://es5.github.com/#x15.2.3.8
if (!Object.seal) {
    Object.seal = function seal(object) {
        // this is misleading and breaks feature-detection, but
        // allows "securable" code to "gracefully" degrade to working
        // but insecure code.
        return object;
    };
}
// ES5 15.2.3.9
// http://es5.github.com/#x15.2.3.9
if (!Object.freeze) {
    Object.freeze = function freeze(object) {
        // this is misleading and breaks feature-detection, but
        // allows "securable" code to "gracefully" degrade to working
        // but insecure code.
        return object;
    };
}
// detect a Rhino bug and patch it
try {
    Object.freeze(function () {});
} catch (exception) {
    Object.freeze = (function freeze(freezeObject) {
        return function freeze(object) {
            if (typeof object == "function") {
                return object;
            } else {
                return freezeObject(object);
            }
        };
    })(Object.freeze);
}
// ES5 15.2.3.10
// http://es5.github.com/#x15.2.3.10
if (!Object.preventExtensions) {
    Object.preventExtensions = function preventExtensions(object) {
        // this is misleading and breaks feature-detection, but
        // allows "securable" code to "gracefully" degrade to working
        // but insecure code.
        return object;
    };
}
// ES5 15.2.3.11
// http://es5.github.com/#x15.2.3.11
if (!Object.isSealed) {
    Object.isSealed = function isSealed(object) {
        return false;
    };
}
// ES5 15.2.3.12
// http://es5.github.com/#x15.2.3.12
if (!Object.isFrozen) {
    Object.isFrozen = function isFrozen(object) {
        return false;
    };
}
// ES5 15.2.3.13
// http://es5.github.com/#x15.2.3.13
if (!Object.isExtensible) {
    Object.isExtensible = function isExtensible(object) {
        // 1. If Type(O) is not Object throw a TypeError exception.
        if (Object(object) !== object) {
            throw new TypeError(); // TODO message
        }
        // 2. Return the Boolean value of the [[Extensible]] internal property of O.
        var name = '';
        while (owns(object, name)) {
            name += '?';
        }
        object[name] = true;
        var returnValue = owns(object, name);
        delete object[name];
        return returnValue;
    };
}
// ES5 15.2.3.14
// http://es5.github.com/#x15.2.3.14
if (!Object.keys) {
    // http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
    var hasDontEnumBug = true,
        dontEnums = [
            "toString",
            "toLocaleString",
            "valueOf",
            "hasOwnProperty",
            "isPrototypeOf",
            "propertyIsEnumerable",
            "constructor"
        ],
        dontEnumsLength = dontEnums.length;
    for (var key in {"toString": null}) {
        hasDontEnumBug = false;
    }
    Object.keys = function keys(object) {
        if ((typeof object != "object" && typeof object != "function") || object === null) {
            throw new TypeError("Object.keys called on a non-object");
        }
        var keys = [];
        for (var name in object) {
            if (owns(object, name)) {
                keys.push(name);
            }
        }
        if (hasDontEnumBug) {
            for (var i = 0, ii = dontEnumsLength; i < ii; i++) {
                var dontEnum = dontEnums[i];
                if (owns(object, dontEnum)) {
                    keys.push(dontEnum);
                }
            }
        }
        return keys;
    };
}
//
// Date
// ====
//
// ES5 15.9.5.43
// http://es5.github.com/#x15.9.5.43
// This function returns a String value represent the instance in time
// represented by this Date object. The format of the String is the Date Time
// string format defined in 15.9.1.15. All fields are present in the String.
// The time zone is always UTC, denoted by the suffix Z. If the time value of
// this object is not a finite Number a RangeError exception is thrown.
if (!Date.prototype.toISOString ||
    (new Date(-1).toISOString() !== '1969-12-31T23:59:59.999Z') ||
    (new Date(-62198755200000).toISOString().indexOf('-000001') === -1)) {
    Date.prototype.toISOString = function toISOString() {
        var result, length, value, year, month;
        if (!isFinite(this)) {
            throw new RangeError("Date.prototype.toISOString called on non-finite value.");
        }
        year = this.getUTCFullYear();
        month = this.getUTCMonth();
        // see https://github.com/kriskowal/es5-shim/issues/111
        year += Math.floor(month / 12);
        month = (month % 12 + 12) % 12;
        // the date time string format is specified in 15.9.1.15.
        result = [month + 1, this.getUTCDate(),
            this.getUTCHours(), this.getUTCMinutes(), this.getUTCSeconds()];
        year = (year < 0 ? '-' : (year > 9999 ? '+' : '')) + ('00000' + Math.abs(year)).slice(0 <= year && year <= 9999 ? -4 : -6);
        length = result.length;
        while (length--) {
            value = result[length];
            // pad months, days, hours, minutes, and seconds to have two digits.
            if (value < 10) {
                result[length] = "0" + value;
            }
        }
        // pad milliseconds to have three digits.
        return year + "-" + result.slice(0, 2).join("-") + "T" + result.slice(2).join(":") + "." +
            ("000" + this.getUTCMilliseconds()).slice(-3) + "Z";
    }
}
// ES5 15.9.4.4
// http://es5.github.com/#x15.9.4.4
if (!Date.now) {
    Date.now = function now() {
        return new Date().getTime();
    };
}
// ES5 15.9.5.44
// http://es5.github.com/#x15.9.5.44
// This function provides a String representation of a Date object for use by
// JSON.stringify (15.12.3).
function isPrimitive(input) {
    var t = typeof input;
    return input === null || t === "undefined" || t === "boolean" || t === "number" || t === "string";
}
function ToPrimitive(input) {
    var val, valueOf, toString;
    if (isPrimitive(input)) {
        return input;
    }
    valueOf = input.valueOf;
    if (typeof valueOf === "function") {
        val = valueOf.call(input);
        if (isPrimitive(val)) {
            return val;
        }
    }
    toString = input.toString;
    if (typeof toString === "function") {
        val = toString.call(input);
        if (isPrimitive(val)) {
            return val;
        }
    }
    throw new TypeError();
}
var dateToJSONIsSupported = false;
try {
    dateToJSONIsSupported = Date.prototype.toJSON && new Date(NaN).toJSON() === null;
} catch (e) {}
if (!dateToJSONIsSupported) {
    Date.prototype.toJSON = function toJSON(key) {
        // When the toJSON method is called with argument key, the following
        // steps are taken:
        // 1.  Let O be the result of calling ToObject, giving it the this
        // value as its argument.
        // 2. Let tv be ToPrimitive(O, hint Number).
        var o = Object(this),
            tv = ToPrimitive(o),
            toISO;
        // 3. If tv is a Number and is not finite, return null.
        if (typeof tv === 'number' && !isFinite(tv)) {
            return null;
        }
        // 4. Let toISO be the result of calling the [[Get]] internal method of
        // O with argument "toISOString".
        toISO = o.toISOString;
        // 5. If IsCallable(toISO) is false, throw a TypeError exception.
        if (typeof toISO != "function") {
            throw new TypeError('toISOString property is not callable');
        }
        // 6. Return the result of calling the [[Call]] internal method of
        //  toISO with O as the this value and an empty argument list.
        return toISO.call(o);
        // NOTE 1 The argument is ignored.
        // NOTE 2 The toJSON function is intentionally generic; it does not
        // require that its this value be a Date object. Therefore, it can be
        // transferred to other kinds of objects for use as a method. However,
        // it does require that any such object have a toISOString method. An
        // object is free to use the argument key to filter its
        // stringification.
    };
}
// ES5 15.9.4.2
// http://es5.github.com/#x15.9.4.2
// based on work shared by Daniel Friesen (dantman)
// http://gist.github.com/303249
if (!Date.parse || "Date.parse is buggy") {
    // XXX global assignment won't work in embeddings that use
    // an alternate object for the context.
    Date = (function(NativeDate) {
        // Date.length === 7
        var Date = function Date(Y, M, D, h, m, s, ms) {
            var length = arguments.length;
            if (this instanceof NativeDate) {
                var date = length == 1 && String(Y) === Y ? // isString(Y)
                    // We explicitly pass it through parse:
                    new NativeDate(Date.parse(Y)) :
                    // We have to manually make calls depending on argument
                    // length here
                    length >= 7 ? new NativeDate(Y, M, D, h, m, s, ms) :
                    length >= 6 ? new NativeDate(Y, M, D, h, m, s) :
                    length >= 5 ? new NativeDate(Y, M, D, h, m) :
                    length >= 4 ? new NativeDate(Y, M, D, h) :
                    length >= 3 ? new NativeDate(Y, M, D) :
                    length >= 2 ? new NativeDate(Y, M) :
                    length >= 1 ? new NativeDate(Y) :
                                  new NativeDate();
                // Prevent mixups with unfixed Date object
                date.constructor = Date;
                return date;
            }
            return NativeDate.apply(this, arguments);
        };
        // 15.9.1.15 Date Time String Format.
        var isoDateExpression = new RegExp("^" +
            "(\\d{4}|[\+\-]\\d{6})" + // four-digit year capture or sign + 6-digit extended year
            "(?:-(\\d{2})" + // optional month capture
            "(?:-(\\d{2})" + // optional day capture
            "(?:" + // capture hours:minutes:seconds.milliseconds
                "T(\\d{2})" + // hours capture
                ":(\\d{2})" + // minutes capture
                "(?:" + // optional :seconds.milliseconds
                    ":(\\d{2})" + // seconds capture
                    "(?:\\.(\\d{3}))?" + // milliseconds capture
                ")?" +
            "(" + // capture UTC offset component
                "Z|" + // UTC capture
                "(?:" + // offset specifier +/-hours:minutes
                    "([-+])" + // sign capture
                    "(\\d{2})" + // hours offset capture
                    ":(\\d{2})" + // minutes offset capture
                ")" +
            ")?)?)?)?" +
        "$");
        var monthes = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];
        function dayFromMonth(year, month) {
            var t = month > 1 ? 1 : 0;
            return monthes[month] + Math.floor((year - 1969 + t) / 4) - Math.floor((year - 1901 + t) / 100) + Math.floor((year - 1601 + t) / 400) + 365 * (year - 1970);
        }
        // Copy any custom methods a 3rd party library may have added
        for (var key in NativeDate) {
            Date[key] = NativeDate[key];
        }
        // Copy "native" methods explicitly; they may be non-enumerable
        Date.now = NativeDate.now;
        Date.UTC = NativeDate.UTC;
        Date.prototype = NativeDate.prototype;
        Date.prototype.constructor = Date;
        // Upgrade Date.parse to handle simplified ISO 8601 strings
        Date.parse = function parse(string) {
            var match = isoDateExpression.exec(string);
            if (match) {
                // parse months, days, hours, minutes, seconds, and milliseconds
                // provide default values if necessary
                // parse the UTC offset component
                var year = Number(match[1]),
                    month = Number(match[2] || 1) - 1,
                    day = Number(match[3] || 1) - 1,
                    hour = Number(match[4] || 0),
                    minute = Number(match[5] || 0),
                    second = Number(match[6] || 0),
                    millisecond = Number(match[7] || 0),
                    // When time zone is missed, local offset should be used (ES 5.1 bug)
                    // see https://bugs.ecmascript.org/show_bug.cgi?id=112
                    offset = !match[4] || match[8] ? 0 : Number(new Date(1970, 0)),
                    signOffset = match[9] === "-" ? 1 : -1,
                    hourOffset = Number(match[10] || 0),
                    minuteOffset = Number(match[11] || 0),
                    result;
                if (hour < (minute > 0 || second > 0 || millisecond > 0 ? 24 : 25) &&
                    minute < 60 && second < 60 && millisecond < 1000 &&
                    month > -1 && month < 12 && hourOffset < 24 && minuteOffset < 60 && // detect invalid offsets
                    day > -1 && day < dayFromMonth(year, month + 1) - dayFromMonth(year, month)) {
                    result = ((dayFromMonth(year, month) + day) * 24 + hour + hourOffset * signOffset) * 60;
                    result = ((result + minute + minuteOffset * signOffset) * 60 + second) * 1000 + millisecond + offset;
                    if (-8.64e15 <= result && result <= 8.64e15) {
                        return result;
                    }
                }
                return NaN;
            }
            return NativeDate.parse.apply(this, arguments);
        };
        return Date;
    })(Date);
}
//
// String
// ======
//
// ES5 15.5.4.20
// http://es5.github.com/#x15.5.4.20
var ws = "\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003" +
    "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028" +
    "\u2029\uFEFF";
if (!String.prototype.trim || ws.trim()) {
    // http://blog.stevenlevithan.com/archives/faster-trim-javascript
    // http://perfectionkills.com/whitespace-deviations/
    ws = "[" + ws + "]";
    var trimBeginRegexp = new RegExp("^" + ws + ws + "*"),
        trimEndRegexp = new RegExp(ws + ws + "*$");
    String.prototype.trim = function trim() {
        if (this === undefined || this === null) {
            throw new TypeError("can't convert "+this+" to object");
        }
        return String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");
    };
}
//
// Util
// ======
//
// ES5 9.4
// http://es5.github.com/#x9.4
// http://jsperf.com/to-integer
var toInteger = function (n) {
    n = +n;
    if (n !== n) { // isNaN
        n = 0;
    } else if (n !== 0 && n !== (1/0) && n !== -(1/0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
};
var prepareString = "a"[0] != "a";
    // ES5 9.9
    // http://es5.github.com/#x9.9
var toObject = function (o) {
    if (o == null) { // this matches both null and undefined
        throw new TypeError("can't convert "+o+" to object");
    }
    // If the implementation doesn't support by-index access of
    // string characters (ex. IE < 9), split the string
    if (prepareString && typeof o == "string" && o) {
        return o.split("");
    }
    return Object(o);
};
});
});

/*
Copyright 2011-14 Newcastle University
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/** @file Stuff to do with loading XML, and getting data out of XML. Provides {@link Numbas.xml}. */
Numbas.queueScript('xml',['base','jme'],function() {
/** @namespace Numbas.xml */
var xml = Numbas.xml = {
    /** DOM parser to use to parse XML
     * @type {DOMParser}
     * @private
     */
    dp: new DOMParser(),
    /** Load in all the XSLT/XML documents from {@link Numbas.rawxml} */
    loadXMLDocs: function()
    {
        var examXML = xml.examXML = xml.loadXML(Numbas.rawxml.examXML);
        var templates = xml.templates = {};
        for(var x in Numbas.rawxml.templates)
        {
            templates[x] = xml.loadXML(Numbas.rawxml.templates[x]);
            xml.localise(templates[x]);
        }
    },
    /** Load in a single XML document
     * @param {String} xmlstring
     * @returns {XMLDocument}
     */
    loadXML: function(xmlstring)
    {
        //parse the XML document
        var doc = xml.dp.parseFromString(xmlstring,'text/xml');
        //check for errors
        if(Sarissa.getParseErrorText(doc) != Sarissa.PARSED_OK)
        {
            throw(new Numbas.Error('xml.could not load',{message:Sarissa.getParseErrorText(doc)}));
        }
        //allow XPath to be used to select nodes
        doc.setProperty('SelectionLanguage','XPath');
        //convert all the attribute names to lower case
        var es = doc.selectNodes('descendant::*');
        for(var i=0; i<es.length; i++)
        {
            var e = es[i];
            var attrs = [];
            var j=0;
            for(j=0; j< e.attributes.length; j++)
            {
                attrs.push(e.attributes[j].name);
            }
            for(j=0; j< attrs.length; j++)
            {
                var name = attrs[j];
                if(name!=name.toLowerCase())
                {
                    var value = e.getAttribute(name);
                    e.removeAttribute(name);
                    e.setAttribute(name.toLowerCase(),value);
                }
            }
        }
        return doc;
    },
    /** Load user-defined functions from an XML node
     * @param {Element} xml
     * @returns {Numbas.jme.variables.func_data[]}
     */
    loadFunctions: function(xml)
    {
        var tmpFunctions = [];
        //work out functions
        var functionNodes = xml.selectNodes('functions/function');
        if(!functionNodes)
            return {};
        //first pass: get function names and types
        for(var i=0; i<functionNodes.length; i++)
        {
            var name = functionNodes[i].getAttribute('name').toLowerCase();
            var definition = functionNodes[i].getAttribute('definition');
            var language = functionNodes[i].getAttribute('language');
            var outtype = functionNodes[i].getAttribute('outtype').toLowerCase();
            var parameterNodes = functionNodes[i].selectNodes('parameters/parameter');
            var parameters = [];
            for(var j=0; j<parameterNodes.length; j++)
            {
                parameters.push({
                    name: parameterNodes[j].getAttribute('name'),
                    type: parameterNodes[j].getAttribute('type').toLowerCase()
                });
            }
            tmpFunctions.push({
                name: name,
                definition: definition,
                language: language,
                outtype: outtype,
                parameters: parameters
            });
        }
        return tmpFunctions;
    },
    /** Load variable definitions from an XML node
     * @param {Element} xml
     * @param {Numbas.jme.Scope} - scope to compile relative to
     * @returns {Numbas.jme.variables.variable_data_dict[]}
     */
    loadVariables: function(xml,scope) {
        var variableNodes = xml.selectNodes('variables/variable');    //get variable definitions out of XML
        if(!variableNodes)
            return {};
        //evaluate variables - work out dependency structure, then evaluate from definitions in correct order
        var todo = {};
        for( var i=0; i<variableNodes.length; i++ )
        {
            var name = variableNodes[i].getAttribute('name').toLowerCase();
            var value = Numbas.xml.getTextContent(variableNodes[i].selectSingleNode('value'));
            if(value.trim()=='') {
                throw(new Numbas.Error('jme.variables.empty definition',{name:name}));
            }
            try {
                var tree = Numbas.jme.compile(value);
            } catch(e) {
                throw(new Numbas.Error('variable.error in variable definition',{name:name}));
            }
            var vars = Numbas.jme.findvars(tree);
            todo[name]={
                tree: tree,
                vars: vars
            };
        }
        return todo;
    },
    /** Lots of the time we have a message stored inside content/html/.. structure.
     *
     * This pulls the message out and serializes it so it can be inserted easily with jQuery
     * @param {Element} node
     * @returns {String}
     */
    serializeMessage: function(node)
    {
        return new XMLSerializer().serializeToString(node.selectSingleNode('content'));
    },
    /** Get all the text belonging to an element
     * @param {Element} elem
     * @returns {String}
     */
    getTextContent: function(elem)
    {
        return $(elem).text();
    },
    /** Set the text content of an element
     * @param {Element} elem
     * @param {String} text
     */
    setTextContent: function(elem,text)
    {
        if(elem.textContent!==undefined)
            elem.textContent = text;
        else
            elem.text = text;
    },
    /** @typedef {Object} Numbas.xml.tryGetAttribute_options
     * @property {Boolean} string - Always return the attribute as a string.
     */
    /** Try to get attributes from an XML node, and use them to fill in an object's properties if they're present. If `obj` is null, then the loaded value is just returned.
     * @param {Object} obj - object to fill up
     * @param {Element} xmlroot - root XML element
     * @param {Element|String} elem - either an XML node to get attributes from, or an XPath query to get the element from `xmlroot`
     * @param {String[]} names - names of attributes to load
     * @param {String[]} [altnames] - names of object properties to associate with attribute names. If undefined, the attribute name is used.
     * @param {Numbas.xml.tryGetAttribute_options} options
     * @returns {Object} - The last attribute loaded.
     */
    tryGetAttribute: function(obj,xmlroot,elem,names,altnames,options)
    {
        if(!options)
            options = {};
        if(typeof(elem)=='string')    //instead of passing in an XML node to use, can give an XPath query, and we try to get that from xmlroot
            elem = xmlroot.selectSingleNode(elem);
        if(!elem)
            return false;
        if(typeof(names)=='string')
            names=[names];
        if(!altnames)
            altnames=[];
        else if(typeof(altnames)=='string')
            altnames=[altnames];
        for(var i=0;i<names.length;i++)
        {
            var value = elem.getAttribute(names[i].toLowerCase());    //try to get attribute from node
            if(value!==null)
            {
                //establish which field of target object we're filling in
                var name = altnames[i] ? altnames[i] : names[i];
                if(options.string)
                {
                }
                //if this property is already defined in the target object, cast the loaded value to the same type as the existing value
                else if(obj!==null && obj[name]!==undefined)
                {
                    if(value.length>0)
                    {
                        if(typeof(obj[name]) == 'number')
                        {
                            if(Numbas.util.isFloat(value))
                                value = parseFloat(value);
                            else if(Numbas.util.isFloat(Numbas.util.unPercent(value)))
                            {
                                value = Numbas.util.unPercent(value);
                            }
                            else
                                throw(new Numbas.Error('xml.property not number',{name:name,value:value,element:elem}));
                        }
                        else if(typeof(obj[name]) == 'boolean')
                        {
                            if(Numbas.util.isBool(value))
                                value = Numbas.util.parseBool(value);
                            else
                                throw(new Numbas.Error('xml.property not boolean',{name:name,value:value,element:elem}));
                        }
                        //otherwise must be a string, so leave it alone
                    }
                }
                else
                {
                    //automatically convert to a number or a boolean if possible
                    if(Numbas.util.isFloat(value))
                    {
                        value = parseFloat(value);
                    }
                    else if(Numbas.util.isBool(value))
                    {
                        value = Numbas.util.parseBool(value);
                    }
                }
                if(obj)
                    obj[name] = value;
            }
        }
        return value;
    },
    /** Replace every `<localise>` tag with its contents, run through localisation, i.e. get localised strings.
     * @param {Element} template
     */
    localise: function(template) {
        $(template).find('localise').each(function() {
            var localString = R($(this).text());
            $(this).replaceWith(localString);
        });
        return template;
    },
    /** Is the given node empty? True if it has no children.
     * @param {Element} node
     * @returns {Boolean}
     */
    isEmpty: function(node) {
        return node.childNodes.length==0;
    }
};
});

Numbas.queueScript('settings',[],function() {
    Numbas.custom_part_types = {};

    Numbas.rawxml = {
        templates: {
            question: "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!--\nCopyright 2011-16 Newcastle University\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n       http://www.apache.org/licenses/LICENSE-2.0\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n-->\n<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n    <xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\" indent=\"yes\" media-type=\"text/xhtml\" omit-xml-declaration=\"yes\"/>\n    <xsl:strip-space elements=\"p\"/>\n    <xsl:template match=\"question\">\n        <div class=\"question clearfix\" data-bind=\"with: question, visible: question.isCurrentQuestion\">\n            <form autocomplete=\"nope\">\n                <span style=\"display:none\">\\( \\begingroup \\)</span>\n                <h3 data-bind=\"text: displayName\" class=\"print-only\"></h3>\n                <xsl:apply-templates />\n                <span style=\"display: none\">\\( \\endgroup \\)</span>\n            </form>\n        </div>\n    </xsl:template>\n    <xsl:template match=\"properties|feedbacksettings|preview|notes|variables|preprocessing|preambles\" />\n    <xsl:template match=\"content\">\n        <xsl:apply-templates select=\"*\" mode=\"content\" />\n    </xsl:template>\n    <xsl:template match=\"@*|node()\" mode=\"content\">\n        <xsl:copy>\n            <xsl:apply-templates select=\"@*|node()\" mode=\"content\" />\n        </xsl:copy>\n    </xsl:template>\n    \n<xsl:template match=\"statement\">\n    <div class=\"statement content-area\" localise-data-jme-context-description=\"question.statement\">\n        <xsl:apply-templates />\n    </div>\n</xsl:template>\n\n    \n<xsl:template match=\"parts\">\n    <div class=\"parts\">\n        <xsl:apply-templates />\n    </div>\n</xsl:template>\n<xsl:template match=\"part\" mode=\"path\">\n    <xsl:choose>\n        <xsl:when test=\"parent::gaps\">\n            <xsl:apply-templates select=\"../..\" mode=\"path\" />\n            <xsl:text>g</xsl:text>\n        </xsl:when>\n        <xsl:when test=\"parent::steps\">\n            <xsl:apply-templates select=\"../..\" mode=\"path\" />\n            <xsl:text>s</xsl:text>\n        </xsl:when>\n        <xsl:when test=\"parent::parts\">\n            <xsl:text>p</xsl:text>\n        </xsl:when>\n    </xsl:choose>\n    <xsl:value-of select=\"count(preceding-sibling::part)\" />\n</xsl:template>\n<xsl:template match=\"part\">\n    <xsl:variable name=\"path\">\n        <xsl:apply-templates select=\".\" mode=\"path\"/>\n    </xsl:variable>\n    <xsl:variable name=\"inline\">\n        <xsl:choose>\n            <xsl:when test=\"ancestor::gaps and @type='1_n_2' and choices/@displaytype='dropdownlist'\"><xsl:text>true</xsl:text></xsl:when>\n            <xsl:when test=\"ancestor::gaps and not (choices)\"><xsl:text>true</xsl:text></xsl:when>\n            <xsl:otherwise></xsl:otherwise>\n        </xsl:choose>\n    </xsl:variable>\n    <xsl:variable name=\"tag\">\n        <xsl:choose>\n            <xsl:when test=\"$inline='true'\">span</xsl:when>\n            <xsl:otherwise>div</xsl:otherwise>\n        </xsl:choose>\n    </xsl:variable>\n    <xsl:variable name=\"clear\">\n        <xsl:choose>\n            <xsl:when test=\"ancestor::gaps\"></xsl:when>\n            <xsl:otherwise><xsl:text>clearfix</xsl:text></xsl:otherwise>\n        </xsl:choose>\n    </xsl:variable>\n    <xsl:variable name=\"block\">\n        <xsl:choose>\n        <xsl:when test=\"@type='m_n_2' or @type='m_n_x'\"><xsl:text> block</xsl:text></xsl:when>\n            <xsl:when test=\"@type='1_n_2' and @displaytype='radiogroup'\"><xsl:text> block</xsl:text></xsl:when>\n        </xsl:choose>\n    </xsl:variable>\n    <xsl:if test=\"parent::parts\">\n        <xsl:if test=\"count(../part) &gt; 1\">\n            <h4 class=\"partheader\"><xsl:number count=\"part\" format=\"a) \"/></h4>\n        </xsl:if>\n    </xsl:if>\n    <xsl:element name=\"{$tag}\">\n        <xsl:attribute name=\"class\">part <xsl:value-of select=\"$clear\"/> type-<xsl:value-of select=\"@type\"/> <xsl:value-of select=\"$block\"/><xsl:if test=\"parent::steps\"> step</xsl:if><xsl:if test=\"parent::gaps\"> gap</xsl:if></xsl:attribute>\n        <xsl:attribute name=\"data-bind\">with: question.display.getPart('<xsl:value-of select=\"$path\" />'), css: {dirty: question.display.getPart('<xsl:value-of select=\"$path\" />').isDirty}</xsl:attribute>\n        <xsl:attribute name=\"data-part-path\"><xsl:value-of select=\"$path\" /></xsl:attribute>\n        <xsl:attribute name=\"data-jme-context-description\"><xsl:value-of select=\"@jme-context-description\" /></xsl:attribute>\n        <xsl:if test=\"not(ancestor::gaps)\">\n            <xsl:apply-templates select=\"prompt\" />\n        </xsl:if>\n        <xsl:if test=\"count(steps/part)>0\">\n            <xsl:apply-templates select=\"steps\"/>\n        </xsl:if>\n        <span class=\"student-answer\">\n            <xsl:attribute name=\"data-bind\">css: {answered: scoreFeedback.answered}, attr: {\"feedback-state\": scoreFeedback.state}</xsl:attribute>\n            <xsl:apply-templates select=\".\" mode=\"typespecific\"/>\n            <span class=\"warning-icon icon-exclamation-sign\" data-bind=\"visible: warnings().length>0, hover: warningsShown, event: {{focus: showWarnings, blur: hideWarnings}}\" tabindex=\"0\"></span>\n            <span class=\"warnings alert alert-danger\" data-bind=\"foreach: warnings, visible: warningsShown\">\n                <span class=\"warning\" data-bind=\"latex: message\"></span>\n            </span>\n        </span>\n        <xsl:apply-templates select=\".\" mode=\"correctanswer\"/>\n        <xsl:if test=\"not(ancestor::gaps)\">\n            <div class=\"submit-and-feedback\">\n                <xsl:if test=\"count(../part) &gt; 1 or ancestor::steps\">\n                    <button class=\"btn btn-primary submitPart\" data-bind=\"visible: showSubmitPart, click: controls.submit\"><localise>question.submit part</localise></button>\n                </xsl:if>\n                <div class=\"feedbackMessages\" data-bind=\"visible: feedbackMessages().length>0\" localise-data-jme-context-description=\"part.feedback\">\n                    <p class=\"out-of-date-message\" data-bind=\"visible: isDirty\"><localise>part.feedback out of date</localise></p>\n                    <ol data-bind=\"visible: showFeedbackMessages, foreach: feedbackMessages\">\n                        <li class=\"feedbackMessage\" data-bind=\"attr: {{'data-credit-change': credit_change}}\"><span data-bind=\"visible: $parent.showFeedbackIcon, css: 'feedback-icon '+icon\"></span> <span data-bind=\"latex: message\"></span></li>\n                    </ol>\n                </div>\n                <div class=\"partFeedback\" data-bind=\"visible: showFeedbackBox\">\n                    <div class=\"marks\" data-bind=\"pulse: scoreFeedback.update, visible: showMarks()\">\n                        <span class=\"score\" data-bind=\"html: scoreFeedback.message\"></span>\n                        <span class=\"feedback-icon\" data-bind=\"visible: scoreFeedback.iconClass, css: scoreFeedback.iconClass, attr: scoreFeedback.iconAttr\"></span>\n                    </div>\n                    <small class=\"answered-state\" data-bind=\"html: scoreFeedback.answeredString\"></small>\n                </div>\n            </div>\n        </xsl:if>\n    </xsl:element>\n</xsl:template>\n<xsl:template match=\"part\" mode=\"typespecific\">\n    <localise>question.unsupported part type</localise> <xsl:text> </xsl:text> <xsl:value-of select=\"@type\"/>\n</xsl:template>\n<xsl:template match=\"part\" mode=\"correctanswer\">\n</xsl:template>\n\n    \n<xsl:template match=\"steps\">\n    <div class=\"steps well clearfix\" data-bind=\"slideVisible: stepsOpen\">\n        <xsl:apply-templates select=\"part\"/>\n    </div>\n    <div class=\"stepsBtn\">\n        <button class=\"btn btn-primary\" data-bind=\"visible: !stepsOpen(), click: controls.showSteps\"><localise>question.show steps</localise></button>\n        <button class=\"btn btn-primary\" data-bind=\"visible: stepsOpen(), click: controls.hideSteps\"><localise>question.hide steps</localise></button>\n        <span class=\"help-block hint penaltyMessage\">(<span data-bind=\"html: stepsPenaltyMessage\"></span>)</span>\n    </div>\n</xsl:template>\n\n    \n<xsl:template match=\"prompt\">\n    <span class=\"prompt content-area\" localise-data-jme-context-description=\"part.prompt\">\n        <xsl:apply-templates />\n    </span>\n</xsl:template>\n\n    \n<xsl:template match=\"advice\">\n    <div class=\"adviceContainer\" data-bind=\"visible: adviceDisplayed\" localise-data-jme-context-description=\"question.advice\">\n        <h3><localise>question.advice</localise></h3>\n        <span class=\"adviceDisplay content-area\">\n            <xsl:apply-templates />\n        </span>\n    </div>\n</xsl:template>\n\n    \n<xsl:template match=\"part[@type='1_n_2']\" mode=\"typespecific\">\n    <xsl:apply-templates select=\"choices\" mode=\"one\"/>\n    <span class=\"feedback-icon\" data-bind=\"css: scoreFeedback.iconClass, attr: scoreFeedback.iconAttr\"></span>\n</xsl:template>\n<xsl:template match=\"part[@type='1_n_2']\" mode=\"correctanswer\">\n    <span class=\"correct-answer\" data-bind=\"visibleIf: showCorrectAnswer, typeset: showCorrectAnswer\">\n        <localise>part.correct answer</localise>\n        <xsl:apply-templates select=\"choices\" mode=\"correctanswer\"/>\n    </span>\n</xsl:template>\n\n    \n<xsl:template match=\"part[@type='m_n_2']\" mode=\"typespecific\">\n    <xsl:apply-templates select=\"choices\" mode=\"one\"/>\n    <span class=\"feedback-icon\" data-bind=\"css: scoreFeedback.iconClass, attr: scoreFeedback.iconAttr\"></span>\n</xsl:template>\n<xsl:template match=\"part[@type='m_n_2']\" mode=\"correctanswer\">\n    <div class=\"correct-answer\" data-bind=\"visibleIf: showCorrectAnswer, typeset: showCorrectAnswer\">\n        <localise>part.correct answer</localise>\n        <xsl:apply-templates select=\"choices\" mode=\"correctanswer\"/>\n    </div>\n</xsl:template>\n\n    \n<xsl:template match=\"choices\" mode=\"one\">\n    <xsl:variable name=\"displaytype\"><xsl:value-of select=\"@displaytype\"/></xsl:variable>\n    <span localise-data-jme-context-description=\"part.mcq.choices\">\n    <xsl:choose>\n        <xsl:when test=\"@displaytype='radiogroup'\">\n            <ul class=\"multiplechoice\" data-bind=\"reorder_list: {{order: part.shuffleAnswers}}, css: {{'show-cell-answer-state': showCellAnswerState, 'columns': displayColumns}}\">\n                <xsl:variable name=\"cols\" select=\"@displaycolumns\"/>\n                <xsl:if test=\"$cols>0\"> \n                    <xsl:attribute name=\"style\">grid-template-columns: repeat(<xsl:number value=\"$cols\"/>,max-content);</xsl:attribute>\n                </xsl:if>\n                <xsl:apply-templates select=\"choice\" mode=\"radiogroup\"/>\n            </ul>\n        </xsl:when>\n        <xsl:when test=\"@displaytype='checkbox'\">\n            <ul class=\"multiplechoice\" data-bind=\"reorder_list: {{order: part.shuffleAnswers}}, css: {{'show-cell-answer-state': showCellAnswerState, 'columns': displayColumns}}\">\n                <xsl:variable name=\"cols\" select=\"@displaycolumns\"/>\n                <xsl:if test=\"$cols>0\"> \n                    <xsl:attribute name=\"style\">grid-template-columns: repeat(<xsl:number value=\"$cols\"/>,max-content);</xsl:attribute>\n                </xsl:if>\n                <xsl:apply-templates select=\"choice\" mode=\"checkbox\"/>\n            </ul>\n        </xsl:when>\n        <xsl:when test=\"@displaytype='dropdownlist'\">\n            <select class=\"multiplechoice\" data-bind=\"value: studentAnswer, disable: revealed, reorder_list: {{order: part.shuffleAnswers, leaders: 1}}, css: {{'show-cell-answer-state': showCellAnswerState}}\">\n                <option value=\"\"></option>\n                <xsl:apply-templates select=\"choice\" mode=\"dropdownlist\"/>\n            </select>\n        </xsl:when>\n    </xsl:choose>\n    </span>\n</xsl:template>\n<xsl:template match=\"choices\" mode=\"correctanswer\">\n    <xsl:variable name=\"displaytype\"><xsl:value-of select=\"@displaytype\"/></xsl:variable>\n    <span>\n    <xsl:choose>\n        <xsl:when test=\"@displaytype='radiogroup'\">\n            <ul class=\"multiplechoice\" data-bind=\"reorder_list: {{order: part.shuffleAnswers}}\">\n                <xsl:apply-templates select=\"choice\" mode=\"radiogroup-correctanswer\"/>\n            </ul>\n        </xsl:when>\n        <xsl:when test=\"@displaytype='checkbox'\">\n            <ul class=\"multiplechoice\" data-bind=\"reorder_list: {{order: part.shuffleAnswers}}\">\n                <xsl:apply-templates select=\"choice\" mode=\"checkbox-correctanswer\"/>\n            </ul>\n        </xsl:when>\n        <xsl:when test=\"@displaytype='dropdownlist'\">\n            <select class=\"multiplechoice\" data-bind=\"value: correctAnswer, reorder_list: {{order: part.shuffleAnswers, leaders: 1}}\" disabled=\"true\">\n                <option value=\"\"></option>\n                <xsl:apply-templates select=\"choice\" mode=\"dropdownlist-correctanswer\"/>\n            </select>\n        </xsl:when>\n    </xsl:choose>\n    </span>\n</xsl:template>\n<xsl:template match=\"choice\" mode=\"radiogroup\">\n    <xsl:variable name=\"path\">\n        <xsl:apply-templates select=\"../..\" mode=\"path\"/>\n    </xsl:variable>\n    <xsl:variable name=\"choicenum\"><xsl:value-of select=\"count(preceding-sibling::choice)\"/></xsl:variable>\n    <li>\n        <xsl:attribute name=\"data-bind\">css: {checked: studentAnswer()==<xsl:value-of select=\"$choicenum\"/>, correct: studentAnswer()==<xsl:value-of select=\"$choicenum\"/> &amp;&amp; correctAnswer()==<xsl:value-of select=\"$choicenum\"/>}</xsl:attribute>\n        <label>\n            <input type=\"radio\" class=\"choice\" name=\"{$path}-choice\" data-bind=\"checked: studentAnswer, disable: revealed\" value=\"{$choicenum}\"/>\n            <xsl:apply-templates select=\"content\"/>\n        </label>\n    </li>\n</xsl:template>\n<xsl:template match=\"choice\" mode=\"radiogroup-correctanswer\">\n    <xsl:variable name=\"path\">\n        <xsl:apply-templates select=\"../..\" mode=\"path\"/>\n    </xsl:variable>\n    <xsl:variable name=\"choicenum\"><xsl:value-of select=\"count(preceding-sibling::choice)\"/></xsl:variable>\n    <li>\n        <label>\n            <input type=\"radio\" class=\"choice\" name=\"{$path}-choice-correctanswer\" data-bind=\"checked: correctAnswer()+''\" disabled=\"true\" value=\"{$choicenum}\"/>\n            <xsl:apply-templates select=\"content\"/>\n        </label>\n    </li>\n</xsl:template>\n<xsl:template match=\"choice\" mode=\"checkbox\">\n    <xsl:variable name=\"choicenum\"><xsl:value-of select=\"count(preceding-sibling::choice)\"/></xsl:variable>\n    <li>\n        <xsl:attribute name=\"data-bind\">css: {checked: ticks[<xsl:value-of select=\"$choicenum\"/>], correct: ticks[<xsl:value-of select=\"$choicenum\"/>] &amp;&amp; correctTicks[<xsl:value-of select=\"$choicenum\"/>]}</xsl:attribute>\n        <label>\n            <input type=\"checkbox\" class=\"choice\" name=\"choice\" data-bind=\"checked: ticks[{$choicenum}], disable: revealed\" />\n            <xsl:apply-templates select=\"content\"/>\n        </label>\n    </li>\n</xsl:template>\n<xsl:template match=\"choice\" mode=\"checkbox-correctanswer\">\n    <xsl:variable name=\"choicenum\"><xsl:value-of select=\"count(preceding-sibling::choice)\"/></xsl:variable>\n    <li>\n        <label>\n            <input type=\"checkbox\" class=\"choice\" name=\"choice\" data-bind=\"checked: correctTicks[{$choicenum}]\" disabled=\"true\" />\n            <xsl:apply-templates select=\"content\"/>\n        </label>\n    </li>\n</xsl:template>\n<xsl:template match=\"choice\" mode=\"dropdownlist\">\n    <xsl:variable name=\"choicenum\"><xsl:value-of select=\"count(preceding-sibling::choice)\"/></xsl:variable>\n    <option value=\"{$choicenum}\">\n        <xsl:apply-templates select=\"content\"/>\n    </option>\n</xsl:template>\n<xsl:template match=\"choice\" mode=\"dropdownlist-correctanswer\">\n    <xsl:variable name=\"choicenum\"><xsl:value-of select=\"count(preceding-sibling::choice)\"/></xsl:variable>\n    <option value=\"{$choicenum}\">\n        <xsl:apply-templates select=\"content\"/>\n    </option>\n</xsl:template>\n<xsl:template match=\"distractor\">\n    <span><xsl:apply-templates /></span>\n</xsl:template>\n\n    \n<xsl:template match=\"part[@type='m_n_x']\" mode=\"typespecific\">\n    <xsl:variable name=\"displaytype\" select=\"choices/@displaytype\"/>\n    <form autocomplete=\"nope\">\n        <table class=\"choices-grid\" data-bind=\"reorder_table: {{rows: part.shuffleChoices, columns: part.shuffleAnswers, leaders: 1}}, css: {{'show-cell-answer-state': showCellAnswerState}}\">\n            <thead localise-data-jme-context-description=\"part.mcq.answers\">\n                <td/>\n                <xsl:for-each select=\"answers/answer\">\n                    <th><xsl:apply-templates select=\"content\"/></th>\n                </xsl:for-each>\n            </thead>\n            <tbody>\n                <xsl:for-each select=\"choices/choice\">\n                    <xsl:apply-templates select=\".\" mode=\"m_n_x\">\n                        <xsl:with-param name=\"displaytype\" select=\"$displaytype\"/>\n                    </xsl:apply-templates>\n                </xsl:for-each>\n            </tbody>\n        </table>\n    </form>\n    <span class=\"feedback-icon\" data-bind=\"css: scoreFeedback.iconClass, attr: scoreFeedback.iconAttr\"></span>\n</xsl:template>\n<xsl:template match=\"part[@type='m_n_x']\" mode=\"correctanswer\">\n    <xsl:variable name=\"displaytype\" select=\"choices/@displaytype\"/>\n    <div class=\"correct-answer\" data-bind=\"visibleIf: showCorrectAnswer, typeset: showCorrectAnswer\">\n        <localise>part.correct answer</localise>\n        <form autocomplete=\"nope\">\n        <table class=\"choices-grid\" data-bind=\"reorder_table: {{rows: part.shuffleChoices, columns: part.shuffleAnswers, leaders: 1}}\">\n            <thead>\n                <td/>\n                <xsl:for-each select=\"answers/answer\">\n                    <th><xsl:apply-templates select=\"content\"/></th>\n                </xsl:for-each>\n            </thead>\n            <tbody>\n                <xsl:for-each select=\"choices/choice\">\n                    <xsl:apply-templates select=\".\" mode=\"m_n_x-correctanswer\">\n                        <xsl:with-param name=\"displaytype\" select=\"$displaytype\"/>\n                    </xsl:apply-templates>\n                </xsl:for-each>\n            </tbody>\n        </table>\n        </form>\n    </div>\n</xsl:template>\n<xsl:template match=\"choice\" mode=\"m_n_x\">\n    <xsl:param name=\"displaytype\"/>\n    <xsl:variable name=\"path\">\n        <xsl:apply-templates select=\"../..\" mode=\"path\"/>\n    </xsl:variable>\n    <xsl:variable name=\"answers\" select=\"../../answers\"/>\n    <xsl:variable name=\"choicenum\" select=\"count(preceding-sibling::choice)\"/>\n    <tr>\n        <td class=\"choice\"><xsl:apply-templates select=\"content\"/></td>\n        <xsl:for-each select=\"$answers/answer\">\n            <xsl:variable name=\"answernum\" select=\"count(preceding-sibling::answer)\"/>\n            <td class=\"option\">\n                <xsl:choose>\n                    <xsl:when test=\"$displaytype='checkbox'\">\n                        <xsl:attribute name=\"data-bind\">css: {checked: ticks[<xsl:value-of select=\"$answernum\"/>][<xsl:value-of select=\"$choicenum\"/>], correct: ticks[<xsl:value-of select=\"$answernum\"/>][<xsl:value-of select=\"$choicenum\"/>] &amp;&amp; correctTicks[<xsl:value-of select=\"$answernum\"/>][<xsl:value-of select=\"$choicenum\"/>]}</xsl:attribute>\n                        <input type=\"checkbox\" class=\"choice\" name=\"${path}-choice-{$choicenum}\" data-bind=\"checked: ticks[{$answernum}][{$choicenum}], disable: revealed, visible: layout[{$answernum}][{$choicenum}]\" />\n                    </xsl:when>\n                    <xsl:when test=\"$displaytype='radiogroup'\">\n                        <xsl:attribute name=\"data-bind\">css: {checked: ticks[<xsl:value-of select=\"$choicenum\"/>]()==<xsl:value-of select=\"$answernum\"/>, correct: ticks[<xsl:value-of select=\"$choicenum\"/>]()==<xsl:value-of select=\"$answernum\"/> &amp;&amp; correctTicks[<xsl:value-of select=\"$choicenum\"/>]==<xsl:value-of select=\"$answernum\"/>}</xsl:attribute>\n                        <input type=\"radio\" class=\"choice\" name=\"${path}-choice-{$choicenum}\" data-bind=\"checked: ticks[{$choicenum}], disable: revealed, visible: layout[{$answernum}][{$choicenum}]\" value=\"{$answernum}\"/>\n                    </xsl:when>\n                </xsl:choose>\n            </td>\n        </xsl:for-each>\n    </tr>\n</xsl:template>\n<xsl:template match=\"choice\" mode=\"m_n_x-correctanswer\">\n    <xsl:param name=\"displaytype\"/>\n    <xsl:variable name=\"path\">\n        <xsl:apply-templates select=\"../..\" mode=\"path\"/>\n    </xsl:variable>\n    <xsl:variable name=\"answers\" select=\"../../answers\"/>\n    <xsl:variable name=\"choicenum\" select=\"count(preceding-sibling::choice)\"/>\n    <tr>\n        <td class=\"choice\"><xsl:apply-templates select=\"content\"/></td>\n        <xsl:for-each select=\"$answers/answer\">\n            <xsl:variable name=\"answernum\" select=\"count(preceding-sibling::answer)\"/>\n            <td class=\"option\">\n                <xsl:choose>\n                    <xsl:when test=\"$displaytype='checkbox'\">\n                        <input type=\"checkbox\" class=\"choice\" name=\"{$path}-choice-{$choicenum}\" data-bind=\"checked: correctTicks[{$answernum}][{$choicenum}], visible: layout[{$answernum}][{$choicenum}], disable: true\" disabled=\"true\"/>\n                    </xsl:when>\n                    <xsl:when test=\"$displaytype='radiogroup'\">\n                        <input type=\"radio\" class=\"choice\" name=\"{$path}-choice-{$choicenum}\" data-bind=\"checked: correctTicks[{$choicenum}]+'', visible: layout[{$answernum}][{$choicenum}], disable: true\" disabled=\"true\" value=\"{$answernum}\"/>\n                    </xsl:when>\n                </xsl:choose>\n            </td>\n        </xsl:for-each>\n    </tr>\n</xsl:template>\n\n    \n<xsl:template match=\"part[@type='patternmatch']\" mode=\"typespecific\">\n    <xsl:if test=\"count(steps/part)>0\"><localise>part.with steps answer prompt</localise></xsl:if>\n    <input type=\"text\" spellcheck=\"false\" class=\"patternmatch\" size=\"12.5\" data-bind=\"event: inputEvents, textInput: studentAnswer, autosize: true, disable: revealed\"></input>\n    <span class=\"feedback-icon\" data-bind=\"css: scoreFeedback.iconClass, attr: scoreFeedback.iconAttr\"></span>\n</xsl:template>\n<xsl:template match=\"part[@type='patternmatch']\" mode=\"correctanswer\">\n    <span class=\"correct-answer\" data-bind=\"visibleIf: showCorrectAnswer, typeset: showCorrectAnswer\">\n        <localise>part.correct answer</localise>\n        <input type=\"text\" spellcheck=\"false\" disabled=\"true\" class=\"patternmatch\" data-bind=\"value: displayAnswer, autosize: true\"/>\n    </span>\n</xsl:template>\n\n    \n<xsl:template match=\"part[@type='gapfill']\" mode=\"typespecific\">\n</xsl:template>\n<xsl:template match=\"part[@type='gapfill']\" mode=\"correctanswer\">\n</xsl:template>\n<xsl:template match=\"gapfill\" mode=\"content\">\n    <xsl:variable name=\"n\"><xsl:value-of select=\"@reference\"/></xsl:variable>\n    <xsl:apply-templates select=\"ancestor::part[1]/gaps/part[$n+1]\" />\n</xsl:template>\n\n    \n<xsl:template match=\"part[@type='jme']\" mode=\"typespecific\">\n    <xsl:if test=\"count(steps/part)>0\"><localise>part.with steps answer prompt</localise></xsl:if>\n    <input type=\"text\" spellcheck=\"false\" class=\"jme\" data-bind=\"event: inputEvents, textInput: studentAnswer, autosize: true, disable: revealed\"/>\n    <span class=\"jme-preview\" data-bind=\"visible: showPreview &amp;&amp; studentAnswerLaTeX(), maths: showPreview ? '\\\\displaystyle{{'+studentAnswerLaTeX()+'}}' : '', click: focusInput\"></span>\n    <span class=\"feedback-icon\" data-bind=\"css: scoreFeedback.iconClass, attr: scoreFeedback.iconAttr\"></span>\n</xsl:template>\n<xsl:template match=\"part[@type='jme']\" mode=\"correctanswer\">\n    <span class=\"correct-answer\" data-bind=\"visibleIf: showCorrectAnswer, typeset: showCorrectAnswer\">\n        <localise>part.correct answer</localise>\n        <input type=\"text\" spellcheck=\"false\" disabled=\"true\" class=\"jme\" data-bind=\"value: correctAnswer, autosize: true\"/>\n        <span class=\"jme-preview\" data-bind=\"maths: '\\\\displaystyle{{'+correctAnswerLaTeX+'}}'\"></span>\n    </span>\n</xsl:template>\n\n    \n<xsl:template match=\"part[@type='numberentry']\" mode=\"typespecific\">\n    <xsl:if test=\"count(steps/part)>0\"><localise>part.with steps answer prompt</localise></xsl:if>\n    <input type=\"text\" step=\"{answer/inputstep/@value}\" class=\"numberentry\" data-bind=\"event: inputEvents, textInput: studentAnswer, autosize: true, disable: revealed\"/>\n    <span class=\"preview\" data-bind=\"visible: showPreview &amp;&amp; studentAnswerLaTeX(), maths: showPreview ? studentAnswerLaTeX() : '', click: focusInput\"></span>\n    <span class=\"help-block hint precision-hint\" data-bind=\"visible: showPrecisionHint, html: precisionHint\"></span>\n    <span class=\"feedback-icon\" data-bind=\"css: scoreFeedback.iconClass, attr: scoreFeedback.iconAttr\"></span>\n</xsl:template>\n<xsl:template match=\"part[@type='numberentry']\" mode=\"correctanswer\">\n    <span class=\"correct-answer\" data-bind=\"visibleIf: showCorrectAnswer, typeset: showCorrectAnswer\">\n        <localise>part.correct answer</localise>\n        <input type=\"text\" spellcheck=\"false\" disabled=\"true\" class=\"jme\" data-bind=\"value: correctAnswer, autosize: true\"/>\n        <span data-bind=\"\"></span>\n    </span>\n</xsl:template>\n\n    \n<xsl:template match=\"part[@type='matrix']\" mode=\"typespecific\">\n    <xsl:if test=\"count(steps/part)>0\"><localise>part.with steps answer prompt</localise></xsl:if>\n    <span><matrix-input params=\"rows: studentAnswerRows, columns: studentAnswerColumns, value: studentAnswer, allowResize: allowResize, disable: revealed\" data-bind=\"event: inputEvents\"></matrix-input></span>\n    <span class=\"preview\" data-bind=\"visible: showPreview &amp;&amp; studentAnswerLaTeX(), maths: showPreview ? studentAnswerLaTeX() : ''\"></span>\n    <span class=\"feedback-icon\" data-bind=\"css: scoreFeedback.iconClass, attr: scoreFeedback.iconAttr\"></span>\n</xsl:template>\n<xsl:template match=\"part[@type='matrix']\" mode=\"correctanswer\">\n    <span class=\"correct-answer\" data-bind=\"visibleIf: showCorrectAnswer, typeset: showCorrectAnswer\">\n        <localise>part.correct answer</localise>\n        <span data-bind=\"maths: correctAnswerLaTeX\"></span>\n    </span>\n</xsl:template>\n\n    \n<xsl:template match=\"part[@type='information']\" mode=\"typespecific\">\n</xsl:template>\n<xsl:template match=\"part[@type='information']\" mode=\"correctanswer\">\n</xsl:template>\n\n    \n<xsl:template match=\"part[@type='extension']\" mode=\"typespecific\">\n</xsl:template>\n<xsl:template match=\"part[@type='extension']\" mode=\"correctanswer\">\n</xsl:template>\n\n    \n<xsl:template match=\"part[@custom='true']\" mode=\"typespecific\">\n    <xsl:if test=\"count(steps/part)>0\"><localise>part.with steps answer prompt</localise></xsl:if>\n    <span data-bind=\"event: inputEvents, component: {{name: 'answer-widget', params: {{answer: studentAnswer, widget: input_widget, widget_options: input_options, part: part}}}}\"></span>\n    <span class=\"help-block hint\" data-bind=\"visible: input_options.hint, html: input_options.hint, typeset: input_options.hint\"></span>\n    <span class=\"feedback-icon\" data-bind=\"css: scoreFeedback.iconClass, attr: scoreFeedback.iconAttr\"></span>\n</xsl:template>\n<xsl:template match=\"part[@custom='true']\" mode=\"correctanswer\">\n    <span class=\"correct-answer\" data-bind=\"visibleIf: showCorrectAnswer, typeset: showCorrectAnswer\">\n        <localise>part.correct answer</localise>\n        <span data-bind=\"component: {{name: 'answer-widget', params: {{answer: correctAnswer, widget: input_widget, widget_options: input_options, part: $data, disable: true}}}}\"></span>\n    </span>\n</xsl:template>\n\n</xsl:stylesheet>"
        },

        examXML: "<exam name=\"Week1Exam\" percentPass=\"0%\"><settings><navigation allowregen=\"True\" browse=\"True\" preventleave=\"True\" reverse=\"True\" showfrontpage=\"True\" showresultspage=\"True\"><event action=\"none\" type=\"onleave\"><content><span /></content></event></navigation><timing allowPause=\"True\" duration=\"0\"><event action=\"none\" type=\"timeout\"><content><span /></content></event><event action=\"none\" type=\"timedwarning\"><content><span /></content></event></timing><feedback allowrevealanswer=\"True\" showactualmark=\"True\" showanswerstate=\"True\" showstudentname=\"True\" showtotalmark=\"True\"><intro><content><span /></content></intro><feedbackmessages /></feedback><rulesets /></settings><functions /><variables /><question_groups showQuestionGroupNames=\"True\"><question_group name=\"Solve proportions (9-C.5)\" pickQuestions=\"1\" pickingStrategy=\"all-ordered\"><questions><question name=\"Recipe Proportions\"><statement><content><span><p>The recipe below makes {m} fruit cakes.</p>\n<p> $\\var{100*{m}}$ g self-raising flour</p>\n<p>$ \\var{75*{m}}$ g caster sugar</p>\n<p>$\\var{50*{m}}$ g margarine</p>\n<p>$ \\var{60*{m}}$ g mixed fruit</p>\n<p>$ \\var{1.5* {m}} $ eggs</p>\n<p /></span></content></statement><parts><part enableminimummarks=\"True\" marks=\"0\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"gapfill\"><prompt><content><span><p>Suppose that you want to make {n} cakes.</p>\n<p>How much {ing1} would you need? Give your answer in grams.</p>\n<p><gapfill reference=\"0\" /> g</p>\n<p>How much {ing2} would you need? Give your answer in kg.</p>\n<p><gapfill reference=\"1\" /> kg</p></span></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><gaps><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span /></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"False\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"{ing1mult}*{n}\" minvalue=\"{ing1mult}*{n}\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"en,si-en,plain\"><precision partialcredit=\"0%\" precision=\"0\" showprecisionhint=\"False\" strict=\"True\" type=\"none\"><message><content><span /></content></message></precision></answer></part><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span /></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"False\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"{ing2mult}*{n}/1000\" minvalue=\"{ing2mult}*{n}/1000\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"en,si-en,plain\"><precision partialcredit=\"0%\" precision=\"0\" showprecisionhint=\"False\" strict=\"True\" type=\"none\"><message><content><span /></content></message></precision></answer></part></gaps><marking sortanswers=\"False\" /></part></parts><advice><content><span><p>Since the recipe is for {m} cakes and you want to make {n} cakes you will need to multiply the amount of each ingredient by $  \\dfrac{\\var{n}}{\\var{m}}$ or $\\simplify{{n}/{m}}$.</p>\n<p />\n<p>See <a href=\"http://www.mathsisfun.com/numbers/ratio.html\" target=\"_blank\">http://www.mathsisfun.com/numbers/ratio.html </a> for more information about ratios and proportions.</p></span></content></advice><notes /><variables condition=\"\" maxRuns=\"100\"><variable name=\"ing2\"><value>switch( ing1 ='flour', random ( 'sugar', 'margarine', 'fruit'),ing1='sugar', random('flour', 'margarine', 'fruit'), ing1='margarine', random('flour', 'sugar','fruit'), random ('flour', 'sugar', 'margarine'))</value></variable><variable name=\"ing1\"><value>random( 'flour', 'sugar', 'margarine', 'fruit')</value></variable><variable name=\"ing1mult\"><value>switch( ing1 = 'flour', 100, ing1='sugar', 75, ing1='margarine', 50, ing1='fruit', 60)</value></variable><variable name=\"ing2mult\"><value>switch( ing2 = 'flour', 100, ing2='sugar', 75, ing2='margarine', 50, ing2='fruit', 60)</value></variable><variable name=\"m\"><value>random(2,4,6)</value></variable><variable name=\"n\"><value>switch( m=2, random(4,8,10,12), m=4, random(2,8,12), m=6,random(2, 12))</value></variable></variables><functions /><preambles nosubvars=\"true\"><preamble language=\"css\" /><preamble language=\"js\" /></preambles><rulesets /></question><question name=\"Scaling up ratios\"><statement><content><span><p>There are {axbx} people at a wedding, with adults to children in a ratio of {a}:{b}.</p></span></content></statement><parts><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span><p>How many adults are there?</p></span></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"False\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"{ax}\" minvalue=\"{ax}\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"plain,en,si-en\"><precision partialcredit=\"0%\" precision=\"0\" showprecisionhint=\"True\" strict=\"True\" type=\"none\"><message><content><span /></content></message></precision></answer></part><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span><p>How many children are there?</p></span></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"False\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"{bx}\" minvalue=\"{bx}\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"plain,en,si-en\"><precision partialcredit=\"0%\" precision=\"0\" showprecisionhint=\"True\" strict=\"True\" type=\"none\"><message><content><span /></content></message></precision></answer></part></parts><advice><content><span><p>Remember:</p>\n<p>Add the two parts of the ratio together to give the total number of parts.</p>\n<p>Divide the number of people at the wedding by the total number of parts.</p>\n<p>Multiply this by each \"side\" of the ratio to give the actual number of adults and children that are present at the wedding.</p></span></content></advice><notes /><variables condition=\"\" maxRuns=\"100\"><variable name=\"y\"><value>random(2..10)</value></variable><variable name=\"axbx\"><value>ax+bx</value></variable><variable name=\"d\"><value>random(1..6)</value></variable><variable name=\"b\"><value>random(1..6)</value></variable><variable name=\"cydy\"><value>cy+dy</value></variable><variable name=\"dy\"><value>d*y</value></variable><variable name=\"cy\"><value>c*y</value></variable><variable name=\"ax\"><value>a*x</value></variable><variable name=\"bx\"><value>b*x</value></variable><variable name=\"a\"><value>random(1..6)</value></variable><variable name=\"x\"><value>random(2..10)</value></variable><variable name=\"c\"><value>random(1..6)</value></variable></variables><functions /><preambles nosubvars=\"true\"><preamble language=\"css\" /><preamble language=\"js\" /></preambles><rulesets /></question><question name=\"Q2 Ratios\"><statement><content><span><p>Solve the following to the nearest whole number:</p></span></content></statement><parts><part enableminimummarks=\"True\" marks=\"0\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"gapfill\"><prompt><content><span><p>A piece of $\\var{material}$ $\\var{lent}$ cm long is cut into three pieces in the ratio of $\\var{numberone}$ to $\\var{numbertwo}$ to $\\var{numberthree}$. Determine the lengths of the three pieces.</p>\n<p><gapfill reference=\"0\" />cm</p>\n<p><gapfill reference=\"1\" />cm</p>\n<p><gapfill reference=\"2\" />cm</p></span></content></prompt><steps><part enableminimummarks=\"True\" marks=\"0\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"information\"><prompt><content><span><p>Imagine that the $\\var{material}$ is divided into $\\var{numberone}$ + $\\var{numbertwo}$ +$\\var{numberthree}$ pieces. The first piece should be $\\var{numberone}$ times its length. The second piece should be $\\var{numbertwo}$ times this length. The third piece should be $\\var{numberthree}$ times this length.</p>\n<p>Double check: When you add up your pieces they should add to $\\var{lent}$.</p></span></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /></part></steps><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><gaps><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span /></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"False\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"{ansone}\" minvalue=\"{ansone}\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"en,si-en,plain\"><precision partialcredit=\"0%\" precision=\"2.00000000000000\" showprecisionhint=\"False\" strict=\"False\" type=\"dp\"><message><content><span>You have not given your answer to the correct precision.</span></content></message></precision></answer></part><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span /></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"False\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"{anstwo}\" minvalue=\"{anstwo}\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"en,si-en,plain\"><precision partialcredit=\"0%\" precision=\"2.00000000000000\" showprecisionhint=\"False\" strict=\"False\" type=\"dp\"><message><content><span>You have not given your answer to the correct precision.</span></content></message></precision></answer></part><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span /></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"False\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"{ansthree}\" minvalue=\"{ansthree}\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"en,si-en,plain\"><precision partialcredit=\"0%\" precision=\"2.00000000000000\" showprecisionhint=\"False\" strict=\"False\" type=\"dp\"><message><content><span>You have not given your answer to the correct precision.</span></content></message></precision></answer></part></gaps><marking sortanswers=\"False\" /></part><part enableminimummarks=\"True\" marks=\"0\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"gapfill\"><prompt><content><span><p>Divide $\\var{total}$ in the ratio $\\var{numberone1}$:$\\var{numbertwo1}$:$\\var{numberfour}$.</p>\n<p><gapfill reference=\"0\" /></p>\n<p><gapfill reference=\"1\" /></p>\n<p><gapfill reference=\"2\" /></p></span></content></prompt><steps><part enableminimummarks=\"True\" marks=\"0\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"information\"><prompt><content><span><p>Divide $\\var{total}$  into $\\var{numberone1}$  + $\\var{numbertwo1}$  + $\\var{numberfour}$ parts. Each of these parts contain $\\var{k}$.</p>\n<p>Find $k \\times \\var{numberone}$</p>\n<p>Find $k \\times \\var{numbertwo}$</p>\n<p>Find $k \\times \\var{numberfour}$</p>\n<p>To double check, add these results together. You should get $\\var{total}$.</p></span></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /></part></steps><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><gaps><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span /></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"False\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"{ansfour}\" minvalue=\"{ansfour}\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"en,si-en,plain\"><precision partialcredit=\"0%\" precision=\"0\" showprecisionhint=\"False\" strict=\"True\" type=\"none\"><message><content><span /></content></message></precision></answer></part><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span /></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"False\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"{ansfive}\" minvalue=\"{ansfive}\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"en,si-en,plain\"><precision partialcredit=\"0%\" precision=\"0\" showprecisionhint=\"False\" strict=\"True\" type=\"none\"><message><content><span /></content></message></precision></answer></part><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span /></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"False\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"{anssix}\" minvalue=\"{anssix}\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"en,si-en,plain\"><precision partialcredit=\"0%\" precision=\"0\" showprecisionhint=\"False\" strict=\"True\" type=\"none\"><message><content><span /></content></message></precision></answer></part></gaps><marking sortanswers=\"False\" /></part><part enableminimummarks=\"True\" marks=\"0\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"gapfill\"><prompt><content><span><p>Divide €$\\var{money}$ in the ratio $\\var{ratioab[0]}:\\var{ratioab[1]}:\\var{ratioc}$</p>\n<p><em>(Calculate to 2 decimal place!!)</em></p>\n<p>€<gapfill reference=\"0\" /> : €<gapfill reference=\"1\" /> : €<gapfill reference=\"2\" /></p></span></content></prompt><steps><part enableminimummarks=\"True\" marks=\"0\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"information\"><prompt><content><span><p>Just as before, add all parts together and divide by this.</p></span></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /></part></steps><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><gaps><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span /></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"False\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"{ans31}\" minvalue=\"{ans31}\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"en,si-en,plain\"><precision partialcredit=\"0%\" precision=\"2.00000000000000\" showprecisionhint=\"False\" strict=\"False\" type=\"dp\"><message><content><span>You have not given your answer to the correct precision.</span></content></message></precision></answer></part><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span /></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"False\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"{ans32}\" minvalue=\"{ans32}\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"en,si-en,plain\"><precision partialcredit=\"0%\" precision=\"2.00000000000000\" showprecisionhint=\"False\" strict=\"False\" type=\"dp\"><message><content><span>You have not given your answer to the correct precision.</span></content></message></precision></answer></part><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span /></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"False\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"{ans33}\" minvalue=\"{ans33}\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"en,si-en,plain\"><precision partialcredit=\"0%\" precision=\"2.00000000000000\" showprecisionhint=\"False\" strict=\"False\" type=\"dp\"><message><content><span>You have not given your answer to the correct precision.</span></content></message></precision></answer></part></gaps><marking sortanswers=\"False\" /></part></parts><advice><content><span><p>Part 1:</p>\n<p>Add the ratio numbers and then divide the length by the summed total</p>\n<p><span class=\"re2\">$\\frac{\\var{lent}}{\\var{summ}}$</span></p>\n<p><span class=\"sy0\">Then multiply each peice by the ratio length</span></p>\n<p><span class=\"sy0\">$\\var{numberone} \\times \\var{ratio}$</span></p>\n<p><span class=\"sy0\">$\\var{numbertwo} \\times \\var{ratio}$</span></p>\n<p><span class=\"sy0\">$\\var{numberthree} \\times \\var{ratio}$</span></p>\n<p><span class=\"sy0\" /></p>\n<p><span class=\"sy0\">Part 2:</span></p>\n<p><span class=\"sy0\">Use the same method as in part 1</span></p>\n<p><span class=\"sy0\">$\\frac{\\var{total}}{(\\var{numberone1}+\\var{numbertwo1}+\\var{numberfour})}$</span></p>\n<p><span class=\"sy0\">$\\var{numberone} \\times \\var{k}$</span></p>\n<p><span class=\"sy0\">$\\var{numbertwo} \\times \\var{k}$</span></p>\n<p><span class=\"sy0\">$\\var{numberfour} \\times \\var{k}$</span></p>\n<p><span class=\"sy0\" /></p>\n<p>Part 4:</p>\n<p>$(\\frac{\\var{money}}{(\\var{ratioab[0]} + \\var{ratioab[1]} + \\var{ratioc})}) \\times \\var{ratioab[0]} = \\var{ans31}$</p>\n<p>$(\\frac{\\var{money}}{(\\var{ratioab[0]} + \\var{ratioab[1]} + \\var{ratioc})}) \\times \\var{ratioab[1]} = \\var{ans32}$</p>\n<p>$(\\frac{\\var{money}}{(\\var{ratioab[0]} + \\var{ratioab[1]} + \\var{ratioc})})  \\times \\var{ratioc} = \\var{ans33}$</p></span></content></advice><notes /><variables condition=\"\" maxRuns=\"100\"><variable name=\"numbertwo\"><value>random(2..7 except {numberone})</value></variable><variable name=\"ansfour\"><value>k*{numberone1}</value></variable><variable name=\"ansthree\"><value>{ratio}*{numberthree}</value></variable><variable name=\"ans31\"><value>({money}/10)*ratioab[0]</value></variable><variable name=\"numberthree\"><value>20-({numberone} + {numbertwo})</value></variable><variable name=\"money\"><value>random(7050..9050#100)</value></variable><variable name=\"anssix\"><value>k*{numberfour}</value></variable><variable name=\"k\"><value>random(61..68)</value></variable><variable name=\"lent\"><value>random(140..400#20)</value></variable><variable name=\"ansone\"><value>{ratio}*{numberone}</value></variable><variable name=\"numbertwo1\"><value>random(2..7 except {numberone1})</value></variable><variable name=\"numberone1\"><value>random(2..9)</value></variable><variable name=\"material\"><value>random('wood','timber','glass','metal','plastic')</value></variable><variable name=\"anstwo\"><value>{ratio}*{numbertwo}</value></variable><variable name=\"numberfour\"><value>random(2..7 except {numberone1} except {numbertwo1})</value></variable><variable name=\"ratioab\"><value>shuffle(2.1..4.4#0.1)[0..2]</value></variable><variable name=\"ansfive\"><value>k*{numbertwo1}</value></variable><variable name=\"summ\"><value>{numberone}+{numbertwo}+{numberthree}</value></variable><variable name=\"ratio\"><value>{lent}/summ</value></variable><variable name=\"total\"><value>({numberone1}+{numbertwo1}+{numberfour})*k</value></variable><variable name=\"ans33\"><value>({money}/10)*{ratioc}</value></variable><variable name=\"numberone\"><value>random(2..9)</value></variable><variable name=\"ans32\"><value>({money}/10)*ratioab[1]</value></variable><variable name=\"ratioc\"><value>10 - (ratioab[0] + ratioab[1])</value></variable></variables><functions /><preambles nosubvars=\"true\"><preamble language=\"css\" /><preamble language=\"js\" /></preambles><rulesets /></question><question name=\"Q3 Ratios\"><statement><content><span><p>Solve the following shape questions, correct to 2 decimal places.</p>\n<p /></span></content></statement><parts><part enableminimummarks=\"True\" marks=\"0\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"gapfill\"><prompt><content><span><p>If the angles of a triangle are in the ratio $\\var{num1}:\\var{num2}:\\var{num3}$.</p>\n<p />\n<p>Find the angles in degrees.</p>\n<p><gapfill reference=\"0\" />degrees</p>\n<p><gapfill reference=\"1\" />degrees</p>\n<p><gapfill reference=\"2\" />degrees</p></span></content></prompt><steps><part enableminimummarks=\"True\" marks=\"0\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"information\"><prompt><content><span><p>There are 180 degrees in a triangle.</p></span></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /></part></steps><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><gaps><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span /></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"False\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"{a1}\" minvalue=\"{a1}\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"en,si-en,plain\"><precision partialcredit=\"0%\" precision=\"0\" showprecisionhint=\"False\" strict=\"True\" type=\"none\"><message><content><span /></content></message></precision></answer></part><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span /></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"False\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"{a2}\" minvalue=\"{a2}\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"en,si-en,plain\"><precision partialcredit=\"0%\" precision=\"0\" showprecisionhint=\"False\" strict=\"True\" type=\"none\"><message><content><span /></content></message></precision></answer></part><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span /></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"False\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"{a3}\" minvalue=\"{a3}\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"en,si-en,plain\"><precision partialcredit=\"0%\" precision=\"0\" showprecisionhint=\"False\" strict=\"True\" type=\"none\"><message><content><span /></content></message></precision></answer></part></gaps><marking sortanswers=\"False\" /></part><part enableminimummarks=\"True\" marks=\"0\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"gapfill\"><prompt><content><span><p>If the angles of a triangle are in the ratio $\\var{numberthree}\\frac{1}{\\var{numberthreea}}:\\var{numberfour}\\frac{1}{\\var{numberfoura}}:\\var{numberfive}\\simplify{{numberfiveb}/{numberfivea}}$.</p>\n<p />\n<p>Find the angles in degrees.</p>\n<p><gapfill reference=\"0\" />degrees</p>\n<p><gapfill reference=\"1\" />degrees</p>\n<p><gapfill reference=\"2\" />degrees</p></span></content></prompt><steps><part enableminimummarks=\"True\" marks=\"0\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"information\"><prompt><content><span><p>Convert the fraction into top heavy fractions. Simplify this ratio into integers like in Q1 (c). Now continue as in part (a) above.</p>\n<p>Or, alternatively add the fractions in fraction form.</p></span></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /></part></steps><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><gaps><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span /></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"False\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"{ansone}\" minvalue=\"{ansone}\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"en,si-en,plain\"><precision partialcredit=\"0%\" precision=\"2.00000000000000\" showprecisionhint=\"False\" strict=\"False\" type=\"dp\"><message><content><span>You have not given your answer to the correct precision.</span></content></message></precision></answer></part><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span /></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"False\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"{anstwo}\" minvalue=\"{anstwo}\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"en,si-en,plain\"><precision partialcredit=\"0%\" precision=\"2.00000000000000\" showprecisionhint=\"False\" strict=\"False\" type=\"dp\"><message><content><span>You have not given your answer to the correct precision.</span></content></message></precision></answer></part><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span /></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"False\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"{ansthree}\" minvalue=\"{ansthree}\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"en,si-en,plain\"><precision partialcredit=\"0%\" precision=\"2.00000000000000\" showprecisionhint=\"False\" strict=\"False\" type=\"dp\"><message><content><span>You have not given your answer to the correct precision.</span></content></message></precision></answer></part></gaps><marking sortanswers=\"False\" /></part></parts><advice><content><span><p />\n<p><em>Part 1:</em></p>\n<p>Add the three ratios together, which gives $15$</p>\n<p>Therefore $1$ is equal to $\\frac{180}{15}$degrees (12degrees)</p>\n<p> Multiply each ratio by 18 to find the value of each angle in degrees</p>\n<p>$12 \\times \\var{num1}$</p>\n<p>$12 \\times \\var{num2}$</p>\n<p>$12 \\times \\var{num3}$</p>\n<p />\n<p><em>Part 2:</em></p>\n<p>Add the three ratios together, which gives $10$</p>\n<p>Therefore $1$ is equal to $\\frac{180}{10}$degrees (18degrees)</p>\n<p> Multiply each ratio by 18 to find the value of each angle in degrees</p>\n<p>$18 \\times \\var{numberthree}\\frac{1}{\\var{numberthreea}}$</p>\n<p>$18 \\times \\var{numberfour}\\frac{1}{\\var{numberfoura}}$</p>\n<p>$18 \\times \\var{numberfive}\\frac{\\var{numberfiveb}}{\\var{numberfivea}}$</p>\n<p><em /></p>\n<p /></span></content></advice><notes /><variables condition=\"\" maxRuns=\"100\"><variable name=\"a2\"><value>12*num2</value></variable><variable name=\"numbertwo\"><value>random(2..25 except {numberone})</value></variable><variable name=\"ansthree\"><value>18*({numberfive} + ({numberfiveb}/{numberfivea}))</value></variable><variable name=\"numberthree\"><value>random(2..4)</value></variable><variable name=\"numberfive\"><value>random(2..4 except {numberthree} except {numberfour})</value></variable><variable name=\"numberfivea\"><value>{numberthreea}*{numberfoura}</value></variable><variable name=\"numberfiveb\"><value>{numberfivea}-({numberthreea}+{numberfoura})</value></variable><variable name=\"numberone\"><value>random(2..25)</value></variable><variable name=\"ansone\"><value>18*({numberthree} + (1/{numberthreea}))</value></variable><variable name=\"numberfoura\"><value>random(2..8 except {numberthreea})</value></variable><variable name=\"anstwo\"><value>18*({numberfour} + (1/{numberfoura}))</value></variable><variable name=\"num1\"><value>random(2..6)</value></variable><variable name=\"num2\"><value>7</value></variable><variable name=\"width\"><value>1-{numbertwo}/100</value></variable><variable name=\"ans\"><value>({area}-1)*100</value></variable><variable name=\"a1\"><value>12*num1</value></variable><variable name=\"area\"><value>lent*width</value></variable><variable name=\"a3\"><value>12*num3</value></variable><variable name=\"lent\"><value>1+{numberone}/100</value></variable><variable name=\"numberfour\"><value>random(2..4 except {numberthree})</value></variable><variable name=\"numberthreea\"><value>random(2..8)</value></variable><variable name=\"num3\"><value>15-(num1+num2)</value></variable></variables><functions /><preambles nosubvars=\"true\"><preamble language=\"css\" /><preamble language=\"js\" /></preambles><rulesets /></question></questions></question_group><question_group name=\"Solve proportions: word problems (9-C.6)\" pickQuestions=\"1\" pickingStrategy=\"all-ordered\"><questions><question name=\"Marte's copy of Percentages and ratios - box of chocolates\"><statement><content><span><p>A family receive a box of chocolates as a gift. There are five different kinds of chocolate inside: plain, nut, caramel, dark and coconut.</p>\n<p>The box contains equal numbers of each kind of chocolate..</p></span></content></statement><parts><part enableminimummarks=\"True\" marks=\"0\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"gapfill\"><prompt><content><span><p>What percentage of the box of chocolates is represented by the caramel chocolates?</p>\n<p>Caramel chocolate = <gapfill reference=\"0\" /> % of the box.</p></span></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><gaps><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span /></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"False\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"20.00000000000000\" minvalue=\"20.00000000000000\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"plain,en,si-en\"><precision partialcredit=\"0%\" precision=\"0\" showprecisionhint=\"True\" strict=\"True\" type=\"none\"><message><content><span /></content></message></precision></answer></part></gaps><marking sortanswers=\"False\" /></part><part enableminimummarks=\"True\" marks=\"0\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"gapfill\"><prompt><content><span><p>If there were $\\var{chocs}$ chocolates in the box originally, how many of each kind were there?</p>\n<p>There are <gapfill reference=\"0\" /> of each type of chocolate in the box.</p>\n<p /></span></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><gaps><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span /></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"False\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"type\" minvalue=\"type\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"plain,en,si-en\"><precision partialcredit=\"0%\" precision=\"0\" showprecisionhint=\"True\" strict=\"True\" type=\"none\"><message><content><span /></content></message></precision></answer></part></gaps><marking sortanswers=\"False\" /></part><part enableminimummarks=\"True\" marks=\"0\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"gapfill\"><prompt><content><span><p>Caramel flavoured chocolate is the family favourite, and so all of these chocolates are eaten first, and none of the other kinds are touched.</p>\n<p>What percentage of the remaining chocolates are plain?</p>\n<p>Plain chocolates = <gapfill reference=\"0\" />% of the box.</p></span></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><gaps><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span /></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"False\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"25.00000000000000\" minvalue=\"25.00000000000000\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"plain,en,si-en\"><precision partialcredit=\"0%\" precision=\"0\" showprecisionhint=\"True\" strict=\"True\" type=\"none\"><message><content><span /></content></message></precision></answer></part></gaps><marking sortanswers=\"False\" /></part><part enableminimummarks=\"True\" marks=\"0\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"gapfill\"><prompt><content><span><p>Over the next few days, the remaining chocolates in the box are slowly devoured so that by day three, all that remain are:</p>\n<p>$\\var{p}$ plain chocolates, $\\var{n}$ nutty chocolates, $\\var{c}$ coconut chocolates and $\\var{d}$ dark chocolates.</p>\n<p />\n<p><em>i) </em>What is the ratio of plain to dark chocolates? Give your answer in its simplest form.</p>\n<p>Plain <gapfill reference=\"0\" /> : <gapfill reference=\"1\" /> Dark</p>\n<p />\n<p><em>ii) </em>What is the ratio of coconut chocolates to the rest of the box? Give your answer in its simplest form.</p>\n<p>Coconut <gapfill reference=\"2\" /> : <gapfill reference=\"3\" /> Rest of the box</p>\n<p /></span></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><gaps><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span /></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"False\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"ratio_plain\" minvalue=\"ratio_plain\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"plain,en,si-en\"><precision partialcredit=\"0%\" precision=\"0\" showprecisionhint=\"True\" strict=\"True\" type=\"none\"><message><content><span /></content></message></precision></answer></part><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span /></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"False\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"ratio_dark\" minvalue=\"ratio_dark\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"plain,en,si-en\"><precision partialcredit=\"0%\" precision=\"0\" showprecisionhint=\"True\" strict=\"True\" type=\"none\"><message><content><span /></content></message></precision></answer></part><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span /></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"False\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"ratio_coconut\" minvalue=\"ratio_coconut\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"plain,en,si-en\"><precision partialcredit=\"0%\" precision=\"0\" showprecisionhint=\"True\" strict=\"True\" type=\"none\"><message><content><span /></content></message></precision></answer></part><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span /></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"False\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"ratio_rest\" minvalue=\"ratio_rest\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"plain,en,si-en\"><precision partialcredit=\"0%\" precision=\"0\" showprecisionhint=\"True\" strict=\"True\" type=\"none\"><message><content><span /></content></message></precision></answer></part></gaps><marking sortanswers=\"False\" /></part></parts><advice><content><span><h4><strong>a)</strong></h4>\n<p>100% represents the whole box of chocolates. As there are 5 different kinds of chocolate in the box and they are all represented equally, to calculate the percentage chocolates which are caramel, divide 100 by 5.</p>\n<p style=\"text-align: center;\">Caramel chocolate = $\\displaystyle\\frac{100}{5}$ = $20$% of the box.</p>\n<p />\n<p />\n<p><strong>b)</strong> </p>\n<p>The original number of chocolates in the box is stated. We worked out above that each type of chocolate makes up 20% of the box, so we need to work out 20% of {chocs}.</p>\n<p>To do this, either divide {chocs} by 100 and mulitply by 20, OR multiply {chocs} by 0.2. The two methods will give the same result.</p>\n<p style=\"text-align: center;\">Method 1: $\\displaystyle\\frac{\\var{chocs}}{100}$ x $20$ = $\\var{type}$;</p>\n<p style=\"text-align: center;\"><strong>OR</strong></p>\n<p style=\"text-align: center;\">Method 2: $\\var{chocs}$ x $0.2$ = $\\var{type}$.</p>\n<p />\n<p />\n<p><strong>c)</strong></p>\n<p>There are now {type} fewer chocolates in the box, but the remaining chocolates now represent 100% of the box. There are now only 4 types of chocolate in it and there is still equal representation inside the box.</p>\n<p>Use the method from part <strong>a)</strong> to find out the equal share of each chocolate type.</p>\n<p style=\"text-align: center;\">Each type = $\\displaystyle\\frac{100}{4}$ = $25$% of the box.</p>\n<p />\n<p />\n<p><strong>d)</strong> </p>\n<p><em>i)</em></p>\n<p>The first section asks you to compare plain chocolate and dark chocolate. It states that there are {p} plain chocolates and {d} dark chocolates left in the box.</p>\n<p>Insert the numbers of each into the gaps.</p>\n<p style=\"text-align: center;\">Plain $\\var{p}$ : $\\var{d}$ Dark</p>\n<p style=\"text-align: left;\">From this, we should look to see if this answer can be simplified down. To do this, we need to find the greatest common divisor of $\\var{p}$ and $\\var{d}$. </p>\n<p style=\"text-align: left;\">The greatest common divisor is $\\var{gcd}$.</p>\n<p style=\"text-align: left;\"><span data-jme-visible=\"gcd&gt;1\">Using this value to simplify down the ratio by dividing each term by the value, the final answer is</span></p>\n<p style=\"text-align: center;\"><span data-jme-visible=\"gcd&gt;1\">Plain $\\var{ratio_plain}$ : $\\var{ratio_dark}$ Dark.</span></p>\n<p><span data-jme-visible=\"gcd&gt;1\">This states that for every {ratio_plain} plain {if(ratio_plain=1,\"chocolate\",\"chocolates\")}, there {if(ratio_dark=1,\"is\",\"are\")} {ratio_dark} dark {if(ratio_dark=1,\"chocolate\",\"chocolates\")}.</span></p>\n<p><span data-jme-visible=\"gcd=1\">Therefore, it is not possible to simplify further and the final answer is</span></p>\n<p style=\"text-align: center;\"><span data-jme-visible=\"gcd=1\">Plain $\\var{p}$ : $\\var{d}$ Dark.</span></p>\n<p><span data-jme-visible=\"gcd=1\">This states that for every {p} plain {if(p=1,\"chocolate\",\"chocolates\")}, there {if(d=1,\"is\",\"are\")}{d} dark {if(d=1,\"chocolate\",\"chocolates\")}.</span></p>\n<p />\n<p><em>ii)</em></p>\n<p>The second section asks you to compare coconut chocolates and the rest of the box. It states that there are {c} coconut chocolates. To calculate the number of chocolates in the rest of the box, add together the stated amounts of plain, dark and nutty chocolates:</p>\n<p style=\"text-align: center;\">$\\var{p}+\\var{d}+\\var{n}$ = $\\var{rob}$.</p>\n<p>Insert these two figures into the gaps.</p>\n<p style=\"text-align: center;\">Coconut $\\var{c}$ : $\\var{rob}$ Other chocolates</p>\n<p style=\"text-align: left;\">From this, we should look to see if this answer can be simplified down. To do this, we need to find the greatest common divisor of $\\var{c}$ and $\\var{rob}$. </p>\n<p style=\"text-align: left;\">The greatest common divisor is $\\var{gcd2}$.</p>\n<p style=\"text-align: left;\"><span data-jme-visible=\"gcd2 &gt; 1\">Using this value to simplify down the ratio by dividing each term by the value, the final answer is</span></p>\n<p style=\"text-align: center;\"><span data-jme-visible=\"gcd2 &gt; 1\">Coconut $\\var{ratio_coconut}$ : $\\var{ratio_rest}$ Other chocolates.</span></p>\n<p><span data-jme-visible=\"gcd2 &gt; 1\">This states that for every {ratio_coconut} coconut {if(ratio_coconut=1,\"chocolate\",\"chocolates\")}, there {if(ratio_rest=1,\"is\",\"are\")} {ratio_rest} other {if(ratio_rest=1,\"chocolate\",\"chocolates\")} in the box.</span></p>\n<p><strong /><span data-jme-visible=\"gcd2 = 1\">Therefore, it is not possible to simplify further and the final answer is </span></p>\n<p style=\"text-align: center;\"><span data-jme-visible=\"gcd2 = 1\">Coconut $\\var{c}$ : $\\var{rob}$ Other chocolates.</span></p>\n<p style=\"text-align: left;\"><span data-jme-visible=\"gcd2 = 1\">This states that for every {c} coconut {if(c=1,\"chocolate\",\"chocolates\")}, there {if(rob=1,\"is\",\"are\")} {rob} other {if(rob=1,\"chocolate\",\"chocolates\")} in the box.</span></p></span></content></advice><notes /><variables condition=\"\" maxRuns=\"100\"><variable name=\"ratio_dark\"><value>d/gcd(p,d)</value></variable><variable name=\"ratio_plain\"><value>p/gcd(p,d)</value></variable><variable name=\"p\"><value>random(2..5)</value></variable><variable name=\"gcd2\"><value>gcd(c,rob)</value></variable><variable name=\"d\"><value>random(1..3)*p</value></variable><variable name=\"minusc\"><value>{chocs-type}</value></variable><variable name=\"rob\"><value>p+n+d</value></variable><variable name=\"chocs\"><value>random(70..95#5)</value></variable><variable name=\"n\"><value>random(1..14 except 7 except 11 except 13)</value></variable><variable name=\"c\"><value>random(1..14 except 7 except 11 except 13)</value></variable><variable name=\"ratio_rest\"><value>rob/gcd(c, rob)</value></variable><variable name=\"perc\"><value>100*(prob)</value></variable><variable name=\"a\"><value>p+n+d+c</value></variable><variable name=\"ratio_coconut\"><value>c/gcd(c, rob)</value></variable><variable name=\"prob\"><value>precround({n/{a},2)</value></variable><variable name=\"gcd\"><value>gcd(p,d)</value></variable><variable name=\"type\"><value>chocs/5</value></variable></variables><functions /><preambles nosubvars=\"true\"><preamble language=\"css\" /><preamble language=\"js\" /></preambles><rulesets /></question><question name=\"Q6 Ratio with rectangles \"><statement><content><span><p>Solve the following shape questions, correct to 2 decimal places.</p>\n<p /></span></content></statement><parts><part enableminimummarks=\"True\" marks=\"0\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"gapfill\"><prompt><content><span><p>The sides of a rectangle are altered. The length is increased by $\\var{numberone}$% while the width is decreased by $\\var{numbertwo}$%. Find the precentage change in the area of the rectangle stating whether it is an increase or a decrease, by indicating a decrease with a negative sign.</p>\n<p><em>(e.g. -8% shows an 8% decrease, and 8% shows an 8% increase)</em></p>\n<p><em><gapfill reference=\"0\" />%</em></p></span></content></prompt><steps><part enableminimummarks=\"True\" marks=\"0\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"information\"><prompt><content><span><p>Imagine the rectangle started off with length 1m and width 1m. In that case what would the new length and width be equal to. The area of a rectangle is length by width. Is this less than or equal to 1 square metre? By how much?</p></span></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /></part></steps><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><gaps><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span /></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"False\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"{ans}\" minvalue=\"{ans}\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"en,si-en,plain\"><precision partialcredit=\"0%\" precision=\"2.00000000000000\" showprecisionhint=\"False\" strict=\"False\" type=\"dp\"><message><content><span>You have not given your answer to the correct precision.</span></content></message></precision></answer></part></gaps><marking sortanswers=\"False\" /></part></parts><advice><content><span><p />\n<p><em>Part 1:</em></p>\n<p>If the length is increased by $\\var{numberone}$%, the length becomes $\\var{lent}$</p>\n<p>Similiarly with the width,</p>\n<p>If the width is decreased by $\\var{numbertwo}$%, the width becomes $\\var{width}$</p>\n<p>multiply length by width to get area:</p>\n<p>$\\var{lent} \\times \\var{width} = \\var{area}$</p>\n<p>Then, multiply the area by 100 to get it as a percentage</p>\n<p>To see if it is a decrease or increase, take away 100 from it</p>\n<p>If it is a negative number it is a decrease, and if a positive number it increases.</p>\n<p />\n<p /></span></content></advice><notes /><variables condition=\"\" maxRuns=\"100\"><variable name=\"a2\"><value>12*num2</value></variable><variable name=\"numbertwo\"><value>random(2..25 except {numberone})</value></variable><variable name=\"ansthree\"><value>18*({numberfive} + ({numberfiveb}/{numberfivea}))</value></variable><variable name=\"numberthree\"><value>random(2..4)</value></variable><variable name=\"numberfive\"><value>random(2..4 except {numberthree} except {numberfour})</value></variable><variable name=\"numberfivea\"><value>{numberthreea}*{numberfoura}</value></variable><variable name=\"numberfiveb\"><value>{numberfivea}-({numberthreea}+{numberfoura})</value></variable><variable name=\"numberone\"><value>random(2..25)</value></variable><variable name=\"ansone\"><value>18*({numberthree} + (1/{numberthreea}))</value></variable><variable name=\"numberfoura\"><value>random(2..8 except {numberthreea})</value></variable><variable name=\"anstwo\"><value>18*({numberfour} + (1/{numberfoura}))</value></variable><variable name=\"num1\"><value>random(2..6)</value></variable><variable name=\"num2\"><value>7</value></variable><variable name=\"width\"><value>1-{numbertwo}/100</value></variable><variable name=\"ans\"><value>({area}-1)*100</value></variable><variable name=\"a1\"><value>12*num1</value></variable><variable name=\"area\"><value>lent*width</value></variable><variable name=\"a3\"><value>12*num3</value></variable><variable name=\"lent\"><value>1+{numberone}/100</value></variable><variable name=\"numberfour\"><value>random(2..4 except {numberthree})</value></variable><variable name=\"numberthreea\"><value>random(2..8)</value></variable><variable name=\"num3\"><value>15-(num1+num2)</value></variable></variables><functions /><preambles nosubvars=\"true\"><preamble language=\"css\" /><preamble language=\"js\" /></preambles><rulesets /></question><question name=\"Writing ratios in the form n:1 or 1:n\"><statement><content><span><p>This question is about writing ratios in the form 1:n or n:1.</p></span></content></statement><parts><part enableminimummarks=\"True\" marks=\"0\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"gapfill\"><prompt><content><span><p>Express the ratio {a}:{b} in the form 1:n.</p>\n<p>Give your decimal answers to 2dp.</p>\n<p />\n<p><gapfill reference=\"0\" />:<gapfill reference=\"1\" /></p></span></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><gaps><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span /></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"True\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"{h}\" minvalue=\"{h}\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"plain,en,si-en\"><precision partialcredit=\"0%\" precision=\"0\" showprecisionhint=\"True\" strict=\"True\" type=\"none\"><message><content><span /></content></message></precision></answer></part><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span /></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"False\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"{n}\" minvalue=\"{n}\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"plain,en,si-en\"><precision partialcredit=\"0%\" precision=\"2.00000000000000\" showprecisionhint=\"False\" strict=\"False\" type=\"dp\"><message><content><span><p>You have not given your answer to the correct number of decimal places.</p></span></content></message></precision></answer></part></gaps><marking sortanswers=\"False\" /></part><part enableminimummarks=\"True\" marks=\"0\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"gapfill\"><prompt><content><span><p>Express the ratio {c}:{d} in the form n:1.</p>\n<p>Give your decimal answers to 2dp.</p>\n<p />\n<p><gapfill reference=\"0\" />:<gapfill reference=\"1\" /></p></span></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><gaps><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span /></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"False\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"{f}\" minvalue=\"{f}\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"plain,en,si-en\"><precision partialcredit=\"0%\" precision=\"2.00000000000000\" showprecisionhint=\"False\" strict=\"False\" type=\"dp\"><message><content><span><p>You have not given your answer to the correct number of decimal places.</p></span></content></message></precision></answer></part><part enableminimummarks=\"True\" marks=\"1\" minimummarks=\"0\" showcorrectanswer=\"True\" showfeedbackicon=\"True\" stepspenalty=\"0\" type=\"numberentry\"><prompt><content><span /></content></prompt><steps /><scripts /><adaptivemarking><variablereplacements strategy=\"originalfirst\" /></adaptivemarking><markingalgorithm extend=\"True\" /><answer allowfractions=\"False\" checkingType=\"range\" correctanswerfraction=\"False\" correctanswerstyle=\"plain\" inputstep=\"1\" maxvalue=\"{g}\" minvalue=\"{g}\" mustbereduced=\"False\" mustbereducedpc=\"0%\" notationstyles=\"plain,en,si-en\"><precision partialcredit=\"0%\" precision=\"0\" showprecisionhint=\"True\" strict=\"True\" type=\"none\"><message><content><span /></content></message></precision></answer></part></gaps><marking sortanswers=\"False\" /></part></parts><advice><content><span><p>Remember:</p>\n<p>When showing a ratio (e.g., 20:30) in the form 1:n, divide both sides by the left hand side of the ratio (e.g., 20 in the previous example).</p>\n<p>When showing a ratio (e.g., 20:30) in the form n:1, divide both sides by the left hand side of the ratio (e.g., 30 in the previous example).</p></span></content></advice><notes /><variables condition=\"\" maxRuns=\"100\"><variable name=\"b\"><value>random(2..15 except a)</value></variable><variable name=\"h\"><value>a/a</value></variable><variable name=\"d\"><value>random(2..15 except c)</value></variable><variable name=\"g\"><value>d/d</value></variable><variable name=\"a\"><value>random(2..15)</value></variable><variable name=\"c\"><value>random(2..15)</value></variable><variable name=\"f\"><value>c/d</value></variable><variable name=\"n\"><value>b/a</value></variable></variables><functions /><preambles nosubvars=\"true\"><preamble language=\"css\" /><preamble language=\"js\" /></preambles><rulesets /></question></questions></question_group></question_groups></exam>"
    };
});
